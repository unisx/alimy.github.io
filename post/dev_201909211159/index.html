  <!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title> Cap&#39;n Proto Schema Language &middot; 北 野 </title>
    
    <link rel="stylesheet" type="text/css" href="http://alimy.me/css/uno.css" />
    <link rel="stylesheet" type="text/css" href="http://alimy.me/css/lightGallery.css" />
    
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://alimy.me/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="http://alimy.me/favicon.png">
    
    <script src="http://alimy.me/js/jquery.min.js"></script>
    <script src="http://alimy.me/js/main.min.js"></script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75081327-1', 'auto');
  ga('send', 'pageview');
</script>


<script>
  "use strict";
  
  !function() {
    var t = window.driftt = window.drift = window.driftt || [];
    if (!t.init) {
      if (t.invoked) return void (window.console && console.error && console.error("Drift snippet included twice."));
      t.invoked = !0, t.methods = [ "identify", "config", "track", "reset", "debug", "show", "ping", "page", "hide", "off", "on" ], 
      t.factory = function(e) {
        return function() {
          var n = Array.prototype.slice.call(arguments);
          return n.unshift(e), t.push(n), t;
        };
      }, t.methods.forEach(function(e) {
        t[e] = t.factory(e);
      }), t.load = function(t) {
        var e = 3e5, n = Math.ceil(new Date() / e) * e, o = document.createElement("script");
        o.type = "text/javascript", o.async = !0, o.crossorigin = "anonymous", o.src = "https://js.driftt.com/include/" + n + "/" + t + ".js";
        var i = document.getElementsByTagName("script")[0];
        i.parentNode.insertBefore(o, i);
      };
    }
  }();
  drift.SNIPPET_VERSION = '0.3.1';
  drift.load('b8zniyzvbfap');
  </script>



<script>
(function(f, a, t, h, o, m){
a[h]=a[h]||function(){
  (a[h].q=a[h].q||[]).push(arguments)
};
o=f.createElement('script'),
m=f.getElementsByTagName('script')[0];
o.async=1; o.src=t; o.id='fathom-script';
m.parentNode.insertBefore(o,m)
})(document, window, '//fathom.traefic.com/tracker.js', 'fathom');
fathom('trackPageview');
</script>


    <style type="text/css">
        body {
          background-color:#f9f9f9;
        }
        .panel-wrapper {
          box-shadow:0px 0px 8px rgba(68,68,68,.6);
          -moz-box-shadow:0px 0px 8px rgba(68,68,68,.6);
          border-radius:4px;
          -moz-border-radius:4px;
          padding:16px 24px;
          margin-top:32px;
          background-color:#fff
        }
        .panel-wrapper:hover {
          box-shadow:0px 0px 12px rgba(68,68,68,.6);
          -moz-box-shadow:0px 0px 12px rgba(68,68,68,.6);
        }
        #more {
          margin-top:16px;
        }
        #copyright {
          padding:2em 0 0;
          display:block;
          font-size:.9em;
          color:#b3b3b3;
          width:100%;
          text-align:center
        }
        #list-indicator {
          min-width:48px;
          text-align:center;
          float:right;
          margin-right:64px;
          background:rgba(68,68,68,.2);
          border-radius:4px;
          -moz-border-radius:4px;
          padding:8px;
        }
        #list-date {
          color:#999;
          font-size: .9em;
          font-style:italic;
        }
        #post-navigator {
          padding:24px 0px 16px 0px;
          vertical-align: middle;
        }
        #post-navigator>a {
          display: block;
          color:#2479cc;
          text-decoration:none;
        }
        #post-navigator-prev {
          float:left;
        }
        #post-navigator-next {
          float:right;
        }
        .pages {
            text-align: center;
            margin-right: -15px;
            margin-left: -15px;
        }
        .pages>ul {
            font-weight: lighter;
        }
        .pages>.pagination {
            display: inline-block;
            padding-left: 0;
            margin: 20px 0px;
            border-radius: 4px;
        }
        .pages .pagination>li {
            display:inline;
        }

.pagination>.active>a, .pagination>.active>span, .pagination>.active>a:hover, .pagination>.active>span:hover, .pagination>.active>a:focus, .pagination>.active>span:focus {
    z-index: 2;
    color: #fff;
    cursor: default;
    background-color: #428bca;
    border-color: #428bca;
}

.pagination>li>a, .pagination>li>span {
    position: relative;
    float: left;
    padding: 6px 12px;
    margin-left: -1px;
    line-height: 1.428571429;
    text-decoration: none;
    background-color: #fff;
    border: 1px solid #ddd;
}
.pagination>li:first-child>a, .pagination>li:first-child>span {
    margin-left: 0;
    border-bottom-left-radius: 4px;
    border-top-left-radius: 4px;
}
.pagination>.disabled>span, .pagination>.disabled>span:hover, .pagination>.disabled>span:focus, .pagination>.disabled>a, .pagination>.disabled>a:hover, .pagination>.disabled>a:focus {
    color: #999;
    cursor: not-allowed;
    background-color: #fff;
    border-color: #ddd;
}
.pagination>li:last-child>a, .pagination>li:last-child>span {
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
}
*, *:before, *:after {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}
    </style>
</head>

  <body>
    <div id="scriptHeader">
    <span class="mobile btn-mobile-menu">
            <i class="fa fa-bars btn-mobile-menu__icon"></i>
            <i class="fa fa-times btn-mobile-close__icon hidden"> </i>
    </span>
    <header class="
        
            panel-cover panel-cover--collapsed
        " >
    <div class="panel-main">
        <div class="panel-main__inner panel-inverted">
            <div class="panel-main__content"> 
                <a href="http://alimy.me/"> <img src="http://alimy.me/images/logo.jpg" width="142" height="142" alt="北 野 logo" class="panel-cover__logo logo" /> </a> 
                <h1 class="panel-cover__title panel-title">
                    <a href="http://alimy.me/">北 野</a>
                </h1>
                <hr class="panel-cover__divider" />
                <p class="panel-cover__description">  糊涂小栈  </p>
                <hr class="panel-cover__divider panel-cover__divider--secondary" />
                <div class="navigation-wrapper">
                    <nav class="cover-navigation cover-navigation--primary">
                        <ul class="navigation">
                            <li class="navigation__item"><a href="http://alimy.me" title="博客首页" class="blog-button">Blog</a> </li> </br></br>
                            <li class="navigation__item"><a href="http://alimy.me/post/" title="文章列表" class="blog-button">Archive</a> </li>
                            </br>  </ul>
                            <nav class="cover-navigation navigation--social">
</br>
    <ul class="navigation"> 
        
        <li class="navigation__item">
            <a href="http://twitter.com/bitriory" title="@Twitter"> <i class='fa fa-twitter'></i> <span class="label">Twitter</span> </a>
        </li>   
        
        <li class="navigation__item">
            <a href="https://github.com/alimy" title="@GitHub"> <i class='fa fa-github'></i> <span class="label">Github</span> </a>
        </li>  
        
        <li class="navigation__item">
            <a href="http://gitbus.com/alimy" title="@GitBus"> <i class='fa fa-bars'></i> <span class="label">GitBus</span> </a>
        </li>  </br>    </ul>
</nav>

                    </nav>  </div>
            </div>
        </div>
        <div class="panel-cover--overlay"></div>
    </div>
</header>
</div>
<noscript>
    <style>
        #scriptHeader {display:none;}
        .navigation-wrapper{
            display: block;
            top: 0;
        }
    </style>

    <header class="panel-cover panel-cover--collapsed" style="background-image: url()">
        <div class="panel-main">
            <div class="panel-main__inner panel-inverted">
                <div class="panel-main__content"> 
                    <a href="http://alimy.me/"> <img src="http://alimy.me/images/logo.jpg" width="80" alt="北 野 logo" class="panel-cover__logo logo" /> </a> 
                    <h1 class="panel-cover__title panel-title">
                        <a href="http://alimy.me/">北 野</a>
                    </h1>
                    <hr class="panel-cover__divider" />
                    <p class="panel-cover__description">  糊涂小栈  </p>
                    <hr class="panel-cover__divider panel-cover__divider--secondary" />
                    <div class="navigation-wrapper">
                        <nav class="cover-navigation cover-navigation--primary">
                            <ul class="navigation">
                                <li class="navigation__item"><a href="http://alimy.me/" title="博客首页" class="blog-button">Blog</a> </li>
                                </br>  </ul>
                        </nav> <nav class="cover-navigation navigation--social">
</br>
    <ul class="navigation"> 
        
        <li class="navigation__item">
            <a href="http://twitter.com/bitriory" title="@Twitter"> <i class='fa fa-twitter'></i> <span class="label">Twitter</span> </a>
        </li>   
        
        <li class="navigation__item">
            <a href="https://github.com/alimy" title="@GitHub"> <i class='fa fa-github'></i> <span class="label">Github</span> </a>
        </li>  
        
        <li class="navigation__item">
            <a href="http://gitbus.com/alimy" title="@GitBus"> <i class='fa fa-bars'></i> <span class="label">GitBus</span> </a>
        </li>  </br>    </ul>
</nav>
 </div>
                </div>
            </div>
            <div class="panel-cover--overlay"></div>
        </div>
    </header>
</noscript>

    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <div class="post panel-wrapper">
            <h2>Cap&#39;n Proto Schema Language</h2>
          
          <h2 id="schema-language">Schema Language</h2>

<p>Like Protocol Buffers and Thrift (but unlike JSON or MessagePack), Cap’n Proto messages are strongly-typed and not self-describing. You must define your message structure in a special language, then invoke the Cap’n Proto compiler (<code>capnp compile</code>) to generate source code to manipulate that message type in your desired language.</p>

<h4 id="for-example">For example:</h4>

<pre><code>@0xdbb9ad1f14bf0b36;  # unique file ID, generated by `capnp id`

struct Person {
  name @0 :Text;
  birthdate @3 :Date;

  email @1 :Text;
  phones @2 :List(PhoneNumber);

  struct PhoneNumber {
    number @0 :Text;
    type @1 :Type;

    enum Type {
      mobile @0;
      home @1;
      work @2;
    }
  }
}

struct Date {
  year @0 :Int16;
  month @1 :UInt8;
  day @2 :UInt8;
}
</code></pre>

<p>Some notes:</p>

<ul>
<li>Types come after names. The name is by far the most important thing to see, especially when quickly skimming, so we put it up front where it is most visible. Sorry, C got it wrong.</li>
<li>The <code>@N</code> annotations show how the protocol evolved over time, so that the system can make sure to maintain compatibility with older versions. Fields (and enumerants, and interface methods) must be numbered consecutively starting from zero in the order in which they were added. In this example, it looks like the <code>birthdate</code> field was added to the <code>Person</code> structure recently – its number is higher than the <code>email</code> and <code>phones</code> fields. Unlike Protobufs, you cannot skip numbers when defining fields – but there was never any reason to do so anyway.</li>
</ul>

<h2 id="language-reference">Language Reference</h2>

<h3 id="comments">Comments</h3>

<p>Comments are indicated by hash signs and extend to the end of the line:</p>

<pre><code># This is a comment.
</code></pre>

<p>Comments meant as documentation should appear after the declaration, either on the same line, or on a subsequent line. Doc comments for aggregate definitions should appear on the line after the opening brace.</p>

<pre><code>struct Date {
  # A standard Gregorian calendar date.

  year @0 :Int16;
  # The year.  Must include the century.
  # Negative value indicates BC.

  month @1 :UInt8;   # Month number, 1-12.
  day @2 :UInt8;     # Day number, 1-30.
}
</code></pre>

<p>Placing the comment after the declaration rather than before makes the code more readable, especially when doc comments grow long. You almost always need to see the declaration before you can start reading the comment.</p>

<h3 id="built-in-types">Built-in Types</h3>

<p>The following types are automatically defined:</p>

<ul>
<li><strong>Void:</strong> <code>Void</code></li>
<li><strong>Boolean:</strong> <code>Bool</code></li>
<li><strong>Integers:</strong> <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code></li>
<li><strong>Unsigned integers:</strong> <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>,<code>UInt64</code></li>
<li><strong>Floating-point:</strong> <code>Float32</code>, <code>Float64</code></li>
<li><strong>Blobs:</strong> <code>Text</code>, <code>Data</code></li>
<li><strong>Lists:</strong> <code>List(T)</code></li>
</ul>

<p>Notes:</p>

<ul>
<li>The <code>Void</code> type has exactly one possible value, and thus can be encoded in zero bits. It is rarely used, but can be useful as a union member.</li>
<li><code>Text</code> is always UTF-8 encoded and NUL-terminated.</li>
<li><code>Data</code> is a completely arbitrary sequence of bytes.</li>
<li><code>List</code> is a parameterized type, where the parameter is the element type. For example, <code>List(Int32)</code>, <code>List(Person)</code>, and <code>List(List(Text))</code> are all valid.</li>
</ul>

<h3 id="structs">Structs</h3>

<p>A struct has a set of named, typed fields, numbered consecutively starting from zero.</p>

<pre><code>struct Person {
  name @0 :Text;
  email @1 :Text;
}
</code></pre>

<p>Fields can have default values:</p>

<pre><code>foo @0 :Int32 = 123;
bar @1 :Text = &quot;blah&quot;;
baz @2 :List(Bool) = [ true, false, false, true ];
qux @3 :Person = (name = &quot;Bob&quot;, email = &quot;bob@example.com&quot;);
corge @4 :Void = void;
grault @5 :Data = 0x&quot;a1 40 33&quot;;
</code></pre>

<h3 id="unions">Unions</h3>

<p>A union is two or more fields of a struct which are stored in the same location. Only one of these fields can be set at a time, and a separate tag is maintained to track which one is currently set. Unlike in C, unions are not types, they are simply properties of fields, therefore union declarations do not look like types.</p>

<pre><code>struct Person {
  # ...

  employment :union {
    # We assume that a person is only one of these.
    unemployed @4 :Void;
    employer @5 :Company;
    school @6 :School;
    selfEmployed @7 :Void;
  }
}
</code></pre>

<p>Additionally, unions can be unnamed. Each struct can contain no more than one unnamed union. Use unnamed unions in cases where you would struggle to think of an appropriate name for the union, because the union represents the main body of the struct.</p>

<pre><code>struct Shape {
  area @0 :Float64;

  union {
    circle @1 :Float64;      # radius
    square @2 :Float64;      # width
  }
}
</code></pre>

<p>Notes:</p>

<ul>
<li><p>Unions members are numbered in the same number space as fields of the containing struct. Remember that the purpose of the numbers is to indicate the evolution order of the struct. The system needs to know when the union fields were declared relative to the non-union fields.</p></li>

<li><p>Notice that we used the “useless” <code>Void</code> type here. We don’t have any extra information to store for the <code>unemployed</code> or <code>selfEmployed</code> cases, but we still want the union to distinguish these states from others.</p></li>

<li><p>By default, when a struct is initialized, the lowest-numbered field in the union is “set”. If you do not want any field set by default, simply declare a field called “unset” and make it the lowest-numbered field.</p></li>

<li><p>You can move an existing field into a new union without breaking compatibility with existing data, as long as all of the other fields in the union are new. Since the existing field is necessarily the lowest-numbered in the union, it will be the union’s default field.</p></li>
</ul>

<p><strong>Wait, why aren’t unions first-class types?</strong></p>

<p>Requiring unions to be declared inside a struct, rather than living as free-standing types, has some important advantages:</p>

<ul>
<li><p>If unions were first-class types, then union members would clearly have to be numbered separately from the containing type’s fields. This means that the compiler, when deciding how to position the union in its containing struct, would have to conservatively assume that any kind of new field might be added to the union in the future. To support this, all unions would have to be allocated as separate objects embedded by pointer, wasting space.</p></li>

<li><p>A free-standing union would be a liability for protocol evolution, because no additional data can be attached to it later on. Consider, for example, a type which represents a parser token. This type is naturally a union: it may be a keyword, identifier, numeric literal, quoted string, etc. So the author defines it as a union, and the type is used widely. Later on, the developer wants to attach information to the token indicating its line and column number in the source file. Unfortunately, this is impossible without updating all users of the type, because the new information ought to apply to all token instances, not just specific members of the union. On the other hand, if unions must be embedded within structs, it is always possible to add new fields to the struct later on.</p></li>

<li><p>When evolving a protocol it is common to discover that some existing field really should have been enclosed in a union, because new fields being added are mutually exclusive with it. With Cap’n Proto’s unions, it is actually possible to “retroactively unionize” such a field without changing its layout. This allows you to continue being able to read old data without wasting space when writing new data. This is only possible when unions are declared within their containing struct.</p></li>
</ul>

<p>Cap’n Proto’s unconventional approach to unions provides these advantages without any real down side: where you would conventionally define a free-standing union type, in Cap’n Proto you may simply define a struct type that contains only that union (probably unnamed), and you have achieved the same effect. Thus, aside from being slightly unintuitive, it is strictly superior.</p>

<h3 id="groups">Groups</h3>

<p>A group is a set of fields that are encapsulated in their own scope.</p>

<pre><code>struct Person {
  # ...

  address :group {
    # Note:  This is a terrible way to use groups, and meant
    #        only to demonstrate the syntax.
    houseNumber @8 :UInt32;
    street @9 :Text;
    city @10 :Text;
    country @11 :Text;
  }
}
</code></pre>

<p>Interface-wise, the above group behaves as if you had defined a nested struct called <code>Address</code> and then a field <code>address :Address</code>. However, a group is not a separate object from its containing struct: the fields are numbered in the same space as the containing struct’s fields, and are laid out exactly the same as if they hadn’t been grouped at all. Essentially, a group is just a namespace.</p>

<p>Groups on their own (as in the above example) are useless, almost as much so as the <code>Void</code> type. They become interesting when used together with unions.</p>

<pre><code>struct Shape {
  area @0 :Float64;

  union {
    circle :group {
      radius @1 :Float64;
    }
    rectangle :group {
      width @2 :Float64;
      height @3 :Float64;
    }
  }
}
</code></pre>

<p>There are two main reason to use groups with unions:</p>

<ol>
<li>They are often more self-documenting. Notice that <code>radius</code> is now a member of <code>circle</code>, so we don’t need a comment to explain that the value of circle is its radius.</li>
<li>You can add additional members later on, without breaking compatibility. Notice how we upgraded <code>square</code> to <code>rectangle</code> above, adding a <code>height</code> field. This definition is actually wire-compatible with the previous version of the <code>Shape</code> example from the “union” section (aside from the fact that <code>height</code> will always be zero when reading old data – hey, it’s not a perfect example). In real-world use, it is common to realize after the fact that you need to add some information to a struct that only applies when one particular union field is set. Without the ability to upgrade to a group, you would have to define the new field separately, and have it waste space when not relevant.</li>
</ol>

<p>Note that a named union is actually exactly equivalent to a named group containing an unnamed union.</p>

<p><strong>Wait, weren’t groups considered a misfeature in Protobufs? Why did you do this again?</strong></p>

<p>They are useful in unions, which Protobufs did not have. Meanwhile, you cannot have a “repeated group” in Cap’n Proto, which was the case that got into the most trouble with Protobufs.</p>

<h3 id="dynamically-typed-fields">Dynamically-typed Fields</h3>

<p>A struct may have a field with type AnyPointer. This field’s value can be of any pointer type – i.e. any struct, interface, list, or blob. This is essentially like a void* in C.</p>

<p>See also <strong>generics</strong>.</p>

<h3 id="enums">Enums</h3>

<p>An enum is a type with a small finite set of symbolic values.</p>

<pre><code>enum Rfc3092Variable {
  foo @0;
  bar @1;
  baz @2;
  qux @3;
  # ...
}
</code></pre>

<p>Like fields, enumerants must be numbered sequentially starting from zero. In languages where enums have numeric values, these numbers will be used, but in general Cap’n Proto enums should not be considered numeric.</p>

<h3 id="interfaces">Interfaces</h3>

<p>An interface has a collection of methods, each of which takes some parameters and return some results. Like struct fields, methods are numbered. Interfaces support inheritance, including multiple inheritance.</p>

<pre><code>interface Node {
  isDirectory @0 () -&gt; (result :Bool);
}

interface Directory extends(Node) {
  list @0 () -&gt; (list :List(Entry));
  struct Entry {
    name @0 :Text;
    node @1 :Node;
  }

  create @1 (name :Text) -&gt; (file :File);
  mkdir @2 (name :Text) -&gt; (directory :Directory);
  open @3 (name :Text) -&gt; (node :Node);
  delete @4 (name :Text);
  link @5 (name :Text, node :Node);
}

interface File extends(Node) {
  size @0 () -&gt; (size :UInt64);
  read @1 (startAt :UInt64 = 0, amount :UInt64 = 0xffffffffffffffff)
       -&gt; (data :Data);
  # Default params = read entire file.

  write @2 (startAt :UInt64, data :Data);
  truncate @3 (size :UInt64);
}
</code></pre>

<p>Notice something interesting here: <code>Node</code>, <code>Directory</code>, and <code>File</code> are interfaces, but several methods take these types as parameters or return them as results. <code>Directory.Entry</code> is a struct, but it contains a Node, which is an interface. Structs (and primitive types) are passed over RPC by value, but interfaces are passed by reference. So when <code>Directory.list</code> is called remotely, the content of a List(Entry) (including the text of each name) is transmitted back, but for the node field, only a reference to some remote Node object is sent.</p>

<p>When an address of an object is transmitted, the RPC system automatically manages making sure that the recipient gets permission to call the addressed object – because if the recipient wasn’t meant to have access, the sender shouldn’t have sent the reference in the first place. This makes it very easy to develop secure protocols with Cap’n Proto – you almost don’t need to think about access control at all. This feature is what makes Cap’n Proto a “capability-based” RPC system – a reference to an object inherently represents a “capability” to access it.</p>

<h3 id="generic-types">Generic Types</h3>

<p>A struct or interface type may be parameterized, making it “generic”. For example, this is useful for defining type-safe containers:</p>

<pre><code>struct Map(Key, Value) {
  entries @0 :List(Entry);
  struct Entry {
    key @0 :Key;
    value @1 :Value;
  }
}

struct People {
  byName @0 :Map(Text, Person);
  # Maps names to Person instances.
}
</code></pre>

<p>Cap’n Proto generics work very similarly to Java generics or C++ templates. Some notes:</p>

<ul>
<li><p>Only pointer types (structs, lists, blobs, and interfaces) can be used as generic parameters, much like in Java. This is a pragmatic limitation: allowing parameters to have non-pointer types would mean that different parameterizations of a struct could have completely different layouts, which would excessively complicate the Cap’n Proto implementation.</p></li>

<li><p>A type declaration nested inside a generic type may use the type parameters of the outer type, as you can see in the example above. This differs from Java, but matches C++. If you want to refer to a nested type from outside the outer type, you must specify the parameters on the outer type, not the inner. For example, <code>Map(Text, Person).Entry</code> is a valid type; <code>Map.Entry(Text, Person)</code> is NOT valid. (Of course, an inner type may declare additional generic parameters.)</p></li>

<li><p>If you refer to a generic type but omit its parameters (e.g. declare a field of type <code>Map</code> rather than <code>Map(T, U)</code>), it is as if you specified <code>AnyPointer</code> for each parameter. Note that such a type is wire-compatible with any specific parameterization, so long as you interpret the <code>AnyPointers</code> as the correct type at runtime.</p></li>

<li><p>Relatedly, it is safe to cast an generic interface of a specific parameterization to a generic interface where all parameters are <code>AnyPointer</code> and vice versa, as long as the <code>AnyPointers</code> are treated as the correct type at runtime. This means that e.g. you can implement a server in a generic way that is correct for all parameterizations but call it from clients using a specific parameterization.</p></li>

<li><p>The encoding of a generic type is exactly the same as the encoding of a type produced by substituting the type parameters manually. For example, <code>Map(Text, Person)</code> is encoded exactly the same as:</p></li>
</ul>

<pre><code>  struct PersonMap {
    # Encoded the same as Map(Text, Person).
    entries @0 :List(Entry);
    struct Entry {
      key @0 :Text;
      value @1 :Person;
    }
  }
</code></pre>

<p>Therefore, it is possible to upgrade non-generic types to generic types while retaining backwards-compatibility.</p>

<ul>
<li>Similarly, a generic interface’s protocol is exactly the same as the interface obtained by manually substituting the generic parameters.</li>
</ul>

<h3 id="generic-methods">Generic Methods</h3>

<p>Interface methods may also have “implicit” generic parameters that apply to a particular method call. This commonly applies to “factory” methods. For example:</p>

<pre><code>interface Assignable(T) {
  # A generic interface, with non-generic methods.
  get @0 () -&gt; (value :T);
  set @1 (value :T) -&gt; ();
}

interface AssignableFactory {
  newAssignable @0 [T] (initialValue :T)
      -&gt; (assignable :Assignable(T));
  # A generic method.
}
</code></pre>

<p>Here, the method <code>newAssignable()</code> is generic. The return type of the method depends on the input type.</p>

<p>Ideally, calls to a generic method should not have to explicitly specify the method’s type parameters, because they should be inferred from the types of the method’s regular parameters. However, this may not always be possible; it depends on the programming language and API details.</p>

<p>Note that if a method’s generic parameter is used only in its returns, not its parameters, then this implies that the returned value is appropriate for any parameterization. For example:</p>

<pre><code>newUnsetAssignable @1 [T] () -&gt; (assignable :Assignable(T));
# Create a new assignable. `get()` on the returned object will
# throw an exception until `set()` has been called at least once.
</code></pre>

<p>Because of the way this method is designed, the returned <code>Assignable</code> is initially valid for any <code>T</code>. Effectively, it doesn’t take on a type until the first time <code>set()</code> is called, and then T retroactively becomes the type of value passed to <code>set()</code>.</p>

<p>In contrast, if it’s the case that the returned type is unknown, then you should NOT declare it as generic. Instead, use <code>AnyPointer</code>, or omit a type’s parameters (since they default to <code>AnyPointer</code>). For example:</p>

<pre><code>getNamedAssignable @2 (name :Text) -&gt; (assignable :Assignable);
# Get the `Assignable` with the given name. It is the
# responsibility of the caller to keep track of the type of each
# named `Assignable` and cast the returned object appropriately.
</code></pre>

<p>Here, we omitted the parameters to <code>Assignable</code> in the return type, because the returned object has a specific type parameterization but it is not locally knowable.</p>

<h3 id="constants">Constants</h3>

<p>You can define constants in Cap’n Proto. These don’t affect what is sent on the wire, but they will be included in the generated code, and can be evaluated using the <code>capnp</code> tool.</p>

<pre><code>const pi :Float32 = 3.14159;
const bob :Person = (name = &quot;Bob&quot;, email = &quot;bob@example.com&quot;);
const secret :Data = 0x&quot;9f98739c2b53835e 6720a00907abd42f&quot;;
</code></pre>

<p>Additionally, you may refer to a constant inside another value (e.g. another constant, or a default value of a field).</p>

<pre><code>const foo :Int32 = 123;
const bar :Text = &quot;Hello&quot;;
const baz :SomeStruct = (id = .foo, message = .bar);
</code></pre>

<p>Note that when substituting a constant into another value, the constant’s name must be qualified with its scope. E.g. if a constant <code>qux</code> is declared nested in a type <code>Corge</code>, it would need to be referenced as <code>Corge.qux</code> rather than just <code>qux</code>, even when used within the <code>Corge</code> scope. Constants declared at the top-level scope are prefixed just with <code>.</code>. This rule helps to make it clear that the name refers to a user-defined constant, rather than a literal value (like <code>true</code> or <code>inf</code>) or an enum value.</p>

<h3 id="nesting-scope-and-aliases">Nesting, Scope, and Aliases</h3>

<p>You can nest constant, alias, and type definitions inside structs and interfaces (but not enums). This has no effect on any definition involved except to define the scope of its name. So in Java terms, inner classes are always “static”. To name a nested type from another scope, separate the path with  <code>.</code>s.</p>

<pre><code>struct Foo {
  struct Bar {
    #...
  }
  bar @0 :Bar;
}

struct Baz {
  bar @0 :Foo.Bar;
}
If typing long scopes becomes cumbersome, you can use `using` to declare an alias.

struct Qux {
  using Foo.Bar;
  bar @0 :Bar;
}

struct Corge {
  using T = Foo.Bar;
  bar @0 :T;
}
</code></pre>

<h3 id="imports">Imports</h3>

<p>An <code>import</code> expression names the scope of some other file:</p>

<pre><code>struct Foo {
  baz @0 :import &quot;bar.capnp&quot;.Baz;
  # Use type &quot;Baz&quot; defined in bar.capnp.
}
</code></pre>

<p>Of course, typically it’s more readable to define an alias:</p>

<pre><code>using Bar = import &quot;bar.capnp&quot;;

struct Foo {
  baz @0 :Bar.Baz;
  # Use type &quot;Baz&quot; defined in bar.capnp.
}
</code></pre>

<p>Or even:</p>

<pre><code>using import &quot;bar.capnp&quot;.Baz;

struct Foo {
  baz @0 :Baz;
  # Use type &quot;Baz&quot; defined in bar.capnp.
}
</code></pre>

<p>The above imports specify relative paths. If the path begins with a <code>/</code>, it is absolute – in this case, the <code>capnp</code> tool searches for the file in each of the search path directories specified with <code>-I</code>.</p>

<h3 id="annotations">Annotations</h3>

<p>Sometimes you want to attach extra information to parts of your protocol that isn’t part of the Cap’n Proto language. This information might control details of a particular code generator, or you might even read it at run time to assist in some kind of dynamic message processing. For example, you might create a field annotation which means “hide from the public”, and when you send a message to an external user, you might invoke some code first that iterates over your message and removes all of these hidden fields.</p>

<p>You may declare annotations and use them like so:</p>

<pre><code>annotation foo(struct, enum) :Text;
# Declare an annotation 'foo' which applies to struct and enum types.

struct MyType $foo(&quot;bar&quot;) {
  # Apply 'foo' to to MyType.

  # ...
}
</code></pre>

<p>The possible targets for an annotation are: <code>file</code>, <code>struct</code>, <code>field</code>, <code>union</code>, <code>group</code>, <code>enum</code>, <code>enumerant</code>, <code>interface</code>, <code>method</code>, <code>parameter</code>, <code>annotation</code>, <code>const</code>. You may also specify <code>*</code> to cover them all.</p>

<pre><code>annotation baz(*) :Int32;
# 'baz' can annotate anything!

$baz(1);  # Annotate the file.

struct MyStruct $baz(2) {
  myField @0 :Text = &quot;default&quot; $baz(3);
  myUnion :union $baz(4) {
    # ...
  }
}

enum MyEnum $baz(5) {
  myEnumerant @0 $baz(6);
}

interface MyInterface $baz(7) {
  myMethod @0 (myParam :Text $baz(9)) -&gt; () $baz(8);
}

annotation myAnnotation(struct) :Int32 $baz(10);
const myConst :Int32 = 123 $baz(11);
</code></pre>

<p><code>Void</code> annotations can omit the value. Struct-typed annotations are also allowed. Tip: If you want an annotation to have a default value, declare it as a struct with a single field with a default value.</p>

<pre><code>annotation qux(struct, field) :Void;

struct MyStruct $qux {
  string @0 :Text $qux;
  number @1 :Int32 $qux;
}

annotation corge(file) :MyStruct;

$corge(string = &quot;hello&quot;, number = 123);

struct Grault {
  value @0 :Int32 = 123;
}

annotation grault(file) :Grault;

$grault();  # value defaults to 123
$grault(value = 456);
</code></pre>

<h3 id="unique-ids">Unique IDs</h3>

<p>A Cap’n Proto file must have a unique 64-bit ID, and each type and annotation defined therein may also have an ID. Use <code>capnp id</code> to generate a new ID randomly. ID specifications begin with <code>@</code>:</p>

<pre><code>@0xdbb9ad1f14bf0b36;
# file ID

struct Foo @0x8db435604d0d3723 {
  # ...
}

enum Bar @0xb400f69b5334aab3 {
  # ...
}

interface Baz @0xf7141baba3c12691 {
  # ...
}

annotation qux @0xf8a1bedf44c89f00 (field) :Text;
</code></pre>

<p>If you omit the ID for a type or annotation, one will be assigned automatically. This default ID is derived by taking the first 8 bytes of the MD5 hash of the parent scope’s ID concatenated with the declaration’s name (where the “parent scope” is the file for top-level declarations, or the outer type for nested declarations). You can see the automatically-generated IDs by “compiling” your file with the <code>-ocapnp</code> flag, which echos the schema back to the terminal annotated with extra information, e.g. <code>capnp compile -ocapnp myschema.capnp</code>. In general, you would only specify an explicit ID for a declaration if that declaration has been renamed or moved and you want the ID to stay the same for backwards-compatibility.</p>

<p>IDs exist to provide a relatively short yet unambiguous way to refer to a type or annotation from another context. They may be used for representing schemas, for tagging dynamically-typed fields, etc. Most languages prefer instead to define a symbolic global namespace e.g. full of “packages”, but this would have some important disadvantages in the context of Cap’n Proto:</p>

<ul>
<li>Programmers often feel the need to change symbolic names and organization in order to make their code cleaner, but the renamed code should still work with existing encoded data.</li>
<li>It’s easy for symbolic names to collide, and these collisions could be hard to detect in a large distributed system with many different binaries using different versions of protocols.</li>
<li>Fully-qualified type names may be large and waste space when transmitted on the wire.</li>
</ul>

<p>Note that IDs are 64-bit (actually, 63-bit, as the first bit is always 1). Random collisions are possible, but unlikely – there would have to be on the order of a billion types before this becomes a real concern. Collisions from misuse (e.g. copying an example without changing the ID) are much more likely.</p>

<h2 id="evolving-your-protocol">Evolving Your Protocol</h2>

<p>A protocol can be changed in the following ways without breaking backwards-compatibility, and without changing the <strong>canonical</strong> encoding of a message:</p>

<ul>
<li><p>New types, constants, and aliases can be added anywhere, since they obviously don’t affect the encoding of any existing type.</p></li>

<li><p>New fields, enumerants, and methods may be added to structs, enums, and interfaces, respectively, as long as each new member’s number is larger than all previous members. Similarly, new fields may be added to existing groups and unions.</p></li>

<li><p>New parameters may be added to a method. The new parameters must be added to the end of the parameter list and must have default values.</p></li>

<li><p>Members can be re-arranged in the source code, so long as their numbers stay the same.</p></li>

<li><p>Any symbolic name can be changed, as long as the type ID / ordinal numbers stay the same. Note that type declarations have an implicit ID generated based on their name and parent’s ID, but you can use capnp compile -ocapnp myschema.capnp to find out what that number is, and then declare it explicitly after your rename.</p></li>

<li><p>Type definitions can be moved to different scopes, as long as the type ID is declared explicitly.</p></li>

<li><p>A field can be moved into a group or a union, as long as the group/union and all other fields within it are new. In other words, a field can be replaced with a group or union containing an equivalent field and some new fields.</p></li>

<li><p>A non-generic type can be made generic, and new generic parameters may be added to an existing generic type. Other types used inside the body of the newly-generic type can be replaced with the new generic parameter so long as all existing users of the type are updated to bind that generic parameter to the type it replaced. For example:</p>

<pre><code>struct Map {
entries @0 :List(Entry);
struct Entry {
  key @0 :Text;
  value @1 :Text;
}
}
</code></pre></li>
</ul>

<p>Can change to:</p>

<pre><code>  struct Map(Key, Value) {
    entries @0 :List(Entry);
    struct Entry {
      key @0 :Key;
      value @1 :Value;
    }
  }
</code></pre>

<p>As long as all existing uses of <code>Map</code> are replaced with <code>Map(Text, Text)</code> (and any uses of <code>Map.Entry</code> are replaced with <code>Map(Text, Text).Entry</code>).</p>

<p>(This rule applies analogously to generic methods.)</p>

<p>The following changes are backwards-compatible but may change the canonical encoding of a message. Apps that rely on canonicalization (such as some cryptographic protocols) should avoid changes in this list, but most apps can safely use them:</p>

<ul>
<li>A field of type <code>List(T)</code>, where <code>T</code> is a primitive type, blob, or list, may be changed to type <code>List(U)</code>, where <code>U</code> is a struct type whose <code>@0</code> field is of type <code>T</code>. This rule is useful when you realize too late that you need to attach some extra data to each element of your list. Without this rule, you would be stuck defining parallel lists, which are ugly and error-prone. As a special exception to this rule, <code>List(Bool)</code> may <strong>not</strong> be upgraded to a list of structs, because implementing this for bit lists has proven unreasonably expensive.</li>
</ul>

<p>Any change not listed above should be assumed <strong>NOT</strong> to be safe. In particular:</p>

<ul>
<li>You cannot change a field, method, or enumerant’s number.</li>
<li>You cannot change a field or method parameter’s type or default value.</li>
<li>You cannot change a type’s ID.</li>
<li>You cannot change the name of a type that doesn’t have an explicit ID, as the implicit ID is generated based in part on the type name.</li>
<li>You cannot move a type to a different scope or file unless it has an explicit ID, as the implicit ID is based in part on the scope’s ID.</li>
<li>You cannot move an existing field into or out of an existing union, nor can you form a new union containing more than one existing field.</li>
</ul>

<p>Also, these rules only apply to the Cap’n Proto native encoding. It is sometimes useful to transcode Cap’n Proto types to other formats, like JSON, which may have different rules (e.g., field names cannot change in JSON).</p>

<hr />

<p>(Notice: Origin official document is <a href="https://capnproto.org/language.html" title="cap'n proto schema language"><em>Here</em></a>)</p>
        </div>
        <div id="post-navigator">
          <a id="post-navigator-prev" href="http://alimy.me/post/dev_201904141055/" title="上一篇">&lt;&lt; Tus Resumable Upload Protocol</a>
          
        </div>
        <div id="post-comments">
          <h3>Comments</h3>
          


<div id="disqus_thread"></div>

<script type="text/javascript">
  var disqusUsername = "alimy";

  (function() { 
  var d = document, s = d.createElement('script');

  s.src = '//' + disqusUsername + '.disqus.com/embed.js';

  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


        </div>
          <footer id="copyright"> <p>&copy;2015-2019 <a href="mailto:alimy@gility.net" title="Email:alimy@gility.net">Alimy</a> All rights reserved. <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258492321'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1258492321' type='text/javascript'%3E%3C/script%3E"));</script></p></footer>

    </div>
    <script>(function(){var WebP=new Image();WebP.onload=WebP.onerror=function(){
if(WebP.height!=2){var sc=document.createElement('script');sc.type='text/javascript';sc.async=true;
var s=document.getElementsByTagName('script')[0];sc.src='http://alimy.me/js/webpjs-0.0.2.min.js';s.parentNode.insertBefore(sc,s);}};
WebP.src='data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';})();</script>

  </body>
</html>
