<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Posts on Alimy </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://alimy.me/post/</link>
    
    
    <copyright>&amp;copy;2016, Alimy; all rights reserved.</copyright>
    <updated>Sat, 24 Mar 2018 12:18:00 CST</updated>
    
    <item>
      <title>rsync: 基本命令和用法</title>
      <link>http://alimy.me/post/dev_201803241218/</link>
      <pubDate>Sat, 24 Mar 2018 12:18:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201803241218/</guid>
      <description>&lt;h3 id=&#34;1-说在前面的话&#34;&gt;1 说在前面的话&lt;/h3&gt;

&lt;p&gt;rsync官方网站: &lt;a href=&#34;https://www.samba.org/ftp/rsync/rsync.html,&#34; title=&#34;rsync官方网站&#34;&gt;https://www.samba.org/ftp/rsync/rsync.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;rsync是可以实现增量备份的工具。配合任务计划，rsync能实现定时或间隔同步，配合inotify或sersync，可以实现触发式的实时同步。&lt;/p&gt;

&lt;p&gt;rsync可以实现scp的远程拷贝(rsync不支持远程到远程的拷贝，但scp支持)、cp的本地拷贝、rm删除和&amp;rdquo;ls -l&amp;rdquo;显示文件列表等功能。但需要注意的是，rsync的最终目的或者说其原始目的是实现两端主机的文件同步，因此实现的scp/cp/rm等功能仅仅只是同步的辅助手段，且rsync实现这些功能的方式和这些命令是不一样的。事实上，rsync有一套自己的算法，其算法原理以及rsync对算法实现的机制可能比想象中要复杂一些。平时使用rsync实现简单的备份、同步等功能足以，没有多大必要去深究这些原理性的内容。但是想要看懂rsync命令的man文档、使用&amp;rdquo;-vvvv&amp;rdquo;分析rsync执行过程，以及实现rsync更强大更完整的功能，没有这些理论知识的支持是绝对不可能实现的。本篇文章将简单介绍rsync的使用方法和它常用的功能。在本篇文章之后的下几篇文章中，将介绍inotify+rsync和sersync，再之后将详细解释rsync相关的原理，其中包括官方技术报告的翻译(即算法原理)、rsync同步的整个过程(也是官方推荐文章的翻译)，然后专门使用一篇文章通过示例来详细解释rsync算法原理，最后给出rsync的man文档翻译。希望各位朋友能藉此深入rsync。&lt;/p&gt;

&lt;p&gt;回归正题，以下是rsync相关基础内容。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-rsync同步基本说明&#34;&gt;2 rsync同步基本说明&lt;/h3&gt;

&lt;p&gt;rsync的目的是实现本地主机和远程主机上的文件同步(包括本地推到远程，远程拉到本地两种同步方式)，也可以实现本地不同路径下文件的同步，但不能实现远程路径1到远程路径2之间的同步(scp可以实现)。&lt;/p&gt;

&lt;p&gt;不考虑rsync的实现细节，就文件同步而言，涉及了源文件和目标文件的概念，还涉及了以哪边文件为同步基准。例如，想让目标主机上的文件和本地文件保持同步，则是以本地文件为同步基准，将本地文件作为源文件推送到目标主机上。反之，如果想让本地主机上的文件和目标主机上的文件保持同步，则目标主机上的文件为同步基准，实现方式是将目标主机上的文件作为源文件拉取到本地。当然，要保持本地的两个文件相互同步，rsync也一样能实现，这就像Linux中cp命令一样，以本地某文件作为源，另一文件作为目标文件，但请注意，虽然rsync和cp能达到相同的目的，但它们的实现方式是不一样的。&lt;/p&gt;

&lt;p&gt;既然是文件同步，在同步过程中必然会涉及到源和目标两文件之间版本控制的问题，例如是否要删除源主机上没有但目标上多出来的文件，目标文件比源文件更新(newer than source)时是否仍要保持同步，遇到软链接时是拷贝软链接本身还是拷贝软链接所指向的文件，目标文件已存在时是否要先对其做个备份等等。&lt;/p&gt;

&lt;p&gt;rsync同步过程中由两部分模式组成：决定哪些文件需要同步的检查模式以及文件同步时的同步模式。&lt;/p&gt;

&lt;p&gt;(1).检查模式是指按照指定规则来检查哪些文件需要被同步，例如哪些文件是明确被排除不传输的。默认情况下，rsync使用&amp;rdquo;quick check&amp;rdquo;算法快速检查源文件和目标文件的大小、mtime(修改时间)是否一致，如果不一致则需要传输。当然，也可以通过在rsync命令行中指定某些选项来改变quick check的检查模式，比如&amp;rdquo;&amp;ndash;size-only&amp;rdquo;选项表示&amp;rdquo;quick check&amp;rdquo;将仅检查文件大小不同的文件作为待传输文件。rsync支持非常多的选项，其中检查模式的自定义性是非常有弹性的。&lt;/p&gt;

&lt;p&gt;(2).同步模式是指在文件确定要被同步后，在同步过程发生之前要做哪些额外工作。例如上文所说的是否要先删除源主机上没有但目标主机上有的文件，是否要先备份已存在的目标文件，是否要追踪链接文件等额外操作。rsync也提供非常多的选项使得同步模式变得更具弹性。&lt;/p&gt;

&lt;p&gt;相对来说，为rsync手动指定同步模式的选项更常见一些，只有在有特殊需求时才指定检查模式，因为大多数检查模式选项都可能会影响rsync的性能。&lt;/p&gt;

&lt;h3 id=&#34;3-rsync三种工作方式&#34;&gt;3 rsync三种工作方式&lt;/h3&gt;

&lt;p&gt;以下是rsync的语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Local:  rsync [OPTION...] SRC... [DEST]

Access via remote shell:
  Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]
  Push: rsync [OPTION...] SRC... [USER@]HOST:DEST

Access via rsync daemon:
  Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]
        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
  Push: rsync [OPTION...] SRC... [USER@]HOST::DEST
        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此语法可知，rsync有三种工作方式：&lt;/p&gt;

&lt;p&gt;(1).本地文件系统上实现同步。命令行语法格式为上述&amp;rdquo;Local&amp;rdquo;段的格式。&lt;/p&gt;

&lt;p&gt;(2).本地主机使用远程shell和远程主机通信。命令行语法格式为上述&amp;rdquo;Access via remote shell&amp;rdquo;段的格式。&lt;/p&gt;

&lt;p&gt;(3).本地主机通过网络套接字连接远程主机上的rsync daemon。命令行语法格式为上述&amp;rdquo;Access via rsync daemon&amp;rdquo;段的格式。&lt;/p&gt;

&lt;p&gt;前两者的本质是通过管道通信，即使是远程shell。而方式(3)则是让远程主机上运行rsync服务，使其监听在一个端口上，等待客户端的连接。&lt;/p&gt;

&lt;p&gt;但是，通过远程shell也能临时启动一个rsync daemon，这不同于方式(3)，它不要求远程主机上事先启动rsync服务，而是临时派生出rsync daemon，它是单用途的一次性daemon，仅用于临时读取daemon的配置文件，当此次rsync同步完成，远程shell启动的rsync daemon进程也会自动消逝。此通信方式的命令行语法格式同&amp;rdquo;Access via rsync daemon&amp;rdquo;，但要求options部分必须明确指定&amp;rdquo;&amp;ndash;rsh&amp;rdquo;选项或其短选项&amp;rdquo;-e&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;以下是对rsync语法的简单说明，由于rsync支持一百多个选项，所以此处只介绍几个常用选项。完整的选项说明以及rsync的使用方法见我翻译的&amp;rdquo;man rsync&amp;rdquo;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Local:  rsync [OPTION...] SRC... [DEST]

Access via remote shell:
  Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]
  Push: rsync [OPTION...] SRC... [USER@]HOST:DEST

Access via rsync daemon:
  Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]
        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
  Push: rsync [OPTION...] SRC... [USER@]HOST::DEST
        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，第一个路径参数一定是源文件路径，即作为同步基准的一方，可以同时指定多个源文件路径。最后一个路径参数则是目标文件路径，也就是待同步方。路径的格式可以是本地路径，也可以是使用user@host:path或user@host::path的远程路径，如果主机和path路径之间使用单个冒号隔开，表示使用的是远程shell通信方式，而使用双冒号隔开的则表示的是连接rsync daemon。另外，连接rsync daemon时，还提供了URL格式的路径表述方式rsync://user@host/path。&lt;/p&gt;

&lt;p&gt;如果仅有一个SRC或DEST参数，则将以类似于&amp;rdquo;ls -l&amp;rdquo;的方式列出源文件列表(只有一个路径参数，总会认为是源文件)，而不是复制文件。&lt;/p&gt;

&lt;p&gt;如果对rsync不熟悉，可暂先只了解本地以及远程shell格式的user@host:path路径格式。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync /etc/fstab /tmp                # 在本地同步
[root@xuexi ~]# rsync -r /etc 172.16.10.5:/tmp       # 将本地/etc目录拷贝到远程主机的/tmp下，以保证远程/tmp目录和本地/etc保持同步
[root@xuexi ~]# rsync -r 172.16.10.5:/etc /tmp       # 将远程主机的/etc目录拷贝到本地/tmp下，以保证本地/tmp目录和远程/etc保持同步
[root@xuexi ~]# rsync /etc/                          # 列出本地/etc/目录下的文件列表
[root@xuexi ~]# rsync 172.16.10.5:/tmp/              # 列出远程主机上/tmp/目录下的文件列表
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，使用rsync一定要注意的一点是，源路径如果是一个目录的话，带上尾随斜线和不带尾随斜线是不一样的，不带尾随斜线表示的是整个目录包括目录本身，带上尾随斜线表示的是目录中的文件，不包括目录本身。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync /etc /tmp
[root@xuexi ~]# rsync /etc/ /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个命令会在/tmp目录下创建etc目录，而第二个命令不会在/tmp目录下创建etc目录，源路径/etc/中的所有文件都直接放在/tmp目录下。&lt;/p&gt;

&lt;h3 id=&#34;4-选项说明和示例&#34;&gt;4 选项说明和示例&lt;/h3&gt;

&lt;p&gt;接下来是rsync的选项说明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-v：显示rsync过程中详细信息。可以使用&amp;quot;-vvvv&amp;quot;获取更详细信息。
-P：显示文件传输的进度信息。(实际上&amp;quot;-P&amp;quot;=&amp;quot;--partial --progress&amp;quot;，其中的&amp;quot;--progress&amp;quot;才是显示进度信息的)。
-n --dry-run  ：仅测试传输，而不实际传输。常和&amp;quot;-vvvv&amp;quot;配合使用来查看rsync是如何工作的。
-a --archive  ：归档模式，表示递归传输并保持文件属性。等同于&amp;quot;-rtopgDl&amp;quot;。
-r --recursive：递归到目录中去。
-t --times：保持mtime属性。强烈建议任何时候都加上&amp;quot;-t&amp;quot;，否则目标文件mtime会设置为系统时间，导致下次更新
          ：检查出mtime不同从而导致增量传输无效。
-o --owner：保持owner属性(属主)。
-g --group：保持group属性(属组)。
-p --perms：保持perms属性(权限，不包括特殊权限)。
-D        ：是&amp;quot;--device --specials&amp;quot;选项的组合，即也拷贝设备文件和特殊文件。
-l --links：如果文件是软链接文件，则拷贝软链接本身而非软链接所指向的对象。
-z        ：传输时进行压缩提高效率。
-R --relative：使用相对路径。意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性。用法见下文示例。
--size-only ：默认算法是检查文件大小和mtime不同的文件，使用此选项将只检查文件大小。
-u --update ：仅在源mtime比目标已存在文件的mtime新时才拷贝。注意，该选项是接收端判断的，不会影响删除行为。
-d --dirs   ：以不递归的方式拷贝目录本身。默认递归时，如果源为&amp;quot;dir1/file1&amp;quot;，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1。
--max-size  ：限制rsync传输的最大文件大小。可以使用单位后缀，还可以是一个小数值(例如：&amp;quot;--max-size=1.5m&amp;quot;)
--min-size  ：限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件。
--exclude   ：指定排除规则来排除不需要传输的文件。
--delete    ：以SRC为主，对DEST进行同步。多则删之，少则补之。注意&amp;quot;--delete&amp;quot;是在接收端执行的，所以它是在
            ：exclude/include规则生效之后才执行的。
-b --backup ：对目标上已存在的文件做一个备份，备份的文件名后默认使用&amp;quot;~&amp;quot;做后缀。
--backup-dir：指定备份文件的保存路径。不指定时默认和待备份文件保存在同一目录下。
-e          ：指定所要使用的远程shell程序，默认为ssh。
--port      ：连接daemon时使用的端口号，默认为873端口。
--password-file：daemon模式时的密码文件，可以从中读取密码实现非交互式。注意，这不是远程shell认证的密码，而是rsync模块认证的密码。
-W --whole-file：rsync将不再使用增量传输，而是全量传输。在网络带宽高于磁盘带宽时，该选项比增量传输更高效。
--existing  ：要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。
--ignore-existing：要求只更新目标端不存在的文件。和&amp;quot;--existing&amp;quot;结合使用有特殊功能，见下文示例。
--remove-source-files：要求删除源端已经成功传输的文件。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rsync的选项非常多，能够实现非常具有弹性的功能，以上选项仅仅只是很小一部分常用的选项，关于更完整更详细的选项说明，见我的rsync man手册翻译。&lt;/p&gt;

&lt;p&gt;虽然选项非常多，但最常用的选项组合是&amp;rdquo;avz&amp;rdquo;，即压缩和显示部分信息，并以归档模式传输。&lt;/p&gt;

&lt;h4 id=&#34;4-1-基础示例&#34;&gt;4.1 基础示例&lt;/h4&gt;

&lt;p&gt;以下是几个本地同步示例和通过远程shell实现的同步示例，示例中没有使用&amp;rdquo;-a&amp;rdquo;选项，目的是为了更清晰地说明各选项的作用。&lt;/p&gt;

&lt;p&gt;(1).将/etc/fstab拷贝到/tmp目录下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync /etc/fstab /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2).将/etc/cron.d目录拷贝到/tmp下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync -r /etc/cron.d /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令会在目标主机上创建/tmp/cron.d目录，并将/etc/cron.d/中的文件放入到/tmp/cron.d/目录中，也就是说默认情况下，是不会在目录路径下创建上层目录/etc的。&lt;/p&gt;

&lt;p&gt;(3).将/etc/cron.d目录拷贝到/tmp下，但要求在/tmp下也生成etc子目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync -R -r /etc/cron.d /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&amp;rdquo;-R&amp;rdquo;选项表示使用相对路径，此相对路径是以目标目录为根的。对于上面的示例，表示在目标上的/tmp下创建etc/cron.d目录，即/tmp/etc/cron.d，etc/cron.d的根&amp;rdquo;/&amp;ldquo;代表的就是目标/tmp。&lt;/p&gt;

&lt;p&gt;如果要拷贝的源路径较长，但只想在目标主机上保留一部分目录结构，例如要拷贝/var/log/anaconda/*到/tmp下，但只想在/tmp下保留从log开始的目录，如何操作？使用一个点代表相对路径的起始位置即可，也就是将长目录进行划分。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync -R -r /var/./log/anaconda /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，从点开始的目录都是相对路径，其相对根目录为目标路径。所以对于上面的示例，将在目标上创建/tmp/log/anaconda/*。&lt;/p&gt;

&lt;p&gt;(4).对远程目录下已存在文件做一个备份。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync -R -r --backup /var/./log/anaconda /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在目标目录下，已存在的文件就被做一个备份，备份文件默认使用&amp;rdquo;~&amp;ldquo;做后缀，可以使用&amp;rdquo;&amp;ndash;suffix&amp;rdquo;指定备份后缀。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi tmp]# ll log/anaconda/
total 3112
-rw------- 1 root root    6668 Jul 14 12:45 anaconda.log
-rw------- 1 root root    6668 Jul 14 11:44 anaconda.log~
-rw------- 1 root root    3826 Jul 14 12:45 ifcfg.log
-rw------- 1 root root    3826 Jul 14 11:44 ifcfg.log~
-rw------- 1 root root 1102699 Jul 14 12:45 journal.log
-rw------- 1 root root 1102699 Jul 14 11:44 journal.log~
-rw------- 1 root root       0 Jul 14 12:45 ks-script-1uLekR.log
-rw------- 1 root root       0 Jul 14 11:44 ks-script-1uLekR.log~
-rw------- 1 root root       0 Jul 14 12:45 ks-script-iGpl4q.log
-rw------- 1 root root       0 Jul 14 11:44 ks-script-iGpl4q.log~
-rw------- 1 root root  160420 Jul 14 12:45 packaging.log
-rw------- 1 root root  160420 Jul 14 11:44 packaging.log~
-rw------- 1 root root   27906 Jul 14 12:45 program.log
-rw------- 1 root root   27906 Jul 14 11:44 program.log~
-rw------- 1 root root   78001 Jul 14 12:45 storage.log
-rw------- 1 root root   78001 Jul 14 11:44 storage.log~
-rw------- 1 root root  197961 Jul 14 12:45 syslog
-rw------- 1 root root  197961 Jul 14 11:44 syslog~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用&amp;rdquo;&amp;ndash;backup-dir&amp;rdquo;指定备份文件保存路径，但要求保存路径必须存在。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# mkdir /tmp/log_back

[root@xuexi ~]# rsync -R -r --backup --backup-dir=/tmp/log_back /var/./log/anaconda /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定备份路径后，默认将不会加备份后缀，除非使用&amp;rdquo;&amp;ndash;suffix&amp;rdquo;显式指定后缀，如&amp;rdquo;&amp;ndash;suffix=~&amp;ldquo;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi tmp]# tree /tmp/log_back/
/tmp/log_back/
└── log
    └── anaconda
        ├── anaconda.log
        ├── ifcfg.log
        ├── journal.log
        ├── ks-script-1uLekR.log
        ├── ks-script-iGpl4q.log
        ├── packaging.log
        ├── program.log
        ├── storage.log
        └── syslog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(5).指定ssh连接参数，如端口、连接的用户、ssh选项等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi tmp]# &amp;gt;~/.ssh/known_hosts   # 先清空host key以便下面的测试

[root@xuexi tmp]# rsync -e &amp;quot;ssh -p 22 -o StrictHostKeyChecking=no&amp;quot; /etc/fstab 172.16.10.5:/tmp
Warning: Permanently added &#39;172.16.10.5&#39; (RSA) to the list of known hosts.
root@172.16.10.5&#39;s password:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见直接指定ssh参数是生效的。&lt;/p&gt;

&lt;p&gt;(6).&amp;ldquo;&amp;ndash;existing&amp;rdquo;和&amp;rdquo;&amp;ndash;ignore-existing&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;rdquo;&amp;ndash;existing&amp;rdquo;是只更新目标端已存在的文件。&lt;/p&gt;

&lt;p&gt;目前/tmp/{a,b}目录中内容如下，bashrc在a目录中，crontab在b目录中，且a目录中多了一个c子目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# tree /tmp/{a,b}
/tmp/a
├── bashrc
├── c
│   └── find
├── fstab
├── profile
└── rc.local
/tmp/b
├── crontab
├── fstab
├── profile
└── rc.local

1 directory, 9 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&amp;rdquo;&amp;ndash;existing&amp;rdquo;选项使得只更新目标端已存在的文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync -r -v --existing /tmp/a/ /tmp/b           
sending incremental file list
fstab
profile
rc.local

sent 2972 bytes  received 70 bytes  6084.00 bytes/sec
total size is 204755  speedup is 67.31
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果只有3个目标上已存在的文件被更新了，由于目标上没有c目录，所以c目录中的文件也没有进行传输。&lt;/p&gt;

&lt;p&gt;而&amp;rdquo;&amp;ndash;ignore-existing&amp;rdquo;是更新目标端不存在的文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync -r -v --ignore-existing /tmp/a/ /tmp/b
sending incremental file list
bashrc
c/
c/find

sent 202271 bytes  received 54 bytes  404650.00 bytes/sec
total size is 204755  speedup is 1.01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(7).&amp;ldquo;&amp;ndash;remove-source-files&amp;rdquo;删除源端文件。&lt;/p&gt;

&lt;p&gt;使用该选项后，源端已经更新成功的文件都会被删除，源端所有未传输或未传输成功的文件都不会被移除。未传输成功的原因有多种，如exclude排除了，&amp;rdquo;quick check&amp;rdquo;未选项该文件，传输中断等等。&lt;/p&gt;

&lt;p&gt;总之，显示在&amp;rdquo;rsync -v&amp;rdquo;被传输列表中的文件都会被移除。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync -r -v --remove-source-files /tmp/a/anaconda /tmp/a/audit /tmp       
sending incremental file list
anaconda/anaconda.log
anaconda/ifcfg.log
anaconda/journal.log
anaconda/ks-script-1uLekR.log
anaconda/ks-script-iGpl4q.log
anaconda/packaging.log
anaconda/program.log
anaconda/storage.log
anaconda/syslog
audit/audit.log

sent 4806915 bytes  received 204 bytes  9614238.00 bytes/sec
total size is 4805676  speedup is 1.00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述显示出来的文件在源端全部被删除。&lt;/p&gt;

&lt;h4 id=&#34;4-2-exclude-排除规则&#34;&gt;4.2 &amp;ldquo;&amp;ndash;exclude&amp;rdquo;排除规则&lt;/h4&gt;

&lt;p&gt;使用&amp;rdquo;&amp;ndash;exclude&amp;rdquo;选项指定排除规则，排除那些不需要传输的文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi tmp]# rsync -r -v --exclude=&amp;quot;anaconda/*.log&amp;quot; /var/log/anaconda /var/log/audit /tmp
sending incremental file list
anaconda/
anaconda/syslog
audit/
audit/audit.log

sent 3365629 bytes  received 58 bytes  6731374.00 bytes/sec
total size is 3365016  speedup is 1.00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上例中只排除了anaconda目录中的log文件，但是audit目录中的log文件是正常传输的。&lt;/p&gt;

&lt;p&gt;注意，一个&amp;rdquo;&amp;ndash;exclude&amp;rdquo;只能指定一条规则，要指定多条排除规则，需要使用多个&amp;rdquo;&amp;ndash;exclude&amp;rdquo;选项，或者将排除规则写入到文件中，然后使用&amp;rdquo;&amp;ndash;exclude-from&amp;rdquo;选项读取该规则文件。&lt;/p&gt;

&lt;p&gt;另外，除了&amp;rdquo;&amp;ndash;exclude&amp;rdquo;排除规则，还有&amp;rdquo;&amp;ndash;include&amp;rdquo;包含规则，顾名思义，它就是筛选出要进行传输的文件，所以include规则也称为传输规则。它的使用方法和&amp;rdquo;&amp;ndash;exclude&amp;rdquo;一样。如果一个文件即能匹配排除规则，又能匹配包含规则，则先匹配到的立即生效，生效后就不再进行任何匹配。&lt;/p&gt;

&lt;p&gt;最后，关于规则，最重要的一点是它的作用时间。当发送端敲出rsync命令后，rsync将立即扫描命令行中给定的文件和目录(扫描过程中还会按照目录进行排序，将同一个目录的文件放在相邻的位置)，这称为拷贝树(copy tree)，扫描完成后将待传输的文件或目录记录到文件列表中，然后将文件列表传输给接收端。而筛选规则的作用时刻是在扫描拷贝树时，所以会根据规则来匹配并决定文件是否记录到文件列表中(严格地说是会记录到文件列表中的，只不过排除的文件会被标记为hide隐藏起来)，只有记录到了文件列表中的文件或目录才是真正需要传输的内容。换句话说，筛选规则的生效时间在rsync整个同步过程中是非常靠前的，它会影响很多选项的操作对象，最典型的如&amp;rdquo;&amp;ndash;delete&amp;rdquo;。也许，你看完这一整篇文章都没感觉到这一点的重要性，但如果你阅读rsync的man文档或者学习rsync的原理，你一定会深有体会。&lt;/p&gt;

&lt;p&gt;实际上，排除规则和包含规则都只是&amp;rdquo;&amp;ndash;filter&amp;rdquo;筛选规则的两种特殊规则。&amp;rdquo;&amp;ndash;filter&amp;rdquo;比较复杂，它有自己的规则语法和匹配模式，由于篇幅有限，以及考虑到本文的难度定位，&amp;rdquo;&amp;ndash;filter&amp;rdquo;规则不便在此多做解释，仅简单说明下规则类，帮助理解下文的&amp;rdquo;&amp;ndash;delete&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;以下是rsync中的规则种类，不解之处请结合下文的&amp;rdquo;&amp;ndash;delete&amp;rdquo;分析：&lt;/p&gt;

&lt;p&gt;(1).exclude规则：即排除规则，只作用于发送端，被排除的文件不会进入文件列表(实际上是加上隐藏规则进行隐藏)。&lt;/p&gt;

&lt;p&gt;(2).include规则：即包含规则，也称为传输规则，只作用于发送端，被包含的文件将明确记录到文件列表中。&lt;/p&gt;

&lt;p&gt;(3).hide规则：即隐藏规则，只作用于发送端，隐藏后的文件对于接收端来说是看不见的，也就是说接收端会认为它不存在于源端。&lt;/p&gt;

&lt;p&gt;(4).show规则：即显示规则，只作用于发送端，是隐藏规则的反向规则。&lt;/p&gt;

&lt;p&gt;(5).protect规则：即保护规则，该规则只作用于接收端，被保护的文件不会被删除掉。&lt;/p&gt;

&lt;p&gt;(6).risk规则：即取消保护规则。是protect的反向规则。&lt;/p&gt;

&lt;p&gt;除此之外，还有一种规则是&amp;rdquo;clear规则&amp;rdquo;，作用是删除include/exclude规则列表。&lt;/p&gt;

&lt;h4 id=&#34;4-3-delete-解释&#34;&gt;4.3 &amp;ldquo;&amp;ndash;delete&amp;rdquo;解释&lt;/h4&gt;

&lt;p&gt;使用&amp;rdquo;&amp;ndash;delete&amp;rdquo;选项后，接收端的rsync会先删除目标目录下已经存在，但源端目录不存在的文件。也就是&amp;rdquo;多则删之，少则补之&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;例如，先实现一次同步，再向目标目录中拷贝一个新文件，这样目标目录中就比源目录多出一个文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync -r /etc/cron.d /tmp/

[root@xuexi ~]# cp /etc/fstab /tmp/cron.d/

[root@xuexi ~]# ls /tmp/cron.d/
0hourly  fstab  raid-check  sysstat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再使用&amp;rdquo;&amp;ndash;delete&amp;rdquo;选项，这时会将目标端多出的文件给删除掉，然后进行同步。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync -r -v /etc/cron.d /tmp --delete
sending incremental file list
deleting cron.d/fstab
cron.d/0hourly
cron.d/raid-check
cron.d/sysstat

sent 704 bytes  received 70 bytes  1548.00 bytes/sec
total size is 471  speedup is 0.61
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的行为实现了远程删除的功能，对于作用于本地的rsync，也就实现了rm的本地删除功能。而且，如果使用空目录作为源目录，则它的作用是清空目录上的整个目录。&lt;/p&gt;

&lt;p&gt;如果将&amp;rdquo;&amp;ndash;delete&amp;rdquo;选项和&amp;rdquo;&amp;ndash;exlcude&amp;rdquo;选项一起使用，则被排除的文件不会被删除。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync -r /var/log/anaconda /var/log/audit /tmp  # 先进行一次同步以便测试

[root@xuexi ~]# cp /etc/fstab /tmp/anaconda/                    # 拷贝一个新文件到目标目录以便测试

[root@xuexi ~]# rsync -r -v --exclude=&amp;quot;anaconda/*.log&amp;quot; /var/log/anaconda /var/log/audit /tmp --delete
sending incremental file list
deleting anaconda/fstab
anaconda/syslog
audit/audit.log

sent 3406190 bytes  received 52 bytes  6812484.00 bytes/sec
total size is 3405579  speedup is 1.00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果发现只删除了&amp;rdquo;anaconda/fstab&amp;rdquo;文件，被&amp;rdquo;&amp;ndash;exclude&amp;rdquo;规则匹配的anaconda/*.log文件都没有被删除。也就是网上所说的言论：exclude排除的文件不会被删除。&lt;/p&gt;

&lt;p&gt;结论是没错的，但我想很多人不知道为何会如此，也可能从来没想过为何会如此，所以我简单地做个说明。&lt;/p&gt;

&lt;p&gt;在发送端将文件列表发送给接收端后，接收端的generator(要是不知道，你认为是某个就好了)进程会扫描每个文件列表中的信息，然后对列表中的每个信息条目都计算数据块校验码，最后将数据库校验码发给发送端，发送端通过校验码来匹配哪些数据块是需要传输的，这样就实现了增量传输的功能——只传输改变的部分，不会传输整个文件。而delete删除的时间点是generator进程处理每个文件列表时、生成校验码之前进行的，先将目标上存在但源上不存在的多余文件删除，这样就无需为多余的文件生成校验码。&lt;/p&gt;

&lt;p&gt;所以，delete动作是比&amp;rdquo;&amp;ndash;exclude&amp;rdquo;规则更晚执行的，被&amp;rdquo;&amp;ndash;exlcude&amp;rdquo;规则排除的文件不会进入文件列表中，在执行了delete时会认为该文件不存在于源端，从而导致目标端将这些文件删除。但这是想当然的，尽管理论上确实是这样的，但是rsync为了防止众多误删除情况，提供了两种规则：保护规则(protect)和取消保护规则(risk)。默认情况下，&amp;rdquo;&amp;ndash;delete&amp;rdquo;和&amp;rdquo;&amp;ndash;exclude&amp;rdquo;一起使用时，虽然发送端的exclude规则将文件标记为隐藏，使得接收端认为这些被排除文件在源端不存在，但rsync会将这些隐藏文件标记为保护文件，使得它们不受delete行为的影响，这样delete就删除不了这些被排除的文件。如果还是想要强行删除被exclude排除的文件，可以使用&amp;rdquo;&amp;ndash;delete-excluded&amp;rdquo;选项强制取消保护，这样即使被排除的文件也会被删除。&lt;/p&gt;

&lt;p&gt;那么现在，是否理解了网上的言论&amp;rdquo;exclude排除的文件不会被删除&amp;rdquo;？&lt;/p&gt;

&lt;p&gt;除了&amp;rdquo;&amp;ndash;delete&amp;rdquo;，相关的选项还有&amp;rdquo;&amp;ndash;delete-before&amp;rdquo;、&amp;rdquo;&amp;ndash;delete-during&amp;rdquo;、&amp;rdquo;&amp;ndash;delete-delay&amp;rdquo;等，它们都隐含了&amp;rdquo;&amp;ndash;delete&amp;rdquo;选项，它们分别表示generator处理各个文件列表之前一次性全部删除待删除文件、处理文件列表时处理到哪个文件列表就删除该文件列表中的待删除文件，以及同步完所有数据后一次性删除所有待删除文件。&lt;/p&gt;

&lt;p&gt;举个例子，假如源端要传输3个目录a、b、c，在目标端a目录中有a1、a2、a3共3个文件需要被删除，b目录中有b1、b2、b3需要删除，同理c目录也一样c1、c2、c3需要被删除。&lt;/p&gt;

&lt;p&gt;如果是&amp;rdquo;&amp;ndash;delete-before&amp;rdquo;，则在目标端rsync刚启动时，就会把a1-a3、b1-b3、c1-c3一次性删除，然后才会处理文件列表中的a目录，处理完a后处理b，再是c。&lt;/p&gt;

&lt;p&gt;如果是&amp;rdquo;&amp;ndash;delete-during&amp;rdquo;，则在目标端rsync刚启动时，先处理文件列表中的a目录，处理a目录时发现此目录中有待删除文件a1-a3，顺手就删除它们，然后完成a目录的相关操作，再处理文件列表中的b目录，发现也有待删除文件b1-b3，顺手删除它们，同理c1-c3也如此。&lt;/p&gt;

&lt;p&gt;如果是&amp;rdquo;&amp;ndash;delete-delay&amp;rdquo;，则同步完文件列表中的a/b/c目录后，最后一次性删除a1-a3、b1-b3、c1-c3。&lt;/p&gt;

&lt;p&gt;其实&amp;rdquo;&amp;ndash;delete&amp;rdquo;选项大多数情况下默认采用的就是&amp;rdquo;&amp;ndash;delete-during&amp;rdquo;。&lt;/p&gt;

&lt;h3 id=&#34;5-rsync-daemon模式&#34;&gt;5 rsync daemon模式&lt;/h3&gt;

&lt;h4 id=&#34;5-1-简单介绍&#34;&gt;5.1 简单介绍&lt;/h4&gt;

&lt;p&gt;既然rsync通过远程shell就能实现两端主机上的文件同步，还要使用rsync的服务干啥？试想下，你有的机器上有一堆文件需要时不时地同步到众多机器上去，比如目录a、b、c是专门传输到web服务器上的，d/e、f、g/h是专门传输到ftp服务器上的，还要对这些目录中的某些文件进行排除，如果通过远程shell连接方式，无论是使用排除规则还是包含规则，甚至一条一条rsync命令地传输，这都没问题，但太过繁琐且每次都要输入同样的命令显得太死板。使用rsync daemon就可以解决这种死板问题。而且，rsync daemon是向外提供服务的，这样只要告诉了别人rsync的url路径，外人就能向ftp服务器一样获取文件列表并进行选择性地下载，所以，你所制定的列表，你的同事也可以获取到并使用。&lt;/p&gt;

&lt;p&gt;举个简单的例子，Linux内核官网www.kernel.org提供rsync的下载方式，官方给出的地址是rsync://rsync.kernel.org/pub，可以根据这个地址找出你想下载的内核版本。例如要找出linux-3.0.15版本的内核相关文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync --no-motd -r -v -f &amp;quot;+ */&amp;quot; -f &amp;quot;+ linux-3.0.15*&amp;quot; -f &amp;quot;- *&amp;quot; -m rsync://rsync.kernel.org/pub/
receiving file list ... done
drwxr-xr-x         124 2017/07/14 20:27:22 .
drwxr-xr-x         178 2014/11/12 05:50:10 linux
drwxr-xr-x        4096 2017/06/27 05:46:27 linux/kernel
drwxr-xr-x      237568 2017/07/05 20:49:33 linux/kernel/v3.x
-rw-r--r--    76803806 2012/01/04 03:00:31 linux/kernel/v3.x/linux-3.0.15.tar.bz2
-rw-r--r--    96726195 2012/01/04 03:00:31 linux/kernel/v3.x/linux-3.0.15.tar.gz
-rw-r--r--         836 2012/01/04 03:00:31 linux/kernel/v3.x/linux-3.0.15.tar.sign
-rw-r--r--    63812604 2012/01/04 03:00:31 linux/kernel/v3.x/linux-3.0.15.tar.xz

sent 59 bytes  received 80.19K bytes  12.35K bytes/sec
total size is 237.34M  speedup is 2957.66
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你无需关注上面的规则代表什么意思，需要关注的重点是通过rsync可以向外提供文件列表并提供相应的下载。&lt;/p&gt;

&lt;p&gt;同样，你还可以根据路径，将rsync daemon上的文件拉取到本地实现下载的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync --no-motd -avzP rsync://rsync.kernel.org/pub/linux/kernel/v3.x/linux-3.0.15.tar.bz2 /tmp
receiving incremental file list
linux-3.0.15.tar.bz2
     2834426   3%   300.51kB/s    0:40:22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面就来介绍下rsync daemon。&lt;/p&gt;

&lt;p&gt;rsync daemon是&amp;rdquo;rsync &amp;ndash;daemon&amp;rdquo;或再加上其他一些选项启动的，它会读取配置文件，默认是/etc/rsyncd.conf，并默认监听在873端口上，当外界有客户端对此端口发起连接请求，通过这个网络套接字就可以完成连接，以后与该客户端通信的所有数据都通过该网络套接字传输。&lt;/p&gt;

&lt;p&gt;rsync daemon的通信方式和传输通道与远程shell不同。远程shell连接的两端是通过管道完成通信和数据传输的，即使连接的一端是远程主机，当连接到目标端时，将在目标端上根据远程shell进程fork出rsync进程使其成为rsync server。而rsync daemon是事先在server端上运行好的rsync后台进程(根据启动选项，也可以设置为非后台进程)，它监听套接字等待client端的连接，连接建立后所有通信方式都是通过套接字完成的。&lt;/p&gt;

&lt;p&gt;注意，rsync中的server的概念从来就不代表是rsync daemon，server在rsync中只是一种通用称呼，只要不是发起rsync请求的client端，就是server端，你可以认为rsync daemon是一种特殊的server，其实daemon更应该称之为service。(之所以解释这一点，是避免各位初学的朋友在阅读man rsync过程中产生误解)&lt;/p&gt;

&lt;p&gt;以下是rsync client连接rsync daemon时的命令语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]
      rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
Push: rsync [OPTION...] SRC... [USER@]HOST::DEST
      rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接命令有两种类型，一种是rsync风格使用双冒号的&amp;rdquo;rsync user@host::src dest&amp;rdquo;，一种是url风格的&amp;rdquo;rsync://user@host:port/src dest&amp;rdquo;。对于rsync风格的连接命令，如果想要指定端口号，则需要使用选项&amp;rdquo;&amp;ndash;port&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;上述语法中，其中daemon端的路径，如user@host::src，它的src代表的是模块名，而不是真的文件系统中的路径。关于rsync中的模块，相信见了下面的配置文件就会知道是什么意思。&lt;/p&gt;

&lt;h4 id=&#34;5-2-daemon配置文件rsyncd-conf&#34;&gt;5.2 daemon配置文件rsyncd.conf&lt;/h4&gt;

&lt;p&gt;默认&amp;rdquo;rsync &amp;ndash;daemon&amp;rdquo;读取的配置文件为/etc/rsyncd.conf，有些版本的系统上可能该文件默认不存在。rsyncd.conf的配置见man rsyncd.conf。以下是部分内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# cat /etc/rsyncd.conf
# /etc/rsyncd: configuration file for rsync daemon mode

# See rsyncd.conf man page for more options.

# configuration example:

# uid = nobody
# gid = nobody
# use chroot = yes
# max connections = 4
# pid file = /var/run/rsyncd.pid
# exclude = lost+found/
# transfer logging = yes
# timeout = 900
# ignore nonreadable = yes
# dont compress   = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2

# [ftp1]
#        path = /home/ftp
#        comment = ftp export area
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上述示例配置文件中，先定义了一些全局选项，然后定义了[ftp1]，这个用中括号包围的&amp;rdquo;[ftp1]&amp;ldquo;就是rsync中所谓的模块，ftp1为模块ID，必须保证唯一，每个模块中必须定义一项&amp;rdquo;path&amp;rdquo;，path定义的是该模块代表的路径，例如此示例文件中，如果想请求ftp1模块，则在客户端使用&amp;rdquo;rsync user@host::ftp1&amp;rdquo;，这表示访问user@host上的/home/ftp目录，如果要访问/home/ftp目录下的子目录www，则&amp;rdquo;rsync user@host::ftp1/www&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;以下是常见的配置项，也算是一个配置示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;######### 全局配置参数 ##########
port=888    # 指定rsync端口。默认873
uid = rsync # rsync服务的运行用户，默认是nobody，文件传输成功后属主将是这个uid
gid = rsync # rsync服务的运行组，默认是nobody，文件传输成功后属组将是这个gid
use chroot = no # rsync daemon在传输前是否切换到指定的path目录下，并将其监禁在内
max connections = 200 # 指定最大连接数量，0表示没有限制
timeout = 300         # 确保rsync服务器不会永远等待一个崩溃的客户端，0表示永远等待
motd file = /var/rsyncd/rsync.motd   # 客户端连接过来显示的消息
pid file = /var/run/rsyncd.pid       # 指定rsync daemon的pid文件
lock file = /var/run/rsync.lock      # 指定锁文件
log file = /var/log/rsyncd.log       # 指定rsync的日志文件，而不把日志发送给syslog
dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2  # 指定哪些文件不用进行压缩传输

###########下面指定模块，并设定模块配置参数，可以创建多个模块###########
[longshuai]        # 模块ID
path = /longshuai/ # 指定该模块的路径，该参数必须指定。启动rsync服务前该目录必须存在。rsync请求访问模块本质就是访问该路径。
ignore errors      # 忽略某些IO错误信息
read only = false  # 指定该模块是否可读写，即能否上传文件，false表示可读写，true表示可读不可写。所有模块默认不可上传
write only = false # 指定该模式是否支持下载，设置为true表示客户端不能下载。所有模块默认可下载
list = false       # 客户端请求显示模块列表时，该模块是否显示出来，设置为false则该模块为隐藏模块。默认true
hosts allow = 10.0.0.0/24 # 指定允许连接到该模块的机器，多个ip用空格隔开或者设置区间
hosts deny = 0.0.0.0/32   # 指定不允许连接到该模块的机器
auth users = rsync_backup # 指定连接到该模块的用户列表，只有列表里的用户才能连接到模块，用户名和对应密码保存在secrts file中，
                          # 这里使用的不是系统用户，而是虚拟用户。不设置时，默认所有用户都能连接，但使用的是匿名连接
secrets file = /etc/rsyncd.passwd # 保存auth users用户列表的用户名和密码，每行包含一个username:passwd。由于&amp;quot;strict modes&amp;quot;
                                  # 默认为true，所以此文件要求非rsync daemon用户不可读写。只有启用了auth users该选项才有效。
[xiaofang]    # 以下定义的是第二个模块
path=/xiaofang/
read only = false
ignore errors
comment = anyone can access
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;(1).客户端推到服务端时，文件的属主和属组是配置文件中指定的uid和gid。但是客户端从服务端拉的时候，文件的属主和属组是客户端正在操作rsync的用户身份，因为执行rsync程序的用户为当前用户。&lt;/p&gt;

&lt;p&gt;(2).auth users和secrets file这两行不是一定需要的，省略它们时将默认使用匿名连接。但是如果使用了它们，则secrets file的权限必须是600。客户端的密码文件也必须是600。&lt;/p&gt;

&lt;p&gt;(3).关于secrets file的权限，实际上并非一定是600，只要满足除了运行rsync daemon的用户可读即可。是否检查权限的设定是通过选项strict mode设置的，如果设置为false，则无需关注文件的权限。但默认是yes，即需要设置权限。&lt;/p&gt;

&lt;p&gt;配置完后，再就是提供模块相关目录、身份验证文件等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# useradd -r -s /sbin/nologin rsync

[root@xuexi ~]# mkdir /{longshuai,xiaofang}

[root@xuexi ~]# chown -R rsync.rsync /{longshuai,xiaofang}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提供模块longshuai身份验证文件，由于rsync daemon是以root身份运行的，所以要求身份验证文件对非root用户不可读写，所以设置为600权限。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# echo &amp;quot;rsync_backup:123456&amp;quot; &amp;gt;&amp;gt; /etc/rsyncd.passwd

[root@xuexi ~]# chmod 600 /etc/rsyncd.passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动rsync daemon，启动方式很简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync --daemon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是CentOS 7，则自带启动脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# systemctl start rsyncd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看该脚本的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# cat /usr/lib/systemd/system/rsyncd.service
[Unit]
Description=fast remote file copy program daemon
ConditionPathExists=/etc/rsyncd.conf

[Service]
EnvironmentFile=/etc/sysconfig/rsyncd
ExecStart=/usr/bin/rsync --daemon --no-detach &amp;quot;$OPTIONS&amp;quot;

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到启动方法也仅仅只是多了一个&amp;rdquo;&amp;ndash;no-detach&amp;rdquo;，该选项表示rsync不将自己从终端上剥离。&lt;/p&gt;

&lt;p&gt;总之，启动好rysnc daemon后，它就监听在指定的端口上，等待客户端的连接。&lt;/p&gt;

&lt;p&gt;由于上述示例中的模块longshuai配置了身份验证功能，所以客户端连接时会询问密码。如果不想手动输入密码，则可以使用&amp;rdquo;&amp;ndash;password-file&amp;rdquo;选项提供密码文件，密码文件中只有第一行才是传递的密码，其余所有的行都会被自动忽略。&lt;/p&gt;

&lt;p&gt;例如在客户端上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# echo &amp;quot;123456&amp;quot; &amp;gt; /tmp/rsync_passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用该&amp;rdquo;&amp;ndash;password-file&amp;rdquo;连接需要身份验证的longshuai模块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# echo &amp;quot;123456&amp;quot; &amp;gt; /tmp/rsync_passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要访问模块中的某个文件，则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync --list-only --port 888 rsync_backup@172.16.l0.6::longshuai/a/b --password-file=/tmp/rsync_passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以使用url格式语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync --list-only rsync://rsync_backup@172.16.l0.6:888/longshuai/a/b --password-file=/tmp/rsync_passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-远程shell方式连接使用daemon&#34;&gt;6 远程shell方式连接使用daemon&lt;/h3&gt;

&lt;p&gt;在前文说了rsync有三种工作方式：本地同步模式、远程shell模式和rsync daemon模式。前两者是使用管道进行通信和传输数据的，后者是通过网络套接字进行通信和传输数据的，且rsync daemon要求在server端必须已经运行好rsync且监听在指定端口上。&lt;/p&gt;

&lt;p&gt;但rsync支持第4种工作方式：通过远程shell方式连接rsync daemon。也就是将第二种和第三种方式结合起来。虽然这种方式用的不多，但还是有必要稍微解释下，为你阅读rsync的man文档提供一些帮助。&lt;/p&gt;

&lt;p&gt;为了下面称呼的方便，暂且将通过远程shell连接使用daemon的方式成为&amp;rdquo;远程shell daemon&amp;rdquo;，当然，官方并没有这样的术语，仅仅只是本人在此为了方便而如此称呼。&lt;/p&gt;

&lt;p&gt;远程shell daemon的方式严格地说是&amp;rdquo;远程shell通信方式+使用rsync daemon的功能&amp;rdquo;。所以它的通信方式和远程shell是一样的，在客户端发起远程shell连接，在server端fork远程shell进程以启动rsync进程，但这个rsync进程是临时的rsync daemon，它只读取配置文件中client所请求的模块部分，且只读取模块部分中的path和身份认证相关内容，(也就是说不会将全局配置项和其它模块项加载到内存，该模块下的其他配置也不会生效)，当rsync操作完成，该rsync daemon就消逝并从内存中被清理。而且，远程shell daemon启动的临时daemon不会和已经在server端运行的rsync daemon冲突，它们可以并存。由于远程shell连接的最终目标是rsync模块，所以它只能使用rsync daemon语法。&lt;/p&gt;

&lt;p&gt;以下是语法格式：为了简洁，没有指定src还是dest，且以ssh这个远程shell为例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rsync [options] --rsh=ssh auth_user@host::module

rsync [options] --rsh=&amp;quot;ssh -l ssh_user&amp;quot; auth_user@host::module

rsync [options] -e &amp;quot;ssh -l ssh_user&amp;quot; auth_user@host::module

rsync [options] -e &amp;quot;ssh -l ssh_user&amp;quot; rsync://auth_user@host/module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;涉及了两个用户ssh_user和auth_user，由于使用的是远程shell通信方式，所以client要和server端建立ssh连接，ssh_user就是ssh连接server的用户。auth_user则是模块中的身份认证用户。如果不指定&amp;rdquo;ssh_user&amp;rdquo;，则默认将使用auth_user，但很多时候auth_user都只是一个虚拟用户，这样就建立不了ssh连接导致失败，所以建议明确指定ssh_user和auth_user。&lt;/p&gt;

&lt;p&gt;举个例子就能说明上面的一切。以下是server端配置文件/etc/rsyncd.conf中的一个模块配置，稍后将从client端使用远程shell方式请求该模块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[tmpdir]
path=/tmp
auth users=lisi
secrets file=/tmp/lisi_passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当前server端是没有rsync daemon在运行的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# netstat -tnl
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN    
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN    
tcp6       0      0 :::22                   :::*                    LISTEN    
tcp6       0      0 ::1:25                  :::*                    LISTEN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在客户端上使用以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@xuexi ~]# rsync --list-only -e &amp;quot;ssh -l root&amp;quot; lisi@172.16.10.6::tmpdir
root@172.16.10.6&#39;s password:

Password:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到要求输入两次密码，第一次密码是root@XXX的密码，即建立ssh连接使用的密码，只有建立了ssh连接，才能在server上启动临时rsync daemon。第二次输入的密码Password是&amp;rdquo;auth users=lisi&amp;rdquo;对应的密码。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: 本文转载自 &lt;a href=&#34;https://www.cnblogs.com/f-ck-need-u/p/7220009.html&#34; title=&#34;rsync基本命令和用法&#34;&gt;&lt;em&gt;这里&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>rsync: 中文手册</title>
      <link>http://alimy.me/post/dev_201803241012/</link>
      <pubDate>Sat, 24 Mar 2018 10:12:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201803241012/</guid>
      <description>&lt;p&gt;rsync(1)&lt;/p&gt;

&lt;p&gt;名称&lt;br /&gt;
       rsync - 一个快速、多功能的远程(和本地)文件拷贝工具&lt;/p&gt;

&lt;p&gt;摘要&lt;br /&gt;
       Local:  rsync [OPTION&amp;hellip;] SRC&amp;hellip; [DEST]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Access via remote shell:
     Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]
     Push: rsync [OPTION...] SRC... [USER@]HOST:DEST

   Access via rsync daemon:
     Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]
           rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
     Push: rsync [OPTION...] SRC... [USER@]HOST::DEST
           rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST


   当仅有一个SRC或DEST参数时将列出源文件列表而不是复制文件。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;描述&lt;br /&gt;
    
       Rsync是一个快速且功能非常丰富的文件拷贝工具。它可以在本地和远程之间通过shell或rsync服务互相拷贝文件。
       它提供了大量的选项来控制它各方面功能的行为，且在指定待拷贝文件方面非常有弹性。它以其增量拷贝算法而出
       名，只拷贝源和目标不同的文件部分，因此减少网络间要传输的数据。Rsync每天都被广泛用于做备份、镜像和当
       作升级版拷贝命令。&lt;br /&gt;
       Rsync使用&amp;rdquo;quick check&amp;rdquo;算法(默认)决定文件是否需要被传输，它会找出大小或最后修改时间(mtime)不同的文件。
       当&amp;rdquo;quick check&amp;rdquo;算法表明了文件不需要被更新时，任何其他保留属性(译者注:除大小和最后修改时间外的属性)都
       将直接在目标文件上修改。&lt;br /&gt;
       rsync的其他特性包括：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   o      支持拷贝链接文件、设备文件、所有权(即所有者和所属组)、属组以及权限

   o      支持类似于GNU tar命令的exclude和exclude-from选项

   o      支持CVS排除模式以忽略相同的文件(译者注：CVS是一种版本控制系统，其他版本控制系统如git、svn)

   o      可以使用任意透明的远程shell(remote shell)，包括ssh或rsh

   o      不要求超级管理员权限

   o      以pipeline管道模型传输文件以便最小化降低成本

   o      支持匿名或可身份认证的rsync daemon模式(做镜像的理想方式)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般特性
       Rsync在本地或远程主机之间拷贝文件(但不支持两个远程之间互相拷贝)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   rsync有两种不同的方式联系远程主机：使用远程shell程序作为传输方式(如ssh或rsh)或直接通过TCP联系rsync守护
   进程。当命令行中指定的源或目标主机后使用了单个冒号(:)时将使用远程shell传输模式。当在命令行中指定的源
   或目标主机后使用双冒号(::)或使用了rsync://这种URL时将表示使用TCP联系rsync守护进程，但rsync://方式有一个
   例外，请参见下文&amp;quot;通过远程SHELL连接使用RSYNC-DAEMON特性&amp;quot;段落的内容。

   但有一个特殊情况，如果只给定了源地址没有给定目标地址，则将以类似于&amp;quot;ls -l&amp;quot;的格式输出文件列表。

   意料之中的是，如果给定的源地址和目标地址都不是远程地址，则在本机进行拷贝(见--list-only选项)。

   Rsync命令中，本地端总是扮演&amp;quot;client&amp;quot;角色，远程端总是扮演&amp;quot;server&amp;quot;角色。不要混淆&amp;quot;server&amp;quot;和rsync daemon，rsync
   daemon一定是一个&amp;quot;server&amp;quot;，但是&amp;quot;server&amp;quot;可能是一个rsync daemon也可能是远程shell派生出来的进程。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装
       请阅读README文件来查看安装说明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   当安装完成后，你可以通过远程shell(也可以通过rsync daemon协议)让rsync与任意你能访问的主机进行交流。对于远
   程传输，现代rsync使用ssh与其他主机进行交流，但是可以配置其他默认的远程shell，如rsh或remsh。

   你也可以通过命令行的&amp;quot;-e&amp;quot;选项或设置RSYNC_RSH环境变量来指定你想要使用的远程shell。

   rsync必须同时装在源主机和目标主机上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用法
       rsync的使用方法和rcp一样。你必须指定源地址和目标地址，其中一个可能是远程地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   也许解释语法最好的方式是通过几个示例：

          rsync -t *.c foo:src/

   这将会把当前目录下所有能匹配*.c的文件传输到主机foo上的src目录下。如果远程主机上已经存在某些同名文件，rsync
   的远程更新(rsync-update)协议将会更新哪些有差异的文件。更详细的内容见技术报告。

          rsync -avz foo:src/bar /data/tmp

   这将会以递归方式把远程主机foo上的src/bar目录下的所有文件传输到本地主机的/data/tmp目录下。这些文件以归档(archive)
   模式传输，它保证在传输过程中保留符号链接、设备文件、属性、权限、所有者、所属组等。另外，在传输过程中会使用压缩功能以减少
   要传输的数据体积。

          rsync -avz foo:src/bar/ /data/tmp

   使用尾随斜线(/)改变了原本的行为，它避免了在目标地址创建一个额外的目录层次。带有尾随斜线时，你可以理解为&amp;quot;拷贝目录
   的内容&amp;quot;而不是拷贝&amp;quot;拷贝目录名&amp;quot;(译者注：即拷贝目录本身)，但是这两种情况都会将目录中包含的文件传输到目标目录下。换句
   话说，下面两条命令都以相同的方式进行拷贝，包括/dest/foo的属性设置。

          rsync -av /src/foo /dest
          rsync -av /src/foo/ /dest/foo

   还需要注意的是，拷贝主机或引用模块的默认目录不需要尾随斜线。例如，下面的命令都拷贝远程(默认)目录的内容到本地的&amp;quot;/dest&amp;quot;。

          rsync -av host: /dest
          rsync -av host::module /dest

   你也可以仅使用rsync的仅本地(local-only)模式，此模式下的源地址和目标地址名称中都不需要冒号(:)。它行为类似于cp命令的升级版。

   最后，你可以通过移除模块名参数部分的方式列出rsync daemon中所有可用模块。

          rsync somehost.mydomain.com::

   更详细信息见下面段落。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;高级用法
       请求从远程主机传输多个文件的语法是通过指定和第一个远程地址格式相同的多个远程地址参数，或者可以省略主机名部分。例如，下面的
       命令都会正常工作：(译者注：远程地址中省略主机名时，将取前一个远程地址的主机名作为它的主机名)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          rsync -av host:file1 :file2 host:file{3,4} /dest/
          rsync -av host::modname/file{1,2} host::modname/file3 /dest/
          rsync -av host::modname/file1 ::modname/file{3,4}

   老版本的rsync需要在SRC部分使用引号和空格，如下示例：

          rsync -av host:&#39;dir1/file1 dir2/file2&#39; /dest
          rsync host::&#39;modname/dir1/file1 modname/dir2/file2&#39; /dest

   这种方式在后续rsync版本中将继续(默认)有效，但是它没有第一种方式简便。

   如果你要传输一个文件名中包含了空白字符的文件，可以使用&amp;quot;--protect-args&amp;quot;(&amp;quot;-s&amp;quot;)选项，也可以使用转义符将空白字符转义。例如：

          rsync -av host:&#39;file\ name\ with\ spaces&#39; /dest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接RSYNC DAEMON
       rsync也可以不使用远程shell作为传输方式。这情况看下，将直接连接远程RSYNC守护进程，一般使用的是TCP的873端口。(显然，这要求
       远程的RSYNC守护进程必须是已运行的，见下文&amp;rdquo;启动RSYNC服务以接受连接请求&amp;rdquo;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   这种方式的rsync使用方式和远程shell方式一样，除了：

   o      需要使用双冒号&amp;quot;::&amp;quot;分隔主机名和路径，或者使用rsync://的URL格式。

   o      &amp;quot;path&amp;quot;部分的第一个词语是一个模块名(译者注：如hostname::modname/file)。

   o      远程RSYNC守护进程可能会输出你连接它的日期时间。

   o      如果没有指定远程rsync服务的路径名，将列出rsync服务主机上可访问的路径。

   o      如果没有指定本地目标地址，将列出远程rsync服务主机上指定的文件。

   o      必须不能指定&amp;quot;--rsh&amp;quot;(&amp;quot;-e&amp;quot;)选项。


   以下是拷贝远程模块名为&amp;quot;src&amp;quot;中的所有文件示例：

       rsync -av host::src /dest

   远程daemon上的某些模块可能需要身份验证。如果是这样，在连接时将会被询问输入密码。如果想要避免被询问，可以通过设置环境变量
   RSYNC_PASSWORD的值为你要使用的密码，或者使用&amp;quot;--password-file&amp;quot;选项。这非常适用于脚本中。

   警告：在某些系统上，环境变量是对所有用户可见的，此时建议使用&amp;quot;--password-file&amp;quot;选项。

   你可以通过web代理(web proxy)的方式与rsync daemon建立连接，只需设置环境变量RSYNC_PROXY的值为hostname:port指向你的web代理。但
   要注意，web代理的配置必须得支持与873端口的代理连接。

   你还可以使用代理程序与rsync daemon建立连接，只需设置环境变量RSYNC_CONNECT_PROG的值为你想要运行的命令来代替建立套接字连接。
   环境变量的值中可能会包含&amp;quot;%H&amp;quot;，它代表rsync命令中所指定的主机名(因此如果想在值中包含一个&amp;quot;%&amp;quot;字符，需要使用&amp;quot;%%&amp;quot;)。例如：

     export RSYNC_CONNECT_PROG=&#39;ssh proxyhost nc %H 873&#39;
     rsync -av targethost1::module/src/ /dest/
     rsync -av rsync:://targethost2/module/src/ /dest/

   上面的命令中使用ssh在proxyhost上运行了nc命令，它将会转发所有数据到目标主机(%H)的873端口。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过远程SHELL连接使用RSYNC-DAEMON特性
       某些时候使用rsync daemon的各种特性(如可命名的模块)比允许任意套接字连接到系统上(除了真正需要使用远程shell的访问)更方便。
       rsync支持使用远程shell连接到主机上，它会派生出一个单用途(single-use)的&amp;rdquo;daemon&amp;rdquo;服务用于读取远程用户家目录下的配置文件。
       如果你想要加密daemon-sytle传输的数据，但由于daemon是被远程用户启动的，你无法通过这样的daemon使用像chroot这样的功能，也
       无法修改uid，这时使用远程shell是比较好的。(另一个加密daemon传输的方式是，使用ssh建立本地端口到远程主机的隧道，并且在远
       程主机上配置一个普通的rsync daemon只允许从&amp;rdquo;localhost&amp;rdquo;发起连接(译者注：其实就是配置ssh的端口转发))&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   从用户角度来看，使用远程shell连接使用rsync daemon与连接普通rsync daemon的命令行语法几乎相同，唯一例外的是必须在命令行使用
   --rsh=COMMAND选项设置远程shell程序。(设置RSYNC_RSH环境变量不会打开此功能)例如：

       rsync -av --rsh=ssh host::module /dest

   如果需要指定不同用户的远程shell，一定要记住，host前缀&amp;quot;user@&amp;quot;设置的是rsync上的用户(即用于需要用户认证的模块)。这意味着必须在ssh命令中
   使用&amp;quot;-l user&amp;quot;选项来指定远程shell，下面的例子中使用了&amp;quot;--rsh&amp;quot;的短格式选项&amp;quot;-e&amp;quot;：

       rsync -av -e &amp;quot;ssh -l ssh-user&amp;quot; rsync-user@host::module /dest

   &amp;quot;ssh-user&amp;quot;将在ssh上生效，而&amp;quot;rsync-user&amp;quot;将用于认证使用&amp;quot;module&amp;quot;模块。(译者注：对于连接目标非daemon时，&amp;quot;ssh -l user&amp;quot;和&amp;quot;user@&amp;quot;作用是一样的)

   (译者注：远程shell连接使用rsync daemon，和真正的守护进程rsync daemon是不同的，后者是配置好后永久监听在后台提供服务，而远程shell使用
   rsync daemon则是一种临时性单用途的daemon进程，虽然也会读取配置文件，但它是由远程shell进程fork出来的子进程，此次连接结束后，此daemon
   进程会自动消逝)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动RSYNC服务以接受连接请求
       要连接到一个rsync daemon，远程系统上的rsync daemon必须已经运行(或者像inetd一样，已经配置了当特殊端口上有连接时会派生出rsync daemon)。
       关于如何启动一个能处理从套接字进来的连接的daemon的完整信息，请查看rsyncd.conf(5)——这是rsync daemon的配置文件，它包含如何运行daemon的
       非常详细的信息(包括独立模式(stand-alone)和inetd格式的配置)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   如果你使用的是某种远程shell传输方式，则没有手动启动rsync daemon的必要。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传输过程中的排序
       Rsync总是会在内部传输列表中对指定的文件名进行排序。这将会使得相同目录名的文件被合并在一起进行传输，这样一来，去除重复文件名就比较容
       易，但这可能会让一些人产生疑惑：文件传输时的顺序和命令行中给的顺序不一致。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   如果想要让那个某个特殊的文件比其他文件先传输，可以将它们分隔到不同的rsync命令上，或考虑使用&amp;quot;--delay-updates&amp;quot;选项(它不会影响传输时的
   排序，但会使得最后的文件更新(file-updating)阶段更迅速)。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例
       以下是一些我使用rsync的示例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   要备份包含了大量word文档和邮件文件夹的家目录，使用一个任务计划(cron job)运行：

          rsync -Cavz . arvidsjaur:backup

   每个晚上都将通过PPP连接到主机&amp;quot;arvidsjaur&amp;quot;上的backup目录。

   要同步samba源码树，使用下面的Makefile targets：

       get:
               rsync -avuzb --exclude &#39;*~&#39; samba:samba/ .
       put:
               rsync -Cavuzb . samba:samba/
       sync: get put

   这可以让我和连接另一端的CVS目录保持同步。然后再在远程主机上做一些CVS操作，这节省了我大量时间，因为远程CVS协议的效率并不高。

   我使用下面的命令在我的&amp;quot;old&amp;quot;和&amp;quot;new&amp;quot;ftp站点之间做一个镜像：

   rsync -az -e ssh --delete ~ftp/pub/samba nimbus:&amp;quot;~ftp/pub/tridge&amp;quot;

   由于设置了cron计划，每隔几小时它就登录一次。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选项汇总
       下面是rsync中可用的命令汇总，关于选项的完整描述，请看后文。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -v, --verbose               increase verbosity
    -q, --quiet                 suppress non-error messages
        --no-motd               suppress daemon-mode MOTD (see caveat)
    -c, --checksum              skip based on checksum, not mod-time &amp;amp; size
    -a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)
        --no-OPTION             turn off an implied OPTION (e.g. --no-D)
    -r, --recursive             recurse into directories
    -R, --relative              use relative path names
        --no-implied-dirs       don&#39;t send implied dirs with --relative
    -b, --backup                make backups (see --suffix &amp;amp; --backup-dir)
        --backup-dir=DIR        make backups into hierarchy based in DIR
        --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
    -u, --update                skip files that are newer on the receiver
        --inplace               update destination files in-place
        --append                append data onto shorter files
        --append-verify         --append w/old data in file checksum
    -d, --dirs                  transfer directories without recursing
    -l, --links                 copy symlinks as symlinks
    -L, --copy-links            transform symlink into referent file/dir
        --copy-unsafe-links     only &amp;quot;unsafe&amp;quot; symlinks are transformed
        --safe-links            ignore symlinks that point outside the tree
    -k, --copy-dirlinks         transform symlink to dir into referent dir
    -K, --keep-dirlinks         treat symlinked dir on receiver as dir
    -H, --hard-links            preserve hard links
    -p, --perms                 preserve permissions
    -E, --executability         preserve executability
        --chmod=CHMOD           affect file and/or directory permissions
    -A, --acls                  preserve ACLs (implies -p)
    -X, --xattrs                preserve extended attributes
    -o, --owner                 preserve owner (super-user only)
    -g, --group                 preserve group
        --devices               preserve device files (super-user only)
        --copy-devices          copy device contents as regular file
        --specials              preserve special files
    -D                          same as --devices --specials
    -t, --times                 preserve modification times
    -O, --omit-dir-times        omit directories from --times
        --super                 receiver attempts super-user activities
        --fake-super            store/recover privileged attrs using xattrs
    -S, --sparse                handle sparse files efficiently
    -n, --dry-run               perform a trial run with no changes made
    -W, --whole-file            copy files whole (w/o delta-xfer algorithm)
    -x, --one-file-system       don&#39;t cross filesystem boundaries
    -B, --block-size=SIZE       force a fixed checksum block-size
    -e, --rsh=COMMAND           specify the remote shell to use
        --rsync-path=PROGRAM    specify the rsync to run on remote machine
        --existing              skip creating new files on receiver
        --ignore-existing       skip updating files that exist on receiver
        --remove-source-files   sender removes synchronized files (non-dir)
        --del                   an alias for --delete-during
        --delete                delete extraneous files from dest dirs
        --delete-before         receiver deletes before xfer, not during
        --delete-during         receiver deletes during the transfer
        --delete-delay          find deletions during, delete after
        --delete-after          receiver deletes after transfer, not during
        --delete-excluded       also delete excluded files from dest dirs
        --ignore-errors         delete even if there are I/O errors
        --force                 force deletion of dirs even if not empty
        --max-delete=NUM        don&#39;t delete more than NUM files
        --max-size=SIZE         don&#39;t transfer any file larger than SIZE
        --min-size=SIZE         don&#39;t transfer any file smaller than SIZE
        --partial               keep partially transferred files
        --partial-dir=DIR       put a partially transferred file into DIR
        --delay-updates         put all updated files into place at end
    -m, --prune-empty-dirs      prune empty directory chains from file-list
        --numeric-ids           don&#39;t map uid/gid values by user/group name
        --timeout=SECONDS       set I/O timeout in seconds
        --contimeout=SECONDS    set daemon connection timeout in seconds
    -I, --ignore-times          don&#39;t skip files that match size and time
        --size-only             skip files that match in size
        --modify-window=NUM     compare mod-times with reduced accuracy
    -T, --temp-dir=DIR          create temporary files in directory DIR
    -y, --fuzzy                 find similar file for basis if no dest file
        --compare-dest=DIR      also compare received files relative to DIR
        --copy-dest=DIR         ... and include copies of unchanged files
        --link-dest=DIR         hardlink to files in DIR when unchanged
    -z, --compress              compress file data during the transfer
        --compress-level=NUM    explicitly set compression level
        --skip-compress=LIST    skip compressing files with suffix in LIST
    -C, --cvs-exclude           auto-ignore files in the same way CVS does
    -f, --filter=RULE           add a file-filtering RULE
    -F                          same as --filter=&#39;dir-merge /.rsync-filter&#39;
                                repeated: --filter=&#39;- .rsync-filter&#39;
        --exclude=PATTERN       exclude files matching PATTERN
        --exclude-from=FILE     read exclude patterns from FILE
        --include=PATTERN       don&#39;t exclude files matching PATTERN
        --include-from=FILE     read include patterns from FILE
        --files-from=FILE       read list of source-file names from FILE
    -0, --from0                 all *from/filter files are delimited by 0s
    -s, --protect-args          no space-splitting; wildcard chars only
        --address=ADDRESS       bind address for outgoing socket to daemon
        --port=PORT             specify double-colon alternate port number
        --sockopts=OPTIONS      specify custom TCP options
        --blocking-io           use blocking I/O for the remote shell
        --stats                 give some file-transfer stats
    -8, --8-bit-output          leave high-bit chars unescaped in output
    -h, --human-readable        output numbers in a human-readable format
        --progress              show progress during transfer
    -P                          same as --partial --progress
    -i, --itemize-changes       output a change-summary for all updates
        --out-format=FORMAT     output updates using the specified FORMAT
        --log-file=FILE         log what we&#39;re doing to the specified FILE
        --log-file-format=FMT   log updates using the specified FMT
        --password-file=FILE    read daemon-access password from FILE
        --list-only             list the files instead of copying them
        --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
        --write-batch=FILE      write a batched update to FILE
        --only-write-batch=FILE like --write-batch but w/o updating dest
        --read-batch=FILE       read a batched update from FILE
        --protocol=NUM          force an older protocol version to be used
        --iconv=CONVERT_SPEC    request charset conversion of filenames
        --checksum-seed=NUM     set block/file checksum seed (advanced)
    -4, --ipv4                  prefer IPv4
    -6, --ipv6                  prefer IPv6
        --version               print version number
   (-h) --help                  show this help (see below for -h comment)


   Rsync以daemon方式运行时，还可以接受以下选项：

        --daemon                run as an rsync daemon
        --address=ADDRESS       bind to the specified address
        --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
        --config=FILE           specify alternate rsyncd.conf file
        --no-detach             do not detach from the parent
        --port=PORT             listen on alternate port number
        --log-file=FILE         override the &amp;quot;log file&amp;quot; setting
        --log-file-format=FMT   override the &amp;quot;log format&amp;quot; setting
        --sockopts=OPTIONS      specify custom TCP options
    -v, --verbose               increase verbosity
    -4, --ipv4                  prefer IPv4
    -6, --ipv6                  prefer IPv6
    -h, --help                  show this help (if used after --daemon)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选项
       Rsync可以接受长格式选项和段格式选项，下面列出了所有可使用的选项。如果以多种方式指定同一个选项，则使用逗号分隔。某些选项只有长格式，
       没有短格式。如果选项要带参数，参数只能列在长格式选项后。如果要指定选项的参数，可以使用&amp;rdquo;&amp;ndash;option=param&amp;rdquo;的格式，也可以使用空白字符替
       换&amp;rdquo;=&amp;ldquo;。某些参数可能需要使用引号包围，避免被shell命令行解析。需要记住，文件名中的前导波浪号(~)是被shell替换的，因此&amp;rdquo;&amp;ndash;option=~/foo&amp;rdquo;
       将不会从波浪号进入家目录(若要如此，将&amp;rdquo;=&amp;ldquo;移除)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   --help 输出所有选项简短格式的帮助信息并退出。为了兼容老版本，当只使用一个&amp;quot;-h&amp;quot;选项时也会输出这些帮助信息。

   --version
          输出rsync的版本号并退出。

   -v, --verbose
          该选项增加了传输过程中的大量信息。默认情况下，rsync以静默(silent)模式工作。单个&amp;quot;-v&amp;quot;将给出哪些文件正在被传输的信息，还会在传输
          结束时给出一个简要总结信息。两个&amp;quot;-v&amp;quot;选项(-vv)将给出哪些文件被忽略，并且在传输结束时给出更详细的信息。超过两个&amp;quot;-v&amp;quot;选项一般只在
          调试过程中使用。

          需要注意的是，传输过程中输出的文件名是被&amp;quot;--out-format=%n%L&amp;quot;处理过的，它表示仅显示文件名，如果是软链接文件，则还显示它指向谁。
          当使用一个&amp;quot;-v&amp;quot;选项时，将不会告诉你文件的属性改变了。如果明确要列出改变了属性的文件列表清单(既可以使用&amp;quot;--itemize-change&amp;quot;也可以
          在&amp;quot;--out-format&amp;quot;中增加&amp;quot;%i&amp;quot;)，(客户端)输出结果中将总是会增加所有已改变的条目清单。更详细信息见&amp;quot;--out-format&amp;quot;选项。

   -q, --quiet
          该选项将减少大量传输过程中的信息，但无法禁止从远程主机产生的信息。该选项适用于cron任务计划中。

   --no-motd
          此选项会影响客户端在守护程序传输开始时输出的信息。它会禁止motd信息，但是也会影响daemon对&amp;quot;rsync host::&amp;quot;请求显示模块列表的回应
          信息，因此如果想要请求daemon的模块列表，应该忽略该选项。

   -I, --ignore-times
          正常情况下，rsync会忽略文件大小相同且最后修改时间戳相同的文件，该选项关闭&amp;quot;quick check&amp;quot;行为，使得所有的文件都会被更新。
          (译者注：即从增量拷贝变成全量拷贝)

   --size-only
          该选项将修改rsync查找需要被传输文件的&amp;quot;quick check&amp;quot;算法，默认该算法会找出所有大小或最后修改时间戳改变文件并传输，使用该选项
          将仅查找大小改变的文件并传输。在使用了某些镜像备份但没有保留精确时间戳的情况下，使用带有该选项的rsync将非常有帮助。

   --modify-window
          当比较时间戳时，rsync会把两者相差不超过该选项所指定的值时认为是相同的时间戳。正常情况下该选项的值为0(精确匹配)，但在某些情
          况下，将此选项的值设置为非0将非常有用。特别是与Windows的FAT文件系统(此文件系统有2秒范围内的精确度差异)传输数据时，设置
          &amp;quot;--modify-window=1&amp;quot;将非常有用(允许文件时间戳有1秒的差异)。

   -c, --checksum
          此选项改变了rsync检查文件改变和决定是否要传输的方式。不使用该选项，rsync使用&amp;quot;quick check&amp;quot;(默认的)检查发送端和接收端两边文件的
          大小和最后一次修改时间是否改变。使用该选项，将对每个匹配了大小的文件比较128位的校验码。生成校验码意味着两端都会消耗大量的磁盘
          I/O以读取传输队列中文件的数据内容(传输队列早于读取文件数据，即先quick check，再生成和比较校验码)，因此该选项会大幅度降低效率。

          发送端生成校验码的时刻是做文件系统扫描以生成可获取文件列表时。接收端生成校验码的时刻是在扫描哪些文件发生改变时，它会对那些与
          发送端文件大小相同的文件生成校验码。所以，该选项的结果是：只传输校验码改变或文件大小改变(意味着校验码也改变)的文件。

          注意，rsync默认总是在文件传输完成后再生成全部文件(whole-file)的校验码，并验证传输完成的文件是否正确重组。但是使用该选项，它隐
          含了在传输前做&amp;quot;该文件是否需要更新？&amp;quot;的检查，使得文件传输结束后不会自动去验证它们重组的正确性。

          从协议30版本开始(对应的rsync版本从3.0.0开始)使用的校验码是MD5格式的，更老的协议版本使用的校验码是MD4格式的。
           (译者注：即基于checksum来判断文件是否要同步，而不是基于quick check算法。在两个地方会计算checksum：sender端发送文件列表时，
           接收端的generator判断文件是否要传输时)

   -a, --archive
          该选项等价于&amp;quot;-rlptgoD&amp;quot;选项的组合。它表示使用归档模式并保留几乎所有属性(明显遗漏了&amp;quot;-H&amp;quot;选项)。上面的等价选项的唯一例外是指定了
          &amp;quot;--files-from&amp;quot;选项，它使得&amp;quot;-r&amp;quot;选项被强制忽略。

          注意，&amp;quot;-a&amp;quot;选项不保留硬链接属性，因为查找多个硬链接文件是非常昂贵的。若要保留硬链接属性，必须与&amp;quot;-a&amp;quot;分开独立使用&amp;quot;-H&amp;quot;选项。

   --no-OPTION
          在选项前面加上前缀&amp;quot;no-&amp;quot;表示关闭该选项的隐含选项功能。不是所有选项都能使用&amp;quot;no-&amp;quot;前缀：
          只有那些隐含了其他选项的选项(如--no-D,--no-perms)或者不同环境下有不同默认值的选项(如--no-whole-file,--no-blocking-io,--no-dirs)。
          &amp;quot;no-&amp;quot;后面即可以接短格式选项，也可以接长格式选项(如--no-R等价于--no-relative)

          例如：你想使用&amp;quot;-a&amp;quot;选项但不想使用它的隐含选项&amp;quot;-o&amp;quot;(--owner)，即让&amp;quot;-a&amp;quot;等价于&amp;quot;-rlptgD&amp;quot;，可以指定&amp;quot;-a --no-o&amp;quot;(或-a --no-owner)。

          选项的顺序是非常重要的：如果指定&amp;quot;--no-r -a&amp;quot;，则最终会启用&amp;quot;-r&amp;quot;选项，与之相反的是&amp;quot;-a --no-r&amp;quot;。同样需要注意的是&amp;quot;--files-from&amp;quot;的副
          作用，它的位置顺序不重要，因为它影响了某些选项的默认行为，并轻微改变了&amp;quot;-a&amp;quot;的意义(见&amp;quot;--files-from&amp;quot;选项以获取更详细说明)。

   -r, --recursive
          此选项告诉rsync以递归模式拷贝目录。参见&amp;quot;--dirs&amp;quot;(-d)。

          从rsync 3.0.0开始，现在使用的递归算法是一种增量扫描，比以前少占用很多内存，并且在最初扫描完一些目录后就开始进行数据传输。增量
          扫描仅影响递归算法，不会改变非递归的传输类型。同样，只有传输两端的版本都高于3.0.0才会如此。

          某些选项要求rsync知道完整的文件列表，所以它们会禁用增量递归模式。这些选项包括：--delete-before,--delete-after,--prune-empty-dirs
          和--delay-updates。正因为如此，如果两端rsync版本都高于3.0.0时，指定&amp;quot;--delete&amp;quot;时的默认删除模式变为&amp;quot;--delete-during&amp;quot;(可以使用&amp;quot;--del&amp;quot;
          或&amp;quot;--del-during&amp;quot;来精确指定删除模式)。同样，选择使用&amp;quot;--delete-delay&amp;quot;选项比&amp;quot;--delete-after&amp;quot;会更好。

          增量递归模式可以使用&amp;quot;--no-inc-recursive&amp;quot;(--no-i-r)选项来禁用。


   -R, --relative
          表示使用相对路径。这意味着会将命令行中指定的全路径名而非路径最尾部的文件名发送给服务端。当要一次性发送多个不同目录时该选项非
          常有用。例如，如果使用下面的命令：

             rsync -av /foo/bar/baz.c remote:/tmp/

          这将会在远程主机上的/tmp/目录下创建一个baz.c文件。如果使用下面的命令：

             rsync -avR /foo/bar/baz.c remote:/tmp/

          将会在远程主机的/tmp/目录下递归创建foo/bar/baz.c，它保留了命令行中指定的全路径。这些额外的路径元素被称为&amp;quot;隐含目录&amp;quot;(如上例中的
          foo和foo/bar)。

          从rsync 3.0.0开始，rsync总是会发送这些隐含目录作为文件列表中的真实的目录，即使发送端的某个路径元素是一个软链接。这使得拷贝全
          路径文件时，不用担心因为路径中包含了软链接而可能出现的非预期的问题(译者注：即链接追踪)。如果要复制服务端符号链接，请通过其
          路径来复制符号链接，并通过实际路径来复制器真实对象。如果使用的rsync版本较老，可能需要使用&amp;quot;--no-implied-dirs&amp;quot;选项。

          也可以对所指定的路径限制发送时作为隐含目录的路径信息。从rsync 2.6.7版本开始，rsync可以在源路径插入一个点&amp;quot;.&amp;quot;，就像这样：

             rsync -avR /foo/./bar/baz.c remote:/tmp/

          这将会在远程主机上创建/tmp/bar/baz.c。(注意点后面必须跟上斜线，因此&amp;quot;/foo/.&amp;quot;将不会被缩写)对于更老版本的rsync，可能需要改变目录来
          限制源路径。例如，推送文件时：

             (cd /foo; rsync -avR bar/baz.c remote:/tmp/)


          (注意，括号将把两个命令放入子shell中执行，因此cd改变目录不会影响未来的命令)如果使用老版本的rsync拉取文件，使用以下惯用格式
          (但只适用于非daemon的传输)：

             rsync -avR --rsync-path=&amp;quot;cd /foo; rsync&amp;quot; \
                 remote:bar/baz.c /tmp/


   --no-implied-dirs
          该选项影响&amp;quot;--relative&amp;quot;选项的默认行为。当指定该选项时，在传输时不会包含源文件的隐含目录。这意味着目标主机上对应路径元素会被保
          留不变(如果它们存在的话)，并且缺少的隐含目录会以默认属性方式被创建。甚至允许目标主机上隐含路径元素和源地址的属性有非常大的区
          别，例如在接收端某文件可能是某个目录的符号链接。

          另外，当rsync要传输的文件为&amp;quot;path/foo/file&amp;quot;时，如果使用&amp;quot;--relative&amp;quot;选项，则目录&amp;quot;path&amp;quot;和&amp;quot;path/foo&amp;quot;是隐含目录。如果在目标主机上
          &amp;quot;path/foo&amp;quot;是一个指向&amp;quot;bar&amp;quot;文件的符号连接，接收端的rsync会删除&amp;quot;path/foo&amp;quot;，并重建它为一个目录，然后将接收到的文件放入此新目录中。
          使用&amp;quot;--no-implied-dirs&amp;quot;选项，接收端使用已存在的路径元素更新&amp;quot;path/foo/file&amp;quot;，意味着最终会在&amp;quot;path/bar&amp;quot;中创建file文件。另一个实现
          连接保留功能的方法是使用&amp;quot;--keep-dirlinks&amp;quot;选项(也将会使得后续的传输从符号链接定位到目录中)。

          当使用早于3.0.0版本的rsync拉取文件时，如果发送端的路径中包含了符号链接，并且希望隐含目录能以普通目录方式被传输时，可能需要使
          用该选项。

   -b, --backup
          当使用该选项时，如果目标路径中已存在需要被传输或需要被删除的文件时将重命名该文件。可以使用&amp;quot;--backup-dir&amp;quot;选项控制备份文件的保
          存路径，使用&amp;quot;--suffix&amp;quot;选项控制备份时追加在原文件名后的后缀。

          注意，如果不指定&amp;quot;--backup-dir&amp;quot;选项：(1)将隐含&amp;quot;--omit-dir-times&amp;quot;选项(2)如果&amp;quot;--delete&amp;quot;选项同时影响该文件，rsync将在排除规则的尾部
          添加一个起&amp;quot;保护&amp;quot;作用的筛选规则(例如，-f &amp;quot;P *~&amp;quot;)，这会阻止之前备份的文件被删除。注意，如果你使用了自己定义的筛选规则，你可能需
          要手动插入你的exclude/include规则，并且保证其优先级较高防止被其他规则先匹配上而导致失效。

   --backup-dir=DIR
          结合&amp;quot;--backup&amp;quot;选项一起使用，这表示rsync在远端将存储所有备份文件到指定的目录下。这可用于增量备份。可以使用&amp;quot;--suffix&amp;quot;选项额外指
          定备份后缀(否则备份到指定目录的文件将使用原文件名)。

          需要注意如果拟制定了一个相对路径，备份目录将会相对到目标目录，因此你可能真正想要指定的是一个绝对路径或以&amp;quot;../&amp;quot;开头的路径。如果
          接收端是rsync daemon，备份目录将无法超出模块的路径层次结构，因此请特别注意不要将其删除或复制到其中。

   --suffix=SUFFIX
          该选项可以自定义&amp;quot;--backup&amp;quot;(-b)选项的备份文件名后缀，如果没有指定&amp;quot;--backup-dir&amp;quot;选项，则默认后缀为&amp;quot;~&amp;quot;，否则后缀为空字符串。

   -u, --update
          该选项将强制忽略在目标路径下已存在且修改时间比源文件更新的文件。(如果已存在的目标文件的修改时间和源文件相同，则只在文件大小
          不同时才会更新)

          注意该选项不会影响软链接或其他特殊文件的拷贝机制。而且，不管两端文件中的数据是否相同，考虑发送端和接收端不同的文件格式对于更
          新来说也是非常重要的。换句话说，如果源文件是一个目录，而目标已存在的同名文件却是一个普通文件，则rsync会直接忽略它们的时间戳。

          该选项是一种传输规则，不是排除规则，因此不会影响进入file-lists的文件，也因此不会影响删除。它仅会限制接收端请求传输的文件。

   --inplace
          该选项会改变当数据需要更新时，rsync传输文件的方式。默认情况下，rysnc会创建一个文件的新副本，当此文件传输完成时会将此副本移动
          到指定的路径下。使用此选项后，将直接把更新部分的数据写入到目标文件中。

          (译者注：此选项的拷贝机制可以理解为类似于drbd基于块的拷贝机制)

          这会带来以下几种影响：

          o      硬链接不会被破坏。这意味着通过其他硬链接文件可以直接访问到新数据。更进一步说，尝试拷贝不同源文件到多重链接的目标文件
                 时，将导致目标数据像&amp;quot;拔河&amp;quot;一样，来来回回地变化。

          o      使用中的二进制程序不会被更新(操作系统会防止这样的事情发生，二进制程序自身也会在尝试数据交换时崩溃)。

          o      在传输过程中，文件的数据会进入不一致状态，并且如果传输被中断或者更新失败时，文件将继续不一致。

          o      rsync无法将数据写入到一个无法被更新的文件中。虽然超级管理员可以更新任意文件，但普通用户需要获取文件的写权限才能打开文件
                 并向其中成功写入数据。

          o      如果目标文件中的数据在它被复制到某个位置之前被覆盖，则rsync的增量拷贝效率会降低。如果使用了&amp;quot;--backup&amp;quot;则不会出现这样的问
                 题，因为rsync足够智能，它会使用备份文件作为传输的基准文件。

          警告：不能使用该选项对那些正被其他用户访问的文件，因此在选择使用此选项进行拷贝时需要小心谨慎。

          该选项适用于对于那些基于数据块(block-based)改变或向文件尾部追加了数据的大文件，也适用于那些安装在磁盘上而不是网络上的系统。
          它也能有效帮助保持写时复制(copy-on-write)文件系统的快照。

          该选项隐含了&amp;quot;--partial&amp;quot;选项(因为传输中断不会删除文件)，但和&amp;quot;--partial-dir&amp;quot;以及&amp;quot;--delay-udpates&amp;quot;选项冲突。

   --append
          该选项使得rsync以追加数据到文件尾部的方式来更新文件，它会假定接收端上已存在的文件和发送端文件的前段数据是一致的。如果接收端上
          文件的大小等于或大于发送端文件的大小，则此文件会被忽略。该选项不会干涉不被传输文件的非内容属性(non-content，如权限，所有者等)，
          也不会影响对非普通文件(non-regular)的更新。隐含了&amp;quot;--inplace&amp;quot;选项，但是和&amp;quot;--sparse&amp;quot;选项不冲突(因为它总是扩充一个文件的长度)。

   --append-verify
          工作方式类似于&amp;quot;--append&amp;quot;选项，但是接收端已存在的数据在验证阶段会被包含在whole-file校验码中，如果最后验证阶段失败了，该文件会被
          传输(rsync将使用正常、非追加的&amp;quot;--inplace&amp;quot;模式重发文件)。

   -d, --dirs
          以不递归的方式拷贝目录本身，它不会拷贝目录中的文件。不像&amp;quot;--recursive&amp;quot;选项，只拷贝目录中的内容而不拷贝目录本身。除非目录名中使
          用了&amp;quot;.&amp;quot;或者以斜线结尾(如&amp;quot;.&amp;quot;,&amp;quot;dir/.&amp;quot;,&amp;quot;dir/&amp;quot;等)。既不指定该选项，也不指定&amp;quot;--recursive&amp;quot;选项时，rsync将忽略所有遇到的目录(并会向输
          出这些影响信息)。如果同时指定了&amp;quot;--dirs&amp;quot;和&amp;quot;--recursive&amp;quot;选项，&amp;quot;--recursive&amp;quot;将优先生效。

          如果没有给定&amp;quot;--recursive&amp;quot;选项，&amp;quot;--files-from&amp;quot;或&amp;quot;--list-only&amp;quot;选项会隐含&amp;quot;--dirs&amp;quot;选项，此时在列表中能见到所有目录。要想关闭此功能，
          可以指定&amp;quot;--no-dirs&amp;quot;或&amp;quot;--no-d&amp;quot;选项。

          还有一个比较有用的向后兼容的选项：&amp;quot;--old-dirs&amp;quot;(--old-d)。它告诉rsync使用&amp;quot;-r --exclude=&#39;/*/*&#39;&amp;quot;仅列出目录而不递归。

   -l, --links
          当遇到符号链接时，将在目标路径重新创建符号链接。(译者注：即拷贝符号链接本身)

   -L, --copy-links
          使用该选项时，当遇到符号链接时将拷贝它所指向的目标而不是符号链接本身(译者加：但仅只是追踪了链接文件指向文件中的数据，文件名
          仍然是符号链接文件的文件名。举个例子，如果client端a文件--&amp;gt;b文件，则使用该选项拷贝a时，将在receiver端生成a文件，但a文件是一个
          普通文件，其中的数据来源是client端b文件的数据)。老版本的rsync使用该选项还会告诉接收端也追踪符号链接到其指向的目标中。在目前
          的rsync版本中，要实现这样的功能需要指定&amp;quot;--keep-dirlinks&amp;quot;(-K)选项。

   --copy-unsafe-links
          This  tells  rsync  to copy the referent of symbolic links that point outside the copied tree.  Absolute symlinks are also treated
          like ordinary files, and so are any symlinks in the source path itself when --relative is used.  This  option  has  no  additional
          effect if --copy-links was also specified.

   --safe-links
          This  tells  rsync to ignore any symbolic links which point outside the copied tree. All absolute symlinks are also ignored. Using
          this option in conjunction with --relative may give unexpected results.

   -k, --copy-dirlinks

          Without  this  option,  if the sending side has replaced a directory with a symlink to a directory, the receiving side will delete
          anything that is in the way of the new symlink, including a directory hierarchy (as long as --force or --delete is in effect).

          See also --keep-dirlinks for an analogous option for the receiving side.

          --copy-dirlinks applies to all symlinks to directories in the source.  If you want to follow only  a  few  specified  symlinks,  a
          trick  you  can  use  is to pass them as additional source args with a trailing slash, using --relative to make the paths match up
          right.  For example:

          rsync -r --relative src/./ src/./follow-me/ dest/


          This works because rsync calls lstat(2) on the source arg as given, and the trailing slash makes lstat(2) follow the symlink, giv‐
          ing rise to a directory in the file-list which overrides the symlink found during the scan of &amp;quot;src/./&amp;quot;.

   -K, --keep-dirlinks
          该选项使得receiver端将符号链接视为目录文件，就像它是真的目录一样，但只有它在sender端能匹配一个真实目录时才会如此。不使用该选
          项，receiver端的符号链接将被删除或替换为一个真实目录。

          例如，假设你要传输一个包含文件&amp;quot;file&amp;quot;的目录&amp;quot;foo&amp;quot;，但是在receiver端上的&amp;quot;foo&amp;quot;是一个指向&amp;quot;bar&amp;quot;目录的符号链接。如果不使用该选项，
          receiver端将删除符号链接&amp;quot;foo&amp;quot;，然后重建它为一个目录，然后接收&amp;quot;file&amp;quot;到此目录中。如果使用了该选项，receiver端将保留符号链接，然
          后将&amp;quot;file&amp;quot;存放到&amp;quot;bar&amp;quot;目录中去。
          (译者注：上述示例的命令格式为&amp;quot;rsync -r foo user@host:/path&amp;quot;，其中path下有个名为foo的链接文件)

          需要注意一点：如果使用了&amp;quot;--keep-dirlinks&amp;quot;，你必须信任你所有拷贝中的链接文件。如果某个非信任用户要创建属于它自己的符号链接(指
          向某目录)，在下一次传输过程中，可能会使用真实目录替换掉符号链接并影响链接文件所指向目录中的文件内容。对于备份拷贝，你最好是
          用mount的bind功能而不是使用符号链接来改变接收端的目录层次。

          参见&amp;quot;--copy-dirlinks&amp;quot;选项，它是在sender端上类似的选项。

   -H, --hard-links
          This tells rsync to look for hard-linked files in the source and link together the corresponding files on the destination.   With‐
          out this option, hard-linked files in the source are treated as though they were separate files.

          This  option  does  NOT  necessarily  ensure that the pattern of hard links on the destination exactly matches that on the source.
          Cases in which the destination may end up with extra hard links include the following:

          o      If the destination contains extraneous hard-links (more linking than what is present in the source file list), the  copying
                 algorithm  will  not  break  them  explicitly.   However,  if one or more of the paths have content differences, the normal
                 file-update process will break those extra links (unless you are using the --inplace option).

          o      If you specify a --link-dest directory that contains  hard  links,  the  linking  of  the  destination  files  against  the
                 --link-dest files can cause some paths in the destination to become linked together due to the --link-dest associations.


          Note that rsync can only detect hard links between files that are inside the transfer set.  If rsync updates a file that has extra
          hard-link connections to files outside the transfer, that linkage will be broken.  If you are tempted to use the --inplace  option
          to  avoid this breakage, be very careful that you know how your files are being updated so that you are certain that no unintended
          changes happen due to lingering hard links (and see the --inplace option for more caveats).

          If incremental recursion is active (see --recursive), rsync may transfer a missing hard-linked file before it finds  that  another
          link for that contents exists elsewhere in the hierarchy.  This does not affect the accuracy of the transfer (i.e. which files are
          hard-linked together), just its efficiency (i.e. copying the data for a new, early copy of a hard-linked file that could have been
          found  later in the transfer in another member of the hard-linked set of files).  One way to avoid this inefficiency is to disable
          incremental recursion using the --no-inc-recursive option.

   -p, --perms
          该选项告诉receiver端的rsync，要将目标文件的权限值设置为何源文件一样(即权限保留)。(参见&amp;quot;--chmod&amp;quot;选项以获取rsync修改sender端权限
          的方式)

          当没有使用该选项时，将以如下方式设置权限值：

          o      已存在的文件继续保留它们的原有权限，尽管&amp;quot;--executability&amp;quot;选项可能会改变文件的执行权限。

          o      对于新文件，将从源文件中获取普通权限值，再配合receiver端文件所在目录的默认ACL权限或umask值决定文件的最终权限，并且会禁
                 用它们的特殊权限位，除非新的目录文件从其父目录中继承了sgid权限。

          因此，当&amp;quot;--perms&amp;quot;和&amp;quot;--executability&amp;quot;选项都被禁用时，rsync的行为和其它文件拷贝工具的行为一样，例如cp、tar。

          总结以下：要设置目标文件(包括新文件和已存在的旧文件)的权限值为源文件的权限值，使用&amp;quot;--perms&amp;quot;选项。要设置新的目标文件默认权限，
          请确保&amp;quot;--perms&amp;quot;选项是关闭的，然后使用&amp;quot;--chmod=ugo=rwX&amp;quot;(这将保证启用所有非掩码位权限)。如果想以更简单的方式实现后一种情况，你
          可能需要为其定义一个popt别名，例如将下面的命令行放入文件~/.popt中(下面的命令中定义了&amp;quot;-Z&amp;quot;选项，并使用了&amp;quot;--no-g&amp;quot;使得目标文件的
          所属组使用目标目录的默认组)：

             rsync alias -Z --no-p --no-g --chmod=ugo=rwX

          然后可以在命令行中使用新的选项，例如：

             rsync -avZ src/ dest/

          (警告：请确保&amp;quot;-a&amp;quot;选项不是跟随在&amp;quot;-Z&amp;quot;后的，否则将重新启用上面已经定义的两个&amp;quot;--no-*&amp;quot;选项。)

   -E, --executability
          该选项使得rsync在未指定&amp;quot;--perms&amp;quot;选项时对普通文件保留文件的执行权限(或者不可执行权限)。普通文件上开启了&amp;quot;x&amp;quot;才认为有可执行权限。
          当目标文件已存在且和对应源文件的可执行权限值不一样时，rsync将采用如下方式修改权限：

          o      To make a file non-executable, rsync turns off all its ’x’ permissions.

          o      To make a file executable, rsync turns on each ’x’ permission that has a corresponding ’r’ permission enabled.

          如果指定了&amp;quot;--perms&amp;quot;选项，则该选项被忽略。

   -A, --acls
          使目标文件的ACL属性和源文件的ACL属性一致。该选项隐含了&amp;quot;--perms&amp;quot;选项。

   -X, --xattrs
          使目标文件的扩展属性和源文件的扩展属性保持一致。

   --chmod
          该选项使得rsync可以将目标文件的权限设定为此处所指定的权限值，让rsync以为这些指定的权限就是源文件的权限。也因此在未配合&amp;quot;--perms&amp;quot;
          一起使用时该选项无效。

          在chmod(1)的man文档中记录了普通的语法解析规则，你可以通过加上一个前缀&amp;quot;D&amp;quot;来指定该权限规则只对目录有效，或者加上前缀&amp;quot;F&amp;quot;指定该权
          限规则只对普通文件有效。例如，下面的例子保证了所有目录都标记了sgid权限，其它人对文件都不可写，所有者和所属组都可写，且所有人
          都有执行权限：

          --chmod=Dg+s,ug+w,Fo-w,+X

          可以指定多个使用逗号分隔的&amp;quot;--chomod&amp;quot;选项。

   -o, --owner
          该选项使得rsync将目标文件的所有者设置为和源文件一样(即保留所有者属性)，但要求接收端的rsync是以super user身份运行的(或指定了
          &amp;quot;--no-super&amp;quot;选项)。如果不指定该选项，目标文件的所有者将设置为调用rsync的用户身份(译者注：例如rsync /src name1@host:/path，则
          目标文件的所有者为name1)。

          默认情况下，目标文件的所有者名称是由uid来匹配的，但在某些环境下，可能会保留使用uid。(详细信息见&amp;quot;--numeric-ids&amp;quot;选项)

          (译者注：例如源文件的所有者为name1，其uid=1000，那么将在目标主机上寻找uid=1000所对应的用户名，如果能找到则所有者设置为用户名，
          否则设置为uid=1000)

   -g, --group
          此选项的意义完全同&amp;quot;--owner&amp;quot;，所以不做对应翻译。

   --devices
          该选项使得rsync可以传输字符设备和块设备到目标主机上以重新创建这些设备。该选项要求接收端的rsync是以super user身份运行的(译者注：
          例如，root用户也算是super user，则rsync /devicename root@host:/path)，否则该选项失效。(见&amp;quot;--super&amp;quot;和&amp;quot;--fake-super&amp;quot;选项)

   --specials
          该选项使得rsync可以传输特殊文件，如命名套接字，命名管道等。

   -D     该选项等价于&amp;quot;--devices --specials&amp;quot;选项组合。

   -t, --times
          该选项告诉rsync将mtime随同文件一起传输给receiver，使得目标文件的mtime和源文件一样。千万注意，如果不指定该选项，原本排除那些
          mtime相同的文件而获得的性能提升将不再生效；换句话说，如果没有在rsync命令行中使用&amp;quot;-t&amp;quot;或&amp;quot;-a&amp;quot;选项，将导致下一次传输以类似于&amp;quot;-I&amp;quot;
          的方式进行，即更新所有文件(尽管在文件没有真正发生更改的情况下，rsync的增量传输算法可以让更新效率很高，但最好还是使用&amp;quot;-t&amp;quot;)

   -O, --omit-dir-times
          该选项告诉rsync，当保留mtime(见&amp;quot;--times&amp;quot;)时，将忽略目录。如果receiver端正在通过NFS共享目录，使用&amp;quot;-O&amp;quot;是一个不错的选择。
          如果指定了&amp;quot;--backup&amp;quot;但没有指定&amp;quot;--backup-dir&amp;quot;，将隐含该选项。

   --super
          该选项告诉receiver端在进行某些操作时尝试使用super-user身份，尽管receiver端的rsync不是以super user身份运行的。这些操作包括：
          通过&amp;quot;--owner&amp;quot;保留文件所有者，通过&amp;quot;--groups&amp;quot;保留文件所属组(包括辅助组)，通过&amp;quot;--devices&amp;quot;选项拷贝设备文件。在receiver端未以super
           user身份调用rsync时，这些选项很有用。如果要关闭super user选项功能，则使用&amp;quot;--no-super&amp;quot;

   --fake-super
          如果启用了该选项，rsync将通过对附加在每个文件上的扩展属性(根据实际需要)的保存/恢复来模拟super user。扩展属性包括：文件的owner、
          group、文件的设备信息(设备文件和特殊文件被创建为空文本文件)以及所有特殊权限位(suid/sgid/sbit)。

          在不使用super user备份数据时但又想保存ACL属性时，该选项很有用。

          &amp;quot;--fake-super&amp;quot;选项默认只影响命令发起端，如果想要通过远程shell影响远程端时，可以指定rsync的路径：

            rsync -av --rsync-path=&amp;quot;rsync --fake-super&amp;quot; /src/ host:/dest/

          由于本地拷贝时，两端都在本地主机上，该选项将会同时影响本地的sender端和receiver端的文件。如果想要避免这样的情况，需要通过指定
          &amp;quot;localhost&amp;quot;的地址方式来实现拷贝，或者可能也可以使用&amp;quot;lsh&amp;quot;远程shell来完成。

          该选项会被&amp;quot;--super&amp;quot;以及&amp;quot;--no-super&amp;quot;选项覆盖。

          其他信息可以参见rsyncd.conf文件中的&amp;quot;fake super&amp;quot;。

   -S, --sparse
          尝试以高效率的方式处理稀疏文件，使得它们在目标主机上占用更少的空间。该选项不能和&amp;quot;--inplace&amp;quot;选项一起使用，因为&amp;quot;--inplace&amp;quot;不能向
          稀疏模式的文件中覆盖数据。

   -n, --dry-run
          该选项使得rsync仅测试运行(并生成和真正运行时几乎一样的输出信息)。该选项常和&amp;quot;-v&amp;quot;、&amp;quot;--verbose&amp;quot;、&amp;quot;-i&amp;quot;、&amp;quot;--itemize-changes&amp;quot;选项一
          起使用，以便查看rsync在这些选项下是如何工作的。

          配合&amp;quot;--itemize-changes&amp;quot;时的输出结果应该要和真正运行的结果完全一致(除非人为故意欺骗rsync或系统调用失败)。如果输出结果不一致，则
          出现了bug。配合其他几个选项时，输出结果除了在某些方面外应该保持几乎一致。尤其是，dry run不会真的发送数据，因此&amp;quot;--progress&amp;quot;将的
          结果将很可能异常。             

   -W, --whole-file
          使用该选项将使得rsync不再使用增量传输算法，而是传输所有文件。如果源和目标主机之间的带宽高于磁盘的带宽(特别是&amp;quot;磁盘&amp;quot;是网络文件
          系统时)，则该选项比增量传输更有效。当源和目标都是本地时，该选项是默认的传输算法，但若受到write batch模式影响，则此算法不生效。

          (译者注：假设A主机和B主机之间的网络可以以1000MB/s的速度传输，而目标主机B上磁盘的带宽只有500MB/s，显然目标主机在文件重组时从
          basis file读取数据块的速度不如A发送给B快，所以在这种情况下，增量传输不如全量传输)

   -x, --one-file-system
          该选项告诉rsync不能跨文件系统递归(译者注：例如根目录下有mnt目录，mnt常用来做挂载点，则递归根目录时，不会递归到mnt里面)。该选
          项不会限制用户从多个文件系统指定拷贝项，仅只是限制rsync在每个目录下进行递归，同时也以类似的限制方式限制删除时receiver端递归。
          需要记住，使用mount命令的&amp;quot;bind&amp;quot;功能绑定了设备文件时，它也被认为是在同一个文件系统上。

          如果重复指定该选项，rsync将忽略client端所有的挂载点目录。否则，当遇到挂载点时将当作是空目录(这些空目录使用已挂载目录的属性，
          因为挂载点目录下的文件是无法访问的)。

          如果指定了&amp;quot;--copy-links&amp;quot;或&amp;quot;--copy-unsafe-links&amp;quot;选项使得rsync&amp;quot;瓦解&amp;quot;符号链接，则符号链接所指向的是另一个设备上的目录时将和挂载点
          一样对待。该选项不会影响指向非目录的符号链接。
          (译者注：翻译有点不标准，以下是原文)
          This  tells rsync to avoid crossing a filesystem boundary when recursing.  This does not limit the user’s ability to specify items
          to copy from multiple filesystems, just rsync’s recursion through the hierarchy of each directory that  the  user  specified,  and
          also  the  analogous  recursion  on the receiving side during deletion.  Also keep in mind that rsync treats a &amp;quot;bind&amp;quot; mount to the
          same device as being on the same filesystem.

          If this option is repeated, rsync omits all mount-point directories from the copy.  Otherwise, it includes an empty  directory  at
          each  mount-point  it encounters (using the attributes of the mounted directory because those of the underlying mount-point direc‐
          tory are inaccessible).

          If rsync has been told to collapse symlinks (via --copy-links or --copy-unsafe-links), a symlink to a directory on another  device
          is treated like a mount-point.  Symlinks to non-directories are unaffected by this option.

   --existing, --ignore-non-existing
          告诉rsync，如果目标主机上文件或文件所在目录还不存在，则不自动创建它们，即这些文件将不被传输。如果该选项和&amp;quot;--ignore-existing&amp;quot;
          选项一起使用，将不更新任何文件(如果你的目的是删除目标主机上的无关文件，这将非常有用)。

          (译者注：例如rsync --existing /etc/dhcp/* /tmp，由于/tmp下没有dhcp目录，所以dhcp目录和其中的文件都不会被传输到/tmp下)

          该选项属于一种transfer rule，而不是exclude rule，因此不会影响进入file list的文件，也因此不会影响删除操作。该选项仅对receiver所
          请求要传输的文件进行了限制。

   --ignore-existing
          该选项告诉rsync忽略对目标主机上已存在的文件的更新(不会忽略已存在的目录，或者什么也不做)。见&amp;quot;--existing&amp;quot;选项说明。

          该选项属于一种transfer rule，而不是exclude rule，因此不会影响进入file list的文件，也因此不会影响删除操作。该选项仅对receiver所
          请求要传输的文件进行了限制。              

          对于使用了&amp;quot;--link-dest&amp;quot;选项做备份时，碰巧备份被中断，如果想继续完成备份，则该选项有用。因为&amp;quot;--link-dest&amp;quot;选项会拷贝到一个新的目
          录层次中，使用&amp;quot;--ignore-existing&amp;quot;将保证已存在的文件不会被调整。这意味着该选项仅盯着目标上已存在的文件不放。

   --remove-source-files
          该选项告诉rsync移除sender端已经成功传输到receiver端的文件(不包括任何目录文件)。

   --delete
          该选项告诉rsync删除receiver端有而sender端没有的文件，但不是删除receiver端所有文件，而是只对将要同步的目录生效。你需要明确指定
          整个目录(如&amp;quot;dir&amp;quot;或&amp;quot;dir/&amp;quot;)而不是使用通配符来通配目录的内容(如&amp;quot;dir/*&amp;quot;)，因为通配符会被shell进行扩展，使得rsync被请求传输单个文件
          而非文件的父目录。被exclude排除的文件也会从delete中排除掉，除非使用了&amp;quot;--delete-excluded&amp;quot;选项或者标记了只对sender端匹配上的文件
          有效(见筛选规则中的include/exclude修饰符)。
          (译者注：由于exclude规则先生效，delete时认为源端不存在而目标端存在，使得delete也想要删除这些被排除的文件，但默认情况下，在删除
          时对这些被排除的文件加上了保护规则，所以这些文件无法被delete掉，这是一个容易疑惑的地方。要删除这些被排除的文件，只需使用选项
          &amp;quot;--delete-excluded&amp;quot;选项将这些被保护的文件强制取消保护)

          (译者注：(1)不会删除receiver端任何目录，即使是子目录也不删除(2)delete动作是由generator进程执行的)

          该选项如果错误使用将是非常危险的！强烈建议先使用&amp;quot;--dry-run&amp;quot;(-n)进行测试，以确定将删除那些文件。

          如果sender端探测到了任何i/o错误，将自动禁用远程删除功能。这是为了防止sender端的临时文件系统故障(如NFS错误)导致大规模删除目标
          文件。可以指定&amp;quot;--ignore-errors&amp;quot;选项强制忽略任何I/O错误。

          &amp;quot;--delete&amp;quot;选项一般可能会配合&amp;quot;--delete-WHEN&amp;quot;的某一种或&amp;quot;--delete-excluded&amp;quot;，它们不会产生冲突。但是，如果未指定任何&amp;quot;--delete-WHEN&amp;quot;
          时，rsync将默认采用&amp;quot;--delete-during&amp;quot;算法。
          (译者注：即在generator启动后，每处理一个文件列表，就删除该文件列表中需要删除的文件，在处理某个文件列表时不会删除别的文件列表
          中的文件，其实这一点从&amp;quot;-vvvv&amp;quot;的结果中很容易获取到)

   --delete-before
          请求在传输开始前执行目标文件删除行为。该选项隐含了&amp;quot;--delete&amp;quot;选项。
          (译者注：传输之前删除指的在处理所有文件列表之前先删除所有文件列表中指定要删除的文件，也就是说在generator刚启动时立即删除所有
          文件列表中待删除文件，而默认的--delete则是在generator刚启动时删除第一个文件列表中的待删除文件)

          在传输之前执行删除对于文件系统空间紧俏时是很有帮助的。但是，由于它会在传输开始之前发起一段延迟，这一段延迟很可能会使得传输
          超时(如果指定了&amp;quot;--timeout&amp;quot;选项)，还会强制rsync使用老的、非增量的递归算法，此算法要求rsync将所有传输中的文件一次性扫描到内存中。

   --delete-during, --del
          请求receiver端的文件删除行为是随着文件传输时逐步执行的。隐含了&amp;quot;--delete&amp;quot;选项。
          (译者注：&amp;quot;--delete&amp;quot;没有和&amp;quot;--delete-WHEN&amp;quot;同时使用时，&amp;quot;--delete&amp;quot;默认采用的就是&amp;quot;--delete-during&amp;quot;）

   --delete-delay
          请求receiver端的文件删除行为在所有文件列表中的文件都全部传输完成后才删除。在结合&amp;quot;--delay-updates&amp;quot;、&amp;quot;--fuzzy&amp;quot;选项一起使用时比较
          有用，并且相比&amp;quot;--delete-after&amp;quot;来说效率更高。

   --delete-after
          请求receiver端的文件删除行为在所有文件列表中的文件都全部传输完成后才删除。和&amp;quot;--delete-delay&amp;quot;不同的是，该选项会采用老的、非增量
          传输的算法将传输中的所有文件一次性扫描到内存中，因此效率不高。

   --delete-excluded
          为了删除sender端没有而receiver端有的文件，可以指定该选项告诉rsync即使文件被&amp;quot;--exclude&amp;quot;排除了，也要在远程将其删除。

   --ignore-errors
          告诉&amp;quot;--delete&amp;quot;，即使在遇到I/O错误时也要继续。

   --force
          该选项告诉rsync，当某个非空目录要被非目录文件替换时，将此非空目录删除掉。这只有在删除行为未激活时才有效。

   --max-delete=NUM
          限制rsync最多能删除NUM个文件或目录，如果突破了该限制，将输出警告信息并以状态码25退出。

          可以使用&amp;quot;--max-delete=0&amp;quot;来保证不会在远程删除任何文件，因为只要有删除行为，就会警告并退出。

   --max-size=SIZE
          限制rsync传输的最大文件大小。可以使用单位后缀，还可以是一个小数值(例如：&amp;quot;--max-size=1.5m&amp;quot;)。

          该选项是一个传输规则，而不是排除规则，因此不会影响文件进入文件列表，也因此不会影响删除行为。它仅仅只是限制了receiver端请求传
          输的文件。

          有如下可用后缀：&amp;quot;K&amp;quot;(&amp;quot;KiB&amp;quot;)=1024字节、&amp;quot;M&amp;quot;(&amp;quot;MiB&amp;quot;)、&amp;quot;G&amp;quot;(&amp;quot;GiB&amp;quot;)。如果想使用1000作为换算单位，则使用KB、MB、GB。(注意，所有大写字母都
          可以使用小写字母替换)。最后，如果后缀以&amp;quot;+1&amp;quot;或&amp;quot;-1&amp;quot;结尾，则值表示减小或增大一个字节。

          例如：&amp;quot;--max-size=1.5mb-1&amp;quot;表示1499999字节，&amp;quot;--max-size=2g+1&amp;quot;表示2147483649字节。

   --min-size=SIZE
          限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件。单位的指定方法同&amp;quot;--max-size&amp;quot;。

   -B, --block-size=BLOCKSIZE
          该选项强制修改rsync算法将文件划分为数据块时的块大小。一般基于正在更新的文件来选择大小值。详细信息见技术报告。
          (译者注：rsync算法的作者说块大小在500-1000时是比较好的选择。
          对于超过1M的文件绝对不要让块大小低于500，否则性能极低。)

   -e, --rsh=COMMAND
          该选项允许你选择用于本地和远程之间的通信的远程shell程序。一般情况下，rsync默认配置为使用ssh，但如果在本地网络上，你可能更喜欢
          使用rsh。

          如果该选项和格式[user@]host::module/path一起使用，则该远程shell命令会在远程主机上启动一个rsync daemon(译者注：可以认为是临时模
          拟的rsync daemon进程)，并且所有数据都将通过此远程shell的连接传输，而不是通过网络套接字所连接的远程主机上的rsync daemon。见上文
          &amp;quot;通过远程SHELL连接使用RSYNC-DAEMON特性&amp;quot;。

          允许在COMMAND中提供多个远程shell参数，它们将会作为一个整体传递给rsync。多个参数必须使用空格(不能是制表符tab或其他任意空白字符)，
          分隔，也可以使用单引号或双引号包围参数来保护空格(但不能使用反斜线)。注意在单引号字符串内部使用多个单引号将返回给你一对单引号，
          同理，双引号也一样(尽管你需要注意哪些引号是shell来解析的，哪些引号是rsync解析的)。例如：

              -e &#39;ssh -p 2234&#39;
              -e &#39;ssh -o &amp;quot;ProxyCommand nohup ssh firewall nc -w1 %h %p&amp;quot;&#39;            

          (Note that ssh users can alternately customize site-specific connect options in their .ssh/config file.)

          你也可以使用RSYNC_RSH环境变量指定远程shell程序，它能接受和&amp;quot;-e&amp;quot;选项一样的值。

          另外请查看会影响该选项的&amp;quot;--blocking-io&amp;quot;选项。

   --rsync-path=PROGRAM
          指定远程机器上要运行的程序以启动远程rsync进程。当远程rsync程序不在默认目录/usr/local/bin/rsync下常会使用该选项指定其路径。
          但要注意，PROGRAM是在shell的帮助下运行的，因此它可以是任意程序、脚本或你想运行的命令序列，只要它们不会破坏rsync正在使用的标准
          输入和标准输出即可。

          一个很棘手的例子是在远程机器上设置不同的默认目录以便使用&amp;quot;--relative&amp;quot;选项。例如：

              rsync -avR --rsync-path=&amp;quot;cd /a/b &amp;amp;&amp;amp; rsync&amp;quot; host:c/d /e/

          (译者注：以上示例将会在本地主机创建/e/c/d，其中c/d数据来源于远程主机的/a/b/c/d)

   -C, --cvs-exclude
          这是一个很有用的简写排除文件法，用于排除大量不希望在系统之间传输的文件。它使用了类似于CVS的算法来决定一个文件是否要被忽略。

          exclude列表被初始化为排除以下格式的文件(这些初始化条目被标记为易过期，见&amp;quot;筛选规则&amp;quot;段落的说明)：

                 RCS SCCS CVS CVS.adm RCSLOG cvslog.* tags TAGS .make.state .nse_depinfo *~ #* .#* ,* _$* *$ *.old *.bak *.BAK *.orig  *.rej
                 .del-* *.a *.olb *.o *.obj *.so *.exe *.Z *.elc *.ln core .svn/ .git/ .hg/ .bzr/

          然后，$HOME/.cvsignore文件中的文件列表将会被添加到此exclude列表，此外还会包含CVSIGNORE环境变量中指定的所有文件(所有cvsignore
          名称由空白字符分隔)

          最后，和.cvsignore文件在同一个目录中的文件，如果它们能匹配此文件中列出的规则，则也会被排除。不像rsync的筛选/排除规则，这些匹
          配模式是使用空白字符分隔的。更多cvs的模式见cvs(1)的man文档。

          如果将&amp;quot;-C&amp;quot;选项结合&amp;quot;--filter&amp;quot;规则，需要记住，无论&amp;quot;-C&amp;quot;选项处于命令行的哪些位置，这些cvs排除规则都将会追加在你所指定的规则之后。
          这就使得&amp;quot;-C&amp;quot;选项指定的规则比你自行指定的规则优先级耕地。如果你想将CVS规则插入到你的筛选规则中的某个位置，那么就不要使用&amp;quot;-C&amp;quot;
          选项，而是使用一种结合方式：&amp;quot;--filter:C&amp;quot;或&amp;quot;--filter=-C&amp;quot;。前者启用.cvsignore文件中的规则进行每目录扫描，后者则是一次性导入所有
          上面说所的CVS规则。

   -f, --filter=RULE
          该选项可以让你添加规则，以便从待传输的文件列表中有选择性地排除某些文件。在递归传输中，结合该选项是非常有用的。

          你可以在命令行中使用任意多个&amp;quot;--filter&amp;quot;选项以建立要排除的文件列表。如果筛选规则中包含了空白字符，需要使用引号包围以防被shell
          解析。在下文中同样介绍了如何使用下划线替代空格来分隔rsync参数和规则。

          该选项的详细信息请参见&amp;quot;筛选规则&amp;quot;段落说明。

   -F     该选项是一种添加到&amp;quot;--filter&amp;quot;规则的简写法，只有两种可能：第一种是单个&amp;quot;-F&amp;quot;选项，此时它是以下规则的简写：

             --filter=&#39;dir-merge /.rsync-filter&#39;

          这告诉rsync查找那些分散在目录结构中的所有.rsync-filter文件，然后使用这些规则筛选出传输中的文件。
          第二种是如果重复使用&amp;quot;-F&amp;quot;选项，则它是以下规则的简写：

             --filter=&#39;exclude .rsync-filter&#39;

          该规则将从传输中筛选出.rsync-filter本身。

          关于该选项如何工作的更详细信息，见&amp;quot;筛选规则&amp;quot;段落说明。

   --exclude=PATTERN
          该选项是&amp;quot;--filter&amp;quot;选项的简化格式，默认为排除(exclude)规则，并且它将禁止对普通的筛选规则进行解析。

          更详细信息见&amp;quot;筛选规则&amp;quot;段落说明。

   --exclude-from=FILE
          该选项和&amp;quot;--exclude&amp;quot;选项类似，但是它是从包含了排除规则的文件中读取排除规则(每行一个规则)。空行以及&amp;quot;;&amp;quot;或&amp;quot;#&amp;quot;开头的行为注释行，如
          果给定的文件为&amp;quot;-&amp;quot;，则表示从标准输入中读取排除规则。

   --include=PATTERN
          该选项是&amp;quot;--filter&amp;quot;选项的简化格式，默认为包含(include)规则，并且它将禁止对普通的筛选规则进行语法解析。

           更详细信息见&amp;quot;筛选规则&amp;quot;段落说明。

   --include-from=FILE
          该选项和&amp;quot;--exclude&amp;quot;选项类似，但是它是从包含了排除规则的文件中读取排除规则(每行一个规则)。空行以及&amp;quot;;&amp;quot;或&amp;quot;#&amp;quot;开头的行为注释行，如
          果给定的文件为&amp;quot;-&amp;quot;，则表示从标准输入中读取排除规则。

   --files-from=FILE
          该选项可以在FILE中精确指定要传输的文件列表。如果FILE为&amp;quot;-&amp;quot;则表示从标准输入中读取文件列表。它还调整了rysnc的默认行为以便能够
          更简单地指定要传输的文件：

          o      它隐含了&amp;quot;--relative&amp;quot;(-R)选项，所以会保留在文件中每个条目所指定的路径信息。(使用&amp;quot;--no-relative&amp;quot;或&amp;quot;--no-R&amp;quot;关闭该功能)

          o      它隐含了&amp;quot;--dirs&amp;quot;(-d)选项，所以将在目标主机上创建列表中指定的目录而不是悄悄地跳过它们。(使用&amp;quot;--no-dirs&amp;quot;或&amp;quot;--no-d&amp;quot;关闭
                 该功能)

          o      &amp;quot;--archive&amp;quot;(-a)将不再隐含&amp;quot;--recursive&amp;quot;(-r)，因此如果真的要递归到目录中，需要显式指定&amp;quot;--recursive&amp;quot;(-r)。

          o      它的副作用是改变了rsync的默认状态，因此&amp;quot;--files-from&amp;quot;选项在命令行中的位置和其它选项的解析无关(例如，&amp;quot;-a&amp;quot;选项放在
                 &amp;quot;--files-from&amp;quot;选项的前后的工作方式是一样的)。

          从FILE中读取的所有文件名都是相对于源目录的相对路径，任何前导斜线都会被移除，也无法使用&amp;quot;..&amp;quot;进入源目录的上一层次目录。例如：

             rsync -a --files-from=/tmp/foo /usr remote:/backup

          如果/tmp/foo中包含了字符串&amp;quot;bin&amp;quot;或&amp;quot;/bin&amp;quot;，将在远程主机上创建/backup/bin作为/usr/bin所对应的目标文件。如果包含了字符串&amp;quot;bin/&amp;quot;
          (注意尾随斜线)，则将传输/usr/bin目录以及其内的文件。如果指定了&amp;quot;-r&amp;quot;选项，则所有目录结构都会被传输(要记住当使用了&amp;quot;--files-from&amp;quot;
          时，&amp;quot;-r&amp;quot;选项需要显式指定，因为&amp;quot;-a&amp;quot;选项不再隐含该选项)。还要注意，适用&amp;quot;--files-from&amp;quot;时，&amp;quot;--relative&amp;quot;选项的默认行为是仅复制从文
          件中读取的路径信息，不再强制复制原规范路径(即此示例中的/usr)

          另外，&amp;quot;--files-from&amp;quot;的文件可以从远程主机上读取，而不一定要从本地主机上读取，只需在文件的前面指定&amp;quot;host:&amp;quot;即可。要求&amp;quot;host:&amp;quot;的host
          必须是rsync两端的某一端，为了简写，可以使用简写的前缀&amp;quot;:&amp;quot;表示远端主机。例如：

             rsync -a --files-from=srchost:/path/file-list srchost:/ /tmp/copy
             rsync -a --files-from=:/path/file-list        srchost:/ /tmp/copy

          这将会拷贝在远程主机&amp;quot;srchost&amp;quot;上/path/file-list文件中指定的所有文件。

          注意：对&amp;quot;--files-from&amp;quot;的文件进行排序可以使得rsync效率更高，因为它将使得rsync不用再重新读取相邻能共用的路径元素。如果不进行排序，
          则rsync可能会多次重新扫描路径元素(隐含目录)，重复生成文件列表。

   -0, --from0
          告诉rsync从文件中读取规则或文件名时是以空字符(\0)终止的。该选项会影响&amp;quot;--exclude-from&amp;quot;、&amp;quot;--include-from&amp;quot;、&amp;quot;--files-from&amp;quot;以及所有
          在&amp;quot;--filter&amp;quot;中指定的规则合并文件。它不会影响&amp;quot;--cvs-exclude&amp;quot;(因为从.cvsignore文件中读取的名称都是以空白字符分隔的)。

   -s, --protect-args
          该选项将使得所有发送给远程rsync进程的文件名和大多数选项都不允许被远程shell解析。这意味着空格不再分隔文件名，任意非通配特殊字符
          都不会被翻译(即成为普通字符，如：~、$、;、&amp;amp;等)。通配字符将被远程主机上的rsync扩展(正常情况下是由远程shell来扩展的)。

   -T, --temp-dir=DIR
          该选项明确receiver端文件重组时的临时目录。默认情况下，receiver端将在文件所在目录中创建临时文件。

          在receiver端，如果目标文件所在磁盘分区剩余大小不足以存储待重组文件时，可以使用该选项将临时文件存储到其他的分区中，在这种情况
          下，由于创建的临时文件和目标路径不在同一个分区上，所以重组完成时无法直接重命名，而是只能从临时目录中拷贝到目标路径下。

          如果你使用该选项的原因不是磁盘空间不足，你可能要将此选项结合&amp;quot;--delay-updates&amp;quot;选项一起使用，这将保证所有的拷贝文件都放入到目标
          层次结构的子目录中，并等待传输结束。

   -y, --fuzzy
          该选项告诉rsync，如果目标主机上的basis file缺失，将主动搜索出一个文件作为basis file。目前的算法是在同一目录中模糊搜索目标
          basis file，搜索的规则是：要么文件大小和修改时间完全一致，要么文件名相似。如果搜索到了符合条件的文件，rsync将使用该文件作为
          basis file，这样可能会加速传输速度。
          (译者注：在目标主机上进行文件重组时，会从basis file中拷贝匹配块，在真正的basis file缺失时，模糊搜索出的basis file可能能提供
          一些匹配块，从而减少sender要发送的数据量，加快整个同步过程)

          注意，如果使用了&amp;quot;--delete&amp;quot;选项，可能会把潜在的basis file给删除掉，因此如果想避免这种情况，可以指定&amp;quot;--delete-after&amp;quot;选项，或者
          直接指定文件名来排除将被删除的文件。

   --compare-dest=DIR
          该选项指示rsync使用目标主机上的DIR作为额外的层次结构，以便和传输中的文件做比较(如果目标目录中不存在basis file)。如果在DIR中发
          现了和sender端完全一致的文件，则该文件将不会传输到目标目录中。该选项在做稀疏备份时很有用，因为它仅备份从某一次更早的备份开始
          发生了改变的文件。(译者注：以备份目录为比较目录DIR，同步时将比较该目录中的文件，最终将仅传输发生了改变的文件到目标目录下)

          从rsync 2.6.4版本开始，可以通过多个&amp;quot;--compare-dest&amp;quot;选项提供多个比较目录，使得rsync可以按照为了精确匹配而指定的顺序来搜索列表。
          如果发现能匹配上但仅只有属性不同，将生成一个本地副本然后更新这些属性信息。如果未能匹配上，将选择DIRs中的basis file来提高传输
          速度。

          如果DIR是相对路径，它将是相对于目标目录的。见&amp;quot;--copy-dest&amp;quot;和&amp;quot;--link-dest&amp;quot;。

   --copy-dest=DIR
          该选项类似于&amp;quot;--compare-dest&amp;quot;，但rsync会从DIR中以本地拷贝的方式拷贝未改变的文件到目标目录中。

          可以通过多个&amp;quot;--copy-dest&amp;quot;选项提供多个DIR，使得rsync可以按照为了匹配未修改文件的顺序来搜索列表。如果未匹配上，则选择DIR中的basis
          file以尝试提高传输速度。

          如果DIR是相对路径，它将是相对于目标目录的。见&amp;quot;--copy-dest&amp;quot;和&amp;quot;--link-dest&amp;quot;。

   --link-dest=DIR
          This  option  behaves like --copy-dest, but unchanged files are hard linked from DIR to the destination directory.  The files must
          be identical in all preserved attributes (e.g. permissions, possibly ownership) in order for the files to be linked together.   An
          example:

            rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/


          If file’s aren’t linking, double-check their attributes.  Also check if some attributes are getting forced outside of rsync’s con‐
          trol, such a mount option that squishes root to a single user, or mounts a removable drive with generic ownership (such as OS  X’s
          &amp;quot;Ignore ownership on this volume&amp;quot; option).

          Beginning  in  version  2.6.4,  multiple --link-dest directories may be provided, which will cause rsync to search the list in the
          order specified for an exact match.  If a match is found that differs only in attributes, a local copy is made and the  attributes
          updated.  If a match is not found, a basis file from one of the DIRs will be selected to try to speed up the transfer.

          This option works best when copying into an empty destination hierarchy, as rsync treats existing files as definitive (so it never
          looks in the link-dest dirs when a destination file already exists), and as malleable (so it might change the attributes of a des‐
          tination file, which affects all the hard-linked versions).

          Note  that  if you combine this option with --ignore-times, rsync will not link any files together because it only links identical
          files together as a substitute for transferring the file, never as an additional check after the file is updated.

          If DIR is a relative path, it is relative to the destination directory.  See also --compare-dest and --copy-dest.

          Note that rsync versions prior to 2.6.1 had a bug that could prevent --link-dest from working properly for a  non-super-user  when
          -o was specified (or implied by -a).  You can work-around this bug by avoiding the -o option when sending to an old rsync.

   -z, --compress
          使用该选项，rsync将对发送给目标主机的文件数据(file data)进行压缩，这可以减少传输的数据量——在某些缓慢的连接中可能比较适用。

          注意，该选项一般情况下可以实现比通过远程shell压缩或传输过程压缩获得更好的压缩比，因为它利用了明确不通过连接发送的匹配数据块中
          的隐含信息。

          请通过&amp;quot;--skip-compress&amp;quot;选项确定不被压缩的默认文件后缀列表。

   --compress-level=NUM
          显式指定&amp;quot;--compress&amp;quot;的压缩级别。如果NUM为非零值，则该选项将隐含&amp;quot;--compress&amp;quot;选项。

   --skip-compress=LIST
          该选项通过指定后缀格式来决定哪些文件不被压缩。LIST的值为使用斜杠&amp;quot;/&amp;quot;分隔的一个或多个文件后缀(不包括点.)

          如果LIST指定的是空字符串，则表示压缩所有文件。

          支持简单的字符类匹配。所谓的字符类由中括号和写在中括号中的一系列的字母组成(例如：非特殊的字符类[abcz]，特殊的字符类[:alpha:]，
          注意，短横线&amp;quot;-&amp;quot;在此没有特殊的意义，仅表示一个简单的字符)。

          注意，字符&amp;quot;*&amp;quot;和&amp;quot;?&amp;quot;没有特殊的意义。

          例如此处示例指定了6个不压缩的后缀(因为其中一个规则mp[34]匹配了两种后缀)：

              --skip-compress=gz/jpg/mp[34]/7z/bz2


          默认不被压缩的后缀列表为：(不同版本的rsync可能会有些微改变)

          7z avi bz2 deb gz iso jpeg jpg mov mp3 mp4 ogg rpm tbz tgz z zip

          该后缀列表将会被&amp;quot;--skip-compress&amp;quot;选项指定的后缀列表覆盖，但有一种情况例外：以rsync daemon为源拷贝文件时，rsync将在不被压缩的
          文件列表中增加你指定的后缀文件(并且该文件列表可能会被配置为非默认情况)(译者注：也就是说，当从rsync daemon拷贝时，指定的压缩忽略
          后缀不是覆盖原压缩忽略列表，而是追加到原压缩忽略列表)。

   --numeric-ids
          使用该选项后，rsync将传输gid和uid，而不是字符格式的username和groupname然后将其映射到两端。

          默认情况下，rsync将使用用户名和组名来决定如何设置文件的所有者和所属组。但要注意，即使没有指定&amp;quot;--numeric-ids&amp;quot;选项，也绝不会通
          过字符格式的username和groupname来映射特殊的uid=0和gid=0。

          如果在源主机上的用户或组没有字符格式的名称(译者注：即只有uid和gid，没有username和groupname)，或者目标主机上没有相同的用户/组，
          则将使用uid/gid来设置所有权关系。请参看rsyncd.conf的man文档中关于&amp;quot;use chroot&amp;quot;的设置说明，以获取关于chroot设置后如何影响rsync对
          用户名和组名的查找能力以及你能对此做些什么。

   --timeout=TIMEOUT
          该选项设置的是最大IO超时时间，单位为秒。如果在指定时间内没有数据被传输，则rsync将直接退出。默认值为0表示永不超时。

   --contimeout
          该选项设置rsync成功连接rsync daemon的等待超时时间。如果在指定时间内未连接上rsync daemon，则rsync将以错误方式退出。

   --address
          默认当rsync连接rsync daemon时，rsync所使用的地址将会绑定到通配符地址上(译者注：默认通配符地址为0.0.0.0，即可以从任意接口的任意
          地址上向外发起连接)。使用该选项可以明确指定rsync要绑定的IP地址或主机名。请同样参见&amp;quot;--daemon&amp;quot;模式中&amp;quot;--address&amp;quot;选项获取详细信息。

   --port=PORT
          该选项可以显式指定一个要使用的tcp端口号而不是默认的873端口。该选项只能在连接rsync daemon时的双冒号(::)的语法格式中使用(因为URL
          rsync://user@host:port/语法本身就可以指定端口号，所以不需要该选项明确指定)。请同样参见&amp;quot;--daemon&amp;quot;模式中&amp;quot;--port&amp;quot;选项获取详细信息。

   --sockopts
          这个选项可以为希望最大程度地调整系统的人们提供无穷乐趣。你可以设置各种套接字选项使得传输速度更快(或更慢！)。关于该选项的可设
          置项请阅读setsockopt()系统调用的man文档。默认情况下，该选项没有设置任何值。该选项只影响使用套接字连接rsync daemon的情况。在
          &amp;quot;--daemon&amp;quot;模式中也有该选项。

   --blocking-io
          该选项告诉rsync在启动远程shell传输时使用阻塞I/O模型。如果远程shell为rsh或remsh，rsync默认会使用阻塞I/O，否则默认将使用非阻塞I/O
          模型。(注意，ssh更适合使用非阻塞I/O)

   -i, --itemize-changes
          请求输出一个明细列表，这个列表记录的是每个文件发生了哪些改变，包括属性的改变。它完全等价于&amp;quot;--out-format=&#39;%i %n%L&#39;&amp;quot;。如果重复
          该选项，未发生改变的文件也会被输出。

          因为几乎不用，所以不做翻译。

   --out-format=FORMAT
          该选项允许你自定义rsync client对每个更新过程产生输出的信息格式。指定的格式为&amp;quot;%&amp;quot;加一个单字符。如果指定了&amp;quot;-v&amp;quot;选项，则其默认的
          格式为&amp;quot;%n%L&amp;quot;(将输出文件名，如果是一个链接文件，则输出其指向的对象)。完整的格式列表，见rsyncd.conf的man文档中&amp;quot;log format&amp;quot;段落。

          指定&amp;quot;--out-format&amp;quot;是对每个文件、目录等都输出信息的。

          rsync将在文件传输之前输出这些信息，除非请求输出传输过程中的统计信息，这样它会在文件传输结束前输出信息，在这种情况下如果同时
          指定了&amp;quot;--progress&amp;quot;选项，rsync将会同时输出正在传输中的文件名。

   --log-file=FILE
          请求将输出信息记录到文件中。类似于&amp;quot;--out-format&amp;quot;。它可以指定记录client以及非daemon的server端的日志。如果在客户端的命令行上指定
          该选项，则默认格式为&amp;quot;%i %n%L&amp;quot;。以下是一个请求远端来记录日志的示例：

            rsync -av --rsync-path=&amp;quot;rsync --log-file=/tmp/rlog&amp;quot; src/ dest/

          该选项对于调试非预期的连接关闭比较有用。

   --log-file-format=FORMAT
          该选项指定要在&amp;quot;--log-file&amp;quot;文件中记录的日志格式(当然，需配合&amp;quot;--log-file&amp;quot;才生效)。如果FORMAT指定为空，将不会记录更新的文件信息。
          完整的格式列表，见rsyncd.conf的man文档中&amp;quot;log format&amp;quot;段落。

   --stats
          该选项让rsync打印文件传输过程中的详细统计数据，从中可以看出增量算法的效率如何。

          统计数据包括如下几项：

          o      Number of files是所有&amp;quot;文件&amp;quot;的数量总数，包含目录、字符链接等。

          o      Number of files transferred是普通文件通过rsync的增量传输算法更新的数据大小，它不包括创建的目录、字符链接等非文件数据。

          o      Total file size是传输中所有文件的总大小。该大小不会计算目录和特殊文件大小，但会包含字符链接的大小。

          o      Total transferred file size是所有已传输文件的总大小。

          o      Literal data是所有非匹配数据块的数据大小，即传输给receiver端的纯文件数据大小。

          o      Matched data是所有匹配块的数据总大小，即receiver端从basis file中拷贝的数据大小。

          o      File list size是sender发送给receiver端的文件列表大小。它比内存中文件列表的内容要小很多，因为sender将其传输给receiver端的时
                 候会将其进行压缩。

          o      File list generation time是sender创建文件列表消耗的时间，单位为秒。老版本的rysnc可能不会输出该项。

          o      File list transfer time是sender将文件列表发送给receiver端所消耗的时间，单位为秒。

          o      Total bytes sent是rsync从sender端传输给receiver端的所有数据大小，单位字节。(译者注：包括纯文件数据，信息数据等等非文件数据)

          o      Total  bytes  received是receiver端收到的所有非信息数据大小，单位字节。

   -8, --8-bit-output
          告诉rsync在输出信息中保留所有高位字符不进行转义。几乎用不上，所以不做翻译。

   -h, --human-readable
          以人类可读方式输出信息。如果只指定单个该选项，则K/M/G的转换单位为1000，指定多次，则转换单位为1024。

   --partial
          默认rsync在传输中断时会删除只传输了一部分不完整文件(partial file)。在某些环境下，可能希望保留这些已传输的部分。&amp;quot;--partial&amp;quot;选项
          告诉rsync保留这些部分，这可以使得下一次传输只传输剩余部分，从而加快传输速度。

   --partial-dir=DIR
          比直接使用&amp;quot;--partial&amp;quot;更好的做法是指定一个存放不完整数据(partial file)的目录DIR，下次再传输时，rsync将使用一个文件来寻找到该DIR
          中的文件，以便提高传输速率，当数据真正传输完整且传输真正完成后，该DIR将被删除。

          注意，如果指定了&amp;quot;--whole-file&amp;quot;选项(后者隐含了该选项)，则所有的&amp;quot;partial-dir&amp;quot;中正在更新的文件都会被删除，因为rsync此时没有使用
          增量传输算法来传输文件。

          rsync如果发现DIR不存在，则自动创建(但不是递归创建整个目录路径)，这使得rsync在需要时能更方便地使用相对路径在文件所在目录下直接
          创建partial-dir(例如&amp;quot;--partial-dir=.rsync-partial&amp;quot;)，并且在partial file被删除时自动移除该目录。

          如果partial-dir的值不是一个绝对路径，rsync将在所有的exclude规则的尾部追加一个exclude规则，用于防止partial file已经存在于sender
          端，也能防止receiver端过早删除partial file。例如：&amp;quot;--partial-dir&amp;quot;将在其他筛选规则的尾部添加一个等价于&amp;quot;-f &#39;P .rsync-partial/&#39;&amp;quot;
          的规则。

          如果你正在使用自定义的exclude规则，你可能需要在你的exclude/hide/protect规则中添加partial-dir相关的条目，因为(1)向其他规则的尾部
          自动添加规则的行为可能会失效(2)你可能希望覆盖rsync的排除选择。例如，如果你想让rsync清除被随意乱放置的剩余partial file，需要指
          定&amp;quot;--delete-after&amp;quot;并且添加一条&amp;quot;risk&amp;quot;筛选规则，如&amp;quot;-f &#39;R .rsync-partial/&#39;&amp;quot;(不要使用&amp;quot;--delete-before&amp;quot;或&amp;quot;--delete-during&amp;quot;，除非你不想
          让rsync使用剩余的partial file来完成此次传输)。

          重要：&amp;quot;--partial-dir&amp;quot;目录不能让其他用户可写，否则它有安全隐患。例如避免使用&amp;quot;/tmp&amp;quot;。

          你也可以通过环境变量&amp;quot;RSYNC_PARTIAL_DIR&amp;quot;来设置partial-dir的值。设置该环境变量不会强制开启&amp;quot;--partial&amp;quot;，但在指定了&amp;quot;--partial&amp;quot;时会
          影响它的partial-dir路径。例如，不再让&amp;quot;-partial-dir=.rsync-tmp&amp;quot;随同&amp;quot;--progress&amp;quot;一起使用，而是设置&amp;quot;RSYNC_PARTIAL_DIR=.rsync-tmp&amp;quot;，
          然后只需使用&amp;quot;-P&amp;quot;选项来应用&amp;quot;.rsync-tmp&amp;quot;目录以完成partial传输。只有在以下情况下&amp;quot;--partial&amp;quot;不会查找该环境变量的值：(1)使用了选项
          &amp;quot;--inplace&amp;quot;(因为&amp;quot;--inplace&amp;quot;和&amp;quot;--partial-dir&amp;quot;选项冲突)(2)使用了选项&amp;quot;--delay-updates&amp;quot;(见下文)。

   --delay-updates
          该选项将receiver端每个重组的临时文件保留在某个目录中，直到传输结束之前才一次性将它们全部重命名为各自对应的目标文件。这样的
          行为使得所有文件的更新更具有原子性(译者注：如果你了解数据库事务，就知道原子性是什么意思，最直白地说，具有原子性表示要么全部
          成功，要么全部失败，所以这里更新具有原子性表示要么全部更新成功，要么全部更新失败，但由于重命名覆盖目标文件后是不可回滚的，所
          以这里的原子性并不是那么的严格)。默认情况下，这些临时文件将放在每个目标文件所在目录下的&amp;quot;.~tmp~&amp;quot;子目录下，但如果指定了选项
          &amp;quot;--partial-dir&amp;quot;，那么将使用该选项指定的目录。请参见&amp;quot;--partial-dir&amp;quot;选项获取相关信息。该选项和&amp;quot;--inplace&amp;quot;以及&amp;quot;--append&amp;quot;选项冲突。

          该选项使得receiver端使用更多的内存空间，并且需要更多的磁盘空间以存储额外的目标文件副本。需要注意，&amp;quot;--partial-dir&amp;quot;不能使用绝对
          路径，除非你能保证传输中的文件没有同名文件(因为如果使用了绝对路径，所有的临时文件都放在那一个目录下，重名文件会先后覆盖)，且
          在目录层次结构中没有挂载点(因为如果无法重命名到指定路径下，延迟更新将失败)

   -m, --prune-empty-dirs
          该选项告诉receiver端的rsync从文件列表中删除空目录，包括那些没有文件的空的嵌套目录。这对于避免创建一堆无用的目录很有用，例如在
          sender端使用include/exclude/filter规则扫描递归层次时会创建所有层次的目录。

          注意传输规则(如&amp;quot;--min-size&amp;quot;)不会影响文件进入文件列表，因此不会让目录成为空目录，即使目录中没有任何文件可以匹配上传输规则。


          由于该选项会修剪file list，所以会影响delete对目录的删除行为。但请记住，exclude排除的文件和目录可以防止现有条目被删除，因为排除
          规则即隐藏了源文件，又保护了目标文件。

          可以使用全局&amp;quot;protect&amp;quot;筛选规则防止file list中的某个特定目录被修剪。例如，下面的选项可以保证目录&amp;quot;emptydir&amp;quot;仍然保留在file list中：

          --filter ’protect emptydir/’

          以下的示例可以从一个层次结构中拷贝其中所有的.pdf文件，并且只在目标主机上创建必要的目录来存放这些.pdf文件，并会移除目标上所有
          多余文件和目录(注意此处使用了非目录文件的hide筛选规则替代exclude规则)：

          rsync -avm --del --include=’*.pdf’ -f ’hide,! */’ src/ dest

          如果不想删除目标主机上多余的文件，可以使用更古老的选项&amp;quot;--include=&#39;*/&#39; --exclude=&#39;*&#39;&amp;quot;替代hide筛选规则，不过你不一定能适应它，毕竟
          它是古老的选项。

   --progress
          该选项告诉rsync显示传输进度信息，这是给那些无聊的用户看的(译者注：写此文档的作者还真是调皮，竟然这么直白)。该选项隐含&amp;quot;--verbose&amp;quot;
          选项。

          如果rsync正在传输的是一个普通文件，将以下面格式显示进度信息：

                782448  63%  110.64kB/s    0:00:04

          在此例中，receiver重组了sender发送的文件的782448字节的数据或者说重组了该文件的63%(译者注：此处的意思是这些数据是文件的纯数据，
          不包括那些非文件信息类数据)，且以110.64kB/s的速率重建文件，如果保持该速率，该文件将在4秒后重建完成。

          如果使用的是rsync的增量拷贝算法，那么这些统计数据可能会误导用户。例如，如果sender的文件由basis file和另一段放在basis file前面
          的数据组成，那么当reciever在获取纯文件数据时，此处所显示的速率值会急剧下降，而且要完成传输可能会比估计的时间更长，因为它还要
          处理匹配的数据块部分。(译者注：换句话说，该进度信息是sender发送的纯数据相关信息，和真正完成同步的进度没有直接关系)              

          当文件传输完成，rsync将使用总结性的行替代进度信息，类似格式如下：

               1238099 100%  146.38kB/s    0:00:08  (xfer#5, to-check=169/396)

          此示例中，文件大小为1238099字节，整体传输平均速率是146.38kB/s，总共消耗了8秒才传输完成。&amp;quot;xfer#5&amp;quot;表示此文件是该rsync会话期间第
          5个传输的文件，&amp;quot;to-check=169/396&amp;quot;表示此次传输的文件列表中共要检查396个文件，其中有169个文件待检查以确定它们是否需要传输。
          (译者注：可以认为396是某些文件被排除后待考虑是否传输的总文件数，196则是还剩下196个文件还未检查)

   -P     该选项等价于&amp;quot;--partial --progess&amp;quot;选项。指定这两个选项的目的是为了让某一次可能会中断的较长传输过程变得更简单。

   --password-file
          该选项让rsync在连接rsync daemon时从密码文件中获取密码。密码文件必须可读。该文件中只有第一行是rsync将读取的密码，其他所有行都自
          动忽略。

          该选项无法为远程shell(如ssh)提供密码，至于如何为远程shell提供密码，参考对应远程shell的文档(译者注：对于ssh而言，使用公钥认证机
          制即可)。当使用远程shell访问rsync daemon时，该选项只有完成了远程shell的身份验证过程才生效。

   --list-only
          该选项强制rsync仅列出源路径的文件列表而不是进行文件传输。如果rsync命令行中只给出了一个地址，将隐含该选项。注意通配符会被shell
          解析并扩展为rsync的参数。例如：

              rsync -av --list-only foo* dest/

   --bwlimit=KBPS
          该选项对rsync的传输最大速度进行限速。该限制值是一个平均值，所以在实际传输过程中可能会短暂的超出该限制值。设置为0则表示不限速。

   --write-batch=FILE
          记录一个稍后被&amp;quot;--read-batch&amp;quot;读取的文件，该文件可被用于另一个完全一致的目标路径。详细信息见&amp;quot;批处理模式&amp;quot;段落信息。

          (译者注：通俗地说，就是将源和目标的不同点记录下来保存在FILE中，然后通过&amp;quot;--read-batch&amp;quot;读取这些不同点并更新目标文件，如果有多台
          目标主机上的文件情况是完全一致的，则可以通过此FILE一次性应用于所有这些主机，因此称之为&amp;quot;批处理模式&amp;quot;。注意，FILE中不仅记录了不
          同之处，还记录了将要应用于目标主机的数据部分，因此它是一个&amp;quot;信息+数据&amp;quot;文件而不仅仅只是小小的信息文件)

   --only-write-batch=FILE
          和&amp;quot;--write-batch&amp;quot;工作方式类似，区别是当生成batch file的时候不会对目标路径做任何操作。这使得你可以通过某些方法将所发生改变的信
          息传输到目标系统上，然后通过&amp;quot;--read-batch&amp;quot;应用这些改变。

          可以直接将批处理文件FILE保存到任意的移动存储设备中。

          注意，只有向远程主机推送这些改变时才能节省带宽，因为这样可以让sender端的数据分流记录到FILE中，而无需通过连接传输给receiver端。
          (如果是拉取数据，则sender端为remote，因此无法写批处理文件FILE)


   --read-batch=FILE
          读取所有通过&amp;quot;--write-batch&amp;quot;生成的批处理文件FILE并通过其中的&amp;quot;信息+数据&amp;quot;应用于目标主机。如果FILE未&amp;quot;-&amp;quot;，则批处理数据将从标准输入
          中读取。  

   --protocol=NUM
          强制指定要使用的协议版本。一般只在创建批处理文件以兼容老版本的rsync时可能会用上，因此不做翻译。

   --iconv=CONVERT_SPEC
          rsync可以在不同字符集间转换文件名。基本用不会上，因此不做翻译。

   -4, --ipv4 or -6, --ipv6
          限制rsync使用ipv4还是ipv6创建套接字。该选项由于明确表示了要用网络套接字，也就限制了只有连接rsync daemon时才生效。

          如果编译rsync时没有将ipv6的功能编译进去，则&amp;quot;--ipv6&amp;quot;无效。通过&amp;quot;--version&amp;quot;的输出结果可以知道是否编译了ipv6功能。

   --checksum-seed=NUM
          指定checksum的种子长度。默认种子长度为4字节，应用于每个数据块级和文件级checksum的计算。默认checksum的种子由server和其默认的当
          前系统时间time()计算生成。该选项显示指定特定的checksum种子，对应想要重复计算块级或文件级checksum时或者用户想要一个更具随机性
          的checksum种子时比较有用。设置NUM为0将导致rsync使用默认的time()来计算种子。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DAEMON OPTIONS
       当启动rsync daemon时，可以指定以下几个选项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   --daemon
          该选项告诉rsync以daemon方式运行。可以在client端使用host::module or rsync://host/module/格式的命令来访问daemon。

          如果标准输入是一个套接字，则rsync被认为是通过inetd方式运行的，否则它将从当前终端上分离出来并成为后台守护进程。每次和daemon进行
          连接时，daemon都会读取配置文件(rsyncd.conf)并给出对应的相应。更详细信息见rsyncd.conf的man文档。

   --address
          rsync daemon的绑定地址，默认会绑定在通配地址上(默认为0.0.0.0)。使用&amp;quot;--address&amp;quot;选项可以显式指定要绑定的IP地址或主机。可以配合
          &amp;quot;--config&amp;quot;一起使用来实现rsync虚拟主机的功能。更多信息见rsyncd.conf的man文档中&amp;quot;address&amp;quot;段落说明。

   --bwlimit=KBPS
          该选项对rsync的传输最大速度进行限速。该限制值是一个平均值，所以在实际传输过程中可能会短暂的超出该限制值。设置为0则表示不限速。

   --config=FILE
          该选项用于指定额外的配置文件来代替默认的配置文件，只有和&amp;quot;--daemon&amp;quot;选项同时使用时才有效。默认daemon的配置文件为/etc/rsyncd.conf，
          除非是通过远程shell启动的临时daemon，使用远程shell连接的daemon的默认配置文件是当前目录(一般是$HOME)下的rsyncd.conf。

   --no-detach
          当以daemon形式运行时，该选项表示rsync不从终端中将自己分离出来，所以工作在前台。在各种daemon管理工具如daemontools、systemd上需要
          使用。如果rsync是由sshd或inetd派生出来的话，则该选项无效。

   --port=PORT
          指定daemon的监听端口，默认为873。

   --log-file=FILE
          该选项告诉rsync daemon使用此处指定的日志文件替代配置文件中&amp;quot;log file&amp;quot;指定的日志文件。

   --log-file-format=FORMAT
          该选项告诉rsync daemon使用此处指定的日志格式而不是配置文件中&amp;quot;log format&amp;quot;指定的日志格式。该选项会自动开启&amp;quot;transfer logging&amp;quot;，除非
          它的值为空，因为这样表示关闭transfer logging功能。

   --sockopts
          指定套接字选项，将覆盖配置文件配置的套接字选项。

   -v, --verbose
          该选项输出rsync daemon启动时的详细信息。它不控制客户端和daemon连接时的信息详细程度，因为这些信息详细程度是由client和模块配置段
          中的&amp;quot;max verbosity&amp;quot;控制的。

   -4, --ipv4 or -6, --ipv6
          告诉rsync使用IPV4还是IPV6创建套接字，然后rsync daemon将监听在对应的地址类型上。

          如果编译rsync时没有将ipv6的功能编译进去，则&amp;quot;--ipv6&amp;quot;无效。通过&amp;quot;--version&amp;quot;的输出结果可以知道是否编译了ipv6功能。

   -h, --help
          如果该选项指定在&amp;quot;--daemon&amp;quot;选项之后，则输出rsync daemon可用选项的简短帮助信息。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FILTER RULES&lt;/p&gt;

&lt;p&gt;(译者注：下面筛选规则的内容很多地方都提到了&amp;rdquo;传输中根目录&amp;rdquo;(transfer-root)的概念，所以提前在此做个解释。
    假设执行rsync -r /www/lvm /www/audit remote_host:/path命令，则待传输的目录lvm和audit称为传输过程中的根目录，即顶级目录)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   筛选规则可以弹性定义哪些文件需要传输(include)(译者注：前文中出现的传输规则指的就是include规则)，以及哪些文件需要跳过(exclude)。这些
   规则要么直接指定include/exclude匹配模式，要么指定一种方式从中获取include/exclude匹配模式(例如从文件中读取规则)。

   对于已经创建好的file list中的文件或目录，rsync会按先后顺序对其中的每一个名称检查是否能匹配incluee/exclude规，且先匹配上的规则生效：
   如果能匹配上exclude规则，则该文件被跳过，如果该文件能匹配include或不能匹配任何规则，则不挑过该文件。

   rsync会按照命令行中指定的筛选规则建立一个有序的规则列表。筛选规则语法如下：

          RULE [PATTERN_OR_FILENAME]
          RULE,MODIFIERS [PATTERN_OR_FILENAME]

   你可以选择使用下面所描述的长格式或短格式的RULE名称。如果使用短格式命名的的rule，则分隔RULE和MODIFIERS中间的&amp;quot;,&amp;quot;是可选的。其后的PATTERN
   或FILENAME必须跟在单个空格或下划线(_)之后。以下是规则前缀：

          exclude, - 指定排除规则。
          include, + 指定包含规则。
          merge, . 指定一个从中读取更多规则的merge-file。
          dir-merge, : 指定一个每目录的merge-file。
          hide, H 指定传输过程中需要隐藏的文件。(译者注：exclude的本质就是hide，该类型的规则显然只作用于sender端，下面的&amp;quot;S&amp;quot;同样如此)
          show, S 指定不被隐藏的文件。         (译者注：include的本质就是show)
          protect, P 指定保护文件不被删除的规则。
          (译者注：--delete和--exclude同时使用时，会对被排除的文件加上保护规则。该类型的规则显然只作用于receiver端，下面的&amp;quot;R&amp;quot;同样如此)
          risk, R 指定不被保护的文件，即能被删除的文件。(译者注：&amp;quot;--delete-excluded&amp;quot;就是将被保护的文件强制取消保护)
          clear, ! 清空当前include/exclude规则列表。 (不带任何参数)

   如果是从一个文件中读取规则，将忽略空行以及使用&amp;quot;#&amp;quot;开头的注释行。

   注意，使用了&amp;quot;--include&amp;quot;或&amp;quot;--exclude&amp;quot;选项后，将不再解析上述所说的规则序列，只允许使用&amp;quot;!&amp;quot;表示清空include/exclude规则。如果匹配模式不是
   使用&amp;quot;- &amp;quot;(减号加一个空格)或&amp;quot;+ &amp;quot;(加号加一个空格)开头，则规则将被认为是在字符串的前面加了&amp;quot;+ &amp;quot;(即包含规则)或&amp;quot;- &amp;quot;(即排除规则)前缀。实际上
   &amp;quot;--filter&amp;quot;选项的规则字符串中必须在字符串开头包含短名称或长名称的规则。

   同时需要注意的是，每个&amp;quot;--filter&amp;quot;、&amp;quot;--include&amp;quot;以及&amp;quot;--exclude&amp;quot;选项都只表示一条规则，如果要使用多条规则，你可以重复使用这些选项，或者使
   用&amp;quot;--filter&amp;quot;选项的merge-file语法，又或者是&amp;quot;--include-from&amp;quot;、&amp;quot;--exclude-from&amp;quot;选项。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;INCLUDE/EXCLUDE PATTERN RULES
       你可以使用&amp;rdquo;+&amp;ldquo;、&amp;rdquo;-&amp;ldquo;等规则名称来指定包含和排除文件的规则，以及其他的规则。每个include/exclude规则都会对应一个匹配模式用于匹配将要传输
       的文件名。匹配模式有以下几种格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   o      如果匹配模式以斜线(/)开头，它表示锚定层次结构中某个特定位置的文件，否则将表示匹配路径名的结尾。这有点类似于正则表达式中的行首
          &amp;quot;^&amp;quot;。因此&amp;quot;/foo&amp;quot;匹配的是&amp;quot;传输中根目录&amp;quot;(transfer-root)下的&amp;quot;foo&amp;quot;文件，或者是merge-file目录中的&amp;quot;foo&amp;quot;文件。对于不做限制的&amp;quot;foo&amp;quot;匹配模
          式，由于算法会从顶部开始向下逐层递归，所以它能匹配任意位置名为&amp;quot;foo&amp;quot;的文件。但是对于非锚定的&amp;quot;sub/foo&amp;quot;模式，将匹配层次结构中位于
          sub目录下的foo。对于如何指定匹配根&amp;quot;/&amp;quot;的模式见&amp;quot;ANCHORING INCLUDE/EXCLUDE PATTERNS&amp;quot;的段落说明。

   o      如果匹配模式以斜线(/)结尾，将只匹配目录，而不匹配普通文件、字符链接以及设备文件。

   o      rsync通过检查匹配模式中是否包含&amp;quot;*&amp;quot;、&amp;quot;?&amp;quot;以及&amp;quot;[&amp;quot;符号来决定是做简单的字符串匹配还是通配符匹配。

   o      单个&amp;quot;*&amp;quot;匹配任意路径元素，但在遇到斜线时终止匹配。

   o      &amp;quot;**&amp;quot;匹配任意路径元素，与&amp;quot;*&amp;quot;不同的是，它能匹配斜线。

   o      &amp;quot;?&amp;quot;匹配任意非斜线的单个字符。

   o      &amp;quot;[&amp;quot;表示字符类匹配，例如&amp;quot;[a-z]&amp;quot;，[[:alpha:]]。

   o      在通配匹配模式中，反斜线(\)可以对通配符号进行转义，但如果不是对通配符号使用反斜线，则它仅仅只是一个普通的反斜线字符。

   o      如果匹配模式中包含了一个&amp;quot;/&amp;quot;(不包括以斜线结尾的情况)或&amp;quot;**&amp;quot;，则表示对包括前导目录的全路径进行匹配。如果匹配模式中不包括&amp;quot;/&amp;quot;或&amp;quot;**&amp;quot;，
          则表示只对全路径尾部的路径元素进行匹配。(注意：使用了递归功能时，&amp;quot;全路径&amp;quot;可能是从最顶端开始向下递归的某中间一段路径)。

   o      对于&amp;quot;dir_name/***&amp;quot;来说，它将匹配dir_name下的所有层次的文件。

   注意，当使用&amp;quot;--recursive&amp;quot;(-r)选项(-a隐含该选项)时，每个子路径元素会自顶向下逐层被访问，因此include/exclude匹配模式会对每个子路径元素
   的全路径名进行递归(例如，要包含&amp;quot;/foo/bar/baz&amp;quot;，则&amp;quot;/foo&amp;quot;和&amp;quot;/foo/bar&amp;quot;必须不能被排除)。实际上，排除匹配模式在发现有文件要传输时，此文件
   所在目录层次的排除遍历会被短路。如果排除了某个父目录，则更深层次的include模式匹配将无效，因为rsync从排除的那个父目录位置开始不会再
   向下遍历。这在使用尾随&amp;quot;*&amp;quot;时尤为重要。例如，下面的例子不会正常工作：

          + /some/path/this-file-will-not-be-found
          + /file-is-included
          - *

   由于父目录&amp;quot;some&amp;quot;被规则&amp;quot;*&amp;quot;所排除，所以会失败，rsync绝不会访问&amp;quot;some&amp;quot;或&amp;quot;some/path&amp;quot;中的任何文件。一种解决方式是请求包含层次结构中的所有目
   录，只需使用一个规则&amp;quot;+ */&amp;quot;(需放在&amp;quot;- *&amp;quot;规则的前面)即可，可能还需要使用&amp;quot;--prune-empty-dirs&amp;quot;选项。另一解决方式是为所有需要被访问的父目录
   增加特定包含规则。例如，下面的规则可以正常工作：

          + /some/
          + /some/path/
          + /some/path/this-file-is-found
          + /file-also-included
          - *

   以下是一些exclude/include规则匹配模式：

   o      &amp;quot;- *.o&amp;quot;将排除所有文件名能匹配&amp;quot;*.o&amp;quot;的文件。

   o      &amp;quot;- /foo&amp;quot;将排除&amp;quot;传输中根目录&amp;quot;(transfer-root)下名为&amp;quot;foo&amp;quot;的文件或目录。

   o      &amp;quot;- foo/&amp;quot;将排除所有名为&amp;quot;foo&amp;quot;的目录。

   o      &amp;quot;- /foo/*/bar&amp;quot;将排除&amp;quot;传输中根目录&amp;quot;(transfer-root)下&amp;quot;foo&amp;quot;目录再向下两层的&amp;quot;bar&amp;quot;文件。

   o      &amp;quot;- /foo/**/bar&amp;quot;将排除transfer-root下&amp;quot;foo&amp;quot;目录再向下递归任意层次后名为&amp;quot;bar&amp;quot;的文件。(译者注：&amp;quot;**&amp;quot;匹配任意多个层次的目录)

   o      同时使用&amp;quot;+  */&amp;quot;、&amp;quot;+ *.c&amp;quot;和&amp;quot;- *&amp;quot;，将只包含所有目录和C源码文件，除此之外的所有文件和目录都被排除。(参见选项&amp;quot;--prune-empty-dirs&amp;quot;)

   o      同时使用&amp;quot;+ foo/&amp;quot;、&amp;quot;+ foo/bar.c&amp;quot;和&amp;quot;- *&amp;quot;将只包含&amp;quot;foo&amp;quot;目录和&amp;quot;foo/bar.c&amp;quot;。(&amp;quot;foo&amp;quot;目录必须显式包含，否则将被排除规则&amp;quot;- *&amp;quot;排除掉)

   以下是&amp;quot;+&amp;quot;或&amp;quot;-&amp;quot;后可接的修饰符：

   o      &amp;quot;/&amp;quot;指定include/exclude规则需要与当前条目的绝对路径进行匹配。例如，&amp;quot;-/ /etc/passwd&amp;quot;将在任意传输/etc目录中文件时刻都排除passwd文
          件。而对于&amp;quot;-/ subdir/foo&amp;quot;规则，当传输&amp;quot;subdir&amp;quot;目录中文件时，将总是排除&amp;quot;foo&amp;quot;文件，即使&amp;quot;foo&amp;quot;文件可能是在transfer-root中的。

   o      &amp;quot;!&amp;quot;指定如果模式匹配失败，则include/exclude规则生效。例如，&amp;quot;-! */&amp;quot;将排除所有非目录文件。(译者注：反向匹配的意思，&amp;quot;- */&amp;quot;规则是排
          除所有目录，那些非目录文件就匹配不上，加上&amp;quot;!&amp;quot;，即&amp;quot;-! */&amp;quot;，则表示匹配不上的这些非目录文件被匹配上)

   o      &amp;quot;C&amp;quot;表示将所有的全局CVS排除规则插入到普通排除规则中，而不再使用&amp;quot;-C&amp;quot;选项来插入。其后不能再接其他参数。

   o      &amp;quot;s&amp;quot;表示规则只应用于sender端。当某规则作用于sender端时，它可以防止文件被传输。默认情况下，所有规则都会作用于两端，除非使用了
          &amp;quot;--delete-exclude&amp;quot;选项，这样规则将只作用于sender端。请参见&amp;quot;hide&amp;quot;(H)和&amp;quot;show&amp;quot;(S)规则，这是指定sender端include/exclude规则的另一种
          方式。

   o      &amp;quot;r&amp;quot;表示规则只应用于receiver端。当规则作用于receiver端，它可以防止文件被删除。更多信息见上面的&amp;quot;s&amp;quot;修饰符。另请参见&amp;quot;P&amp;quot;和&amp;quot;R&amp;quot;规则，
          它们是指定receiver端include/exclude规则的另一种方式。

   o      &amp;quot;p&amp;quot;表示此规则是易过期的，这意味着将忽略正在被删除的目录。例如，&amp;quot;-C&amp;quot;选项的默认规则是以CVS风格进行排除，且&amp;quot;*.o&amp;quot;文件会被标记为
          易过期，这将不会阻止在源端移除的目录在目标端上被删除(译者注：也就是说在源端删除的目录在目标端上也会被删除。以下是原文，翻译
          也许有误)。
          A p indicates that a rule is perishable, meaning that it is ignored in directories that are being deleted.  For instance,  the  -C
          option’s  default  rules  that exclude things like &amp;quot;CVS&amp;quot; and &amp;quot;*.o&amp;quot; are marked as perishable, and will not prevent a directory that
          was removed on the source from being deleted on the destination.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MERGE-FILE FILTER RULES
       你可以通过指定&amp;rdquo;.&amp;ldquo;将某文件中的规则合并在规则集合中，或指定&amp;rdquo;:&amp;ldquo;(dir-merge)将目录下文件中的规则合并在规则集合中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   有两种合并文件的方式：单实例合并&amp;quot;.&amp;quot;和每目录合并&amp;quot;:&amp;quot;。单实例合并文件仅读取一次，其中的规则被合并到筛选列表中替代&amp;quot;.&amp;quot;所代表的规则。对于
   每目录合并文件，rsync将扫描每个目录以遍历指定名称的规则文件，并合并规则文件中的内容到当前规则列表中。每目录合并的规则文件必须创建在
   sender端，因为会扫描sender端来决定哪些文件要被传输。如果想让规则文件作用于receiver端不想被删除的文件，则需要将规则文件传输到receiver
   端(见下面的&amp;quot;PER-DIRECTORY RULES AND DELETE&amp;quot;)。

   一些示例：

          merge /etc/rsync/default.rules
          . /etc/rsync/default.rules
          dir-merge .per-dir-filter
          dir-merge,n- .non-inherited-per-dir-excludes
          :n- .non-inherited-per-dir-excludes

   以下是单实例合并&amp;quot;.&amp;quot;和每目录合并&amp;quot;:&amp;quot;后可接的修饰符：

   o      &amp;quot;-&amp;quot;表示规则文件中只有exclude规则，可以在文件中使用注释行。

   o      &amp;quot;+&amp;quot;表示规则文件中只有include规则，可以在文件中使用注释行。

   o      &amp;quot;C&amp;quot;指定的是CVS分格的规则。它将会开启&amp;quot;n&amp;quot;、&amp;quot;w&amp;quot;和&amp;quot;-&amp;quot;，也允许指定规则列表清空修饰符&amp;quot;!&amp;quot;。若不提供任何文件名，则默认为&amp;quot;.cvsignore&amp;quot;。

   o      &amp;quot;e&amp;quot;表示排除合并文件使其不被传输。例如&amp;quot;dir-merge,e .rules&amp;quot;等价于&amp;quot;dir-merge .rules&amp;quot;+&amp;quot;- .rules&amp;quot;。

   o      &amp;quot;n&amp;quot;表示规则不被子目录继承。

   o      &amp;quot;w&amp;quot;表示规则是使用空白符号分隔的而不是默认的换行符。显然，这种方式下合并文件中不能使用注释行。
          注意：分隔规则前缀的空格是有特殊意义的，例如&amp;quot;- foo + bar&amp;quot;会被解析为两条规则。

   o      此外，你可能还需要指定上文所述的&amp;quot;+&amp;quot;、&amp;quot;-&amp;quot;规则的修饰符，以便对这些从文件中读取的规则具有修饰符集(除了&amp;quot;!&amp;quot;修饰符)。例如
          &amp;quot;merge,-/ .excl&amp;quot;将把&amp;quot;.excl&amp;quot;文件中的内容视为绝对路径排除，而&amp;quot;dir-merge,s .filt&amp;quot;和&amp;quot;:sC&amp;quot;都将使得所有每目录规则仅作用于sender端。

  Per-directory rules are inherited in all subdirectories of the directory where the merge-file was found unless the &#39;n&#39; modifier was used.
  Each subdirectory&#39;s rules are prefixed to the inherited per-directory rules from its parents, which gives the newest rules a higher priority
  than the inherited rules. The entire set of dir-merge rules are grouped together in the spot where the merge-file was specified, so it is
  possible to override dir-merge rules via a rule that got specified earlier in the list of global rules. When the list-clearing rule (&amp;quot;!&amp;quot;) is
  read from a per-directory file, it only clears the inherited rules for the current merge file.

  Another way to prevent a single rule from a dir-merge file from being inherited is to anchor it with a leading slash. Anchored rules
  in a per-directory merge-file are relative to the merge-file&#39;s directory, so a pattern &amp;quot;/foo&amp;quot; would only match the file &amp;quot;foo&amp;quot; in the directory
  where the dir-merge filter file was found.

  Here&#39;s an example filter file which you&#39;d specify via --filter=&amp;quot;. file&amp;quot;:

     merge /home/user/.global-filter
     - *.gz
     dir-merge .rules
     + *.[ch]
     - *.o

   This will merge the contents of the /home/user/.global-filter file at the start of the list and also turns the &amp;quot;.rules&amp;quot; filename into a
   per-directory filter file. All rules read in prior to the start of the directory scan follow the global anchoring rules (i.e. a leading slash
   matches at the root of the transfer).

   If  a  per-directory  merge-file is specified with a path that is a parent directory of the first transfer directory, rsync will scan all
   the parent dirs from that starting point to the transfer directory for the indicated per-directory file.  For instance, here is a  common
   filter (see -F):

          --filter=&#39;: /.rsync-filter&#39;


   That rule tells rsync to scan for the file .rsync-filter in all directories from the root down through the parent directory of the trans‐
   fer prior to the start of the normal directory scan of the file in the directories that are sent as a part of the transfer.   (Note:  for
   an rsync daemon, the root is always the same as the module’s &amp;quot;path&amp;quot;.)

   Some examples of this pre-scanning for per-directory files:

          rsync -avF /src/path/ /dest/dir
          rsync -av --filter=&#39;: ../../.rsync-filter&#39; /src/path/ /dest/dir
          rsync -av --filter=&#39;: .rsync-filter&#39; /src/path/ /dest/dir


   The  first  two  commands  above  will  look  for &amp;quot;.rsync-filter&amp;quot; in &amp;quot;/&amp;quot; and &amp;quot;/src&amp;quot; before the normal scan begins looking for the file in
   &amp;quot;/src/path&amp;quot; and its subdirectories.  The last command avoids the parent-dir scan and only looks for the  &amp;quot;.rsync-filter&amp;quot;  files  in  each
   directory that is a part of the transfer.

   If  you  want  to include the contents of a &amp;quot;.cvsignore&amp;quot; in your patterns, you should use the rule &amp;quot;:C&amp;quot;, which creates a dir-merge of the
   .cvsignore file, but parsed in a CVS-compatible manner.  You can use this to affect where the --cvs-exclude (-C)  option’s  inclusion  of
   the  per-directory .cvsignore file gets placed into your rules by putting the &amp;quot;:C&amp;quot; wherever you like in your filter rules.  Without this,
   rsync would add the dir-merge rule for the .cvsignore file at the end of all your other rules (giving it a lower priority than your  com‐
   mand-line rules).  For example:

          cat &amp;lt;&amp;lt;EOT | rsync -avC --filter=&#39;. -&#39; a/ b
          + foo.o
          :C
          - *.old
          EOT
          rsync -avC --include=foo.o -f :C --exclude=&#39;*.old&#39; a/ b


   Both  of  the  above  rsync commands are identical.  Each one will merge all the per-directory .cvsignore rules in the middle of the list
   rather than at the end.  This allows their dir-specific rules to supersede the rules that follow the :C instead of being  subservient  to
   all  your  rules.   To affect the other CVS exclude rules (i.e. the default list of exclusions, the contents of $HOME/.cvsignore, and the
   value of $CVSIGNORE) you should omit the -C command-line option and instead insert a &amp;quot;-C&amp;quot; rule  into  your  filter  rules;  e.g.  &amp;quot;--fil‐
   ter=-C&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LIST-CLEARING FILTER RULE(清空筛选规则列表)
       You can clear the current include/exclude list by using the &amp;ldquo;!&amp;rdquo; filter rule (as introduced in the FILTER RULES section above).  The &amp;ldquo;cur‐
       rent&amp;rdquo; list is either the global list of rules (if the rule is encountered while parsing the filter options) or  a  set  of  per-directory
       rules (which are inherited in their own sub-list, so a subdirectory can use this to clear out the parent’s rules).&lt;/p&gt;

&lt;p&gt;ANCHORING INCLUDE/EXCLUDE PATTERNS(INCLUDE/EXCULDE匹配模式的锚定行为)
       As  mentioned  earlier, global include/exclude patterns are anchored at the &amp;ldquo;root of the transfer&amp;rdquo; (as opposed to per-directory patterns,
       which are anchored at the merge-file’s directory).  If you think of the transfer as a subtree of names that are being sent from sender to
       receiver,  the  transfer-root  is  where the tree starts to be duplicated in the destination directory.  This root governs where patterns
       that start with a / match.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Because the matching is relative to the transfer-root, changing the trailing slash on a source path or changing your use of  the  --rela‐
   tive  option  affects  the  path you need to use in your matching (in addition to changing how much of the file tree is duplicated on the
   destination host).  The following examples demonstrate this.

   Let’s say that we want to match  two  source  files,  one  with  an  absolute  path  of  &amp;quot;/home/me/foo/bar&amp;quot;,  and  one  with  a  path  of
   &amp;quot;/home/you/bar/baz&amp;quot;.  Here is how the various command choices differ for a 2-source transfer:

          Example cmd: rsync -a /home/me /home/you /dest
          +/- pattern: /me/foo/bar
          +/- pattern: /you/bar/baz
          Target file: /dest/me/foo/bar
          Target file: /dest/you/bar/baz


          Example cmd: rsync -a /home/me/ /home/you/ /dest
          +/- pattern: /foo/bar               (note missing &amp;quot;me&amp;quot;)
          +/- pattern: /bar/baz               (note missing &amp;quot;you&amp;quot;)
          Target file: /dest/foo/bar
          Target file: /dest/bar/baz


          Example cmd: rsync -a --relative /home/me/ /home/you /dest
          +/- pattern: /home/me/foo/bar       (note full path)
          +/- pattern: /home/you/bar/baz      (ditto)
          Target file: /dest/home/me/foo/bar
          Target file: /dest/home/you/bar/baz


          Example cmd: cd /home; rsync -a --relative me/foo you/ /dest
          +/- pattern: /me/foo/bar      (starts at specified path)
          +/- pattern: /you/bar/baz     (ditto)
          Target file: /dest/me/foo/bar
          Target file: /dest/you/bar/baz


   The  easiest  way  to see what name you should filter is to just look at the output when using --verbose and put a / in front of the name
   (use the --dry-run option if you’re not yet ready to copy any files).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PER-DIRECTORY RULES AND DELETE
       Without a delete option, per-directory rules are only relevant on the sending side, so you can feel free to exclude the merge files them‐
       selves  without  affecting  the transfer.  To make this easy, the ’e’ modifier adds this exclude for you, as seen in these two equivalent
       commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          rsync -av --filter=&#39;: .excl&#39; --exclude=.excl host:src/dir /dest
          rsync -av --filter=&#39;:e .excl&#39; host:src/dir /dest


   However, if you want to do a delete on the receiving side AND you want some files to be excluded from being deleted, you’ll  need  to  be
   sure  that  the  receiving side knows what files to exclude.  The easiest way is to include the per-directory merge files in the transfer
   and use --delete-after, because this ensures that the receiving side gets all the same exclude rules as the sending side before it  tries
   to delete anything:

          rsync -avF --delete-after host:src/dir /dest


   However,  if  the  merge files are not a part of the transfer, you’ll need to either specify some global exclude rules (i.e. specified on
   the command line), or you’ll need to maintain your own per-directory merge files on the receiving side.  An example of the first is  this
   (assume that the remote .rules files exclude themselves):

   rsync -av --filter=’: .rules’ --filter=’. /my/extra.rules’
      --delete host:src/dir /dest


   In  the  above example the extra.rules file can affect both sides of the transfer, but (on the sending side) the rules are subservient to
   the rules merged from the .rules files because they were specified after the per-directory merge rule.

   In one final example, the remote side is excluding the .rsync-filter files from the transfer, but we want to use  our  own  .rsync-filter
   files to control what gets deleted on the receiving side.  To do this we must specifically exclude the per-directory merge files (so that
   they don’t get deleted) and then put rules into the local files to control what else should not get deleted.  Like one of these commands:

       rsync -av --filter=&#39;:e /.rsync-filter&#39; --delete \
           host:src/dir /dest
       rsync -avFF --delete host:src/dir /dest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BATCH MODE
       Batch mode can be used to apply the same set of updates to many identical systems. Suppose one has a tree which is replicated on a number
       of  hosts.   Now  suppose  some changes have been made to this source tree and those changes need to be propagated to the other hosts. In
       order to do this using batch mode, rsync is run with the write-batch option to apply the changes made to the source tree to  one  of  the
       destination  trees.   The write-batch option causes the rsync client to store in a &amp;ldquo;batch file&amp;rdquo; all the information needed to repeat this
       operation against other, identical destination trees.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Generating the batch file once saves having to perform the file status, checksum, and data block generation more than once when  updating
   multiple  destination  trees.  Multicast  transport protocols can be used to transfer the batch update files in parallel to many hosts at
   once, instead of sending the same data to every host individually.

   To apply the recorded changes to another destination tree, run rsync with the read-batch option, specifying the name of  the  same  batch
   file, and the destination tree.  Rsync updates the destination tree using the information stored in the batch file.

   For  your  convenience,  a  script file is also created when the write-batch option is used:  it will be named the same as the batch file
   with &amp;quot;.sh&amp;quot; appended.  This script file contains a command-line suitable for updating a destination tree using the associated batch  file.
   It can be executed using a Bourne (or Bourne-like) shell, optionally passing in an alternate destination tree pathname which is then used
   instead of the original destination path.  This is useful when the destination tree path on the current host differs from the one used to
   create the batch file.

   Examples:

          $ rsync --write-batch=foo -a host:/source/dir/ /adest/dir/
          $ scp foo* remote:
          $ ssh remote ./foo.sh /bdest/dir/


          $ rsync --write-batch=foo -a /source/dir/ /adest/dir/
          $ ssh remote rsync --read-batch=- -a /bdest/dir/ &amp;lt;foo


   In  these examples, rsync is used to update /adest/dir/ from /source/dir/ and the information to repeat this operation is stored in &amp;quot;foo&amp;quot;
   and &amp;quot;foo.sh&amp;quot;.  The host &amp;quot;remote&amp;quot; is then updated with the batched data going into the directory /bdest/dir.  The differences between  the
   two examples reveals some of the flexibility you have in how you deal with batches:

   o      The  first  example  shows that the initial copy doesn’t have to be local -- you can push or pull data to/from a remote host using
          either the remote-shell syntax or rsync daemon syntax, as desired.

   o      The first example uses the created &amp;quot;foo.sh&amp;quot; file to get the right rsync options when running the read-batch command on the  remote
          host.

   o      The  second example reads the batch data via standard input so that the batch file doesn’t need to be copied to the remote machine
          first.  This example avoids the foo.sh script because it needed to use a modified --read-batch option,  but  you  could  edit  the
          script  file  if  you  wished  to  make  use of it (just be sure that no other option is trying to use standard input, such as the
          &amp;quot;--exclude-from=-&amp;quot; option).


   Caveats:

   The read-batch option expects the destination tree that it is updating to be identical to the destination tree that was  used  to  create
   the  batch  update  fileset.  When a difference between the destination trees is encountered the update might be discarded with a warning
   (if the file appears to be up-to-date already) or the file-update may be attempted and then, if the file fails to verify, the update dis‐
   carded with an error.  This means that it should be safe to re-run a read-batch operation if the command got interrupted.  If you wish to
   force the batched-update to always be attempted regardless of the file’s size and date, use the -I option (when reading the  batch).   If
   an  error  occurs,  the  destination  tree  will probably be in a partially updated state. In that case, rsync can be used in its regular
   (non-batch) mode of operation to fix up the destination tree.

   The rsync version used on all destinations must be at least as new as the one used to generate the batch file.  Rsync will  die  with  an
   error  if  the protocol version in the batch file is too new for the batch-reading rsync to handle.  See also the --protocol option for a
   way to have the creating rsync generate a batch file that an older rsync can understand.  (Note that batch files changed format  in  ver‐
   sion 2.6.3, so mixing versions older than that with newer versions will not work.)

   When  reading  a  batch file, rsync will force the value of certain options to match the data in the batch file if you didn’t set them to
   the same as the batch-writing command.  Other options can (and should) be changed.  For instance --write-batch changes  to  --read-batch,
   --files-from is dropped, and the --filter/--include/--exclude options are not needed unless one of the --delete options is specified.

   The  code  that  creates  the BATCH.sh file transforms any filter/include/exclude options into a single list that is appended as a &amp;quot;here&amp;quot;
   document to the shell script file.  An advanced user can use this to modify the exclude list if a change in what gets deleted by --delete
   is  desired.   A normal user can ignore this detail and just use the shell script as an easy way to run the appropriate --read-batch com‐
   mand for the batched data.

   The original batch mode in rsync was based on &amp;quot;rsync+&amp;quot;, but the latest version uses a new implementation.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;符号链接
       当rsync在源目录中遇到符号链接有3种基本行为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   默认情况下，符号链接不会被传输。且会提示&amp;quot;skipping non-regular file is emmitted&amp;quot;。

   如果指定了&amp;quot;--links&amp;quot;选项，则在目标路径下创建指向相同对象的符号链接。注意，&amp;quot;--archive&amp;quot;选项隐含了&amp;quot;--links&amp;quot;选项。
   (译者注：即传输符号链接本身，如果目标主机上没有该链接指向的对象，则目标主机上此符号链接是一个损坏的软链接)

   如果指定了&amp;quot;--copy-links&amp;quot;选项，符号链接将&amp;quot;折叠&amp;quot;(collapsed)其所指向文件的内容并传输，而不是传输链接本身。
   (译者注：举个例子，例如源主机符号链接a指向b，如果指定该选项，则在目标主机上会创建文件a，但a不是符号链接，而是普通文件或目录，其内容
   和b中的内容完全一致，也就是将b中的内容叠进符号链接中。)

   rsync同样可以识别&amp;quot;安全&amp;quot;(safe)和&amp;quot;不安全&amp;quot;(unsafe)链接。可能会在web镜像站点中使用它们，例如希望保证被拷贝的rsync模块不包含指向/etc/passwd
   的符号链接。使用&amp;quot;--copy-unsafe-links&amp;quot;将导致任何软链接以其指向的文件进行拷贝，使用&amp;quot;--safe-links&amp;quot;则使得unsafe软链接完全被忽略。
   (注意：必须指定&amp;quot;--links&amp;quot;，&amp;quot;--safe-links&amp;quot;选项才会生效。)


   以下是被视为不安全的符号链接的情况：路径是绝对链接(以斜线/开头)、空链接、路径中包含&amp;quot;..&amp;quot;。

   以下是符号链接相关选项的解释：优先级从高到低排序

   --copy-links
          将所有符号链接变为普通文件(所有符号链接相关的其他选项都不会对此选项产生影响)。

   --links --copy-unsafe-links
          将所有不安全符号链接编程文件，并复制所有安全符号链接。

   --copy-unsafe-links
          将所有不安全符号链接变为文件，但跳过所有安全符号链接。

   --links --safe-links
          复制所有安全符号链接并跳过不安全符号链接。

   --links
          复制所有符号链接本身。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DIAGNOSTICS
       rsync  occasionally  produces  error messages that may seem a little cryptic. The one that seems to cause the most confusion is &amp;ldquo;protocol
       version mismatch &amp;ndash; is your shell clean?&amp;ldquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   This message is usually caused by your startup scripts or remote shell facility producing unwanted garbage on the stream  that  rsync  is
   using for its transport. The way to diagnose this problem is to run your remote shell like this:

          ssh remotehost /bin/true &amp;gt; out.dat


   then  look  at  out.dat. If everything is working correctly then out.dat should be a zero length file. If you are getting the above error
   from rsync then you will probably find that out.dat contains some text or data. Look at the contents and try to work out what is  produc‐
   ing it. The most common cause is incorrectly configured shell startup scripts (such as .cshrc or .profile) that contain output statements
   for non-interactive logins.

   If you are having trouble debugging filter patterns, then try specifying the -vv option.  At this level of verbosity rsync will show  why
   each individual file is included or excluded.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ENVIRONMENT VARIABLES
       CVSIGNORE
              The CVSIGNORE environment variable supplements any ignore patterns in .cvsignore files. See  the  &amp;ndash;cvs-exclude  option  for  more
              details.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   RSYNC_ICONV
          Specify a default --iconv setting using this environment variable. (First supported in 3.0.0.)

   RSYNC_RSH
          The RSYNC_RSH environment variable allows you to override the default shell used as the transport for rsync.  Command line options
          are permitted after the command name, just as in the -e option.

   RSYNC_PROXY
          The RSYNC_PROXY environment variable allows you to redirect your rsync client to use a web proxy when connecting to a  rsync  dae‐
          mon. You should set RSYNC_PROXY to a hostname:port pair.

   RSYNC_PASSWORD
          Setting  RSYNC_PASSWORD to the required password allows you to run authenticated rsync connections to an rsync daemon without user
          intervention. Note that this does not supply a password to a remote shell transport such as ssh; to learn how to do that,  consult
          the remote shell’s documentation.

   USER or LOGNAME
          The  USER or LOGNAME environment variables are used to determine the default username sent to an rsync daemon.  If neither is set,
          the username defaults to &amp;quot;nobody&amp;quot;.

   HOME   The HOME environment variable is used to find the user’s default .cvsignore file.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FILES
       /etc/rsyncd.conf or rsyncd.conf&lt;/p&gt;

&lt;p&gt;SEE ALSO
       rsyncd.conf(5)&lt;/p&gt;

&lt;p&gt;VERSION
       This man page is current for version 3.0.9 of rsync.&lt;/p&gt;

&lt;p&gt;INTERNAL OPTIONS
       The options &amp;ndash;server and &amp;ndash;sender are used internally by rsync, and should never be typed by a user  under  normal  circumstances.   Some
       awareness  of  these options may be needed in certain scenarios, such as when setting up a login that can only run an rsync command.  For
       instance, the support directory of the rsync distribution has an example script named rrsync (for restricted rsync) that can be used with
       a restricted ssh login.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: 本文转载自 &lt;a href=&#34;http://www.cnblogs.com/f-ck-need-u/p/7221713.html&#34; title=&#34;man rsync翻译(rsync命令中文手册&#34;&gt;&lt;em&gt;这里&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RFC: DNS</title>
      <link>http://alimy.me/post/dev_201803181751/</link>
      <pubDate>Sun, 18 Mar 2018 17:51:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201803181751/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc1034&#34; title=&#34;DOMAIN NAMES - CONCEPTS AND FACILITIES&#34;&gt;&lt;strong&gt;DNS - CONCEPTS AND FACILITIES&lt;/strong&gt; RFC https://www.ietf.org/rfc/rfc1034.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc1035&#34; title=&#34;DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION&#34;&gt;&lt;strong&gt;DNS - IMPLEMENTATION AND SPECIFICATION&lt;/strong&gt; RFC https://www.ietf.org/rfc/rfc1035.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(&lt;a href=&#34;https://tools.ietf.org/html/&#34; title=&#34;IETF Documents&#34;&gt;&lt;strong&gt;IETF Documents&lt;/strong&gt;&lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://datatracker.ietf.org/&#34; title=&#34;IETF Datatracker&#34;&gt;&lt;strong&gt;IETF Datatracker&lt;/strong&gt;&lt;/a&gt;)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RFC: SMTP/POP3/IMAP</title>
      <link>http://alimy.me/post/dev_201803181718/</link>
      <pubDate>Sun, 18 Mar 2018 17:18:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201803181718/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc5321&#34; title=&#34;Simple Mail Transfer Protocol&#34;&gt;&lt;strong&gt;SMTP&lt;/strong&gt; RFC https://www.ietf.org/rfc/rfc5321.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc1939&#34; title=&#34;Post Office Protocol - Version 3&#34;&gt;&lt;strong&gt;POP3&lt;/strong&gt; RFC https://www.ietf.org/rfc/rfc1939.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc3501&#34; title=&#34; INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1&#34;&gt;&lt;strong&gt;IMAP&lt;/strong&gt; RFC https://www.ietf.org/rfc/rfc3501.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(&lt;a href=&#34;https://tools.ietf.org/html/&#34; title=&#34;IETF Documents&#34;&gt;&lt;strong&gt;IETF Documents&lt;/strong&gt;&lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://datatracker.ietf.org/&#34; title=&#34;IETF Datatracker&#34;&gt;&lt;strong&gt;IETF Datatracker&lt;/strong&gt;&lt;/a&gt;)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AMP: Accelerated Mobile Pages</title>
      <link>http://alimy.me/post/dev_201803130721/</link>
      <pubDate>Tue, 13 Mar 2018 07:21:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201803130721/</guid>
      <description>&lt;p&gt;The AMP Project is an open-source initiative aiming to make the web better for all. The project enables the creation of websites and ads that are consistently fast, beautiful and high-performing across devices and distribution platforms.&lt;/p&gt;

&lt;p&gt;AMP pages are built with 3 core components:&lt;/p&gt;

&lt;h3 id=&#34;amp-html&#34;&gt;AMP HTML ⚡&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ampproject.org/docs/get_started/about-amp.html&#34;&gt;AMP HTML&lt;/a&gt; is a way to build web pages that render with reliable and fast performance. It is our attempt at fixing what many perceive as painfully slow page load times – especially when reading content on the mobile web.  AMP HTML is built on existing web technologies; an AMP page will load (quickly) in any modern browser.&lt;/p&gt;

&lt;p&gt;You can learn more at &lt;a href=&#34;https://www.ampproject.org/&#34;&gt;ampproject.org&lt;/a&gt; including &lt;a href=&#34;https://www.ampproject.org/learn/about-amp/&#34;&gt;what AMP is&lt;/a&gt;, &lt;a href=&#34;https://www.ampproject.org/learn/how-amp-works/&#34;&gt;how it works&lt;/a&gt; and the importance of &lt;a href=&#34;https://www.ampproject.org/docs/guides/validate&#34;&gt;validation in AMP&lt;/a&gt;.  You can also walk through &lt;a href=&#34;https://www.ampproject.org/docs/get_started/create&#34;&gt;creating an AMP page&lt;/a&gt; and read through the &lt;a href=&#34;https://www.ampproject.org/docs/reference/components&#34;&gt;reference docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;amp-js&#34;&gt;AMP JS&lt;/h3&gt;

&lt;p&gt;The AMP JS library ensures the fast rendering of AMP HTML pages.&lt;/p&gt;

&lt;p&gt;The AMP JS library implements all of AMP&amp;rsquo;s best performance practices, manages resource loading and gives you the custom tags mentioned above, all to ensure a fast rendering of your page.&lt;/p&gt;

&lt;p&gt;Among the biggest optimizations is the fact that it makes everything that comes from external resources asynchronous, so nothing in the page can block anything from rendering.&lt;/p&gt;

&lt;p&gt;Other performance techniques include the sandboxing of all iframes, the pre-calculation of the layout of every element on page before resources are loaded and the disabling of slow CSS selectors.&lt;/p&gt;

&lt;p&gt;To learn more about not just the optimizations but the limitations, read the &lt;a href=&#34;https://www.ampproject.org/docs/fundamentals/spec&#34; title=&#34;AMP HTML specification&#34;&gt;&lt;strong&gt;AMP HTML specification&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;amp-cache&#34;&gt;AMP Cache&lt;/h3&gt;

&lt;p&gt;The &lt;strong&gt;Google AMP Cache&lt;/strong&gt; can be used to serve cached AMP HTML pages.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://developers.google.com/amp/cache/&#34; title=&#34;Google AMP Cach&#34;&gt;&lt;strong&gt;Google AMP Cache&lt;/strong&gt;&lt;/a&gt; is a proxy-based content delivery network for delivering all valid AMP documents. It fetches AMP HTML pages, caches them, and improves page performance automatically. When using the Google AMP Cache, the document, all JS files and all images load from the same origin that is using &lt;a href=&#34;https://http2.github.io/&#34; title=&#34;HTTP 2.0 @GitHub&#34;&gt;&lt;strong&gt;HTTP 2.0&lt;/strong&gt;&lt;/a&gt; for maximum efficiency.&lt;/p&gt;

&lt;p&gt;The cache also comes with a built-in validation system which confirms that the page is guaranteed to work, and that it doesn&amp;rsquo;t depend on external resources. The validation system runs a series of assertions confirming the page’s markup meets the AMP HTML specification.&lt;/p&gt;

&lt;p&gt;Another version of the validator comes bundled with every AMP page. This version can log validation errors directly to the browser’s console when the page is rendered, allowing you to see how complex changes in your code might impact performance and user experience.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RFC: HTTP 0.9/1.0/1.1/2.0</title>
      <link>http://alimy.me/post/dev_201803122215/</link>
      <pubDate>Mon, 12 Mar 2018 22:15:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201803122215/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.w3.org/Protocols/HTTP/AsImplemented.html&#34; title=&#34;The Original HTTP as defined in 1991&#34;&gt;&lt;strong&gt;HTTP 0.9&lt;/strong&gt; https://www.w3.org/Protocols/HTTP/AsImplemented.html &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc1945&#34; title=&#34;Hypertext Transfer Protocol -- HTTP/1.0&#34;&gt;&lt;strong&gt;HTTP 1.0&lt;/strong&gt; RFC https://www.ietf.org/rfc/rfc1945.txt &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2616&#34; title=&#34;Hypertext Transfer Protocol -- HTTP/1.1&#34;&gt;&lt;strong&gt;HTTP 1.1&lt;/strong&gt; RFC https://www.ietf.org/rfc/rfc2616.txt &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7540&#34; title=&#34;Hypertext Transfer Protocol Version 2 -- HTTP/2&#34;&gt;&lt;strong&gt;HTTP 2.0&lt;/strong&gt; RFC https://www.ietf.org/rfc/rfc7540.txt &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(&lt;a href=&#34;https://tools.ietf.org/html/&#34; title=&#34;IETF Documents&#34;&gt;&lt;strong&gt;IETF Documents&lt;/strong&gt;&lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://datatracker.ietf.org/&#34; title=&#34;IETF Datatracker&#34;&gt;&lt;strong&gt;IETF Datatracker&lt;/strong&gt;&lt;/a&gt;)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RFC: TLS 1.0/1.1/1.2/1.3</title>
      <link>http://alimy.me/post/dev_201803122145/</link>
      <pubDate>Mon, 12 Mar 2018 21:45:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201803122145/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2246&#34; title=&#34;TLS 1.0&#34;&gt;&lt;strong&gt;TLS 1.0&lt;/strong&gt; RFC http://www.ietf.org/rfc/rfc2246.txt &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc4346&#34; title=&#34;TLS 1.1&#34;&gt;&lt;strong&gt;TLS 1.1&lt;/strong&gt; RFC http://www.ietf.org/rfc/rfc4346.txt &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc5246&#34; title=&#34;TLS 1.2&#34;&gt;&lt;strong&gt;TLS 1.2&lt;/strong&gt; RFC http://www.ietf.org/rfc/rfc5246.txt &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/draft-ietf-tls-tls13-28&#34; title=&#34;draft-ietf-tls-tls13-28&#34;&gt;&lt;strong&gt;TLS 1.3&lt;/strong&gt; RFC https://www.ietf.org/id/draft-ietf-tls-tls13-28.txt &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(&lt;a href=&#34;https://tools.ietf.org/html/&#34; title=&#34;IETF Documents&#34;&gt;&lt;strong&gt;IETF Documents&lt;/strong&gt;&lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://datatracker.ietf.org/&#34; title=&#34;IETF Datatracker&#34;&gt;&lt;strong&gt;IETF Datatracker&lt;/strong&gt;&lt;/a&gt;)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang Tutorial: What&#39;s DefaultServeMux in net/http</title>
      <link>http://alimy.me/post/dev_201803031932/</link>
      <pubDate>Sat, 03 Mar 2018 19:34:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201803031932/</guid>
      <description>&lt;p&gt;craete a HTTPS Server use net/http and route handle function by DefaultServeMux, see code below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;net/http&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

func hello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &amp;quot;[%s]: hello!&amp;quot;, r.Host)
}

func world(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &amp;quot;[%s]: world!&amp;quot;, r.Host)
}

func main() {
	server := http.Server{
		Addr: &amp;quot;127.0.0.1:8080&amp;quot;,
	}
	http.HandleFunc(&amp;quot;/hello&amp;quot;, hello)
	http.HandleFunc(&amp;quot;/world&amp;quot;, world)

	log.Fatal(server.ListenAndServe())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;the http.HandleFunc is defined below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package http

// HandleFunc registers the handler function for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DefaultServeMux is a ref var of &amp;amp;ServeMux&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// DefaultServeMux is the default ServeMux used by Serve.
var DefaultServeMux = &amp;amp;defaultServeMux

var defaultServeMux ServeMux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the method of HandleFunc is defined below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Server

// HandleFunc registers the handler function for the given pattern.
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	mux.Handle(pattern, HandlerFunc(handler))
}

// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers. If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we see,  the method of HandleFunc convert arg of func(ResponseWriter, *Request) to a http Handler and passed to ServeMux.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: &lt;a href=&#34;http://gitbus.com/alimy/dugo.git&#34; title=&#34;My Go Programming code repository&#34;&gt;&lt;em&gt;My Code repository&lt;/em&gt;&lt;/a&gt;)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang Tutorial: Create HTTPS Server use net/http</title>
      <link>http://alimy.me/post/dev_201803030946/</link>
      <pubDate>Sat, 03 Mar 2018 09:46:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201803030946/</guid>
      <description>&lt;p&gt;It is simple to craete a HTTPS Server use net/http, see code below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;net/http&amp;quot;
	&amp;quot;fmt&amp;quot;
)

type SimpleHandler struct {
	Name string
}

func (h *SimpleHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &amp;quot;%s: Hello World!&amp;quot;, h.Name)
}

func main() {
	server := http.Server{
		Addr:    &amp;quot;127.0.0.1:8080&amp;quot;,
		Handler: &amp;amp;SimpleHandler{Name: &amp;quot;SimpleServer&amp;quot;},
	}
	server.ListenAndServeTLS(&amp;quot;cert.pem&amp;quot;, &amp;quot;key.pem&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;We can use golang&amp;rsquo;s crypto libraries to create SSL certificates that used in simple https server above. see code below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;crypto/rand&amp;quot;
	&amp;quot;crypto/x509/pkix&amp;quot;
	&amp;quot;math/big&amp;quot;
	&amp;quot;crypto/x509&amp;quot;
	&amp;quot;encoding/pem&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;time&amp;quot;
	&amp;quot;crypto/rsa&amp;quot;
)

const (
	certFileName = &amp;quot;cert.pem&amp;quot;
	keyFileName  = &amp;quot;key.pem&amp;quot;
)

func main() {
	max := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, _ := rand.Int(rand.Reader, max)
	subject := pkix.Name{
		Organization:       []string{&amp;quot;Manning Publications Co.&amp;quot;},
		OrganizationalUnit: []string{&amp;quot;Books&amp;quot;},
		CommonName:         &amp;quot;Go Web Programming&amp;quot;,
	}

	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject:      subject,
		NotBefore:    time.Now(),
		NotAfter:     time.Now().Add(365 * 24 * time.Hour),
		KeyUsage:     x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		IPAddresses:  []net.IP{net.ParseIP(&amp;quot;127.0.0.1&amp;quot;)},
	}

	pk, _ := rsa.GenerateKey(rand.Reader, 2048)

	derBytes, _ := x509.CreateCertificate(rand.Reader, &amp;amp;template, &amp;amp;template, &amp;amp;pk.PublicKey, pk)
	certOut, _ := os.Create(certFileName)
	pem.Encode(certOut, &amp;amp;pem.Block{Type: &amp;quot;CERTIFICATE&amp;quot;, Bytes: derBytes})
	certOut.Close()

	keyOut, _ := os.Create(keyFileName)
	pem.Encode(keyOut, &amp;amp;pem.Block{Type: &amp;quot;RSA PRIVATE KEY&amp;quot;, Bytes: x509.MarshalPKCS1PrivateKey(pk)})
	keyOut.Close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s code is reference from the simple code in book &lt;a href=&#34;https://github.com/sausheong/gwp.git&#34; title=&#34;Go Web Programming code repository&#34;&gt;&amp;lt;&lt;strong&gt;Go Web Programming&lt;/strong&gt;&amp;gt;&lt;/a&gt; and this link is &lt;a href=&#34;http://gitbus.com/alimy/dugo.git&#34; title=&#34;My Go Programming code repository&#34;&gt;&lt;em&gt;My Code repository&lt;/em&gt;&lt;/a&gt;)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>拯救者</title>
      <link>http://alimy.me/post/art_201803030843/</link>
      <pubDate>Sat, 03 Mar 2018 08:43:01 CST</pubDate>
      
      <guid>http://alimy.me/post/art_201803030843/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://alimy.me/images/post/20180303084300.jpg&#34; title=&#34;点击查看大图&#34;&gt;&lt;img src=&#34;http://alimy.me/images/post/20180303084300.webp&#34; alt=&#34;图片加载中...使用支持Webp的浏览器可以加速查看&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;行者无忌（&lt;a href=&#34;http://alimy.me/images/post/20180303084300.webp&#34; title=&#34;webp格式图片&#34;&gt;查看大图&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>陶渊明 -「桃花源记」</title>
      <link>http://alimy.me/post/arc_201604151010/</link>
      <pubDate>Fri, 15 Apr 2016 10:10:00 CST</pubDate>
      
      <guid>http://alimy.me/post/arc_201604151010/</guid>
      <description>&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近。忽逢桃花林，夹岸数百步，中无杂树，芳草鲜美，落英缤纷，渔人甚异之。复前行，欲穷其林。&lt;/p&gt;

&lt;p&gt;　　林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。土地平旷，屋舍俨然，有良田美池桑竹之属。阡陌交通，鸡犬相闻。其中往来种作，男女衣着，悉如外人。黄发垂髫，并怡然自乐。&lt;/p&gt;

&lt;p&gt;　　见渔人，乃大惊，问所从来。具答之。便要还家，设酒杀鸡作食。村中闻有此人，咸来问讯。自云先世避秦时乱，率妻子邑人来此绝境，不复出焉，遂与外人间隔。问今是何世，乃不知有汉，无论魏晋。此人一一为具言所闻，皆叹惋。余人各复延至其家，皆出酒食。停数日，辞去。此中人语云：“不足为外人道也。”&lt;/p&gt;

&lt;p&gt;　　既出，得其船，便扶向路，处处志之。及郡下，诣太守，说如此。太守即遣人随其往，寻向所志，遂迷，不复得路。&lt;/p&gt;

&lt;p&gt;　　南阳刘子骥，高尚士也，闻之，欣然规往。未果，寻病终，后遂无问津者。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>老子 - 「道 德 經」</title>
      <link>http://alimy.me/post/arc_201604150952/</link>
      <pubDate>Fri, 15 Apr 2016 09:52:00 CST</pubDate>
      
      <guid>http://alimy.me/post/arc_201604150952/</guid>
      <description>&lt;h4 id=&#34;第-一-章&#34;&gt;第 一 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;道 可 道 ， 非 常 道 。 名 可 名 ， 非 常 名 。  
无 名 天 地 之 始 ﹔ 有 名 万 物 之 母 。  
故 常 无 ， 欲 以 观 其 妙 ﹔ 常 有 ， 欲 以 观 其 徼 。  
此 两 者 ， 同 出 而 异 名 ， 同 谓 之 玄 。  
玄 之 又 玄 ， 众 妙 之 门 。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-章&#34;&gt;第 二 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;天 下 皆 知 美 之 为 美 ， 斯 恶 已 。  
皆 知 善 之 为 善 ， 斯 不 善 已 。  
有 无 相 生 ， 难 易 相 成 ， 长 短 相 形 ，  
高 下 相 盈 ， 音 声 相 和 ， 前 后 相 随 。  
恒 也 。 是 以 圣 人 处 无 为 之 事 ，  
行 不 言 之 教 ﹔ 万 物 作 而 弗 始 ，  
生 而 弗 有 ， 为 而 弗 恃 ， 功 成 而 不 居 。   
夫 唯 弗 居 ， 是 以 不 去 。   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;第-三-章&#34;&gt;第 三 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;不 尚 贤 ， 使 民 不 争   
不 贵 难 得 之 货 ， 使 民 不 为 盗 ﹔   
不 见 可 欲 ， 使 民 心 不 乱 。   
是 以 圣 人 之 治 ，   
虚 其 心 ，   
实 其 腹 ，  
弱 其 志 ，   
强 其 骨 。   
常 使 民 无 知 无 欲 。   
使 夫 智 者 不 敢 为 也 。   
为 无 为 ， 则 无 不 治 。   
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-章&#34;&gt;第 四 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;道 冲 ， 而 用 之 或 不 盈 。
渊 兮 ， 似 万 物 之 宗 ﹔ 湛 兮 ， 似 或 存 。
吾 不 知 谁 之 子 ， 象 帝 之 先 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-章&#34;&gt;第 五 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;天 地 不 仁 ， 以 万 物 为 刍 狗 ﹔ 圣 人 不 仁 ， 以 百 姓 为 刍 狗 。
天 地 之 间 ， 其 犹 橐 钥 乎 。 虚 而 不 屈 ， 动 而 愈 出 。
多 言 数 穷 ， 不 如 守 中 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-章&#34;&gt;第 六 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;谷 神 不 死 ， 是 谓 玄 牝 。
玄 牝 之 门 ， 是 谓 天 地 根 。帛系 若 存 ， 用 之 不 勤 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-章&#34;&gt;第 七 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;天 长 地 久 。
天 地 所 以 能 长 且 久 者 ，
以 其 不 自 生 ， 故 能 长 生 。
是 以 圣 人 后 其 身 而 身 先 ﹔ 外 其 身 而 身 存 。
非 以 其 无 私 邪 。
故 能 成 其 私 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-八-章&#34;&gt;第 八 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;上 善 若 水 。
水 善 利 万 物 而 不 争 ，
处 众 人 之 所 恶 ， 故 几 于 道 。
居 善 地 ， 心 善 渊 ， 与 善 仁 ，
言 善 信 ， 政 善 治 ， 事 善 能 ，
动 善 时 。 夫 唯 不 争 ， 故 无 尤 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-九-章&#34;&gt;第 九 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;持 而 盈 之 ， 不 如 其 已 ﹔
揣 而 锐 之 ， 不 可 长 保 。
金 玉 满 堂 ， 莫 之 能 守 ﹔
富 贵 而 骄 ， 自 遗 其 咎 。
功 遂 身 退 ， 天 之 道 也 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-十-章&#34;&gt;第 十 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;载 营 魄 抱 一 ， 能 无 离 乎 。
专 气 致 柔 ， 能 如 婴 儿 乎 。
涤 除 玄 鉴 ， 能 如 疵 乎 。
爱 国 治 民 ， 能 无 为 乎 。
天 门 开 阖 ， 能 为 雌 乎 。
明 白 四 达 ， 能 无 知 乎 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-十-一-章&#34;&gt;第 十 一 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;三 十 辐 ， 共 一 毂 ， 当 其 无 ， 有 车 之 用 。
埏 埴 以 为 器 ， 当 其 无 ， 有 器 之 用 。
凿 户 牖 以 为 室 ， 当 其 无 ， 有 室 之 用 。
故 有 之 以 为 利 ， 无 之 以 为 用 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-十-二-章&#34;&gt;第 十 二 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;五 色 令 人 目 盲 ﹔ 五 音 令 人 耳 聋 ﹔ 五 味 令 人 口 爽 ﹔
驰 骋 畋 猎 ， 令 人 心 发 狂 ﹔ 难 得 之 货 ， 令 人 行 妨 。
是 以 圣 人 为 腹 不 为 目 ， 故 去 彼 取 此 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-十-三-章&#34;&gt;第 十 三 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;宠 辱 若 惊 ， 贵 大 患 若 身 。
何 谓 宠 辱 若 惊 。
宠 为 下 ， 得 之 若 惊 ， 失 之 若 惊 ， 是 谓 宠 辱 若 惊 。
何 谓 贵 大 患 若 身 。
吾 所 以 有 大 患 者 ， 为 吾 有 身 ，
及 吾 无 身 ， 吾 有 何 患 。
故 贵 以 身 为 天 下 ， 若 可 寄 天 下 ﹔
爱 以 身 为 天 下 ， 若 可 托 天 下 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-十-四-章&#34;&gt;第 十 四 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;视 之 不 见 ， 名 曰 夷 ﹔
听 之 不 闻 ， 名 曰 希 ﹔
搏 之 不 得 ， 名 曰 微 。
此 三 者 不 可 致 诘 ， 故 混 而 为 一 。
其 上 不 皦 ， 其 下 不 昧 。
绳 绳 兮 不 可 名 ， 复 归 于 物 。
是 谓 无 状 之 状 ， 无 物 之 象 ， 是 谓 惚 恍 。
迎 之 不 见 其 首 ， 随 之 不 见 其 后 。
执 古 之 道 ， 以 御 今 之 有 。
能 知 古 始 ， 是 谓 道 纪 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-十-五-章&#34;&gt;第 十 五 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;古 之 善 为 道 者 ， 微 妙 玄 通 ， 深 不 可 识 。
夫 唯 不 可 识 ， 故 强 为 之 容 ：
豫 兮 若 冬 涉 川 ﹔
犹 兮 若 畏 四 邻 ﹔
俨 兮 其 若 客 ﹔
涣 兮 其 若 凌 释 ﹔
敦 兮 其 若 朴 ﹔
旷 兮 其 若 谷 ﹔
混 兮 其 若 浊 ﹔
澹 兮 其 若 海 ﹔
飂 兮 若 无 止 。
孰 能 浊 以 静 之 徐 清 。
孰 能 安 以 动 之 徐 生 。
保 此 道 者 ， 不 欲 盈 。
夫 唯 不 盈 ， 故 能 蔽 而 新 成 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-十-六-章&#34;&gt;第 十 六 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;致 虚 极 ， 守 静 笃。
万 物 并 作 ， 吾 以 观 复。
夫 物 芸 芸 ， 各 复 归 其 根 。
归 根 曰 静 ， 静 曰 复 命 。
复 命 曰 常 ， 知 常 曰 明 。
不 知 常 ， 妄 作 凶 。
知 常 容 ， 容 乃 公 ，
公 乃 全 ， 全 乃 天 ，
天 乃 道 ， 道 乃 久 ， 没 身 不 殆 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-十-七-章&#34;&gt;第 十 七 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;太 上 ， 不 知 有 之 ﹔
其 次 ， 亲 而 誉 之 ﹔
其 次 ， 畏 之 ﹔
其 次 ， 侮 之 。
信 不 足 焉 ， 有 不 信 焉 。
悠 兮 其 贵 言 。
功 成 事 遂 ， 百 姓 皆 谓 ： 「 我 自 然 」 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-十-八-章&#34;&gt;第 十 八 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;大 道 废 ， 有 仁 义 ﹔ 智 慧 出 ， 有 大 伪 ﹔
六 亲 不 和 ， 有 孝 慈 ﹔ 国 家 昏 乱 ， 有 忠 臣 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-十-九-章&#34;&gt;第 十 九 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;绝 圣 弃 智 ， 民 利 百 倍 ﹔
绝 仁 弃 义 ， 民 复 孝 慈 ﹔
绝 巧 弃 利 ， 盗 贼 无 有 。
此 三 者 以 为 文 ， 不 足 。
故 令 有 所 属 ： 见 素 抱 朴 ， 少 思 寡 欲 ， 绝 学 无 忧 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-十-章&#34;&gt;第 二 十 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;唯 之 与 阿 ， 相 去 几 何 。
之 与 恶 ， 相 去 若 何 。
人 之 所 畏 ， 不 可 不 畏 。
荒 兮 ， 其 未 央 哉 。
众 人 熙 熙 ， 如 享 太 牢 ， 如 春 登 台 。
我 独 泊 兮 ， 其 未 兆 ﹔
沌 沌 兮 ， 如 婴 儿 之 未 孩 ﹔
儽 儽 兮 ， 若 无 所 归 。
众 人 皆 有 余 ， 而 我 独 若 遗 。 我 愚 人 之 心 也 哉 。
俗 人 昭 昭 ， 我 独 昏 昏 。
俗 人 察 察 ， 我 独 闷 闷 。
众 人 皆 有 以 ， 而 我 独 顽 且 鄙 。
我 独 异 于 人 ， 而 贵 食 母 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-十-一-章&#34;&gt;第 二 十 一 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;孔 德 之 容 ， 惟 道 是 从 。
道 之 为 物 ， 惟 恍 惟 惚 。
惚 兮 恍 兮 ， 其 中 有 象 ﹔ 恍 兮 惚 兮 ， 其 中 有 物 。
窈 兮 冥 兮 ， 其 中 有 精 ﹔ 其 精 甚 真 ， 其 中 有 信 。
自 今 及 古 ， 其 名 不 去 ， 以 阅 众 甫 。
吾 何 以 知 众 甫 之 状 哉 。 以 此 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-十-二-章&#34;&gt;第 二 十 二 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;曲 则 全 ， 枉 则 直 ， 洼 则 盈 ，
敝 则 新 ， 少 则 得 ， 多 则 惑 。
是 以 圣 人 抱 一 为 天 下 式 。
不 自 见 ， 故 明 ﹔
不 自 是 ， 故 彰 ﹔
不 自 伐 ， 故 有 功 ﹔
不 自 矜 ， 故 长 。
夫 唯 不 争 ， 故 天 下 莫 能 与 之 争 。
古 之 所 谓 「 曲 则 全 」 者 ， 岂 虚 言 哉 。
诚 全 而 归 之 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-十-三-章&#34;&gt;第 二 十 三 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;希 言 自 然 。
故 飘 风 不 终 朝 ， 骤 雨 不 终 日 。
孰 为 此 者 。
天 地 。 天 地 尚 不 能 久 ， 而 况 于 人 乎 。
故 从 事 于 道 者 ， 同 于 道 ﹔
德 者 ， 同 于 德 ﹔ 失 者 ， 同 于 失 。
同 于 道 者 ， 道 亦 乐 得 之 ﹔
同 于 德 者 ， 德 亦 乐 得 之 ﹔
同 于 失 者 ， 失 亦 乐 得 之 。
信 不 足 焉 ， 有 不 信 焉 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-十-四-章&#34;&gt;第 二 十 四 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;企 者 不 立 ﹔ 跨 者 不 行 ﹔
自 见 者 不 明 ﹔ 自 是 者 不 彰 ﹔
自 伐 者 无 功 ﹔ 自 矜 者 不 长 。
其 在 道 也 ， 曰 ： 余 食 赘 形 。
物 或 恶 之 ， 故 有 道 者 不 处 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-十-五-章&#34;&gt;第 二 十 五 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;有 物 混 成 ， 先 天 地 生 。
寂 兮 寥 兮 ， 独 立 而 不 改 ，
周 行 而 不 殆 ， 可 以 为 天 地 母 。
吾 不 知 其 名 ， 强 字 之 曰 道 ， 强 为 之 名 曰 大 。
大 曰 逝 ， 逝 曰 远 ， 远 曰 反 。
故 道 大 ， 天 大 ， 地 大 ， 人 亦 大 。
域 中 有 四 大 ， 而 人 居 其 一 焉 。
人 法 地 ， 地 法 天 ， 天 法 道 ， 道 法 自 然 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-十-六-章&#34;&gt;第 二 十 六 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;重 为 轻 根 ， 静 为 躁 君 。
是 以 君 子 终 日 行 不 离 辎 重 。
虽 有 荣 观 ， 燕 处 超 然 。
奈 何 万 乘 之 主 ， 而 以 身 轻 天 下 。
轻 则 失 根 ， 躁 则 失 君 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-十-七-章&#34;&gt;第 二 十 七 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;善 行 无 辙 迹 ， 善 言 无 瑕 谪 ﹔
善 数 不 用 筹 策 ﹔ 善 闭 无 关 楗 而 不 可 开 ，
善 结 无 绳 约 而 不 可 解 。
是 以 圣 人 常 善 救 人 ， 故 无 弃 人 ﹔
常 善 救 物 ， 故 无 弃 物 。
是 谓 袭 明 。
故 善 人 者 ， 不 善 人 之 师 ﹔
不 善 人 者 ， 善 人 之 资 。
不 贵 其 师 ， 不 爱 其 资 ，
虽 智 大 迷 ， 是 谓 要 妙 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-十-八-章&#34;&gt;第 二 十 八 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;知 其 雄 ， 守 其 雌 ， 为 天 下 溪 。
为 天 下 溪 ， 常 德 不 离 ， 复 归 于 婴 儿 。
知 其 白 ， 守 其 辱 ， 为 天 下 谷 。
为 天 下 谷 ， 常 德 乃 足 ， 复 归 于 朴 。
知 其 白 ， 守 其 黑 ， 为 天 下 式 。
为 天 下 式 ， 常 德 不 忒 ， 复 归 于 无 极 。
朴 散 则 为 器 ， 圣 人 用 之 ，
则 为 官 长 ， 故 大 智 不 割 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-二-十-九-章&#34;&gt;第 二 十 九 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;将 欲 取 天 下 而 为 之 ， 吾 见 其 不 得 已 。
天 下 神 器 ， 不 可 为 也 ， 不 可 执 也 。
为 者 败 之 ， 执 者 失 之 。
是 以 圣 人 无 为 ， 故 无 败 ﹔
无 执 ， 故 无 失。
夫 物 或 行 或 随 ﹔ 或 嘘 或 吹 ﹔
或 强 或 羸 ﹔ 或 载 或 隳 。
是 以 圣 人 去 甚 ， 去 奢 ， 去 泰 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-三-十-章&#34;&gt;第 三 十 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;以 道 佐 人 主 者 ， 不 以 兵 强 天 下 。
其 事 好 远 。
师 之 所 处 ， 荆 棘 生 焉 。
大 军 之 后 ， 必 有 凶 年 。
善 有 果 而 已 ， 不 以 取 强 。
果 而 勿 矜 ， 果 而 勿 伐 ， 果 而 勿 骄 。
果 而 不 得 已 ， 果 而 勿 强 。
物 壮 则 老 ， 是 谓 不 道 ， 不 道 早 已 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-三-十-一-章&#34;&gt;第 三 十 一 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;夫 兵 者 ， 不 祥 之 器 ，
物 或 恶 之 ， 故 有 道 者 不 处 。
君 子 居 则 贵 左 ， 用 兵 则 贵 右 。
兵 者 不 祥 之 器 ， 非 君 子 之 器 ，
不 得 已 而 用 之 ， 恬 淡 为 上 。
胜 而 不 美 ， 而 美 之 者 ， 是 乐 杀 人 。
夫 乐 杀 人 者 ， 则 不 可 得 志 于 天 下 矣 。
吉 事 尚 左 ， 凶 事 尚 右 。
偏 将 军 居 左 ， 上 将 军 居 右 ， 言 以 丧 礼 处 之 。
杀 人 之 众 ， 以 悲 哀 泣 之 ， 战 胜 以 丧 礼 处 之 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-三-十-二-章&#34;&gt;第 三 十 二 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;道 常 无 名 朴 。
虽 小 ， 天 下 莫 能 臣 。
侯 王 若 能 守 之 ， 万 物 将 自 宾 。
天 地 相 合 ， 以 降 甘 露 ， 民 莫 之 令 而 自 均 。
始 制 有 名 ， 名 亦 既 有 ，
夫 亦 将 知 止 ， 知 止 可 以 不 殆 。
譬 道 之 在 天 下 ， 犹 川 谷 之 于 江 海 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-三-十-三-章&#34;&gt;第 三 十 三 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;知 人 者 智 ， 自 知 者 明 。
胜 人 者 有 力 ， 自 胜 者 强 。
知 足 者 富 。
强 行 者 有 志 。
不 失 其 所 者 久 。
死 而 不 亡 者 寿 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-三-十-四-章&#34;&gt;第 三 十 四 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;大 道 泛 兮 ， 其 可 左 右 。
万 物 恃 之 以 生 而 不 辞 ， 功 成 而 不 有 。
衣 养 万 物 而 不 为 主 ， 可 名 于 小 ﹔
万 物 归 焉 而 不 为 主 ， 可 名 为 大 。
以 其 终 不 自 为 大 ， 故 能 成 其 大 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-三-十-五-章&#34;&gt;第 三 十 五 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;执 大 象 ， 天 下 往 。
往 而 不 害 ， 安 平 泰 。
乐 与 饵 ， 过 客 止 。
道 之 出 口 ， 淡 乎 其 无 味 ，
视 之 不 足 见 ， 听 之 不 足 闻 ， 用 之 不 足 既 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-三-十-六-章&#34;&gt;第 三 十 六 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;将 欲 歙 之 ， 必 故 张 之 ﹔ 将 欲 弱 之 ， 必 故 强 之 ﹔
将 欲 废 之 ， 必 故 兴 之 ﹔ 将 欲 取 之 ， 必 故 与 之 。
是 谓 微 明 。
柔 弱 胜 刚 强 。
鱼 不 可 脱 于 渊 ， 国 之 利 器 不 可 以 示 人 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-三-十-七-章&#34;&gt;第 三 十 七 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;道 常 无 为 而 无 不 为 。
侯 王 若 能 守 之 ， 万 物 将 自 化 。
化 而 欲 作 ， 吾 将 镇 之 以 无 名 之 朴 。
镇 之 以 无 名 之 朴 ， 夫 将 不 欲 。
不 欲 以 静 ， 天 下 将 自 正 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-三-十-八-章&#34;&gt;第 三 十 八 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;上 德 不 德 ， 是 以 有 德 ﹔
下 德 不 失 德 ， 是 以 无 德 。
上 德 无 为 而 无 以 为 ﹔
下 德 无 为 而 有 以 为 。
上 仁 为 之 而 无 以 为 ﹔
上 义 为 之 而 有 以 为 。
上 礼 为 之 而 莫 之 应 ，
则 攘 臂 而 扔 之 。
故 失 道 而 后 德 ， 失 德 而 后 仁 ，
失 仁 而 后 义 ， 失 义 而 后 礼 。
夫 礼 者 ， 忠 信 之 薄 ， 而 乱 之 首 。
前 识 者 ， 道 之 华 ， 而 愚 之 始 。
是 以 大 丈 夫 处 其 厚 ， 不 居 其 薄 ﹔
处 其 实 ， 不 居 其 华 。 故 去 彼 取 此 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-三-十-九-章&#34;&gt;第 三 十 九 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;昔 之 得 一 者 ：
天 得 一 以 清 ﹔
地 得 一 以 宁 ﹔
神 得 一 以 灵 ﹔
谷 得 一 以 生 ﹔
侯 得 一 以 为 天 下 正 。
其 致 之 也 ， 谓 天 无 以 清 ， 将 恐 裂 ﹔
地 无 以 宁 ， 将 恐 废 ﹔
神 无 以 灵 ， 将 恐 歇 ﹔
谷 无 以 盈 ， 将 恐 竭 ﹔
万 物 无 以 生 ， 将 恐 灭 ﹔
侯 王 无 以 正 ， 将 恐 蹶 。
故 贵 以 贱 为 本 ， 高 以 下 为 基 。
是 以 侯 王 自 称 孤 、 寡 、 不 谷 。
此 非 以 贱 为 本 邪 。 非 乎 。 故 致 誉 无 誉 。
是 故 不 欲 琭 琭 如 玉 ， 珞 珞 如 石 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-十-章&#34;&gt;第 四 十 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;反 者 道 之 动 ﹔ 弱 者 道 之 用 。
天 下 万 物 生 于 有 ， 有 生 于 无 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-十-一-章&#34;&gt;第 四 十 一 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;上 士 闻 道 ， 勤 而 行 之 ﹔ 中 士 闻 道 ， 若 存 若 亡 ﹔
下 士 闻 道 ， 大 笑 之 。 不 笑 不 足 以 为 道 。
故 建 言 有 之 ：
明 道 若 昧 ﹔
进 道 若 退 ﹔
夷 道 若 颣 ﹔
上 德 若 谷 ﹔
广 德 若 不 足 ﹔
建 德 若 偷 ﹔
质 真 若 渝 ﹔
大 白 若 辱 ﹔
大 方 无 隅 ﹔
大 器 晚 成 ﹔
大 音 希 声 ﹔
大 象 无 形 ﹔
道 隐 无 名 。
夫 唯 道 ， 善 贷 且 成 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-十-二-章&#34;&gt;第 四 十 二 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;道 生 一 ， 一 生 二 ， 二 生 三 ， 三 生 万 物 。
万 物 负 阴 而 抱 阳 ， 冲 气 以 为 和 。
人 之 所 恶 ， 唯 孤 、 寡 、 不 谷 ， 而 王 公 以 为 称 。
故 物 或 损 之 而 益 ， 或 益 之 而 损 。
人 之 所 教 ， 我 亦 教 之 。
强 梁 者 不 得 其 死 ， 吾 将 以 为 教 父 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-十-三-章&#34;&gt;第 四 十 三 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;天 下 之 至 柔 ， 驰 骋 天 下 之 至 坚 。
无 有 入 无 间 ， 吾 是 以 知 无 为 之 有 益 。
不 言 之 教 ， 无 为 之 益 ， 天 下 希 及 之 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-十-四-章&#34;&gt;第 四 十 四 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;名 与 身 孰 亲 。 身 与 货 孰 多 。 得 与 亡 孰 病 。
甚 爱 必 大 费 ﹔ 多 藏 必 厚 亡 。
故 知 足 不 辱 ， 知 止 不 殆 ， 可 以 长 久 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-十-五-章&#34;&gt;第 四 十 五 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;大 成 若 缺 ， 其 用 不 弊 。
大 盈 若 冲 ， 其 用 不 穷 。
大 直 若 屈 ， 大 巧 若 拙 ， 大 辩 若 讷 。
静 胜 躁 ， 寒 胜 热 。 清 静 为 天 下 正 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-十-六-章&#34;&gt;第 四 十 六 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;天 下 有 道 ， 却 走 马 以 粪 。
天 下 无 道 ， 戎 马 生 于 郊 。
祸 莫 大 于 不 知 足 ﹔ 咎 莫 大 于 欲 得 。
故 知 足 之 足 ， 常 足 矣 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-十-七-章&#34;&gt;第 四 十 七 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;不 出 户 ， 知 天 下 ﹔ 不 窥 牖 ， 见 天 道 。
其 出 弥 远 ， 其 知 弥 少 。
是 以 圣 人 不 行 而 知 ， 不 见 而 明 ， 不 为 而 成 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-十-八-章&#34;&gt;第 四 十 八 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;为 学 日 益 ， 为 道 日 损 。
损 之 又 损 ， 以 至 于 无 为 。
无 为 而 无 不 为 。
取 天 下 常 以 无 事 ， 及 其 有 事 ， 不 足 以 取 天 下 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-四-十-九-章&#34;&gt;第 四 十 九 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;圣 人 常 无 心 ， 以 百 姓 心 为 心 。
善 者 ， 吾 善 之 ﹔ 不 善 者 ， 吾 亦 善 之 ﹔ 德 善 。
信 者 ， 吾 信 之 ﹔ 不 信 者 ， 吾 亦 信 之 ﹔ 德 信 。
圣 人 在 天 下 ， 歙 歙 焉 ， 为 天 下 浑 其 心 ，
百 姓 皆 注 其 耳 目 ， 圣 人 皆 孩 之 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-十-章&#34;&gt;第 五 十 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;出 生 入 死 。
生 之 徒 ， 十 有 三 ﹔
死 之 徒 ， 十 有 三 ﹔
人 之 生 ， 动 之 于 死 地 ， 亦 十 有 三 。
夫 何 故 。
以 其 生 之 厚 。
盖 闻 善 摄 生 者 ， 路 行 不 遇 兕 虎 ， 入 军 不 被 甲 兵 ﹔
兕 无 所 投 其 角 ， 虎 无 所 用 其 爪 ， 兵 无 所 容 其 刃 。
夫 何 故 。 以 其 无 死 地 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-十-一-章&#34;&gt;第 五 十 一 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;道 生 之 ， 德 畜 之 ， 物 形 之 ， 势 成 之 。
是 以 万 物 莫 不 尊 道 而 贵 德 。
道 之 尊 ， 德 之 贵 ， 夫 莫 之 命 而 常 自 然 。
故 道 生 之 ， 德 畜 之 ﹔
长 之 育 之 ﹔ 成 之 熟 之 ﹔ 养 之 覆 之 。
生 而 不 有 ， 为 而 不 恃 ，
长 而 不 宰 。 是 谓 玄 德 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-十-二-章&#34;&gt;第 五 十 二 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;天 下 有 始 ， 以 为 天 下 母 。
既 得 其 母 ， 以 知 其 子 ，
复 守 其 母 ， 没 身 不 殆 。
塞 其 兑 ， 闭 其 门 ， 终 身 不 勤 。
开 其 兑 ， 济 其 事 ， 终 身 不 救 。
见 小 曰 明 ， 守 柔 曰 强 。
用 其 光 ， 复 归 其 明 ， 无 遗 身 殃 ﹔ 是 为 袭 常 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-十-三-章&#34;&gt;第 五 十 三 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;使 我 介 然 有 知 ， 行 于 大 道 ， 唯 施 是 畏 。
大 道 甚 夷 ， 而 人 好 径 。
朝 甚 除 ， 田 甚 芜 ， 仓 甚 虚 ﹔
服 文 采 ， 带 利 剑 ， 厌 饮 食 ，
财 货 有 余 ﹔ 是 为 盗 夸 。
非 道 也 哉 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-十-四-章&#34;&gt;第 五 十 四 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;善 建 者 不 拔 ，
善 抱 者 不 脱 ， 子 孙 以 祭 祀 不 辍 。
修 之 于 身 ， 其 德 乃 真 ﹔
修 之 于 家 ， 其 德 乃 余 ﹔
修 之 于 乡 ， 其 德 乃 长 ﹔
修 之 于 邦 ， 其 德 乃 丰 ﹔
修 之 于 天 下 ， 其 德 乃 普 。
故 以 身 观 身 ，
以 家 观 家 ， 以 乡 观 乡 ，
以 邦 观 邦 ， 以 天 下 观 天 下 。
吾 何 以 知 天 下 然 哉 。 以 此 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-十-五-章&#34;&gt;第 五 十 五 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;含 「 德 」 之 厚 ， 比 于 赤 子 。
毒 虫 不 螫 ， 猛 兽 不 据 ， 攫 鸟 不 搏 。
骨 弱 筋 柔 而 握 固 。
未 知 牝 牡 之 合 而 峻 作 ， 精 之 至 也 。
终 日 号 而 不 嗄 ， 和 之 至 也 。
知 和 曰 「 常 」 ，
知 常 曰 「 明 」 。
益 生 曰 祥 。 心 使 气 曰 强 。
物 壮 则 老 ， 谓 之 不 道 ， 不 道 早 已 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-十-六-章&#34;&gt;第 五 十 六 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;知 者 不 言 ， 言 者 不 知 。
挫 其 锐 ， 解 其 纷 ， 和 其 光 ，
同 其 尘 ， 是 谓 「 玄 同 」 。
故 不 可 得 而 亲 ， 不 可 得 而 疏 ﹔
不 可 得 而 利 ， 不 可 得 而 害 ﹔
不 可 得 而 贵 ， 不 可 得 而 贱 。 故 为 天 下 贵 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-十-七-章&#34;&gt;第 五 十 七 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;以 正 治 国 ， 以 奇 用 兵 ， 以 无 事 取 天 下 。
吾 何 以 知 其 然 哉 。 以 此 ：
天 下 多 忌 讳 ， 而 民 弥 贫 ﹔
人 多 利 器 ， 国 家 滋 昏 ﹔
人 多 伎 巧 ， 奇 物 滋 起 ﹔
法 令 滋 彰 ， 盗 贼 多 有 。
故 圣 人 云 ：
「 我 无 为 ， 而 民 自 化 ﹔
我 好 静 ， 而 民 自 正 ﹔
我 无 事 ， 而 民 自 富 ﹔
我 无 欲 ， 而 民 自 朴 。 」
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-十-八-章&#34;&gt;第 五 十 八 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;其 政 闷 闷 ， 其 民 淳 淳 ﹔
其 政 察 察 ， 其 民 缺 缺 。
是 以 圣 人 方 而 不 割 ， 廉 而 不 刿 ，
直 而 不 肆 ， 光 而 不 耀 。
祸 兮 福 之 所 倚 ， 福 兮 祸 之 所 伏 。
孰 知 其 极 。 其 无 正 也 。
正 复 为 奇 ， 善 复 为 妖 。
人 之 迷 ， 其 日 固 久 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-五-十-九-章&#34;&gt;第 五 十 九 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;治 人 事 天 ， 莫 若 啬 。
夫 唯 啬 ， 是 谓 早 服 ﹔
早 服 谓 之 重 积 德 ﹔ 重 积 德 则 无 不 克 ﹔
无 不 克 则 莫 知 其 极 ﹔ 莫 知 其 极 ， 可 以 有 国 ﹔
有 国 之 母 ， 可 以 长 久 ﹔
是 谓 深 根 固 柢 ， 长 生 久 视 之 道 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-十-章&#34;&gt;第 六 十 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;治 大 国 ， 若 烹 小 鲜 。
以 道 莅 天 下 ， 其 鬼 不 神 ﹔
非 其 鬼 不 神 ， 其 神 不 伤 人 ﹔
非 其 神 不 伤 人 ， 圣 人 亦 不 伤 人 。
夫 两 不 相 伤 ， 故 德 交 归 焉 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-十-一-章&#34;&gt;第 六 十 一 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;大 邦 者 下 流 ， 天 下 之 牝 ，
天 下 之 交 也 。
牝 常 以 静 胜 牡 ， 以 静 为 下 。
故 大 邦 以 下 小 邦 ， 则 取 小 邦 ﹔
小 邦 以 下 大 邦 ， 则 取 大 邦 。
故 或 下 以 取 ， 或 下 而 取 。
大 邦 不 过 欲 兼 畜 人 ， 小 邦 不 过 欲 入 事 人 。
夫 两 者 各 得 所 欲 ， 大 者 宜 为 下 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-十-二-章&#34;&gt;第 六 十 二 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;道 者 万 物 之 奥 。 善 人 之 宝 ， 不 善 人 之 所 保 。
美 言 可 以 市 尊 ， 美 行 可 以 加 人 。
人 之 不 善 ， 何 弃 之 有 。
故 立 天 子 ， 置 三 公 ，
虽 有 拱 璧 以 先 驷 马 ，
不 如 坐 进 此 道 。
古 之 所 以 贵 此 道 者 何 。
不 曰 ： 求 以 得 ， 有 罪 以 免 邪 。 故 为 天 下 贵 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-十-三-章&#34;&gt;第 六 十 三 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;为 无 为 ， 事 无 事 ， 味 无 味 。
图 难 于 其 易 ， 为 大 于 其 细 ﹔
天 下 难 事 ， 必 作 于 易 ，
天 下 大 事 ， 必 作 于 细 。
是 以 圣 人 终 不 为 大 ， 故 能 成 其 大 。
夫 轻 诺 必 寡 信 ， 多 易 必 多 难 。
是 以 圣 人 犹 难 之 ， 故 终 无 难 矣 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-十-四-章&#34;&gt;第 六 十 四 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;其 安 易 持 ， 其 未 兆 易 谋 。
其 脆 易 泮 ， 其 微 易 散 。
为 之 于 未 有 ， 治 之 于 未 乱 。
合 抱 之 木 ， 生 于 毫 末 ﹔
九 层 之 台 ， 起 于 累 土 ﹔
千 里 之 行 ， 始 于 足 下。
民 之 从 事 ， 常 于 几 成 而 败 之 。
慎 终 如 始 ， 则 无 败 事 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-十-五-章&#34;&gt;第 六 十 五 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;古 之 善 为 道 者 ， 非 以 明 民 ， 将 以 愚 之 。
民 之 难 治 ， 以 其 智 多 。
故 以 智 治 国 ， 国 之 贼 ﹔
不 以 智 治 国 ， 国 之 福 。
知 此 两 者 亦 稽 式 。
常 知 稽 式 ， 是 谓 「 玄 德 」 。
「 玄 德 」 深 矣 ， 远 矣 ， 与 物 反 矣 ， 然 后 乃 至 大 顺 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-十-六-章&#34;&gt;第 六 十 六 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;江 海 之 所 以 能 为 百 谷 王 者 ，
以 其 善 下 之 ， 故 能 为 百 谷 王 。
是 以 圣 人 欲 上 民 ， 必 以 言 下 之 ﹔
欲 先 民 ， 必 以 身 后 之 。
是 以 圣 人 处 上 而 民 不 重 ， 处 前 而 民 不 害 。
是 以 天 下 乐 推 而 不 厌 。
以 其 不 争 ， 故 天 下 莫 能 与 之 争 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-十-七-章&#34;&gt;第 六 十 七 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;天 下 皆 谓 我 道 大 ， 似 不 肖 。
夫 唯 大 ， 故 似 不 肖 。
若 肖 ， 久 矣 其 细 也 夫 。
我 有 三 宝 ， 持 而 保 之 。
一 曰 慈 ，
二 曰 俭 ，
三 曰 不 敢 为 天 下 先 。
慈 故 能 勇 ﹔ 俭 故 能 广 ﹔
不 敢 为 天 下 先 ， 故 能 成 器 长 。
今 舍 慈 且 勇 ﹔ 舍 俭 且 广 ﹔
舍 后 且 先 ﹔ 死 矣 。
夫 慈 以 战 则 胜 ， 以 守 则 固 。
天 将 救 之 ， 以 慈 卫 之 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-十-八-章&#34;&gt;第 六 十 八 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;善 为 士 者 ， 不 武 ﹔
善 战 者 ， 不 怒 ﹔
善 胜 敌 者 ， 不 与 ﹔
善 用 人 者 ， 为 之 下 。
是 谓 不 争 之 德 ，
是 谓 用 人 之 力 ，
是 谓 配 天 古 之 极 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-六-十-九-章&#34;&gt;第 六 十 九 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;用 兵 有 言 ：
「 吾 不 敢 为 主 ， 而 为 客 ﹔
不 敢 进 寸 ， 而 退 尺 。 」
是 谓 行 无 行 ﹔ 攘 无 臂 ﹔
扔 无 敌 ﹔ 执 无 兵 。
祸 莫 大 于 轻 敌 ， 轻 敌 几 丧 吾 宝 。
故 抗 兵 相 若 ， 哀 者 胜 矣 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-十-章&#34;&gt;第 七 十 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;吾 言 甚 易 知 ， 甚 易 行 。
天 下 莫 能 知 ， 莫 能 行 。
言 有 宗 ， 事 有 君 。
夫 唯 无 知 ， 是 以 不 我 知 。
知 我 者 希 ， 则 我 者 贵 。
是 以 圣 人 被 褐 而 怀 玉 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-十-一-章&#34;&gt;第 七 十 一 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;知 不 知 ， 尚 矣 ﹔ 不 知 知 ， 病 也 。
圣 人 不 病 ， 以 其 病 病 。
夫 唯 病 病 ， 是 以 不 病 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-十-二-章&#34;&gt;第 七 十 二 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;民 不 畏 威 ，
则 大 威 至 。
无 狎 其 所 居 ，
无 厌 其 所 生 。
夫 唯 不 厌 ，
是 以 不 厌 。
是 以 圣 人 自 知 不 自 见 ﹔
自 爱 不 自 贵 。
故 去 彼 取 此 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-十-三-章&#34;&gt;第 七 十 三 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;勇 于 敢 则 杀 ， 勇 于 不 敢 则 活 。
此 两 者 ， 或 利 或 害 。
天 之 所 恶 ， 孰 知 其 故 。
天 之 道 ，
不 争 而 善 胜 ， 不 言 而 善 应 ，
不 召 而 自 来 ， 繟 然 而 善 谋 。
天 网 恢 恢 ， 疏 而 不 失 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-十-四-章&#34;&gt;第 七 十 四 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;民 不 畏 死 ， 奈 何 以 死 惧 之 。
若 使 民 常 畏 死 ， 而 为 奇 者 ，
吾 得 执 而 杀 之 ， 孰 敢 。
常 有 司 杀 者 杀 。
夫 代 司 杀 者 杀 ， 是 谓 代 大 匠 斲 ，
夫 代 大 匠 斲 者 ， 希 有 不 伤 其 手 矣 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-十-五-章&#34;&gt;第 七 十 五 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;民 之 饥 ， 以 其 上 食 税 之 多 ， 是 以 饥 。
民 之 难 治 ， 以 其 上 之 有 为 ， 是 以 难 治 。
民 之 轻 死 ， 以 其 上 求 生 之 厚 ， 是 以 轻 死 。
夫 唯 无 以 生 为 者 ， 是 贤 于 贵 生 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-十-六-章&#34;&gt;第 七 十 六 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;人 之 生 也 柔 弱 ， 其 死 也 坚 强 。
草 木 之 生 也 柔 脆 ， 其 死 也 枯 槁 。
故 坚 强 者 死 之 徒 ， 柔 弱 者 生 之 徒 。
是 以 兵 强 则 灭 ， 木 强 则 折 。
强 大 处 下 ， 柔 弱 处 上 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-十-七-章&#34;&gt;第 七 十 七 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;天 之 道 ， 其 犹 张 弓 欤 。
高 者 抑 之 ， 下 者 举 之 ﹔
有 余 者 损 之 ， 不 足 者 补 之 。
天 之 道 ， 损 有 余 而 补 不 足 。
人 之 道 ， 则 不 然 ， 损 不 足 以 奉 有 余 。
孰 能 有 余 以 奉 天 下 ， 唯 有 道 者 。
是 以 圣 人 为 而 不 恃 ， 功 成 而 不 处 ， 其 不 欲 见 贤 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-十-八-章&#34;&gt;第 七 十 八 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;天 下 莫 柔 弱 于 水 ， 而 攻 坚 强 者 莫 之 能 胜 ， 以 其 无 以 易 之 。
弱 之 胜 强 ， 柔 之 胜 刚 ，
天 下 莫 不 知 ， 莫 能 行 。
是 以 圣 人 云 ：
「 受 国 之 垢 ， 是 谓 社 稷 主 ﹔
受 国 不 祥 ， 是 为 天 下 王 。 」
正 言 若 反 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-七-十-九-章&#34;&gt;第 七 十 九 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;和 大 怨 ， 必 有 余 怨 ﹔
报 怨 以 德 ， 安 可 以 为 善 。
是 以 圣 人 执 左 契 ， 而 不 责 于 人 。
有 德 司 契 ， 无 德 司 彻 。
天 道 无 亲 ， 常 与 善 人 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-八-十-章&#34;&gt;第 八 十 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;小 国 寡 民 。
使 有 什 伯 之 器 而 不 用 ﹔
使 民 重 死 而 不 远 徙 。
虽 有 舟 舆 ， 无 所 乘 之 ，
虽 有 甲 兵 ， 无 所 陈 之 。
使 民 复 结 绳 而 用 之 。
甘 其 食 ， 美 其 服 ， 安 其 居 ， 乐 其 俗 。
邻 国 相 望 ， 鸡 犬 之 声 相 闻 ，
民 至 老 死 ， 不 相 往 来 。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第-八-十-一-章&#34;&gt;第 八 十 一 章&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;信 言 不 美 ， 美 言 不 信 。
善 者 不 辩 ， 辩 者 不 善 。
知 者 不 博 ， 博 者 不 知 。
圣 人 不 积 ， 既 以 为 人 己 愈 有 ，
既 以 与 人 己 愈 多 。
天 之 道 ， 利 而 不 害 ﹔
圣 人 之 道 ， 为 而 不 争 。
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Go - See what packages my app imports</title>
      <link>http://alimy.me/post/dev_201604101827/</link>
      <pubDate>Sun, 10 Apr 2016 18:27:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201604101827/</guid>
      <description>&lt;p&gt;It’s often practical to see what packages your app is importing. Unfortunately there isn’t a simple way to do that, however it is doable via the go list tool and using templates.&lt;/p&gt;

&lt;p&gt;Go to your app and run the following.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go list -f &#39;{{join .Deps &amp;quot;\n&amp;quot;}}&#39; |  xargs go list -f &#39;{{if not .Standard}}{{.ImportPath}}{{end}}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is an example with the clirescue refactoring example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/GoBootcamp/clirescue
$ go list -f &#39;{{join .Deps &amp;quot;\n&amp;quot;}}&#39; | xargs go list -f &#39;{{if not .Standard}}{{.ImportPath}}{{end}}&#39;
github.com/GoBootcamp/clirescue/cmdutil
github.com/GoBootcamp/clirescue/trackerapi
github.com/GoBootcamp/clirescue/user
github.com/codegangsta/cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want the list to also contain standard packages, edit the template and use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go list -f &#39;{{join .Deps &amp;quot;\n&amp;quot;}}&#39; |  xargs go list -f &#39;{{.ImportPath}}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>爱</title>
      <link>http://alimy.me/post/art_201604091521/</link>
      <pubDate>Sat, 09 Apr 2016 15:21:01 CST</pubDate>
      
      <guid>http://alimy.me/post/art_201604091521/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://alimy.me/images/post/20160409152101.jpg&#34; title=&#34;点击查看大图&#34;&gt;&lt;img src=&#34;http://alimy.me/images/post/20160409152100.webp&#34; alt=&#34;图片加载中...使用支持Webp的浏览器可以加速查看&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;繁星点点（&lt;a href=&#34;http://alimy.me/images/post/20160409152101.webp&#34; title=&#34;webp格式图片&#34;&gt;查看大图&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Go - EBNF</title>
      <link>http://alimy.me/post/dev_201604021445/</link>
      <pubDate>Sat, 02 Apr 2016 14:45:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201604021445/</guid>
      <description>&lt;h3 id=&#34;notation&#34;&gt;Notation&lt;/h3&gt;

&lt;p&gt;The syntax is specified using Extended Backus-Naur Form (EBNF):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Production  = production_name &amp;quot;=&amp;quot; [ Expression ] &amp;quot;.&amp;quot; .
Expression  = Alternative { &amp;quot;|&amp;quot; Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ &amp;quot;…&amp;quot; token ] | Group | Option | Repetition .
Group       = &amp;quot;(&amp;quot; Expression &amp;quot;)&amp;quot; .
Option      = &amp;quot;[&amp;quot; Expression &amp;quot;]&amp;quot; .
Repetition  = &amp;quot;{&amp;quot; Expression &amp;quot;}&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Productions are expressions constructed from terms and the following operators, in increasing precedence:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lower-case production names are used to identify lexical tokens. Non-terminals are in CamelCase. Lexical tokens are enclosed in double quotes &amp;ldquo;&amp;rdquo; or back quotes ``.

The form a … b represents the set of characters from a through b as alternatives. The horizontal ellipsis … is also used elsewhere in the spec to informally denote various enumerations or code snippets that are not further specified. The character … (as opposed to the three characters &amp;hellip;) is not a token of the Go language.&lt;/p&gt;

&lt;h3 id=&#34;go-ebnf&#34;&gt;Go EBNF&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Characters&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;newline        = /* the Unicode code point U+000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as &amp;quot;Letter&amp;quot; */ .
unicode_digit  = /* a Unicode code point classified as &amp;quot;Number, decimal digit&amp;quot; */ .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Letters and digits&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;letter        = unicode_letter | &amp;quot;_&amp;quot; .
decimal_digit = &amp;quot;0&amp;quot; … &amp;quot;9&amp;quot; .
octal_digit   = &amp;quot;0&amp;quot; … &amp;quot;7&amp;quot; .
hex_digit     = &amp;quot;0&amp;quot; … &amp;quot;9&amp;quot; | &amp;quot;A&amp;quot; … &amp;quot;F&amp;quot; | &amp;quot;a&amp;quot; … &amp;quot;f&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Identifiers&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;identifier = letter { letter | unicode_digit } .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Keywords&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Operators and Delimiters&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;     +=    &amp;amp;=     &amp;amp;&amp;amp;    ==    !=    (    )    +
|     -=    |=     ||    &amp;lt;     &amp;lt;=    [    ]    -
^     *=    ^=     &amp;lt;-    &amp;gt;     &amp;gt;=    {    }    *
/    &amp;lt;&amp;lt;    /=    &amp;lt;&amp;lt;=    ++    =     :=    ,    ;
%    &amp;gt;&amp;gt;    %=    &amp;gt;&amp;gt;=    --    !     ...   .    :
     &amp;amp;^          &amp;amp;^=
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integer literals&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int_lit     = decimal_lit | octal_lit | hex_lit .
decimal_lit = ( &amp;quot;1&amp;quot; … &amp;quot;9&amp;quot; ) { decimal_digit } .
octal_lit   = &amp;quot;0&amp;quot; { octal_digit } .
hex_lit     = &amp;quot;0&amp;quot; ( &amp;quot;x&amp;quot; | &amp;quot;X&amp;quot; ) hex_digit { hex_digit } .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Floating-point literals&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float_lit = decimals &amp;quot;.&amp;quot; [ decimals ] [ exponent ] |
            decimals exponent |
            &amp;quot;.&amp;quot; decimals [ exponent ] .
decimals  = decimal_digit { decimal_digit } .
exponent  = ( &amp;quot;e&amp;quot; | &amp;quot;E&amp;quot; ) [ &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; ] decimals .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Imaginary literals&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;imaginary_lit = (decimals | float_lit) &amp;quot;i&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rune literals&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\&#39;   U+0027 single quote  (valid escape only within rune literals)
\&amp;quot;   U+0022 double quote  (valid escape only within string literals)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;rune_lit         = &amp;quot;&#39;&amp;quot; ( unicode_value | byte_value ) &amp;quot;&#39;&amp;quot; .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` &amp;quot;x&amp;quot; hex_digit hex_digit .
little_u_value   = `\` &amp;quot;u&amp;quot; hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` &amp;quot;U&amp;quot; hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( &amp;quot;a&amp;quot; | &amp;quot;b&amp;quot; | &amp;quot;f&amp;quot; | &amp;quot;n&amp;quot; | &amp;quot;r&amp;quot; | &amp;quot;t&amp;quot; | &amp;quot;v&amp;quot; | `\` | &amp;quot;&#39;&amp;quot; | `&amp;quot;` ) .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String literals&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = &amp;quot;`&amp;quot; { unicode_char | newline } &amp;quot;`&amp;quot; .
interpreted_string_lit = `&amp;quot;` { unicode_value | byte_value } `&amp;quot;` .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Type      = TypeName | TypeLit | &amp;quot;(&amp;quot; Type &amp;quot;)&amp;quot; .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
            SliceType | MapType | ChannelType .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Numeric types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32

uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Array types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayType   = &amp;quot;[&amp;quot; ArrayLength &amp;quot;]&amp;quot; ElementType .
ArrayLength = Expression .
ElementType = Type .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slice types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SliceType = &amp;quot;[&amp;quot; &amp;quot;]&amp;quot; ElementType .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;make([]T, length, capacity)
make([]int, 50, 100)
new([100]int)[0:50]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Struct types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;StructType     = &amp;quot;struct&amp;quot; &amp;quot;{&amp;quot; { FieldDecl &amp;quot;;&amp;quot; } &amp;quot;}&amp;quot; .
FieldDecl      = (IdentifierList Type | AnonymousField) [ Tag ] .
AnonymousField = [ &amp;quot;*&amp;quot; ] TypeName .
Tag            = string_lit .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pointer types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PointerType = &amp;quot;*&amp;quot; BaseType .
BaseType    = Type .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FunctionType   = &amp;quot;func&amp;quot; Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = &amp;quot;(&amp;quot; [ ParameterList [ &amp;quot;,&amp;quot; ] ] &amp;quot;)&amp;quot; .
ParameterList  = ParameterDecl { &amp;quot;,&amp;quot; ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ &amp;quot;...&amp;quot; ] Type .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Interface types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;InterfaceType      = &amp;quot;interface&amp;quot; &amp;quot;{&amp;quot; { MethodSpec &amp;quot;;&amp;quot; } &amp;quot;}&amp;quot; .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Map types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MapType     = &amp;quot;map&amp;quot; &amp;quot;[&amp;quot; KeyType &amp;quot;]&amp;quot; ElementType .
KeyType     = Type .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Channel types&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ChannelType = ( &amp;quot;chan&amp;quot; | &amp;quot;chan&amp;quot; &amp;quot;&amp;lt;-&amp;quot; | &amp;quot;&amp;lt;-&amp;quot; &amp;quot;chan&amp;quot; ) ElementType .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;chan T          // can be used to send and receive values of type T
chan&amp;lt;- float64  // can only be used to send float64s
&amp;lt;-chan int      // can only be used to receive ints

chan&amp;lt;- chan int    // same as chan&amp;lt;- (chan int)
chan&amp;lt;- &amp;lt;-chan int  // same as chan&amp;lt;- (&amp;lt;-chan int)
&amp;lt;-chan &amp;lt;-chan int  // same as &amp;lt;-chan (&amp;lt;-chan int)
chan (&amp;lt;-chan int)

make(chan int, 100)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Type identity&lt;/p&gt;

&lt;p&gt;Two types are either identical or different.&lt;/p&gt;

&lt;p&gt;Two named types are identical if their type names originate in the same TypeSpec. A named and an unnamed type are always different. Two unnamed types are identical if the corresponding type literals are identical, that is, if they have the same literal structure and corresponding components have identical types. In detail:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Two &lt;strong&gt;array&lt;/strong&gt; types are identical if they have identical element types and the same array length.&lt;/li&gt;
&lt;li&gt;Two &lt;strong&gt;slice&lt;/strong&gt; types are identical if they have identical element types.&lt;/li&gt;
&lt;li&gt;Two &lt;strong&gt;struct&lt;/strong&gt; types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags. Two anonymous fields are considered to have the same name. Lower-case field names from different packages are always different.&lt;/li&gt;
&lt;li&gt;Two &lt;strong&gt;pointer&lt;/strong&gt; types are identical if they have identical base types.&lt;/li&gt;
&lt;li&gt;Two &lt;strong&gt;function&lt;/strong&gt; types are identical if they have the same &lt;em&gt;number of parameters and result values, corresponding parameter and result types&lt;/em&gt; are identical, and either both functions are variadic or neither is. Parameter and result names are not required to match.&lt;/li&gt;
&lt;li&gt;Two &lt;strong&gt;interface&lt;/strong&gt; types are identical if they have the same set of methods with the same names and identical function types. Lower-case method names from different packages are always different. The order of the methods is irrelevant.&lt;/li&gt;
&lt;li&gt;Two &lt;strong&gt;map&lt;/strong&gt; types are identical if they have identical key and value types.&lt;/li&gt;
&lt;li&gt;Two &lt;strong&gt;channel&lt;/strong&gt; types are identical if they have identical value types and the same direction.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Assignability&lt;/p&gt;

&lt;p&gt;A value x is assignable to a variable of type T (&amp;ldquo;x is assignable to T&amp;rdquo;) in any of these cases:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;x&amp;rsquo;s type is identical to T.&lt;/li&gt;
&lt;li&gt;x&amp;rsquo;s type V and T have identical underlying types and at least one of V or T is not a named type.&lt;/li&gt;
&lt;li&gt;T is an interface type and x implements T.&lt;/li&gt;
&lt;li&gt;x is a bidirectional channel value, T is a channel type, x&amp;rsquo;s type V and T have identical element types, and at least one of V or T is not a named type.&lt;/li&gt;
&lt;li&gt;x is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or interface type.&lt;/li&gt;
&lt;li&gt;x is an untyped constant representable by a value of type T.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Blocks&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Block = &amp;quot;{&amp;quot; StatementList &amp;quot;}&amp;quot; .
StatementList = { Statement &amp;quot;;&amp;quot; } .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Declarations and scope&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Predeclared identifiers&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Types:
    bool byte complex64 complex128 error float32 float64
    int int8 int16 int32 int64 rune string
    uint uint8 uint16 uint32 uint64 uintptr

Constants:
    true false iota

Zero value:
    nil

Functions:
    append cap close complex copy delete imag len
    make new panic print println real recover
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exported identifiers&lt;/p&gt;

&lt;p&gt;An identifier may be exported to permit access to it from another package. An identifier is exported if both:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the first character of the identifier&amp;rsquo;s name is a Unicode upper case letter (Unicode class &amp;ldquo;Lu&amp;rdquo;); and&lt;/li&gt;
&lt;li&gt;the identifier is declared in the package block or it is a field name or method name.
All other identifiers are not exported.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uniqueness of identifiers&lt;/p&gt;

&lt;p&gt;Given a set of identifiers, an identifier is called unique if it is different from every other in the set. Two identifiers are different if they are spelled differently, or if they appear in different packages and are not exported. Otherwise, they are the same.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Constant declarations&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ConstDecl      = &amp;quot;const&amp;quot; ( ConstSpec | &amp;quot;(&amp;quot; { ConstSpec &amp;quot;;&amp;quot; } &amp;quot;)&amp;quot; ) .
ConstSpec      = IdentifierList [ [ Type ] &amp;quot;=&amp;quot; ExpressionList ] .

IdentifierList = identifier { &amp;quot;,&amp;quot; identifier } .
ExpressionList = Expression { &amp;quot;,&amp;quot; Expression } .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Iota
Within a constant declaration, the predeclared identifier iota represents successive untyped integer constants. It is reset to 0 whenever the reserved word const appears in the source and increments after each ConstSpec. It can be used to construct a set of related constants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const ( // iota is reset to 0
    c0 = iota  // c0 == 0
    c1 = iota  // c1 == 1
    c2 = iota  // c2 == 2
)

const ( // iota is reset to 0
    a = 1 &amp;lt;&amp;lt; iota  // a == 1
    b = 1 &amp;lt;&amp;lt; iota  // b == 2
    c = 3          // c == 3  (iota is not used but still incremented)
    d = 1 &amp;lt;&amp;lt; iota  // d == 8
)

const ( // iota is reset to 0
    u         = iota * 42  // u == 0     (untyped integer constant)
    v float64 = iota * 42  // v == 42.0  (float64 constant)
    w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0  (iota has been reset)
const y = iota  // y == 0  (iota has been reset)

const (
    bit0, mask0 = 1 &amp;lt;&amp;lt; iota, 1&amp;lt;&amp;lt;iota - 1  // bit0 == 1, mask0 == 0
    bit1, mask1                           // bit1 == 2, mask1 == 1
    _, _                                  // skips iota == 2
    bit3, mask3                           // bit3 == 8, mask3 == 7
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Type declarations&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TypeDecl     = &amp;quot;type&amp;quot; ( TypeSpec | &amp;quot;(&amp;quot; { TypeSpec &amp;quot;;&amp;quot; } &amp;quot;)&amp;quot; ) .
TypeSpec     = identifier Type .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;type IntArray [16]int

type (
    Point struct{ x, y float64 }
    Polar Point
)

type TreeNode struct {
    left, right *TreeNode
    value *Comparable
}

type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The declared type does not inherit any methods bound to the existing type, but the method set of an interface type or of elements of a composite type remains unchanged:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock implementation */ }
func (m *Mutex) Unlock()  { /* Unlock implementation */ }

// NewMutex has the same composition as Mutex but its method set is empty.
type NewMutex Mutex

// The method set of the base type of PtrMutex remains unchanged,
// but the method set of PtrMutex is empty.
type PtrMutex *Mutex

// The method set of *PrintableMutex contains the methods
// Lock and Unlock bound to its anonymous field Mutex.
type PrintableMutex struct {
    Mutex
}

// MyBlock is an interface type that has the same method set as Block.
type MyBlock Block
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A type declaration may be used to define a different boolean, numeric, or string type and attach methods to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type TimeZone int

const (
    EST TimeZone = -(5 + iota)
    CST
    MST
    PST
)

func (tz TimeZone) String() string {
    return fmt.Sprintf(&amp;quot;GMT%+dh&amp;quot;, tz)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Variable declarations&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VarDecl     = &amp;quot;var&amp;quot; ( VarSpec | &amp;quot;(&amp;quot; { VarSpec &amp;quot;;&amp;quot; } &amp;quot;)&amp;quot; ) .
VarSpec     = IdentifierList ( Type [ &amp;quot;=&amp;quot; ExpressionList ] | &amp;quot;=&amp;quot; ExpressionList ) .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Short variable declarations&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ShortVarDecl = IdentifierList &amp;quot;:=&amp;quot; ExpressionList .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is shorthand for a regular variable declaration with initializer expressions but no types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;var&amp;quot; IdentifierList = ExpressionList .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w := os.Pipe(fd)  // os.Pipe() returns two values
_, y, _ := coord(p)  // coord() returns three values; only interested in y coordinate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike regular variable declarations, a short variable declaration may redeclare variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-blank variables is new. As a consequence, redeclaration can only appear in a multi-variable short declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the original.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclares offset
a, a := 1, 2       // illegal: double declaration of a or no new variable if a was declared elsewhere
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Short variable declarations may appear only inside functions. In some contexts such as the initializers for &amp;ldquo;if&amp;rdquo;, &amp;ldquo;for&amp;rdquo;, or &amp;ldquo;switch&amp;rdquo; statements, they can be used to declare local temporary variables.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function declarations&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FunctionDecl = &amp;quot;func&amp;quot; FunctionName ( Function | Signature ) .
FunctionName = identifier .
Function     = Signature FunctionBody .
FunctionBody = Block .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Method declarations&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MethodDecl   = &amp;quot;func&amp;quot; Receiver MethodName ( Function | Signature ) .
Receiver     = Parameters .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Operands&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Operand     = Literal | OperandName | MethodExpr | &amp;quot;(&amp;quot; Expression &amp;quot;)&amp;quot; .
Literal     = BasicLit | CompositeLit | FunctionLit .
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
OperandName = identifier | QualifiedIdent.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Qualified identifiers&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;QualifiedIdent = PackageName &amp;quot;.&amp;quot; identifier .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Composite literals&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | &amp;quot;[&amp;quot; &amp;quot;...&amp;quot; &amp;quot;]&amp;quot; ElementType |
                SliceType | MapType | TypeName .
LiteralValue  = &amp;quot;{&amp;quot; [ ElementList [ &amp;quot;,&amp;quot; ] ] &amp;quot;}&amp;quot; .
ElementList   = KeyedElement { &amp;quot;,&amp;quot; KeyedElement } .
KeyedElement  = [ Key &amp;quot;:&amp;quot; ] Element .
Key           = FieldName | Expression | LiteralValue .
FieldName     = identifier .
Element       = Expression | LiteralValue .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function literals&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FunctionLit = &amp;quot;func&amp;quot; Function .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Primary expressions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PrimaryExpr =
    Operand |
    Conversion |
    PrimaryExpr Selector |
    PrimaryExpr Index |
    PrimaryExpr Slice |
    PrimaryExpr TypeAssertion |
    PrimaryExpr Arguments .

Selector       = &amp;quot;.&amp;quot; identifier .
Index          = &amp;quot;[&amp;quot; Expression &amp;quot;]&amp;quot; .
Slice          = &amp;quot;[&amp;quot; ( [ Expression ] &amp;quot;:&amp;quot; [ Expression ] ) |
                  ( [ Expression ] &amp;quot;:&amp;quot; Expression &amp;quot;:&amp;quot; Expression )
                 &amp;quot;]&amp;quot; .
TypeAssertion  = &amp;quot;.&amp;quot; &amp;quot;(&amp;quot; Type &amp;quot;)&amp;quot; .
Arguments      = &amp;quot;(&amp;quot; [ ( ExpressionList | Type [ &amp;quot;,&amp;quot; ExpressionList ] ) [ &amp;quot;...&amp;quot; ] [ &amp;quot;,&amp;quot; ] ] &amp;quot;)&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Selectors&lt;/p&gt;

&lt;p&gt;For a primary expression x that is not a package name, the selector expression&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x.f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;denotes the field or method f of the value x (or sometimes *x; see below). The identifier f is called the (field or method) selector; it must not be the blank identifier. The type of the selector expression is the type of f. If x is a package name, see the section on qualified identifiers.&lt;/p&gt;

&lt;p&gt;A selector f may denote a field or method f of a type T, or it may refer to a field or method f of a nested anonymous field of T. The number of anonymous fields traversed to reach f is called its depth in T. The depth of a field or method f declared in T is zero. The depth of a field or method f declared in an anonymous field A in T is the depth of f in A plus one.&lt;/p&gt;

&lt;p&gt;The following rules apply to selectors:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;For a value x of type T or *T where T is not a pointer or interface type, x.f denotes the field or method at the shallowest depth in T where there is such an f. If there is not exactly one f with shallowest depth, the selector expression is illegal.&lt;/li&gt;
&lt;li&gt;For a value x of type I where I is an interface type, x.f denotes the actual method with name f of the dynamic value of x. If there is no method with name f in the method set of I, the selector expression is illegal.&lt;/li&gt;
&lt;li&gt;As an exception, if the type of x is a named pointer type and (*x).f is a valid selector expression denoting a field (but not a method), x.f is shorthand for (*x).f.&lt;/li&gt;
&lt;li&gt;In all other cases, x.f is illegal.&lt;/li&gt;
&lt;li&gt;If x is of pointer type and has the value nil and x.f denotes a struct field, assigning to or evaluating x.f causes a run-time panic.&lt;/li&gt;
&lt;li&gt;If x is of interface type and has the value nil, calling or evaluating the method x.f causes a run-time panic.
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Method expressions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MethodExpr    = ReceiverType &amp;quot;.&amp;quot; MethodName .
ReceiverType  = TypeName | &amp;quot;(&amp;quot; &amp;quot;*&amp;quot; TypeName &amp;quot;)&amp;quot; | &amp;quot;(&amp;quot; ReceiverType &amp;quot;)&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Index expressions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a[x]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slice expressions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a[low : high]

a[low : high : max]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Type assertions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x.(T)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f(a1, a2, … an)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Passing arguments to &amp;hellip; parameters&lt;/p&gt;

&lt;p&gt;Given the function and calls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Greeting(prefix string, who ...string)
Greeting(&amp;quot;nobody&amp;quot;)
Greeting(&amp;quot;hello:&amp;quot;, &amp;quot;Joe&amp;quot;, &amp;quot;Anna&amp;quot;, &amp;quot;Eileen&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given the slice s and call&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s := []string{&amp;quot;James&amp;quot;, &amp;quot;Jasmine&amp;quot;}
Greeting(&amp;quot;goodbye:&amp;quot;, s...)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &amp;quot;||&amp;quot; | &amp;quot;&amp;amp;&amp;amp;&amp;quot; | rel_op | add_op | mul_op .
rel_op     = &amp;quot;==&amp;quot; | &amp;quot;!=&amp;quot; | &amp;quot;&amp;lt;&amp;quot; | &amp;quot;&amp;lt;=&amp;quot; | &amp;quot;&amp;gt;&amp;quot; | &amp;quot;&amp;gt;=&amp;quot; .
add_op     = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;|&amp;quot; | &amp;quot;^&amp;quot; .
mul_op     = &amp;quot;*&amp;quot; | &amp;quot;/&amp;quot; | &amp;quot;%&amp;quot; | &amp;quot;&amp;lt;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;gt;&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;amp;^&amp;quot; .

unary_op   = &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;!&amp;quot; | &amp;quot;^&amp;quot; | &amp;quot;*&amp;quot; | &amp;quot;&amp;amp;&amp;quot; | &amp;quot;&amp;lt;-&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Operator precedence&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Precedence    Operator
5             *  /  %  &amp;lt;&amp;lt;  &amp;gt;&amp;gt;  &amp;amp;  &amp;amp;^
4             +  -  |  ^
3             ==  !=  &amp;lt;  &amp;lt;=  &amp;gt;  &amp;gt;=
2             &amp;amp;&amp;amp;
1             ||
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Arithmetic operators&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sum                    integers, floats, complex values, strings&lt;/li&gt;
&lt;li&gt;difference             integers, floats, complex values&lt;/li&gt;
&lt;li&gt;product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;amp;    bitwise AND            integers
|    bitwise OR             integers
^    bitwise XOR            integers
&amp;amp;^   bit clear (AND NOT)    integers&lt;/p&gt;

&lt;p&gt;&amp;lt;&amp;lt;   left shift             integer &amp;lt;&amp;lt; unsigned integer
&amp;gt;&amp;gt;   right shift            integer &amp;gt;&amp;gt; unsigned integer
```&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Comparison operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==    equal
!=    not equal
&amp;lt;     less
&amp;lt;=    less or equal
&amp;gt;     greater
&amp;gt;=    greater or equal
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Logical operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;&amp;amp;    conditional AND    p &amp;amp;&amp;amp; q  is  &amp;quot;if p then q else false&amp;quot;
||    conditional OR     p || q  is  &amp;quot;if p then true else q&amp;quot;
!     NOT                !p      is  &amp;quot;not p&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Address operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;x
&amp;amp;a[f(2)]
&amp;amp;Point{2, 3}
*p
*pf(x)

var x *int = nil
*x   // causes a run-time panic
&amp;amp;*x  // causes a run-time panic
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Receive operator&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;v1 := &amp;lt;-ch
v2 = &amp;lt;-ch
f(&amp;lt;-ch)
&amp;lt;-strobe  // wait until clock pulse and discard received value

x, ok = &amp;lt;-ch
x, ok := &amp;lt;-ch
var x, ok = &amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conversions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Conversion = Type &amp;quot;(&amp;quot; Expression [ &amp;quot;,&amp;quot; ] &amp;quot;)&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Statement =
    Declaration | LabeledStmt | SimpleStmt |
    GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
    FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
    DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Empty statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EmptyStmt = .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Labeled statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LabeledStmt = Label &amp;quot;:&amp;quot; Statement .
Label       = identifier .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Expression statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ExpressionStmt = Expression .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following built-in functions are not permitted in statement context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;append cap complex imag len make new real
unsafe.Alignof unsafe.Offsetof unsafe.Sizeof
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Send statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SendStmt = Channel &amp;quot;&amp;lt;-&amp;quot; Expression .
Channel  = Expression .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IncDec statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IncDecStmt = Expression ( &amp;quot;++&amp;quot; | &amp;quot;--&amp;quot; ) .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Assignments&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Assignment = ExpressionList assign_op ExpressionList .

assign_op = [ add_op | mul_op ] &amp;quot;=&amp;quot; .

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IfStmt = &amp;quot;if&amp;quot; [ SimpleStmt &amp;quot;;&amp;quot; ] Expression Block [ &amp;quot;else&amp;quot; ( IfStmt | Block ) ] .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Switch statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Expression switches&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ExprSwitchStmt = &amp;quot;switch&amp;quot; [ SimpleStmt &amp;quot;;&amp;quot; ] [ Expression ] &amp;quot;{&amp;quot; { ExprCaseClause } &amp;quot;}&amp;quot; .
ExprCaseClause = ExprSwitchCase &amp;quot;:&amp;quot; StatementList .
ExprSwitchCase = &amp;quot;case&amp;quot; ExpressionList | &amp;quot;default&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Type switches&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch x.(type) {
// cases
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;TypeSwitchStmt  = &amp;quot;switch&amp;quot; [ SimpleStmt &amp;quot;;&amp;quot; ] TypeSwitchGuard &amp;quot;{&amp;quot; { TypeCaseClause } &amp;quot;}&amp;quot; .
TypeSwitchGuard = [ identifier &amp;quot;:=&amp;quot; ] PrimaryExpr &amp;quot;.&amp;quot; &amp;quot;(&amp;quot; &amp;quot;type&amp;quot; &amp;quot;)&amp;quot; .
TypeCaseClause  = TypeSwitchCase &amp;quot;:&amp;quot; StatementList .
TypeSwitchCase  = &amp;quot;case&amp;quot; TypeList | &amp;quot;default&amp;quot; .
TypeList        = Type { &amp;quot;,&amp;quot; Type } .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ForStmt = &amp;quot;for&amp;quot; [ Condition | ForClause | RangeClause ] Block .
Condition = Expression .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ForClause = [ InitStmt ] &amp;quot;;&amp;quot; [ Condition ] &amp;quot;;&amp;quot; [ PostStmt ] .
InitStmt = SimpleStmt .
PostStmt = SimpleStmt .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;RangeClause = [ ExpressionList &amp;quot;=&amp;quot; | IdentifierList &amp;quot;:=&amp;quot; ] &amp;quot;range&amp;quot; Expression .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Range expression                          1st value          2nd value

array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E
string          s  string type            index    i  int    see below  rune
map             m  map[K]V                key      k  K      m[k]       V
channel         c  chan E, &amp;lt;-chan E       element  e  E
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Go statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GoStmt = &amp;quot;go&amp;quot; Expression .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Select statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SelectStmt = &amp;quot;select&amp;quot; &amp;quot;{&amp;quot; { CommClause } &amp;quot;}&amp;quot; .
CommClause = CommCase &amp;quot;:&amp;quot; StatementList .
CommCase   = &amp;quot;case&amp;quot; ( SendStmt | RecvStmt ) | &amp;quot;default&amp;quot; .
RecvStmt   = [ ExpressionList &amp;quot;=&amp;quot; | IdentifierList &amp;quot;:=&amp;quot; ] RecvExpr .
RecvExpr   = Expression .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Return statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ReturnStmt = &amp;quot;return&amp;quot; [ ExpressionList ] .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Break statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BreakStmt = &amp;quot;break&amp;quot; [ Label ] .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Continue statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ContinueStmt = &amp;quot;continue&amp;quot; [ Label ] .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Goto statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GotoStmt = &amp;quot;goto&amp;quot; Label .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fallthrough statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FallthroughStmt = &amp;quot;fallthrough&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Defer statements&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DeferStmt = &amp;quot;defer&amp;quot; Expression .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Source file organization&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SourceFile       = PackageClause &amp;quot;;&amp;quot; { ImportDecl &amp;quot;;&amp;quot; } { TopLevelDecl &amp;quot;;&amp;quot; } .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Package clause&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PackageClause  = &amp;quot;package&amp;quot; PackageName .
PackageName    = identifier .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Import declarations&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ImportDecl       = &amp;quot;import&amp;quot; ( ImportSpec | &amp;quot;(&amp;quot; { ImportSpec &amp;quot;;&amp;quot; } &amp;quot;)&amp;quot; ) .
ImportSpec       = [ &amp;quot;.&amp;quot; | PackageName ] ImportPath .
ImportPath       = string_lit .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Import declaration          Local name of Sin

import   &amp;quot;lib/math&amp;quot;         math.Sin
import m &amp;quot;lib/math&amp;quot;         m.Sin
import . &amp;quot;lib/math&amp;quot;         Sin

import _ &amp;quot;lib/math&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Size and alignment guarantees&lt;/p&gt;

&lt;p&gt;For the numeric types, the following sizes are guaranteed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type                                 size in bytes

byte, uint8, int8                     1
uint16, int16                         2
uint32, int32, float32                4
uint64, int64, float64, complex64     8
complex128                           16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following minimal alignment properties are guaranteed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For a variable x of any type: unsafe.Alignof(x) is at least 1.&lt;/li&gt;
&lt;li&gt;For a variable x of struct type: unsafe.Alignof(x) is the largest of all the values unsafe.Alignof(x.f) for each field f of x, but at least 1.&lt;/li&gt;
&lt;li&gt;For a variable x of array type: unsafe.Alignof(x) is the same as unsafe.Alignof(x[0]), but at least 1.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: The Go Programming Language Specification is &lt;a href=&#34;https://golang.org/ref/spec&#34; title=&#34;The Go Programming Language Specification&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
