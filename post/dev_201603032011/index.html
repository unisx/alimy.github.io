  <!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title> SimpleXML: Tutorial &middot; Alimy </title>
    
    <link rel="stylesheet" type="text/css" href="http://alimy.me/css/uno.min.css" />
    <link rel="stylesheet" type="text/css" href="http://alimy.me/css/lightGallery.css" />
    
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://alimy.me/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="http://alimy.me/favicon.png">
    
    <script src="http://alimy.me/js/jquery.min.js"></script>
    <script src="http://alimy.me/js/main.min.js"></script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75081327-1', 'auto');
  ga('send', 'pageview');

</script>
    <style type="text/css">
        body {
          background-color:#f9f9f9;
        }
        .panel-wrapper {
          box-shadow:0px 0px 8px rgba(68,68,68,.6);
          -moz-box-shadow:0px 0px 8px rgba(68,68,68,.6);
          border-radius:4px;
          -moz-border-radius:4px;
          padding:16px 24px;
          margin-top:32px;
          background-color:#fff
        }
        .panel-wrapper:hover {
          box-shadow:0px 0px 12px rgba(68,68,68,.6);
          -moz-box-shadow:0px 0px 12px rgba(68,68,68,.6);
        }
        #more {
          margin-top:16px;
        }
        #copyright {
          padding:2em 0 0;
          display:block;
          font-size:.9em;
          color:#b3b3b3;
          width:100%;
          text-align:center
        }
        #list-indicator {
          min-width:48px;
          text-align:center;
          float:right;
          margin-right:64px;
          background:rgba(68,68,68,.2);
          border-radius:4px;
          -moz-border-radius:4px;
          padding:8px;
        }
        #list-date {
          color:#999;
          font-size: .9em;
          font-style:italic;
        }
        #post-navigator {
          padding:24px 0px 16px 0px;
          vertical-align: middle;
        }
        #post-navigator>a {
          display: block;
          color:#2479cc;
          text-decoration:none;
        }
        #post-navigator-prev {
          float:left;
        }
        #post-navigator-next {
          float:right;
        }
        .pages {
            text-align: center;
            margin-right: -15px;
            margin-left: -15px;
        }
        .pages>ul {
            font-weight: lighter;
        }
        .pages>.pagination {
            display: inline-block;
            padding-left: 0;
            margin: 20px 0px;
            border-radius: 4px;
        }
        .pages .pagination>li {
            display:inline;
        }
       
.pagination>.active>a, .pagination>.active>span, .pagination>.active>a:hover, .pagination>.active>span:hover, .pagination>.active>a:focus, .pagination>.active>span:focus {
    z-index: 2;
    color: #fff;
    cursor: default;
    background-color: #428bca;
    border-color: #428bca;
}

.pagination>li>a, .pagination>li>span {
    position: relative;
    float: left;
    padding: 6px 12px;
    margin-left: -1px;
    line-height: 1.428571429;
    text-decoration: none;
    background-color: #fff;
    border: 1px solid #ddd;
}
.pagination>li:first-child>a, .pagination>li:first-child>span {
    margin-left: 0;
    border-bottom-left-radius: 4px;
    border-top-left-radius: 4px;
}
.pagination>.disabled>span, .pagination>.disabled>span:hover, .pagination>.disabled>span:focus, .pagination>.disabled>a, .pagination>.disabled>a:hover, .pagination>.disabled>a:focus {
    color: #999;
    cursor: not-allowed;
    background-color: #fff;
    border-color: #ddd;
}
.pagination>li:last-child>a, .pagination>li:last-child>span {
    border-top-right-radius: 4px;
    border-bottom-right-radius: 4px;
}
*, *:before, *:after {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}
    </style>
</head>

  <body>
    <div id="scriptHeader">
    <span class="mobile btn-mobile-menu">
            <i class="fa fa-bars btn-mobile-menu__icon"></i>
            <i class="fa fa-times btn-mobile-close__icon hidden"> </i>
    </span>
    <header class="
        
            panel-cover panel-cover--collapsed
        " >
    <div class="panel-main">
        <div class="panel-main__inner panel-inverted">
            <div class="panel-main__content"> 
                <a href="http://alimy.me/"> <img src="http://alimy.me/images/logo.jpg" width="80" alt="Alimy logo" class="panel-cover__logo logo" /> </a> 
                <h1 class="panel-cover__title panel-title">
                    <a href="http://alimy.me/">Alimy</a>
                </h1>
                <hr class="panel-cover__divider" />
                <p class="panel-cover__description">  Make it easy and stupid.  </p>
                <hr class="panel-cover__divider panel-cover__divider--secondary" />
                <div class="navigation-wrapper">
                    <nav class="cover-navigation cover-navigation--primary">
                        <ul class="navigation">
                            <li class="navigation__item"><a href="http://alimy.me" title="博客首页" class="blog-button">Blog</a> </li>
                            </br>  </ul>
                    </nav> <nav class="cover-navigation navigation--social">
    <ul class="navigation"> 
        
        <li class="navigation__item">
            <a href="http://twitter.com/alimy86" title="@Twitter"> <i class='fa fa-twitter'></i> <span class="label">Twitter</span> </a>
        </li>   
        
        <li class="navigation__item">
            <a href="https://github.com/alimy" title="@GitHub"> <i class='fa fa-github'></i> <span class="label">Github</span> </a>
        </li>  </br>    </ul>
</nav>
 </div>
            </div>
        </div>
        <div class="panel-cover--overlay"></div>
    </div>
</header>
</div>
<noscript>
    <style>
        #scriptHeader {display:none;}
        .navigation-wrapper{
            display: block;
            top: 0;
        }
    </style>

    <header class="panel-cover panel-cover--collapsed" style="background-image: url()">
        <div class="panel-main">
            <div class="panel-main__inner panel-inverted">
                <div class="panel-main__content"> 
                    <a href="http://alimy.me/"> <img src="http://alimy.me/images/logo.jpg" width="80" alt="Alimy logo" class="panel-cover__logo logo" /> </a> 
                    <h1 class="panel-cover__title panel-title">
                        <a href="http://alimy.me/">Alimy</a>
                    </h1>
                    <hr class="panel-cover__divider" />
                    <p class="panel-cover__description">  Make it easy and stupid.  </p>
                    <hr class="panel-cover__divider panel-cover__divider--secondary" />
                    <div class="navigation-wrapper">
                        <nav class="cover-navigation cover-navigation--primary">
                            <ul class="navigation">
                                <li class="navigation__item"><a href="http://alimy.me/" title="博客首页" class="blog-button">Blog</a> </li>
                                </br>  </ul>
                        </nav> <nav class="cover-navigation navigation--social">
    <ul class="navigation"> 
        
        <li class="navigation__item">
            <a href="http://twitter.com/alimy86" title="@Twitter"> <i class='fa fa-twitter'></i> <span class="label">Twitter</span> </a>
        </li>   
        
        <li class="navigation__item">
            <a href="https://github.com/alimy" title="@GitHub"> <i class='fa fa-github'></i> <span class="label">Github</span> </a>
        </li>  </br>    </ul>
</nav>
 </div>
                </div>
            </div>
            <div class="panel-cover--overlay"></div>
        </div>
    </header>
</noscript>

    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <div class="post panel-wrapper">
            <h2>SimpleXML: Tutorial</h2>
          
          <p>This page provides a tutorial that will prepare users for using XML serialization. Before this tutorial is attempted it is advisable to have a look at the <a href="http://simple.sourceforge.net/download/stream/doc/javadoc/">Javadoc</a> documentation for the framework. Although there are only several annotations and objects involved in the serialization process the framework itself has many powerful features which this tutorial attempts to describe.

1. <a href="#1">Serializing a simple object</a>
2. <a href="#2">Deserializing a simple object</a>
3. <a href="#3">Nested object serialization</a>
4. <a href="#4">Optional elements and attributes</a>
5. <a href="#5">Reading a list of elements</a>
6. <a href="#6">Overriding an annotated type</a>
7. <a href="#7">Dealing with an inline list of elements</a>
8. <a href="#8">Constructor injection</a>
9. <a href="#9">Reading an array of elements</a>
10. <a href="#10">Adding text and attributes to elements</a>
11. <a href="#11">Dealing with map objects</a>
12. <a href="#12">Scattering inline element entries</a>
13. <a href="#13">Loose object mapping</a>
14. <a href="#14">Java Bean serialization</a>
15. <a href="#15">Default object serialization</a>
16. <a href="#16">Example using template filters</a>
17. <a href="#17">Receiving persister callbacks</a>
18. <a href="#18">Maintaining state between persister callbacks</a>
19. <a href="#19">Serializing with CDATA blocks</a>
20. <a href="#20">Using XML namespaces</a>
21. <a href="#21">Resolving object reference cycles</a>
22. <a href="#22">Reusing XML elements</a>
23. <a href="#23">Using utility collections</a>
24. <a href="#24">Object substitution</a>
25. <a href="#25">Serializing Java language types</a>
26. <a href="#26">Styling serialized XML</a>
27. <a href="#27">Version tolerant serialization</a>
28. <a href="#28">Serializing static final fields</a>
29. <a href="#29">Overriding serialization with converters</a>
30. <a href="#30">Intercepting the serialization process</a>
31. <a href="#31">Mapping with XPath expressions</a>
32. <a href="#32">Dynamic serialization with unions</a></p>

<h3 id="a-name-1-sect-serializing-a-simple-object"><a name="1"/> &sect;Serializing a simple object</h3>

<p>In order to serialize an object to XML a series of annotations must be placed within that object. These annotations tell the persister how the object should be serialized. For example take the class shown below. Here there are three different annotations, one used to describe the name of the root element, one that describes an XML message element, and a final annotation for an id attribute.</p>

<pre><code>@Root
public class Example {

   @Element
   private String text;

   @Attribute
   private int index;

   public Example() {
      super();
   }  

   public Example(String text, int index) {
      this.text = text;
      this.index = index;
   }

   public String getMessage() {
      return text;
   }

   public int getId() {
      return index;
   }
}
</code></pre>

<p>To serialize an instance of the above object a <a href="http://simple.sourceforge.net/download/stream/doc/javadoc/org/simpleframework/xml/core/Persister.html">Persister</a> is required. The persister object is then given an instance of the annotated object and an output result, which is a file in this example. Other output formats are possible with the persister object.</p>

<pre><code>Serializer serializer = new Persister();
Example example = new Example(&quot;Example message&quot;, 123);
File result = new File(&quot;example.xml&quot;);

serializer.write(example, result);

</code></pre>

<p>Once the above code is executed the object instance will have been transferred as an XML document to the specified file. The resulting XML file will contain the contents shown below.</p>

<pre><code>&lt;example index=&quot;123&quot;&gt;
   &lt;text&gt;Example message&lt;/text&gt;
&lt;/example&gt;
</code></pre>

<p>As well as the capability of using the field an object name to acquire the XML element and attribute names explicit naming is possible. Each annotation contains a name attribute, which can be given a string providing the name of the XML attribute or element. This ensures that should the object have unusable field or method names they can be overridden, also if your code is obfuscated explicit naming is the only reliable way to serialize and deserialize objects consistently. An example of the previous object with explicit naming is shown below.</p>

<pre><code>@Root(name=&quot;root&quot;)
public class Example {

   @Element(name=&quot;message&quot;)
   private String text;

   @Attribute(name=&quot;id&quot;)
   private int index;

   public Example() {
      super();
   }  

   public Example(String text, int index) {
      this.text = text;
      this.index = index;
   }

   public String getMessage() {
      return text;
   }

   public int getId() {
      return index;
   }
}
</code></pre>

<p>For the above object the XML document constructed from an instance of the object results in a different format. Here the XML element and attribute names have been overridden with the annotation names. The resulting output is shown below.</p>

<pre><code>&lt;root id=&quot;123&quot;&gt;
   &lt;message&gt;Example message&lt;/message&gt;
&lt;/root&gt;
</code></pre>

<h3 id="a-name-2-sect-deserializing-a-simple-object"><a name="2" /> &sect;Deserializing a simple object</h3>

<p>Taking the above example object the XML deserialization process is described in the code snippet shown below. As can be seen the deserialization process is just as simple. The persister is given the class representing the serialized object and the source of the XML document. To deserialize the object the read method is used, which produces an instance of the annotated object. Also, note that there is no need to cast the return value from the read method as the method is generic.</p>

<pre><code>Serializer serializer = new Persister();
File source = new File(&quot;example.xml&quot;);

Example example = serializer.read(Example.class, source);
</code></pre>

<h3 id="a-name-3-sect-nested-object-serialization"><a name="3" /> &sect;Nested object serialization</h3>

<p>As well as simple object serialization, nested object serialization is possible. This is where a serializable object can contain any number of serializable objects, to any depth. Take the example shown in the code snippet below. This shows several objects that are linked together to form a single serializable entity. Here the root configuration object contains a server object, which in turn contains a security information object.</p>

<pre><code>@Root
public class Configuration {

   @Element
   private Server server;

   @Attribute
   private int id;

   public int getIdentity() {
      return id;
   }

   public Server getServer() {
      return server;           
   }
}

public class Server {

   @Attribute
   private int port;

   @Element
   private String host;

   @Element
   private Security security;

   public int getPort() {
      return port;           
   }

   public String getHost() {
      return host;           
   }

   public Security getSecurity() {
      return security;           
   }
}

public class Security {

   @Attribute
   private boolean ssl;

   @Element
   private String keyStore;

   public boolean isSSL() {
      return ssl;           
   }

   public String getKeyStore() {
      return keyStore;           
   }
}
</code></pre>

<p>In order to create an initialized configuration object an XML document can be used. This XML document needs to match the XML annotations for the object graph. So taking the above class schema the XML document would look like the following example.</p>

<pre><code>&lt;configuration id=&quot;1234&quot;&gt;
   &lt;server port=&quot;80&quot;&gt;
      &lt;host&gt;www.domain.com&lt;/host&gt;
      &lt;security ssl=&quot;true&quot;&gt;
         &lt;keyStore&gt;example keystore&lt;/keyStore&gt;
      &lt;/security&gt;
   &lt;/server&gt;
&lt;/configuration&gt;
</code></pre>

<p>How the mapping is done can be seen by examining the XML document elements and attributes and comparing these to the annotations within the schema classes. The mapping is quite simple and can be picked up and understood in several minutes.</p>

<h3 id="a-name-4-sect-optional-elements-and-attributes"><a name="4" />&sect;Optional elements and attributes</h3>

<p>At times it may be required to have an optional XML element or attribute as the source XML may not contain the attribute or element. Also, it may be that an object field is null and so cannot be serialized. In such scenarios the element or attribute can be set as not required. The following code example demonstrates an optional element and attribute.</p>

<pre><code>@Root
public class OptionalExample {

   @Attribute(required=false)
   private int version;

   @Attribute
   private String id;

   @Element(required=false)
   private String name;   

   @Element
   private String address;

   public int getId() {
      return id;
   }

   public int getVersion() {
      return version;
   }

   public String getName() {
      return name;
   }

   public String getAddress() {
      return address;
   }
}
</code></pre>

<p>For the above object the version and name are not required. So, and XML source document may not contain either of these details and the object can still be serialized safely. For example take the following XML document, which is a valid representation of the above object.</p>

<pre><code>&lt;optionalExample id=&quot;10&quot;&gt;
   &lt;address&gt;Some example address&lt;/address&gt;
&lt;/optionalExample&gt;
</code></pre>

<p>Even without the name and version XML nodes this document can be deserialized in to an object. This feature is useful when your XML contains optional details and allows more flexible parsing. To further clarify the implementation of optional fields take the example shown below. This shows how the entry object is deserialized from the above document, which is contained within a file. Once deserialized the object values can be examined.</p>

<pre><code>Serializer serializer = new Persister();
File source = new File(&quot;example.xml&quot;);
OptionalExample example = serializer.read(OptionalExample.class, source);

assert example.getVersion() == 0;
assert example.getName() == null;
assert example.getId() == 10;
</code></pre>

<h3 id="a-name-5-sect-reading-a-list-of-elements"><a name="5" />&sect;Reading a list of elements</h3>

<p>In XML configuration and in Java objects there is often a one to many relationship from a parent to a child object. In order to support this common relationship an ElementList annotation has been provided. This allows an annotated schema class to be used as an entry to a Java collection object. Take the example shown below.</p>

<pre><code>@Root
public class PropertyList {

   @ElementList
   private List&lt;Entry&gt; list;

   @Attribute
   private String name;

   public String getName() {
      return name;
   }

   public List getProperties() {
      return list;
   }
}

@Root
public class Entry {

   @Attribute
   private String key;

   @Element
   private String value;

   public String getName() {
      return name;
   }

   public String getValue() {
      return value;
   }
}
</code></pre>

<p>From the above code snippet the element list annotation can be seen. The field type is reflectively instantiated as a matching concrete object from the Java collections framework, typically it is an array list, but can be any collection object if the field type declaration provides a concrete implementation type rather than the abstract list type shown in the above example.</p>

<p>Below an XML document is shown that matches the schema class. Here each entry element will be deserialized using the declared entry class and inserted into the collection instance created. Once all entry objects have been deserialized the object instance contains a collection containing individual property objects.</p>

<pre><code>&lt;propertyList name=&quot;example&quot;&gt;
   &lt;list&gt;
      &lt;entry key=&quot;one&quot;&gt;
         &lt;value&gt;first value&lt;/value&gt;
      &lt;/entry&gt;
      &lt;entry key=&quot;two&quot;&gt;
         &lt;value&gt;first value&lt;/value&gt;
      &lt;/entry&gt;
      &lt;entry key=&quot;three&quot;&gt;
         &lt;value&gt;first value&lt;/value&gt;
      &lt;/entry&gt;
      &lt;entry key=&quot;four&quot;&gt;
         &lt;value&gt;first value&lt;/value&gt;
      &lt;/entry&gt;
   &lt;/list&gt;
&lt;/propertyList&gt;
</code></pre>

<p>From the above example it can be seen that the entry details are taken from the generic type of the collection. It declares a list with the entry class as its generic parameter. This type of declaration is often not possible, for example if a specialized list contains more than one generic type which one is the correct type to use for deserialization or serialization. In such scenarios the type must be provided explicitly. Take the following example.</p>

<pre><code>@Root
public class ExampleList {

   @ElementList(type=C.class)
   private SpecialList&lt;A, B, C&gt; list;

   public SpecialList&lt;A, B, C&gt; getSpecialList() {
      return list;
   }
}
</code></pre>

<p>In the above example the special list takes three generic parameters, however only one is used as the generic parameter for the collection. As can be seen an explicit declaration of which type to use is required. This can be done with the type attribute of the ElementList annotation.</p>

<h3 id="a-name-6-sect-overriding-an-annotated-type"><a name="6" />&sect;Overriding an annotated type</h3>

<p>In order to accommodate dynamic types within the deserialization process a class attribute can be added to an XML element, which will ensure that that element can be instantiated as the declared type. This ensures that field and method types can reference abstract classes and interfaces, it also allows multiple types to be added into an annotated collection.</p>

<pre><code>package example.demo;

public interface Task {

   public double execute();
}

@Root
public class Example implements Task {

   @Element
   private Task task;

   public double execute() {
      return task.execute();
   }  
}

public class DivideTask implements Task {

   @Element(name=&quot;left&quot;)
   private float text;

   @Element(name=&quot;right&quot;)
   private float right;

   public double execute() {
      return left / right;
   }
}

public class MultiplyTask implements Task {

   @Element(name=&quot;first&quot;)
   private int first;

   @Element(name=&quot;second&quot;)
   private int second;

   public double execute() {
      return first * second;
   }
}
</code></pre>

<p>The class attribute must be a fully qualified class name so that the context class loader can load it. Also, the type can contain its own unique annotations and types which makes the deserialization and serialization process truly dynamic. Below is an example XML document declaring the class type for the task object.</p>

<pre><code>&lt;example&gt;
   &lt;task class=&quot;example.demo.DivideTask&quot;&gt;
      &lt;left&gt;16.5&lt;/left&gt;
      &lt;right&gt;4.1&lt;/right&gt;
   &lt;/task&gt;
&lt;/example&gt;  
</code></pre>

<p>In order to execute the task described in the XML document the following code can be used. Here it is assumed the XML source is contained within a file. Once the example object has been deserialized the task can be executed and the result acquired.</p>

<pre><code>Serializer serializer = new Persister();
File example = new File(&quot;example.xml&quot;);
Example example = serializer.read(Example.class, example)

double value = example.execute();
</code></pre>

<h3 id="a-name-7-sect-dealing-with-an-inline-list-of-elements"><a name="7" />&sect;Dealing with an inline list of elements</h3>

<p>When dealing with third party XML or with XML that contains a grouping of related elements a common format involves the elements to exist in a sequence with no wrapping parent element. In order to accomodate such structures the element list annotation can be configured to ignore the parent element for the list. For example take the following XML document.</p>

<pre><code>&lt;propertyList&gt;
   &lt;name&gt;example&lt;/name&gt;
   &lt;entry key=&quot;one&quot;&gt;
      &lt;value&gt;first value&lt;/value&gt;
   &lt;/entry&gt;
   &lt;entry key=&quot;two&quot;&gt;
      &lt;value&gt;second value&lt;/value&gt;
   &lt;/entry&gt;
   &lt;entry key=&quot;three&quot;&gt;
      &lt;value&gt;third value&lt;/value&gt;
   &lt;/entry&gt;
&lt;/propertyList&gt;
</code></pre>

<p>In the above XML document there is a sequence of entry elements, however unlike the previous example these are not enclosed within a parent element. In order to achieve this the inline attribute of the ElementList annotation can be set to true. The following code snippet demonstrates how to use the inline attribute to process the above XML document.</p>

<pre><code>@Root
public class PropertyList {

   @ElementList(inline=true)
   private List&lt;Entry&gt; list;

   @Element
   private String name;

   public String getName() {
      return name;
   }

   public List getProperties() {
      return list;
   }
}
</code></pre>

<p>There are a number of conditions for the use of the inline element list. Firstly, each element within the inline list must be placed one after another. They cannot be dispersed in between other elements. Also, each entry type within the list must have the same root name, to clarify take the following example.</p>

<pre><code>package example.demo;

@Root
public class Entry {

    @Attribute
    protected String key;

    @Element
    protected String value;

    public String getKey() {
       return key;
    }
}

public class ValidEntry extends Entry {

   public String getValue() {
      return value;
   }
}

@Root
public class InvalidEntry extends Entry {

   public String getValue() {
      return value;
   }
}

@Root(name=&quot;entry&quot;)
public class FixedEntry extends InvalidEntry {
}
</code></pre>

<p>All of the above types extend the same base type, and so all are candidates for use with the PropertyList described earlier. However, although all types could be successfully deserialized and serialized using a list which is not inline, only some can be serialized with an inline list. For instance the type InvalidEntry could not be serialized as it will be serialized with a different name from all the other entrie implementations. The InvalidEntry object has a Root annotation which means that its XML element name will be &ldquo;invalidEntry&rdquo;. In order to be used with the inline list all objects must have the same XML element name of &ldquo;entry&rdquo;. By extending the InvalidEntry type and explicitly specifying the name to be &ldquo;entry&rdquo; the FixedEntry subclass can be used without any issues. For example take the following XML document, which could represent a mixture of entry types.</p>

<pre><code>&lt;propertyList&gt;
   &lt;name&gt;example&lt;/name&gt;
   &lt;entry key=&quot;one&quot; class=&quot;example.demo.ValidEntry&quot;&gt;
      &lt;value&gt;first value&lt;/value&gt;
   &lt;/entry&gt;
   &lt;entry key=&quot;two&quot; class=&quot;example.demo.FixedEntry&quot;&gt;
      &lt;value&gt;second value&lt;/value&gt;
   &lt;/entry&gt;
   &lt;entry key=&quot;three&quot; class=&quot;example.demo.Entry&quot;&gt;
      &lt;value&gt;third value&lt;/value&gt;
   &lt;/entry&gt;
&lt;/propertyList&gt;
</code></pre>

<p>All of the above entry elements within the inline list contain the same XML element name. Also each type is specified as a subclass implementation of the root Entry object.</p>

<h3 id="a-name-8-sect-constructor-injection"><a name="8" />&sect;Constructor injection</h3>

<p>All but the simplest of programs will have some form of immutable objects. These are objects that do not have setters and so will acquire data by using constructor injection. In this manner the object sets its internal state from the data provided to the constructor. This can also be achieved with serialization, if you would like to serialize and deserialize objects but do not want to provide setter methods this can be done, as illustrated in the example below.</p>

<pre><code>@Root
public class OrderManager {

    private final List&lt;Order&gt; orders;

    public OrderManager(@ElementList(name=&quot;orders&quot;) List&lt;Order&gt; orders) {
        this.orders = orders;
    }

    @ElementList(name=&quot;orders&quot;)
    public List&lt;Order&gt; getOrders() {
        return orders;
    }
}

@Root
public class Order {

    @Attribute(name=&quot;name&quot;)
    private final String name;

    @Element(name=&quot;product&quot;)
    private final String product;

    public Order(@Attribute(name=&quot;name&quot;) String name,
                 @Element(name=&quot;product&quot;) String product)
    {
        this.product = product;
        this.name = name;
    }

    public String getProduct() {
        return product;
    }
}
</code></pre>

<p>The above code illustrates an order manager that contains a list of immutable order objects. On deserialization the values are taken from the XML document and injected in to the constructor to instantiate the object. This is a very useful feature that is not often found in serialization frameworks. One restriction on the constructor injection is that it must be used with an annotated get method or field. This is required so that on serialization the persister knows where to get the data to write. Taking the above example if the getOrders method was not annotated then there would be no way to determine how to write the order manager object. Below is some example XML resulting from serialization of the order manager.</p>

<pre><code>&lt;orderManager&gt;
    &lt;order name=&quot;AX101&quot;&gt;
        &lt;product&gt;Product A&lt;/product&gt;
    &lt;/order&gt;
    &lt;order name=&quot;AX102&quot;&gt;
        &lt;product&gt;Product B&lt;/product&gt;
    &lt;/order&gt;
    &lt;order name=&quot;AX103&quot;&gt;
        &lt;product&gt;Product C&lt;/product&gt;
    &lt;/order&gt;
&lt;/orderManager&gt;
</code></pre>

<h3 id="a-name-9-sect-reading-an-array-of-elements"><a name="9" />&sect;Reading an array of elements</h3>

<p>As well as being able to deserialize elements in to a collection arrays can also be serialized and deserialized. However, unlike the @ElementList annotation the ElementArray annotation can also deserialize primitive values such as int arrays, char arrays, and so on. Below is an example object with an array of integer values and a parallel array of string values.</p>

<pre><code>@Root
public class AddressBook {

   @ElementArray
   private Address[] addresses;   

   @ElementArray
   private String[] names;        

   @ElementArray
   private int[] ages;   

   public Address[] getAddresses() {
      return addresses;           
   }

   public String[] getNames() {
      return names;           
   }

   public int[] getAges() {
      return ages;           
   }
}

@Root
public class Address {

   @Element(required=false)
   private String house;        

   @Element
   private String street;  

   @Element
   private String city;

   public String getHouse() {
      return house;           
   }

   public String getStreet() {
      return street;           
   }

   public String getCity() {
      return city;           
   }     
}
</code></pre>

<p>For the above object both primitive arrays require an entry attribute, this is because primitives can not be annotated with the Root annotation. The entry attribute tells the persister than an extra XML element is required to wrap the entry. This entry element can also be applied to serializable objects that have the Root annotation, however it is typically only used for primitive arrays. The following XML is an example of what is produced by the above objects.</p>

<pre><code>&lt;addressBook&gt;
   &lt;addresses length=&quot;3&quot;&gt;
      &lt;address&gt;
         &lt;house&gt;House 33&lt;/house&gt;
         &lt;street&gt;Sesame Street&lt;/street&gt;
         &lt;city&gt;City&lt;/city&gt;
      &lt;/address&gt;
      &lt;address&gt;
         &lt;street&gt;Some Street&lt;/street&gt;
         &lt;city&gt;The City&lt;/city&gt;
      &lt;/address&gt;
      &lt;address&gt;
         &lt;house&gt;Another House&lt;/house&gt;
         &lt;street&gt;My Street&lt;/street&gt;
         &lt;city&gt;Same City&lt;/city&gt;
      &lt;/address&gt;
   &lt;/addresses&gt;
   &lt;names length=&quot;3&quot;&gt;
      &lt;string&gt;Jonny Walker&lt;/string&gt;
      &lt;string&gt;Jack Daniels&lt;/string&gt;
      &lt;string&gt;Jim Beam&lt;/string&gt;
   &lt;/names&gt;
   &lt;ages length=&quot;3&quot;&gt;
      &lt;int&gt;30&lt;/int&gt;
      &lt;int&gt;42&lt;/int&gt;
      &lt;int&gt;31&lt;/int&gt;
   &lt;/ages&gt;
&lt;/addressBook&gt;
</code></pre>

<p>Looking at the above XML it can be seen that each entity within an array index is named the same as its type. So a string is wrapped in a &lsquo;string&rsquo; element and an int is wrapped in an &lsquo;int&rsquo; element. This is done because the default name for the ElementArray annotation is its type name, unless the Root annotation is used with a name. This can be overridden by providing an explicit entry name for the array. For example take the simple object below which contains an array of names as string objects.</p>

<pre><code>@Root
public class NameList {

   @ElementArray(entry=&quot;name&quot;)
   private String[] names;        

   public String[] getNames() {
      return names;           
   }
}
</code></pre>

<p>For the above XML the following document is a valid representation. Notice how each of the names within the XML document is wrapped in a &lsquo;name&rsquo; element. This element name is taken from the annotation provided.</p>

<pre><code>&lt;nameList&gt;
   &lt;names length=&quot;3&quot;&gt;
      &lt;name&gt;Jonny Walker&lt;/name&gt;
      &lt;name&gt;Jack Daniels&lt;/name&gt;
      &lt;name&gt;Jim Beam&lt;/name&gt;
   &lt;/names&gt;
&lt;/nameList&gt;
</code></pre>

<h3 id="a-name-10-sect-adding-text-and-attributes-to-elements"><a name="10" />&sect;Adding text and attributes to elements</h3>

<p>As can be seen from the previous example annotating a primitive such as a String with the Element annotation will result in text been added to a names XML element. However it is also possible to add text to an element that contains attributes. An example of such a class schema is shown below.</p>

<pre><code>@Root
public class Entry {

   @Attribute
   private String name;

   @Attribute
   private int version;     

   @Text
   private String value;

   public int getVersion() {
      return version;           
   }

   public String getName() {
      return name;
   }

   public String getValue() {
      return value;              
   }
}
</code></pre>

<p>Here the class is annotated in such a way that an element contains two attributes named version and name. It also contains a text annotation which specifies text to add to the generated element. Below is an example XML document that can be generated using the specified class schema.</p>

<pre><code>&lt;entry version='1' name='name'&gt;
   Some example text within an element
&lt;/entry&gt;
</code></pre>

<p>The rules that govern the use of the Text annotation are that there can only be one per schema class. Also, this annotation cannot be used with the Element annotation. Only the Attribute annotation can be used with it as this annotation does not add any content within the owning element.</p>

<h3 id="a-name-11-sect-dealing-with-map-objects"><a name="11" />&sect;Dealing with map objects</h3>

<p>Although it is possible to deal with most repetitive XML elements within documents using element lists it is often more convenient to use a Map object. In order to deal with maps the ElementMap annotation can be used. The element map annotation can be used with both primitive and composite objects. For example take the following XML document.</p>

<pre><code>&lt;properties&gt;
   &lt;property key=&quot;one&quot;&gt;first value&lt;/property&gt;
   &lt;property key=&quot;two&quot;&gt;second value&lt;/property&gt;
   &lt;property key=&quot;three&quot;&gt;third value&lt;/property&gt;
   &lt;name&gt;example name&lt;/name&gt;
&lt;/properties&gt;
</code></pre>

<p>In the above XML document the sequence of properties elements can be used to describe a map of strings, where the key attribute acts as the key for the value within the property element. The following code snipped demonstrates how to use the ElementMap annotation to process the above XML document.</p>

<pre><code>@Root(name=&quot;properties&quot;)
public class PropertyMap {

   @ElementMap(entry=&quot;property&quot;, key=&quot;key&quot;, attribute=true, inline=true)
   private Map&lt;String, String&gt; map;

   @Element
   private String name;  

   public String getName() {
      return name;
   }

   public Map&lt;String, Entry&gt; getMap() {
      return map;
   }
}
</code></pre>

<h3 id="a-name-12-sect-scattering-inline-element-entries"><a name="12" />&sect;Scattering inline element entries</h3>

<p>Elements that are scattered throughout an XML document can be collected by inline lists and inline maps. Simply provide an entry name for the XML element name the list or map is to collect and they will be extracted and placed in to the collection object. For example take the following XML element. It contains include and exclude XML elements which are in no specific order. Even though they are not in any order the deserialization process is able to gather the XML elements as thet are encountered.</p>

<pre><code>&lt;fileSet path=&quot;/user/niall&quot;&gt;
   &lt;include pattern=&quot;.*.jar&quot;/&gt;
   &lt;exclude pattern=&quot;.*.bak&quot;/&gt;
   &lt;exclude pattern=&quot;~.*&quot;/&gt;
   &lt;include pattern=&quot;.*.class&quot;/&gt;
   &lt;exclude pattern=&quot;images/.*&quot;/&gt;
&lt;/fileSet&gt;
</code></pre>

<p>In order to achieve this the following object can be used. This declares two inline collections which specify the name of the entry objects that they are collecting. If the entry attribute is not specified then the name of the object will be used instead.</p>

<pre><code>@Root
public class FileSet {

   @ElementList(entry=&quot;include&quot;, inline=true)
   private List&lt;Match&gt; include;

   @ElementList(entry=&quot;exclude&quot;, inline=true)
   private List&lt;Match&gt; exclude;

   @Attribute
   private File path;

   private List&lt;File&gt; files;

   public FileSet() {
      this.files = new ArrayList&lt;File&gt;();
   }

   @Commit
   public void commit() {
      scan(path);
   }

   private void scan(File path) {
      File[] list = path.listFiles();

      for(File file : list) {
         if(file.isDirectory()) {
            scan(path);
         } else {            
            if(matches(file)) {
               files.add(file);
            }
         }
      }
   }

   private boolean matches(File file) {
      for(Match match : exclude) {
         if(match.matches(file)) {
            return false;
         }
      }
      for(Match match : include) {
         if(match.matches(file)) {
            return true;
         }
      }
      return false;
   }

   public List&lt;File&gt; getFiles() {
      return files;
   }

   @Root
   private static class Match {

      @Attribute            
      private String pattern;            

      public boolean matches(File file) {
         Stirng path = file.getPath();

         if(!file.isFile()) {
            return false;
         }
         return path.matches(pattern);         
      }         
   }
}
</code></pre>

<h3 id="a-name-13-sect-loose-object-mapping"><a name="13" />&sect;Loose object mapping</h3>

<p>An important feature for any XML tool is the ability to sift through the source XML to find particular XML attributes an elements of interest. It would not be very convinient if you had to write an object that accurately mapped every attribute an element in an XML document if all you are interested in is perhaps an element and several attributes. Take the following XML document.</p>

<pre><code>&lt;contact id=&quot;71&quot; version=&quot;1.0&quot;&gt;
   &lt;name&gt;
      &lt;first&gt;Niall&lt;/first&gt;
      &lt;surname&gt;Gallagher&lt;/surname&gt;
   &lt;/name&gt;
   &lt;address&gt;
      &lt;house&gt;House 33&lt;/house&gt;
      &lt;street&gt;Sesame Street&lt;/street&gt;
      &lt;city&gt;City&lt;/city&gt;
   &lt;/address&gt;
   &lt;phone&gt;
      &lt;mobile&gt;123456789&lt;/mobile&gt;
      &lt;home&gt;987654321&lt;/home&gt;
   &lt;/phone&gt;
&lt;/contact&gt;
</code></pre>

<p>If my object only required the some of the details of the specified contact, for example the phone contacts and the name then it needs to be able to ignore the address details safely. The following code shows how this can be done by setting strict to false within the Root annotation.</p>

<pre><code>@Root(strict=false)
public class Contact {

   @Element
   private Name name;

   @Element
   private Phone phone;

   public String getName() {
      return name.first;
   }

   public String getSurname() {
      return name.surname;
   }

   public String getMobilePhone() {
      return phone.mobile;
   }

   public String getHomePhone() {
      return phone.home;
   }

   @Root
   private static class Name {

      @Element
      private String first;

      @Element
      private String surname;
   }

   @Root
   private static class Phone {

      @Element(required=false)
      private String mobile;

      @Element
      private String home;
   }
}
</code></pre>

<p>The above object can be used to parse the contact XML source. This simple ignores any XML elements or attributes that do not appear in the class schema. To further clarify the implementation of loose mappings take the example shown below. This shows how the entry object is deserialized from the above document, which is contained within a file. Once deserialized the object values can be examined.</p>

<pre><code>Serializer serializer = new Persister();
File source = new File(&quot;contact.xml&quot;);
Contact contact = serializer.read(Contact.class, source);

assert contact.getName().equals(&quot;Niall&quot;);
assert contact.getSurname().equals(&quot;Gallagher&quot;);
assert contact.getMobilePhone().equals(&quot;123456789&quot;);
assert contact.getHomePhone().equals(&quot;987654321&quot;);
</code></pre>

<p>Should there be more than a single object that requires loose mapping then using the Root annotation might not be the ideal solution. In such a scenario the persister itself can be asked to perform loose mapping. Simply pass a boolean to the read method indicating the type of mapping required. By default the persister uses strict mapping, which can be overridden on an object by object basis using the Root annotation, as shown in the above example. However, this default can be overridden as can be seen in the code snippet below.</p>

<pre><code>Contact contact = serializer.read(Contact.class, source, false);
</code></pre>

<p>Here the boolean passed to the overridden read method tells the serializer to perform a loose mapping. There is no need to specify anything in the annotations, the serializer will simply map every object loosely. This can be a much more convenient way to perform loose mapping, as you only need to annotate your objects with the elements or attributes you are interested in, all other elements and attributes will be ignored during deserialization. Such a solution is best suited to external XML documents where your annotated objects do not define the schema.</p>

<h3 id="a-name-14-sect-java-bean-serialization"><a name="14" />&sect;Java Bean serialization</h3>

<p>Although field based serialization offers a simple and efficient means for serializing and deserializing an object it can often be benificial to use Java Bean getters and setters to read and write values. In particular annotating Java Bean setter and getter methods will allow for a cleaner means to override the serialization behaviour than using fields. It also allows for processing and validation to be performed as the object is being deserialized. Below is an example of how to annotate an objects methods for use in the serialization process, this example mixes annotated fields with annotated methods.</p>

<pre><code>@Root
public class Message {

   private Collection&lt;Entry&gt; list;

   @Attribute
   private float version;        

   @ElementList
   public void setList(Collection&lt;Entry&gt; entry) {
      if(entry.isEmpty()) {
         throw new IllegalArgumentException(&quot;Empty collection&quot;);              
      }
      this.entry = entry;           
   }        

   @ElementList
   public Collection&lt;Entry&gt; getList() {
      return entry;           
   }
}

@Root
public class Entry {

   @Attribute
   public String name;    

   public String text;   

   @Text
   public String getText() {
      return text;           
   }

   @Text
   public void setText(String text){
      this.text = text;           
   }

   public String getName() {
      return name;           
   }
}
</code></pre>

<p>In the above code the message class will have its methods invoked when a list of entry objects is encountered. Here the method can perform some form of validation when the list of entry objects is deserialized. Such validation can also be peformed using the persister callback methods, which is described in a later section. The requirements for Java Bean method serialization are that both the setter and getter must be annotated with the same annotation, and both annotations must contain identical attributes. The object class schema could produce the following XML document.</p>

<pre><code>&lt;message version=&quot;1.2&quot;&gt;
   &lt;list&gt;
      &lt;entry name=&quot;a&quot;&gt;Example text one&lt;/entry&gt;
      &lt;entry name=&quot;b&quot;&gt;Example text two&lt;/entry&gt;
   &lt;/list&gt;
&lt;/message&gt;
</code></pre>

<h3 id="a-name-15-sect-default-object-serialization"><a name="15" />&sect;Default object serialization</h3>

<p>If an object grows large it often becomes tedious to annotate each field or method that needs to be serialized. In such scenarios the Default annotation can be used. This will apply default annotations to either the fields or methods of an object that is to be serialized. To specify whether it is the fields or methods that will have default annotations, the DefaultType enumeration can be used. Take the code snippet below, this shows two objects with default annotations, one that will apply defaults to the object fields, and one that will apply defaults to the Java Bean methods of the object.</p>

<pre><code>@Root
@Default(DefaultType.FIELD)
public class OrderItem {

   private Customer customer;

   private String name;

   @Attribute
   private double price;

   @Transient
   private String category;

   public String getName() {
      return name;
   }   

   public Customer getCustomer() {
      return customer;
   }
}

@Root
@Default(DefaultType.PROPERTY)
private class Customer {

   private String name;

   private String address;

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }
}
</code></pre>

<p>In the above object the Transient annotation is used to specify that even though default annotations should be applied to the objects fields, the field annotated as transient should not be serialized. Below is the XML that could be produced using the above classes, notice that if defaults apply to Java Bean methods, the fields will not be defaulted, instead they will be ignored.</p>

<pre><code>&lt;orderItem price=&quot;10.99&quot;&gt;
    &lt;customer&gt;
        &lt;name&gt;Elvis Presley&lt;/name&gt;
    &lt;/customer&gt;
    &lt;name&gt;IRT452&lt;/name&gt;
&lt;/orderItem&gt;
</code></pre>

<p>From the above XML it is obvious, that defaults apply to only those fields or methods requested. If a field or method already has an annotation, that is the annotation that is used. If a field or method is to be omitted from serialization then it can be marked as transient. Applying defaults to an object, can often lead to a cleaner object structure, and makes it much easier to make objects serializable.</p>

<h3 id="a-name-16-sect-example-using-template-filters"><a name="16" />&sect;Example using template filters</h3>

<p>Another very powerful feature with this XML serialization framework is the ability to use templating when deserializing an XML document. This allows values within elements and attributes to use template variables that can be replaced using a Filter object. The simplest filter object is the map filter, which allows the user to place a Java map within the filter object exposing the key value pairs to the templating system. The template system can now use the filter to find replacement values for template variables within the XML document. To clarify take the following example.</p>

<pre><code>@Root
public class Layout {

   @Element
   private String path;

   @Element
   private String user;

   @Attribute
   private int id;

   public String getPath() {
      return path;
   }

   public String getUser() {
      return user;
   }

   public int getId() {
      return id;
   }
}  
</code></pre>

<p>The above object has declared two elements and an attribute to be deserialized from an XML document. These values are typically static values within the XML source. However using a template variable syntax the deserialization process will attempt to substitute the keys with values from the filter. Take the XML document below with two template variables declared ${home.path} and ${user.name}.</p>

<pre><code>&lt;layout id=&quot;123&quot;&gt;
   &lt;path&gt;${home.path}&lt;/path&gt;
   &lt;user&gt;${user.name}&lt;/user&gt;
&lt;/layout&gt;
</code></pre>

<p>To ensure that these values can be replaced with user specified mappings a map filter can be used. Below is an example of how to create a persister that can be given user specified key value pairs. Here the above XML source is deserialized from a file and the annotated fields are given filter mappings if there is a mapping specified.</p>

<pre><code>Map map = new HashMap();

map.put(&quot;home.path&quot;, &quot;/home/john.doe&quot;);
map.put(&quot;user.name&quot;, &quot;john.doe&quot;);

Filter filter = new MapFilter(map);
Serializer serializer = new Persister(filter);
File source = new File(&quot;layout.xml&quot;);
Layout layout = serializer.read(Layout.class, source);

assert layout.getPath().equals(&quot;/home/john.doe&quot;);
assert layout.getUser().equals(&quot;john.doe&quot;);
</code></pre>

<p>As well as the map filter there are several stock filters which can be used to substitute template variables with OS environment variables and JVM system properties. Also several template variables can exist within the values. For example take the following XML document, which could be used in the above example given that the mappings for ${first.name} and ${second.name} were added to the map filter.</p>

<pre><code>&lt;layout id=&quot;123&quot;&gt;
   &lt;path&gt;/home/${first.name}.${second.name}&lt;/path&gt;
   &lt;user&gt;${first.name}.${second.name}&lt;/user&gt;
&lt;/layout&gt;
</code></pre>

<h3 id="a-name-17-sect-receiving-persister-callbacks"><a name="17" />&sect;Receiving persister callbacks</h3>

<p>Of critical importance to the serialization and deserialization process is that the objects have some control or participation in the process. It is no good to have the persister deserialize the object tree from an XML document only to see that the data is not valid or that further data structures need to be created in many of the deserialized objects. To allow objects to participate in the deserialization process two annotations can be used, these are the Validate and Commit annotations.</p>

<p>Both are involved in the deserialization process (not the serialization process) and are called immediately after an object has been deserialized. Validation is performed first, and if the deserialized object contains a method annotated with the validate annotation it is invoked. This allows the object to perform validation of its fields, if the object requirements are met the method returns quietly, if they are not met the object can throw an exception to terminate the deserialization process. The commit method is invoked in much the same way, the persister looks for a method marked with the commit annotation, if one exists it is invoked. However, unlike the validate method the commit method is typically used to build further data structures, for example hash tables or trees. Below is an example of an object making use of these annotations.</p>

<pre><code>@Root
public class PropertyMap {

   private Map&lt;String, Property&gt; map;

   @ElementList
   private List&lt;Property&gt; list;

   public PropertyMap() {
      this.map = new HashMap&lt;String, Entry&gt;();
   }

   @Validate
   public void validate() {
      List&lt;String&gt; keys = new ArrayList&lt;String&gt;();

      for(Property entry : list) {
         String key = entry.getKey();

         if(keys.contains(key)) {
            throw new PersistenceException(&quot;Duplicate key %s&quot;, key);
         }
         keys.put(key);         
      }      
   }

   @Commit
   public void build() {
      for(Property entry : list) {
         insert(entry);
      }     
   }

   public void insert(Property entry) {
      map.put(entry.getName(), entry);      
   }  

   public String getProperty(String name) {
      return map.get(name).getValue();
   }
}
</code></pre>

<p>The above object deserializes a list of property objects into a list. Once the property objects have been deserialized they are validated by checking that an entry with a specific key exists only once. After the validation process has completed the commit method is invoked by the persister, here the object uses the deserialized property object to build a hash table containing the property values keyed via the property key. Below is how the above object would be represented as an XML document.</p>

<pre><code>&lt;properties&gt;
   &lt;list&gt;
      &lt;entry key=&quot;one&quot;&gt;
         &lt;value&gt;first value&lt;/value&gt;
      &lt;/entry&gt;
      &lt;entry key=&quot;two&quot;&gt;
         &lt;value&gt;first value&lt;/value&gt;
      &lt;/entry&gt;
      &lt;entry key=&quot;three&quot;&gt;
         &lt;value&gt;first value&lt;/value&gt;
      &lt;/entry&gt;
   &lt;/list&gt;
&lt;/properties&gt;
</code></pre>

<p>As well as annotations involved in the deserialization process there are annotations that can be used to receive persister callbacks for the serialization process. Two annotations can be used, they are the Persist and Complete methods. To receive persister callbacks the methods must be no argument methods marked with the appropriate annotations.
The persist method is invoked before the serialization of the object. This allows the object to prepare in some implementation specific way for the serialization process. This method may throw an exception to terminate the serialization process. Once serialization has completed the complete method is invoked. This allows the object to revert to its previous state, that is, to undo what the persist method has done. Below is an example of how these annotations can be used.</p>

<pre><code>@Root
public class MailMessage {

   @Attribute
   private Stirng format;

   @Element
   private String encoded;

   private byte[] content;

   private Encoder encoder;

   public MailMessage() {
      this.encoder = new Encoder();
   }

   public void setEncoding(String format) {
      this.format = format;
   }

   public String getEncoding() {
      return format;
   }

   public void setMessage(byte[] content) {
      this.content = content;
   }

   public byte[] getMessage() {
      return content;
   }

   @Commit
   public void commit() {
      decoded = encoder.decode(encoded, format);
      encoded = null;
   }

   @Persist
   public void prepare() {
      encoded = encoder.encode(decoded, format);      
   }

   @Complete
   public void release() {
      encoded = null;
   }
}
</code></pre>

<p>The above example illustrates how the persist and complete methods can be used in a scenario where the serialization process needs to encode a byte array into a specific encoding format. Before the object is persisted the persistable field is set to an encoded string. When serialization has completed the encoded value is nulled to free the memory it holds. This example is somewhat contrived however it effectively demonstrates how the annotations can be used. Below is an example of what the XML document should look like.</p>

<pre><code>&lt;mailMessage format=&quot;base64&quot;&gt;
    U2ltcGxlIGlzIGFuIFhNTCBzZXJpYWxpemF0aW9uIGZyYW1ld29yayBmb3IgSmF2YS4gSXRzIGdv
    YWwgaXMgdG8gcHJvdmlkZSBhbiBYTUwgZnJhbWV3b3JrIHRoYXQgZW5hYmxlcyByYXBpZCBkZXZl
    bG9wbWVudCBvZiBYTUwgY29uZmlndXJhdGlvbiBhbmQgY29tbXVuaWNhdGlvbiBzeXN0ZW1zLiBU
    aGlzIGZyYW1ld29yayBhaWRzIHRoZSBkZXZlbG9wbWVudCBvZiBYTUwgc3lzdGVtcyB3aXRoIG1p
    bmltYWwgZWZmb3J0IGFuZCByZWR1Y2VkIGVycm9ycy4gVGhlIGZyYW1ld29yayBib3Jyb3dzIGlk
    ZWFzIGFuZCBjb25jZXB0cyBmcm9tIGV4aXN0aW5nIFhNTCB0b29scyBzdWNoIGFzIEMjIFhNTCBz
    ZXJpYWxpemF0aW9uIGFuZCBvdGhlciBwcm9wcmlldGFyeSBmcmFtZXdvcmtzIGFuZCBjb21iaW5l
    cyB0aG9zZSBpZGVhcyByZXN1bHRpbmcgaW4gYSBzaW1wbGUgeWV0IGV4dHJlbWVseSBwb3dlcmZ1
    bCB0b29sIGZvciB1c2luZyBhbmQgbWFuaXB1bGF0aW5nIFhNTC4gQmVsb3cgaXMgYSBsaXN0IG9m
    IHNvbWUgb2YgdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgZnJhbWV3b3JrLiA=    
&lt;/mailMessage&gt;
</code></pre>

<p>For the above XML message the contents can be serialized and deserialized safely using persister callbacks. The object can prepare itself before serialization by encoding the contents of the message to the encoding format specified. Once it has been encoded and serialized any resources created for serialization can be released.</p>

<h3 id="a-name-18-sect-maintaining-state-between-persister-callbacks"><a name="18" />&sect;Maintaining state between persister callbacks</h3>

<p>When serializing and deserializing objects there is often a need to share information between callbacks without affecting the object implementation. In order to achieve this the persister can provide a session map to the methods annotated for persister callbacks. Below is an example of a serializable object that can receive a persister session object.</p>

<pre><code>@Root
public class Person {

   @ElementList
   private List&lt;Variable&gt; details;

   @Element
   private Address address;

   private List names;

   @Validate
   public void validate(Map session) throws PersistenceException {
      if(session.isEmpty()) {
         throw new PersistenceException(&quot;Map must not be empty&quot;)
      }
   }

   @Commit
   public void commit(Map session) {
      Set keys = session.keySet();

      for(Object item : keys) {
         names.add(item);
      }
   }
}

@Address
public class Address {

   @Element
   private String street;

   @Element
   private String city;

   @Element
   private String state;

   public String getStreet() {
      return street;
   }

   public String getCity() {
      return city;
   }

   public String getState() {
      return state;
   }
}

@Root
public class Variable {

   @Attribute
   private String name;

   @Attribute
   private String value;

   @Commit
   public void commit(Map session) {
      session.put(name, value);
   }

   public String getName() {
      return name;
   }

   public String getValue() {
      return value;
   }
}
</code></pre>

<p>The above example shows how entry objects can pass there names to its parent during the deserialization process. To clarify, deserialization is performed in a depth first manner so for this example the entry objects will be initialized and have their callback methods invoked before the root example class.
Although this may not seem like a very powerful feature, it offers great capabilities when paired with the templating system described earlier. The templating engine has access to all details placed into the session map object. So other values within the XML document can reference each other. For example take the XML document below for the above objects.</p>

<pre><code>&lt;person&gt;
   &lt;details&gt;
      &lt;var name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;
      &lt;var name=&quot;street&quot; value=&quot;Sesame Street&quot;/&gt;
      &lt;var name=&quot;city&quot; value=&quot;Metropolis&quot;/&gt;
      &lt;var name=&quot;state&quot; value=&quot;Some State&quot;/&gt;
   &lt;/details&gt;
   &lt;address&gt;
      &lt;street&gt;${street}&lt;/street&gt;
      &lt;city&gt;${city}&lt;/city&gt;
      &lt;state&gt;${state}&lt;/state&gt;
   &lt;/address&gt;   
&lt;/person&gt;
</code></pre>

<p>The above XML document illustrates how the variable objects values are accessible to the elements declared in the address element. The street, city, and state needed to be defined only once to be shared throughout the document</p>

<h3 id="a-name-19-sect-serializing-with-cdata-blocks"><a name="19" />&sect;Serializing with CDATA blocks</h3>

<p>At times it is nessecary to serialize large text and element data values. Such values may also contain formatting that you wish to preserve. In such situations it is often best to wrap the values within XML CDATA blocks. The CDATA block can contain XML characters and formatting information which will not be modified by other XML parsers. For example take the following XML source.</p>

<pre><code>&lt;query type=&quot;scrape&quot; name=&quot;title&quot;&gt;
   &lt;data&gt;&lt;![CDATA[

         &lt;news&gt;
         {
            for $text in .//B
            return $text
         }
         &lt;/news&gt;

    ]]&gt;&lt;/data&gt;
&lt;/query&gt;
</code></pre>

<p>The above XML there is an embedded XQuery expression which is encapsulated within a CDATA block. Such a configuration allows the XQuery expression to exist within the XML document without any need to escape the XML characters. Also, if the XQuery expression was very large then this form of encoding would provide better performance. In order to ensure that the data is maintained within the CDATA block the following could be used.</p>

<pre><code>@Root
public class Query {

   @Attribute
   private String scrape;

   @Attribute
   private String title;

   @Element(data=true)
   private String data;  

   public String getData() {
      return data;
   }

   public String getTitle() {
      return title;
   }

   public String getScrape() {
      return scrape;
   }
}
</code></pre>

<p>Here the Element annotation has the data attribute set to true. This tells the serialization process that any value stored within the data field must be written to the resulting XML document within a CDATA block. The data attribute can be used with the Text, ElementArray, and ElementList annotations also.</p>

<h3 id="a-name-20-sect-using-xml-namespaces"><a name="20" />&sect;Using XML namespaces</h3>

<p>Namespaces are used to qualify an element or an attribute in an XML document. In order to use namespaces the Namespace annotation can be used. This allows the declaration of the namespace prefix and reference, often called the namespace URI. Namespace annotations can be used on fields, methods, and even classes. For example take the XML snippet below.</p>

<pre><code>&lt;parent xmlns=&quot;http://domain/parent&quot;&gt;
   &lt;pre:child xmlns:pre=&quot;http://domain/child&quot;&gt;
      &lt;name&gt;John Doe&lt;/name&gt;
      &lt;address xmlns=&quot;&quot;&gt;
          &lt;street&gt;Sin City&lt;/street&gt;
      &lt;/address&gt;
   &lt;/pre:child&gt;
&lt;/parent&gt;
</code></pre>

<p>In the above XML document, the root element is qualified with a default namespace. A default namespace is a namespace that is inherited by all child elements, for further details see Section 6.2 of the namespaces in XML 1.0 specification. In order to annotate a field, method, or class with a default namespace the Namespace annotation can be declared using only the reference attribute. For example, see the annotated class below that produces the above XML.</p>

<pre><code>@Root
@Namespace(reference=&quot;http://domain/parent&quot;)
public class Parent {

   @Element
   @Namespace(reference=&quot;http://domain/child&quot;, prefix=&quot;pre&quot;)
   private Child child;

   public Child getChild() {
      return child;
   }
}

@Root
public class Child {

   @Element
   private String name;

   @Element
   @Namespace
   private Address address;

   public Address getAddress() {
      return address;
   }
}

@Root
public class Address {

   @Element
   private String street;

   public String getStreet() {
      return street;
   }
}
</code></pre>

<p>The above code snippet also shows an annotation with both the namespace reference and prefix attributes declared. Such an annotation declaration will result in a namespace qualified with a prefix. As can be seen in the XML example a prefixed namespace qualifies the XML element with a string prefix followed by a colon.</p>

<p>Should your document require more than one namespace declared in a single element the NamespaceList annotation can be used. This allows multiple namespaces to be declared in a single element. Declaring multiple namespaces in a single element can produce a cleaner more readable XML document. Take the XML snippet below from the namespaces in XML 1.0 specification, which shows an element with multiple namespaces.</p>

<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;book xmlns=&quot;urn:loc.gov:books&quot; xmlns:isbn=&quot;urn:ISBN:0-395-36341-6&quot;&gt;
    &lt;title&gt;Cheaper by the Dozen&lt;/title&gt;
    &lt;isbn:number&gt;1568491379&lt;/isbn:number&gt;
&lt;/book&gt;
</code></pre>

<p>This XML snippet shows two namespaces declared in the root element. Here the root element will be qualified with the default namespace, and child elements can if desired be qualified by the prefixed namespace. To illustrate how such namespace declarations can be done, see the annotated class below.</p>

<pre><code>@Root
@NamespaceList({
@Namespace(reference=&quot;urn:loc.gov:books&quot;)
@Namespace(reference=&quot;urn:ISBN:0-395-36341-6&quot;, prefix=&quot;isbn&quot;)
})
public class Book {

   @Element
   @Namespace(reference=&quot;urn:ISBN:0-395-36341-6&quot;)
   private String number;

   @Element
   private String title;

   public String getTitle() {
      return title;
   }
}
</code></pre>

<p>As can be seen above, there is no need to redeclare the prefix attribute once it has already been declared. This allows the annotation declarations to be less verbose and ensures a consistent use of a prefix for a given namespace reference. Also, once a namespace has been declared and is in scope then it will not be declared a second time in the resulting XML, this ensures the resulting XML document does not contain redundant namespace declarations.</p>

<h3 id="a-name-21-sect-resolving-object-reference-cycles"><a name="21" />&sect;Resolving object reference cycles</h3>

<p>When there are cycles in your object graph this can lead to recursive serialization. However it is possible to resolve these references using a stock strategy. The CycleStrategy maintains the object graph during serialization and deserialization such that cyclical references can be traced and resolved. For example take the following object relationships.</p>

<pre><code>@Root
public class Parent {

   private Collection&lt;Child&gt; children;

   private String name;

   @Attribute
   public String getName() {
      return name;                   
   }

   @Attribute
   public void setName(String name) {
      this.name = name;           
   }

   @Element
   public void setChildren(Collection&lt;Child&gt; children) {
      this.children = children;           
   }

   @Element   
   public Collection&lt;Child&gt; getChildren() {
      return children;           
   }        

   public void addChild(Child child) {
      children.add(child);           
   }
}

@Root
public class Child {

   private Parent parent;

   private String name;

   public Child() {
      super();           
   }

   public Child(Parent parent) {
      this.parent = parent;           
   }

   @Attribute
   public String getName() {
      return name;           
   }

   @Attribute
   public void setName(String name) {
      this.name = name;           
   }

   @Element
   public Parent getParent() {
      return parent;
   }

   @Element
   public void setParent(Parent parent) {
      this.parent = parent;
   }
}
</code></pre>

<p>In the above code snippet the cyclic relation ship between the parent and child can be seen. A parent can have multiple children and a child can have a reference to its parent. This can cause problems for some XML binding and serialization frameworks. However this form of object relationship can be handled seamlessly using the CycleStrategy object. Below is an example of what a resulting XML document might look like.</p>

<pre><code>&lt;parent name=&quot;john&quot; id=&quot;1&quot;&gt;
   &lt;children&gt;
      &lt;child id=&quot;2&quot; name=&quot;tom&quot;&gt;
         &lt;parent ref=&quot;1&quot;/&gt;
      &lt;/child&gt;
      &lt;child id=&quot;3&quot; name=&quot;dick&quot;&gt;
         &lt;parent ref=&quot;1&quot;/&gt;
      &lt;/child&gt;
      &lt;child id=&quot;4&quot; name=&quot;harry&quot;&gt;
         &lt;parent ref=&quot;1&quot;/&gt;
      &lt;/child&gt;
   &lt;/children&gt;
&lt;/parent&gt;
</code></pre>

<p>As can be seen there are two extra attributes present, the id attribute and the ref attribute. These references are inserted into the serialized XML document when the object is persisted. They allow object relationships and references to be recreated during deserialization. To further clarify take the following code snippet which shows how to create a persister that can handle such references.</p>

<pre><code>Strategy strategy = new CycleStrategy(&quot;id&quot;, &quot;ref&quot;);
Serializer serializer = new Persister(strategy);
File source = new File(&quot;example.xml&quot;);
Parent parent = serializer.read(Parent.class, source);
</code></pre>

<p>The strategy is created by specifying the identity attribute as id and the refering attribute as ref. For convinience these attributes have reasonable defaults and the no argument constructor can be used to create the strategy. Although the example shown here is very simple the cycle strategy is capable of serializing and deserializing large and complex relationships.</p>

<h3 id="a-name-22-sect-reusing-xml-elements"><a name="22" />&sect;Reusing XML elements</h3>

<p>As can be seen from using the CycleStrategy in the previous section object references can easily be maintained regardless of complexity. Another benifit of using the cycle strategy is that you can conviniently reuse elements when creating configuration. For example take the following example of a task framework.</p>

<pre><code>@Root
public class Workspace {

   @Attribute
   private File path;

   @Attribute
   private String name

   private File getPath() {
      return path;           
   }

   private String getName() {
      return name;           
   }
}

@Root
public abstract Task {

   @Element        
   private Workspace workspace;         

   public abstract void execute() throws Exception;
}

public class DeleteTask extends Task {

   @ElementList(inline=true, entry=&quot;resource&quot;)        
   private Collection&lt;String&gt; list;        

   public void execute() {
      File root = getPath();

      for(String path : list) {
         new File(root, path).delete();              
      }
   }  
}

public class MoveTask extends Task {

   @ElementList(inline=true, entry=&quot;resource&quot;)
   private Collection&lt;String&gt; list;

   @Attribute
   private File from;

   public void execute() {
      File root = getPath();

      for(String path : list) {
         File create = new File(root, path);
         File copy = new File(from, path);

         copy.renameTo(create);
      }
    }
}
</code></pre>

<p>The above code snippet shows a very simple task framework that is used to perform actions on a workspace. Each task must contain details for the workspace it will perform its specific task on. So, making use of the cycle strategy it is possible to declare a specific object once, using a know identifier and referencing that object throughout a single XML document. This eases the configuration burden and ensures that less errors can creap in to large complex documents where may objects are declared.</p>

<pre><code>&lt;job&gt;
   &lt;workspace id=&quot;default&quot;&gt;
      &lt;path&gt;c:\workspace\task&lt;/path&gt;
   &lt;/workspace&gt;
   &lt;task class=&quot;example.DeleteTask&quot;&gt;
      &lt;workspace ref=&quot;default&quot;/&gt;
      &lt;resource&gt;output.dat&lt;/resource&gt;
      &lt;resource&gt;result.log&lt;/resource&gt;
   &lt;/task&gt;
   &lt;task class=&quot;example.MoveTask&quot;&gt;
      &lt;workspace ref=&quot;default&quot;/&gt;
      &lt;from&gt;c:\workspace\data&lt;/from&gt;
      &lt;resource&gt;input.xml&lt;/resource&gt;
   &lt;/task&gt;
&lt;/job&gt;
</code></pre>

<h3 id="a-name-23-sect-using-utility-collections"><a name="23" />&sect;Using utility collections</h3>

<p>For convinience there are several convinience collections which can be used. These collections only need to be annotated with the ElementList annotation to be used. The first stock collection resembles a map in that it will accept values that have a known key or name object, it is the Dictionary collection. This collection requires objects of type Entry to be inserted on deserialization as this object contains a known key value. To illustrate how to use this collection take the following example.</p>

<pre><code>@Root
public class TextMap {

   @ElementList(inline=true)
   private Dictionary&lt;Text&gt; list;   

   public Text get(String name) {
      return list.get(name);           
   }
}

@Root
public class Text extends Entry {

   @Text          
   public String text;

   public String getText() {
      return text;           
   }
}
</code></pre>

<p>The above objects show how the dictionary collection is annotated with the element list annotation. The containing object can not serialize and deserialize entry objects which can be retrieve by name. For example take the following XML which shows the serialized representation of the text map object.</p>

<pre><code>&lt;textMap&gt;
   &lt;text name=&quot;name&quot;&gt;Niall Gallagher&lt;/text&gt;
   &lt;text name=&quot;street&quot;&gt;Seasme Street&lt;/text&gt;
   &lt;text name=&quot;city&quot;&gt;Atlantis&lt;/text&gt;
&lt;/textMap&gt;
</code></pre>

<p>Each text entry deserialized in to the dictionary can now be acquired by name. Although this offers a convinient map like structure of acquring objects based on a name there is often a need to match objects. For such a requirement the Resolver collection can be used. This offers a fast pattern matching collection that matches names or keys to patterns. Patterns are deserialized within Match objects, which are inserted in to the resolver on deserialization. An example of the resolver is shown below.</p>

<pre><code>@Root
private static class ContentType extends Match {

   @Attribute
   private String value;        

   public ContentType() {
      super();                  
   }

   public ContentType(String pattern, String value) {
      this.pattern = pattern;
      this.value = value;        
   }
}

@Root
private static class ContentResolver implements Iterable {

   @ElementList
   private Resolver&lt;ContentType&gt; list;           

   @Attribute
   private String name;

   public Iterator&lt;ContentType&gt; iterator() {
      return list.iterator();
   }

   public ContentType resolve(String name) {
      return list.resolve(name);              
   }
}  
</code></pre>

<p>The above content resolver will match a string with a content type. Such an arrangement could be used to resolve paths to content types. For example the following XML document illustrates how the resolver could be used to match URL paths to content types for a web application.</p>

<pre><code>&lt;contentResolver name=&quot;example&quot;&gt;
   &lt;contentType pattern=&quot;*.html&quot; value=&quot;text/html&quot;/&gt;
   &lt;contentType pattern=&quot;*.jpg&quot; value=&quot;image/jpeg&quot;/&gt;
   &lt;contentType pattern=&quot;/images/*&quot; value=&quot;image/jpeg&quot;/&gt;
   &lt;contentType pattern=&quot;/log/**&quot; value=&quot;text/plain&quot;/&gt;
   &lt;contentType pattern=&quot;*.exe&quot; value=&quot;application/octetstream&quot;/&gt;
   &lt;contentType pattern=&quot;**.txt&quot; value=&quot;text/plain&quot;/&gt;
   &lt;contentType pattern=&quot;/html/*&quot; value=&quot;text/html&quot;/&gt;
&lt;/contentResolver&gt;
</code></pre>

<p>Although the resolver collection can only deal with wild card characters such as * and ? it is much faster than resolutions performed using Java regular expressions. Typically it is several orders of magnitude faster that regular expressions, particularly when it is used to match reoccuring values, such as URI paths.</p>

<h3 id="a-name-24-sect-object-substitution"><a name="24" />&sect;Object substitution</h3>

<p>Often there is a need to substitute an object into the XML stream either during serialization or deserialization. For example it may be more convinient to use several XML documents to represent a configuration that can be deserialized in to a single object graph transparently. For example take the following XML.</p>

<pre><code>&lt;registry&gt;
    &lt;import name=&quot;external.xml&quot; class=&quot;example.ExternalDefinition&quot;/&gt;
    &lt;define name=&quot;blah&quot; class=&quot;example.DefaultDefinition&quot;&gt;
       &lt;property key=&quot;a&quot;&gt;Some value&lt;/property&gt;
       &lt;property key=&quot;b&quot;&gt;Some other value&lt;/property&gt;
    &lt;/define&gt;
&lt;/registry&gt;
</code></pre>

<p>In the above XML document there is an import XML element, which references a file external.xml. Given that this external file contains further definitions it would be nice to be able to replace the import with the definition from the file. In such cases the Resolve annotation can be used. Below is an example of how to annotate your class to substitute the objects.</p>

<pre><code>@Root
private class Registry {

   @ElementList(inline=true)
   private Dictionary&lt;Definition&gt; import;

   @ElementList(inline=true)
   private Dictionary&lt;Definition&gt; define;

   public Definition getDefinition(String name) {
      Definition value = define.get(name);

      if(value == null) {
         value = import.get(name);
      }
      return value;
   }
}

public interface Definition {

   public String getProperty(String key);
}

@Root(name=&quot;define&quot;)
public class DefaultDefinition implements Definition {

   @ElementList(inline=true)
   private Dictionary&lt;Property&gt; list;

   public String getProperty(String key) {
      return list.get(key);
   }
}

@Root(name=&quot;import&quot;)
public class ExternalDefinition implements Definition {

   @Element
   private File name;

   public String getProperty(String key) {
      throw new IllegalStateException(&quot;Method not supported&quot;);
   }    

   @Resolve
   public Definition substitute() throws Exception {
      return new Persister().read(Definition.class, name);
   }
}
</code></pre>

<p>Using this form of substitution objects can be replaced in such a way that deserialized objects can be used as factories for other object instances. This is similar to the Java serialization concept of readResolve and writeReplace methods.</p>

<h3 id="a-name-25-sect-serializing-java-language-types"><a name="25" />&sect;Serializing Java language types</h3>

<p>A common requirement of any serialization framework is to be able to serialize and deserialize existing types without modification. In particular types from the Java class libraries, like dates, locales, and files. For many of the Java class library types there is a corrosponding Transform implementation, which enables the serialization and deserialization of that type. For example the java.util.Date type has a transform that accepts a date instance and transforms that into a string, which can be embedded in to the generated XML document during serialization. For deserialization the same transform is used, however this time it converts the string value back in to a date instance. The code snippet below demonstrates how a such transformations make it possible to use such a type when implementing your class XML schema.</p>

<pre><code>@Root
public class DateList {

   @Attribute
   private Date created;

   @ElementList
   private List&lt;Date&gt; list;

   public Date getCreationDate() {
      retrun created;
   }

   public List&lt;Date&gt; getDates() {
      return list;
   }
}
</code></pre>

<p>Here the date object is used like any other Java primitive, it can be used with any of the XML annotations. Such objects can also be used with the CycleStrategy so that references to a single instance within your object graph can be maintained throughout serialization and deserialization operations. Below is an example of the XML document generated.</p>

<pre><code>&lt;dateList created=&quot;2007-01-03 18:05:11.234 GMT&quot;&gt;
    &lt;list&gt;
        &lt;date&gt;2007-01-03 18:05:11.234 GMT&lt;/date&gt;
        &lt;date&gt;2007-01-03 18:05:11.234 GMT&lt;/date&gt;
    &lt;/list&gt;
&lt;/dateList&gt;
</code></pre>

<p>Using standard Java types, such as the Date type, can be used with any of the XML annotations. The set of supported types is shown below. Of particular note are the primitive array types, which when used with the ElementArray annotation enable support for multidimentional arrays.</p>

<pre><code>char
char[]
java.lang.Character
java.lang.Character[]
int
int[]
java.lang.Integer
java.lang.Integer[]
short
short[]
java.lang.Short
java.lang.Short[]
long        
long[]
java.lang.Long
java.lang.Long[]
double
double[]
java.lang.Double
java.lang.Double[]
byte
byte[]
java.lang.Byte
java.lang.Byte[]
float       
float[]        
java.lang.Float        
java.lang.Float[]        
boolean
boolean[]
java.lang.Boolean
java.lang.Boolean[]
java.lang.String
java.lang.String[]
java.util.Date
java.util.Locale
java.util.Currency
java.util.TimeZone
java.util.GregorianCalendar
java.net.URL
java.io.File
java.math.BigInteger
java.math.BigDecimal
java.sql.Date
java.sql.Time
java.sql.Timestamp
</code></pre>

<p>For example take the following code snippet, here points on a graph are represented as a multidimentional array of integers. The array is annotated in such a way that it can be serialized and deserialized seamlessly. Each index of the array holds an array of type int, which is transformed using the Transformer in to a comma separated list of integer values. Obviously this is not of much use in a real world situation, however it does illustrate how the transformable types can be integrated seamlessly with existing XML annotations.</p>

<pre><code>@Root
public class Graph {

   @ElementArray(entry=&quot;point&quot;)
   private int[][] points;

   public Graph() {
      super();
   }

   @Validate
   private void validate() throws Exception {
      for(int[] array : points) {
         if(array.length != 2) {
            throw new InvalidPointException(&quot;Point can not have %s values&quot;, array.length);
         }
      }
   }

   public int[][] getPoints() {
      return points;      
   }
}
</code></pre>

<p>For the above code example the resulting XML generated would look like the XML document below. Here each index of the element array represents an array of integers within the comma separated list. Such structures also work well with the cycle strategy in maintaining references.</p>

<pre><code>&lt;graph&gt;
   &lt;points length=&quot;4&quot;&gt;
      &lt;point&gt;3, 5&lt;/point&gt;
      &lt;point&gt;5, 6&lt;/point&gt;
      &lt;point&gt;5, 1&lt;/point&gt;
      &lt;point&gt;3, 2&lt;/point&gt;
   &lt;/points&gt;
&lt;/graph&gt;
</code></pre>

<h3 id="a-name-26-sect-styling-serialized-xml"><a name="26" />&sect;Styling serialized XML</h3>

<p>In order to serialize objects in a consistent format a Style implementation can be used to format the elements and attributes written to the XML document. Styling of XML allows both serialization and deserialization to be performed. So once serialized in a styled XML format you can deserialize the same document back in to an object.</p>

<pre><code>@Root
public class PersonProfile {

   @Attribute
   private String firstName;

   @Attribute
   private String lastName;

   @Element
   private PersonAddress personAddress;

   @Element
   private Date personDOB;

   public Date getDateOfBirth() {
      return personDOB;
   }

   public String getFirstName() {
      return firstName;
   }

   public String getLastName() {
      return lastName;
   }

   public PersonAddress getAddress() {
      return personAddress;
   }
}

@Root
public class PersonAddress {

   @Element
   private String houseNumber;

   @Element
   private String streetName;

   @Element
   private String city;

   public String getHouseNumber() {
      return houseNumber;
   }

   public String getStreetName() {
      return streetName;
   }

   public String getCity() {
      return city;
   }
}
</code></pre>

<p>For example, taking the above annotated objects. An instance of the person profile can be serialized in to an XML document that is styled with a hyphenated format. This produces a consistently formated result which is just as deserializable as a serialization that is not styled.</p>

<pre><code>&lt;person-profile first-name=&quot;Niall&quot; last-name=&quot;Gallagher&quot;&gt;
   &lt;person-DOB&gt;10/10/2008&lt;/person-DOB&gt;
   &lt;person-address&gt;
      &lt;house-number&gt;10&lt;/house-number&gt;
      &lt;street-name&gt;Sesame Street&lt;/street-name&gt;
      &lt;city&gt;Disney Land&lt;/city&gt;
   &lt;/person-address&gt;
&lt;/person-profile&gt;
</code></pre>

<p>In order to serialize an object in a styled format either the HyphenStyle or CamelCaseStyle can be used. If neither suits one can always be implemented. Also, for convenience any of the elements or attributes can be overridden with a specific string by setting it to the style instance. The code snippet below shows how to serialize the object in the hyphenated style above.</p>

<pre><code>Style style = new HyphenStyle();
Format format = new Format(style);
Serializer serializer = new Persister(format);

serializer.write(personDetail, file);
</code></pre>

<h3 id="a-name-27-sect-version-tolerant-serialization"><a name="27" />&sect;Version tolerant serialization</h3>

<p>In order to serialize objects in a version tolerant format a Version annotation can be introduced to the class. This will allow a later, modified class to be read from XML generated by the original class. For example take the following code snippet showing an annotated class.</p>

<pre><code>@Root
@Namespace(prefix=&quot;p&quot;, reference=&quot;http://www.domain.com/person&quot;)
public class Person {

  @Attribute
  private String name;

  @Element
  private String height;

  @Element
  private String weight;

  public String getName() {
     return name;
  }

  public String getHeight() {
     return height;
  }

  public String getWeight() {
     return weight;
  }
}
</code></pre>

<p>The above annotated class schema will generate XML in a format compatible with that class. For example, a serialization of the class could result in the following XML snippet. This shows the height and weight elements as well as the name attribute.</p>

<pre><code>&lt;p:person name=&quot;John Doe&quot; xmlns:p=&quot;http://www.domain.com/person&quot;&gt;
    &lt;height&gt;185&lt;/height&gt;
    &lt;weight&gt;84&lt;/height&gt;
&lt;/p:person&gt;
</code></pre>

<p>Having used this class schema to serialize instances of the Person class, It could later be extended or modified as follows and still read and write in a format compatible with the old class schema like so, even though the resulting XML has changed.</p>

<pre><code>@Root
@Namespace(prefix=&quot;p&quot;, reference=&quot;http://www.domain.com/person&quot;)
public class Person {

  @Version(revision=1.1)
  private double version;

  @Attribute
  private String name;

  @Attribute
  private int age;

  @Element
  private int height;

  public String getName() {
     return name;
  }

  public int getHeight() {
     return height;
  }

  public int getAge() {
     return age;
  }
}
</code></pre>

<p>Here the version attribute is annotated with the special Version annotation. This will read the previously generated XML and compare the version attribute of the person element and compare it to the revision attribute of the annotation. If the version annotation does not exist the initial 2.0 version is assumed. So when using the new modified class, which is revision 1.1, with the old serialized XML the serializer will determine that the two have differing versions. So when deserializing it will ignore the excess weight element and ignore the fact that the age attribute does not exist. It will do this for all attributes and elements that do not match.</p>

<p>This is quite similar to the C# XML serialization version capability. Where the initial version of each class is 1.0 (implicitly) and subsequent versions increase. This tells the serializer how it should approach deserialization of different versions. The later version of the class when serialized will explicitly write the version as follows.</p>

<pre><code>&lt;p:person version=&quot;1.1&quot; name=&quot;John Doe&quot; age=&quot;60&quot; xmlns:p=&quot;http://www.domain.com/person&quot;&gt;
    &lt;height&gt;185&lt;/height&gt;
&lt;/p:person&gt;
</code></pre>

<h3 id="a-name-28-sect-serializing-static-final-fields"><a name="28" />&sect;Serializing static final fields</h3>

<p>Often there is a need to add elements and attributes to an XML document that do not change. In such an event it is often attractive to declare these fields as static final fields. When annotating static final fields they form part of the XML schema and contribute to the validation of the document but do not get set when deserializing the XML in to a object instance. So should a required static final field not exist in the source XML then an exception is thrown when deserializing, much like what would happen if the field was mutable. For example take the code snippet below, which shows an immutable static final field used with mutable fields.</p>

<pre><code>@Root
public class Citation {

   @Element(name=&quot;author&quot;)
   private static final String AUTHOR = &quot;Niall Gallagher&quot;;

   @Element
   private String title;

   @Element   
   private String date;

   public Date getDate() {
      return date;
   }
}
</code></pre>

<p>The above annotated object describes a simple citation. The citation object itself contains a static final field that will be written to the resulting XML document when serialized. However, on deserialization the values read from the XML will not change the annotated final static field. Instead the deserialization process will simply validate the presence of the elements and attributes within the document. This results in an object that will always write the same value for the annotated final static elements or attributes.</p>

<pre><code>&lt;citation&gt;
   &lt;author&gt;Niall Gallagher&lt;/author&gt;
   &lt;title&gt;Simple XML Serialization&lt;/author&gt;
   &lt;date&gt;12 January 2010&lt;/date&gt;
&lt;/citation&gt;
</code></pre>

<h3 id="a-name-29-sect-overriding-serialization-with-converters"><a name="29" />&sect;Overriding serialization with converters</h3>

<p>Often times there is a need to serialize an object that can not be annotated. Such objects may exist in third party dependencies or packages. To serialize these objects a Converter object can be implemented. A converter can be used to intercept the normal serialization process. Interception of the normal serialization process can be done in several different ways, for example take the code snippet below.</p>

<pre><code>@Root
public class Example {

   @Element
   @Convert(ExternalConverter.class)
   private External external;

   public External getExternal() {
      return external;
   }
}

public class ExternalConverter implements Converter&lt;External&gt; {

   public External read(InputNode node) {
      String name = node.getAttribute(&quot;name&quot;);
      String value = node.getAttribute(&quot;value&quot;);

      return new External(name, value);
   }

   public void write(OutputNode node, External external) {
      String name = external.getName();
      String value = external.getValue();

      node.setAttribute(&quot;name&quot;, name);
      node.setAttribute(&quot;value&quot;, value);
   }
}
</code></pre>

<p>The above code snippet also shows a field annotated with the Convert annotation. The converter specified by the annotation will be used to intercept the normal serialization process and produce a customized XML element. Take the XML below, this is produced when the example object is serialized.</p>

<pre><code>&lt;example&gt;
    &lt;external name=&quot;book&quot; value=&quot;Shantaram&quot;/&gt;
&lt;/example&gt;
</code></pre>

<p>Interception of the normal serialization process is performed using a Strategy implementation and so does not form part of the core serialization process. Instead a specific strategy needs to be provided to the persister as is shown in the code snippet below.</p>

<pre><code>Strategy strategy = new AnnotationStrategy();
Serializer serializer = new Persister(strategy);

serializer.read(Example.class, file);
</code></pre>

<p>Without the specification of the AnnotationStrategy the interception could not be performed, as the core serialization process will not acknowledge the Convert annotation. So in effect this strategy extends the core serialization process in an independent and transparent manner. Another even more transparent way to intercept the normal serialization process is to use another strategy implementation. The RegistryStrategy allows bindings to be registered between classes and converters, there is no need for additional annotations as was required for the previous example. Below is an example of how to establish bindings between a class and a converter.</p>

<pre><code>Registry registry = new Registry();
Strategy strategy = new RegistryStrategy(registry);
Serializer serializer = new Persister(strategy);

registry.bind(External.class, ExternalConverter.class);
</code></pre>

<p>As many bindings as is required can be established with a registry. Also, if more complex converters are required a converter instance can be registered. Such a converter could have a reference to the Persister object so that nested serialization can be performed. This registry strategy also ensures that objects within Java collection objects can be serialized with registered converters. To illustrate how a complex converter could be registered take a look at the snippet below.</p>

<pre><code>Registry registry = new Registry();
Strategy strategy = new RegistryStrategy(registry);
Serializer serializer = new Persister(strategy);
ComplexConverter converter = new ComplexConverter(serializer);

registry.bind(ComplexObject.class, converter);
</code></pre>

<h3 id="a-name-30-sect-intercepting-the-serialization-process"><a name="30" />&sect;Intercepting the serialization process</h3>

<p>Interception of the serialization process can be useful in several scenarios, for example if attributes are to be added or removed from an XML element then that element can be intercepted and modified during the serialization process. One useful application of interception is to change attribute names or values. For example, the &ldquo;class&rdquo; annotations added by the TreeStrategy could be intercepted and changed to a language neutral format that does not contain the Java class name. Below is an example of how to use a Visitor to add debug comments to an obect which is to be serialized.</p>

<pre><code>@Root
@Default
public class CommentExample {

    private String name;

    private BigDecimal number;

    private Date date;     
}

public class CommentVisitor implements Visitor {

   public void write(Type type, NodeMap&lt;OutputNode&gt; node) {
      OutputNode element = node.getNode();
      Class type = type.getType();
      String comment = type.getName();

      if(!element.isRoot()) {
         element.setComment(comment);
      }
   }
}
</code></pre>

<p>The above visitor implementation will get the OutputNode that represents the XML element for the provided map of attributes. If the element does not represent the root element in the XML document then every element will have an associated comment, which descrives the class it represents. Such a visitor can be useful when serializing large document structures. The XML snippet below provides an example of what would be written.</p>

<pre><code>&lt;commentExample&gt;
    &lt;!-- java.lang.String --&gt;
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;!-- java.math.BigDecimal --&gt;
    &lt;number&gt;100.0&lt;/number&gt;
    &lt;!-- java.lang.Integer --&gt;
    &lt;value&gt;18&lt;/value&gt;
&lt;/commentExample&gt;
</code></pre>

<p>To add a visitor to serialization the VisitorStrategy must be used. This strategy takes a visitor implementation and if required a strategy to delegate to. As usual, this strategy implementation can then be used to construct a persister, which can then serialize and deserialize objects.</p>

<h3 id="a-name-31-sect-mapping-with-xpath-expressions"><a name="31" />&sect;Mapping with XPath expressions</h3>

<p>At times it is useful to have your object model map to complex XML documents, without having to write an annotated class to map to the required elements and attributes. For such scenarios the Path annotation can be used. This requires the user to specify an XPath expression for a field or method. For example take annotated fields below.</p>

<pre><code>@Root
public class ServerDeployment {

   @Attribute
   @Path(&quot;group&quot;)
   private ServerType type;

   @Element
   @Path(&quot;group/server[1]/details&quot;)
   private Server primary;

   @Element
   @Path(&quot;group/server[2]/details&quot;)
   private Server secondary;

   public Server getPrimary() {
      return primary;
   }

   public Server getSecondary() {
      return secondary;
   }
}

@Root
public class Server {

   @Attribute
   private String host;

   @Attribute
   private int port;
}

public enum ServerType {
   WINDOWS,
   LINUX,
   SOLARIS
}
</code></pre>

<p>The above code shows annotations applied to two objects. One contains XPath expressions that tell the serialization process how to read and write the details to an from the document. Here the expression defines a server within wrapper elements. When serializing such objects, the following XML results.</p>

<pre><code>&lt;serverDeployment&gt;
   &lt;group type=&quot;LINUX&quot;&gt;
      &lt;server&gt;
         &lt;details&gt;
            &lt;primary host=&quot;host1.domain.com&quot; port=&quot;4567&quot;/&gt;
         &lt;/details&gt;
      &lt;/server&gt;
      &lt;server&gt;
         &lt;details&gt;
            &lt;secondary host=&quot;host2.domain.com&quot; port=&quot;4567&quot;/&gt;
         &lt;/details&gt;
      &lt;/server&gt;
   &lt;/group&gt;
&lt;/serverDeployment&gt;
</code></pre>

<p>As can be seen the XPath expressions defined have been used to determine the structure of the XML document. Such expressions allow a complex XML format to be serialized in to two simple objects. This can greatly reduce the number of types required to map an object to an XML structure. Both attributes and elements can be mapped in this manner.</p>

<p>When ordering elements with the Order annotation these wrapper elements can be sorted. To order wrapper elements an XPath expression can be used to identify the wrapper. Simply place the expression in the order annotation along with any element or attribute names and it is ordered as required. For example, take the following code snippet.</p>

<pre><code>@Default
@Order(elements={&quot;name[1]/first&quot;, &quot;name[1]/surname&quot;, &quot;age/date&quot;, &quot;name[2]/nickname&quot;})
public class Person {

   @Path(&quot;name[1]&quot;)
   private String first;

   @Path(&quot;name[1]&quot;)
   private String surname;

   @Path(&quot;name[2]&quot;)
   private String nickname;

   @Path(&quot;age&quot;)
   private String date;

   public String getName() {
      return first;
   }

   public String getSurname() {
      return surname;
   }
}
</code></pre>

<p>Just like ordering of elements or attributes without XPath expressions, a reference is all that is needed to ensure order. For the above code the serialization of the object will result in the following XML.</p>

<pre><code>&lt;person&gt;
   &lt;name&gt;
      &lt;first&gt;Jack&lt;/first&gt;
      &lt;surname&gt;Daniels&lt;/surname&gt;
   &lt;/name&gt;
   &lt;age&gt;
       &lt;birth&gt;19/10/1912&lt;/birth&gt;
   &lt;/age&gt;
   &lt;name&gt;
      &lt;nickname&gt;JD&lt;/nickname&gt;
   &lt;/name&gt;
&lt;/person&gt;
</code></pre>

<p>In the above XML snippet we have serialized a single object in to multiple elements and ensured the order of the elements is as we required. Ordering can be applied to elements and attributes with Path annotations as easily as it can to those without, and both can be mixed within the same annotation. Using this type of ordering it is possible to generate very predictible results. One thing to note when using such annotations, is that only a subset of the XPath expression syntax is supported. For example, element and attribute references can not be taken from the root of the document, only references within the current context are allowed.</p>

<h3 id="a-name-32-sect-dynamic-serialization-with-unions"><a name="32" />&sect;Dynamic serialization with unions</h3>

<p>In order to perform dynamic serialization where element names bind to specific types the ElementUnion annotation can be used. This allows different XML schema classes to be associated with a single annotated field or method. Serialization of the associated instance determines the XML element name using the instance type. On deserialization the XML element name is then used to determine the schema class to use. For example, take the following set of annotated classes.</p>

<pre><code>public interface Shape {

   public double area();
}

@Root
public class Circle implements Shape {

   @Element
   private double radius;

   public Circle(@Element(name=&quot;radius&quot;) double radius) {
      this.radius = radius;
   }

   public double area() {
      return Math.PI * Math.pow(radius, 2.0);
   }
}

@Root
public class Rectangle implements Shape {

   @Element
   private double width;

   @Element
   private double height;

   public Rectangle(
      @Element(name=&quot;width&quot;) double width,
      @Element(name=&quot;height&quot;) double height)
   {
      this.height = height;
      this.width = width;
   }

   public double area() {
      return width * height;
   }
}

@Root
public class Diagram {

   @ElementUnion({
      @Element(name=&quot;circle&quot;, type=Circle.class),
      @Element(name=&quot;rectangle&quot;, type=Rectangle.class)
   })
   private Shape shape;

   public Diagram() {
      super();
   }

   public void setShape(Shape shape){
      this.shape = shape;
   }

   public Shape getShape() {
      return shape;
   }
}
</code></pre>

<p>The above set of classes can now be used to dynamically deserialize different XML documents using a single schema class. For example, take the XML snippet below, this shows what is generated when the shape is assigned an instance of the circle type.</p>

<pre><code>&lt;diagram&gt;
   &lt;circle&gt;
      &lt;radius&gt;3.0&lt;/radius&gt;
   &lt;/circle&gt;
&lt;/diagram&gt;
</code></pre>

<p>However, if the shape field is assigned an instance of the square type then serialization of the diagram results in a different XML document. See the XML snippet below.</p>

<pre><code>&lt;diagram&gt;
   &lt;rectangle&gt;
      &lt;width&gt;5.0&lt;/width&gt;
      &lt;height&gt;11.0&lt;/heigth&gt;
   &lt;/rectangle&gt;
&lt;/diagram&gt;
</code></pre>

<p>Providing dynamic serialization capabilities via the ElementUnion annotation ensures that more complex XML documents can be handled with ease. Typically, such unions will be required for a list of similar types. To tackle lists the ElementListUnion annotation can be used. This can be used as a union of inline lists to collect similar XML declarations in to a single list. For example, take the annotated classes below.</p>

<pre><code>public interface Operation {

   public void execute();
}

@Default
public class Delete implements Operation {

   private File file;

   public Delete(@Element(name=&quot;file&quot;) File file) {
      this.file = file;
   }

   public void execute() {
      file.delete();
   }
}

@Default
public class MakeDirectory implements Operation {

   private File path;

   private MakeDirectory(@Element(name=&quot;path&quot;) File path) {
      this.path = path;
   }

   public void execute() {
      path.mkdirs();
   }
}

@Default
public class Move implements Operation {

   private File source;
   private File destination;

   public Move(
         @Element(name=&quot;source&quot;) File source,
         @Element(name=&quot;destination&quot;) File destination)
   {
      this.source = source;
      this.destination = destination;
   }

   public void execute() {
      source.renameTo(destination);
   }
}

@Root
public class Task {

   @ElementListUnion({
      @ElementList(entry=&quot;delete&quot;, inline=true, type=Delete.class),
      @ElementList(entry=&quot;mkdir&quot;, inline=true, type=MakeDirectory.class),
      @ElementList(entry=&quot;move&quot;, inline=true, type=Move.class)
   })
   private List&lt;Operation&gt; operations;

   @Attribute
   private String name;

   public Task(@Attribute(name=&quot;name&quot;) String name) {
      this.operations = new LinkedList&lt;Operation&gt;();
      this.name = name;
   }

   public void add(Operation operation) {
      operations.add(operation);
   }

   public void execute() {
      for(Operation operation : operations) {
         operation.execute();
      }
   }
}
</code></pre>

<p>For the above set of annotated classes a list of operations can be defined in an XML document. Each type inserted in to the list can be resolved using the XML element name. Below is an example XML document generated from the annotated classes.</p>

<pre><code>&lt;task name=&quot;setup&quot;&gt;
   &lt;delete&gt;
      &lt;file&gt;C:\workspace\classes&lt;/file&gt;
   &lt;/delete&gt;
   &lt;mkdir&gt;
      &lt;path&gt;C:\workspace\classes&lt;/path&gt;
   &lt;/mkdir&gt;
   &lt;move&gt;
      &lt;source&gt;C:\worksace\classes&lt;/source&gt;
      &lt;destination&gt;C:\workspace\build&lt;/destination&gt;
   &lt;/move&gt;
&lt;/task&gt;
</code></pre>

<hr />

<p>(Note: This article’s original links is <a href="http://simple.sourceforge.net/download/stream/doc/tutorial/tutorial.php" title="SimpleXML Tutorial"><em>here</em></a> )</p>
        </div>
        <div id="post-navigator">
          <a id="post-navigator-prev" href="http://alimy.me/post/dev_201602021955/" title="上一篇">&lt;&lt; TypeScript Language Specification</a>
          <a id="post-navigator-next" href="http://alimy.me/post/art_201603071419/" title="下一篇">吻 >></a>
        </div>
        <div id="post-comments">
          <h3>Comments</h3>
          


<div id="disqus_thread"></div>

<script type="text/javascript">
  var disqusUsername = "alimy";

  (function() { 
  var d = document, s = d.createElement('script');

  s.src = '//' + disqusUsername + '.disqus.com/embed.js';

  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


        </div>
        <footer id="copyright"> <p>&copy;2018 <a href="mailto:alimy@gility.net" title="Email:alimy@gility.net">Alimy</a> All rights reserved. <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258492321'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1258492321' type='text/javascript'%3E%3C/script%3E"));</script></p></footer>

    </div>
    <script>(function(){var WebP=new Image();WebP.onload=WebP.onerror=function(){
if(WebP.height!=2){var sc=document.createElement('script');sc.type='text/javascript';sc.async=true;
var s=document.getElementsByTagName('script')[0];sc.src='/js/webpjs-0.0.2.min.js';s.parentNode.insertBefore(sc,s);}};
WebP.src='data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';})();</script>

  </body>
</html>
