<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Xml on 北野家 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://alimy.me/tags/xml/</link>
    
    
    <copyright>&amp;copy;2016, Alimy; all rights reserved.</copyright>
    <updated>Wed, 09 Mar 2016 21:20:00 CST</updated>
    
    <item>
      <title>XStream: XML Transformation</title>
      <link>http://alimy.me/post/dev_201603092120/</link>
      <pubDate>Wed, 09 Mar 2016 21:20:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092120/</guid>
      <description>&lt;p&gt;XStream provides a TraxSource (extends SAXSource) that can be used as an input to XSLT transformation. The TraxSource uses a java Object and the corresponding XStream Object. The java object can then be directly converted to XSLT target without actually converting to XML. Lets look at an example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.ArrayList;

import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.TraxSource;

public class XStreamTransformationExample {
	public static void main(String[] args) throws TransformerFactoryConfigurationError, TransformerException {
		XStreamTransformationExample transformationExample = new XStreamTransformationExample();
		transformationExample.runTransformation();
	}

	private void runTransformation() throws TransformerFactoryConfigurationError, TransformerException {
		XStream xstream = new XStream();
		xstream.alias(&amp;quot;rss&amp;quot;, Rss2.class);
		xstream.alias(&amp;quot;item&amp;quot;, Item2.class);
		Rss2 rss = new Rss2();
		Channel2 channel = new Channel2();
		rss.channel = channel;
		channel.title = &amp;quot;Title&amp;quot;;
		channel.link = &amp;quot;link&amp;quot;;
		channel.image = new Image2();
		channel.image.link = &amp;quot;image link&amp;quot;;
		Item2 item1 = new Item2();
		item1.link = &amp;quot;item link&amp;quot;;
		item1.title = &amp;quot;Item Title&amp;quot;;
		channel.items = new ArrayList&amp;lt;Item2&amp;gt;();
		channel.items.add(item1);
		System.out.println(xstream.toXML(rss));

		Transformer transformer = TransformerFactory.newInstance().newTransformer(new StreamSource(&amp;quot;bbc.xsl&amp;quot;));
		TraxSource traxSource = new TraxSource(rss, xstream);
		StreamResult result = new StreamResult(System.out);
		transformer.transform(traxSource, result);

		// prints the html on console

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The XML.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

			link

				image link




					item link

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Rss2 and other classes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.Arrays;
import java.util.List;

public class Rss2 {
	public Channel2 channel;

	@Override
	public String toString() {
		return &amp;quot;Rss [channel=&amp;quot; + channel + &amp;quot;]&amp;quot;;
	}

}

class Channel2 {
	public String title;
	public String link;
	public String description;
	public String language;
	public String lastBuildDate;
	public String copyright;
	public Image2 image;
	public String ttl;
	public AtomLink a_link;
	public List items;

	public class AtomLink {
		public String href;
		public String rel;
		public String type;

		@Override
		public String toString() {
			return &amp;quot;AtomLink [href=&amp;quot; + href + &amp;quot;, rel=&amp;quot; + rel + &amp;quot;, type=&amp;quot; + type + &amp;quot;]&amp;quot;;
		}

	}

	@Override
	public String toString() {
		return &amp;quot;Channel [title=&amp;quot; + title + &amp;quot;, link=&amp;quot; + link + &amp;quot;, description=&amp;quot; + description + &amp;quot;, language=&amp;quot; + language + &amp;quot;, lastBuildDate=&amp;quot;
				+ lastBuildDate + &amp;quot;, copyright=&amp;quot; + copyright + &amp;quot;, image=&amp;quot; + image + &amp;quot;, ttl=&amp;quot; + ttl + &amp;quot;, a_link=&amp;quot; + a_link + &amp;quot;, items=&amp;quot; + items + &amp;quot;]&amp;quot;;
	}

}

class Item2 {
	public String title;
	public String description;
	public String link;
	public String guid;
	public String pubDate;
	public MediaThumbnail[] media_thumbnails;

	@Override
	public String toString() {
		return &amp;quot;Item [title=&amp;quot; + title + &amp;quot;, link=&amp;quot; + link + &amp;quot;, guid=&amp;quot; + guid + &amp;quot;, pubDate=&amp;quot; + pubDate + &amp;quot;, media_thumbnails=&amp;quot;
				+ Arrays.toString(media_thumbnails) + &amp;quot;]&amp;quot;;
	}

	public class MediaThumbnail {
		public int width;
		public int height;
		public String url;

		@Override
		public String toString() {
			return &amp;quot;MediaThumbnail [width=&amp;quot; + width + &amp;quot;, height=&amp;quot; + height + &amp;quot;, url=&amp;quot; + url + &amp;quot;]&amp;quot;;
		}

	}

}

class Image2 {
	public String url;
	public String title;
	public String link;
	public String width;
	public String height;

	@Override
	public String toString() {
		return &amp;quot;Image [url=&amp;quot; + url + &amp;quot;, title=&amp;quot; + title + &amp;quot;, link=&amp;quot; + link + &amp;quot;, width=&amp;quot; + width + &amp;quot;, height=&amp;quot; + height + &amp;quot;]&amp;quot;;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-xml-transformation.jsp&#34; title=&#34;XML Transformation&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>XStream: Json to Java</title>
      <link>http://alimy.me/post/dev_201603092115/</link>
      <pubDate>Wed, 09 Mar 2016 21:15:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092115/</guid>
      <description>&lt;p&gt;XStream can also be used with JSON. XStream provides two drivers : a JsonHierarchicalStreamDriver and a JettisonMappedXmlDriver. The JsonHierarchicalStreamDriver can be used to write a JSON string but cannot deserialize a JSON. JettisonMappedXmlDriver can be used to deserialize a JSON but it introduces an additional dependency. In this example we deserialize a json string into a java object.&lt;/p&gt;

&lt;p&gt;Note: The mapping from Java to JSON (and back) is limited, since not anything can be expressed in JSON as with XML. It works quite well for simple objects, but one should not expect wonders. Additionally XStream supports only Jettison 1.0.1. Any other version will not work correctly (even newer ones).
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.ArrayList;
import java.util.List;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.io.json.JettisonMappedXmlDriver;

public class XStreamJsonExample {

	private String json = &amp;quot;{Music:{albums:[{name:name1,year:1980}]}}&amp;quot;;

	public static void main(String[] args) {
		XStreamJsonExample example = new XStreamJsonExample();
		example.serializeJsonUsingxStream();
	}

	private void serializeJsonUsingxStream() {

		XStream xStream = new XStream(new JettisonMappedXmlDriver());
		xStream.processAnnotations(Music7.class);
		Music7 music7 = (Music7) xStream.fromXML(json);
		System.out.println(music7);
		Music7 music = new Music7();
		Album7 album1 = new Album7();
		album1.name = &amp;quot;name1&amp;quot;;
		album1.year = 1980;
		music.albums.add(album1);
		Album7 album2 = new Album7();
		album2.name = &amp;quot;name2&amp;quot;;
		album2.year = 1981;
		music.albums.add(album2);
		System.out.println(xStream.toXML(music));
	}
}

@XStreamAlias(&amp;quot;Music&amp;quot;)
class Music7 {
	@XStreamImplicit
	List&amp;lt;Album7&amp;gt; albums = new ArrayList&amp;lt;Album7&amp;gt;();

	@Override
	public String toString() {
		return &amp;quot;Music7 [albums=&amp;quot; + albums + &amp;quot;]&amp;quot;;
	}

}

@XStreamAlias(&amp;quot;Album&amp;quot;)
class Album7 {
	String name;
	int year;

	@Override
	public String toString() {
		return &amp;quot;Album7 [name=&amp;quot; + name + &amp;quot;, year=&amp;quot; + year + &amp;quot;]&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-json-example.jsp&#34; title=&#34;XStream - Json to Java&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>XStream: Collection Converters</title>
      <link>http://alimy.me/post/dev_201603092105/</link>
      <pubDate>Wed, 09 Mar 2016 21:05:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092105/</guid>
      <description>&lt;p&gt;In the earlier tutorials we saw how to convert a &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;parsing an xml&#34;&gt;Java object to XML and back&lt;/a&gt;, &lt;a href=&#34;http://alimy.me/post/dev_201603092055&#34; title=&#34;custom converter&#34;&gt;custom converter&lt;/a&gt; and &lt;a href=&#34;http://alimy.me/post/dev_201603092100&#34; title=&#34;basic converters&#34;&gt;basic converters&lt;/a&gt;. In this tutorial we look at how XStream converts array and collections from java to xml and vice versa. We will convert the following types :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;String[]&lt;/li&gt;
&lt;li&gt;char[]&lt;/li&gt;
&lt;li&gt;List&lt;String&gt;&lt;/li&gt;
&lt;li&gt;java.util.Properties&lt;/li&gt;
&lt;li&gt;List&lt;String&gt;&lt;/li&gt;
&lt;li&gt;Map&lt;String, String&gt;&lt;/li&gt;
&lt;li&gt;TreeMap&lt;String, String&gt; treeMap&lt;/li&gt;
&lt;li&gt;TreeSet&lt;String&gt; treeSet&lt;/li&gt;
&lt;li&gt;enum&lt;/li&gt;
&lt;li&gt;EnumMap&lt;testEnum, String&gt; testEnum is an enum&lt;/li&gt;
&lt;li&gt;EnumSet&lt;testEnum&gt; testEnum is an enum

Here&amp;rsquo;s the complete example
```
package com.studytrails.xml.xstream;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;
import java.util.TreeSet;&lt;/p&gt;

&lt;p&gt;import com.thoughtworks.xstream.XStream;&lt;/p&gt;

&lt;p&gt;public class ConverterExample2 {
	public static void main(String[] args) {
		ConverterExample2 example2 = new ConverterExample2();
		example2.runExample();
	}&lt;/p&gt;

&lt;p&gt;	public void runExample() {
		XStream xStream = new XStream();
		CollectionConverterExample classContainingCollection = new CollectionConverterExample();
		classContainingCollection.initialize();
		String xml = xStream.toXML(classContainingCollection);
		System.out.println(xml);
	}
}&lt;/p&gt;

&lt;p&gt;class CollectionConverterExample {&lt;/p&gt;

&lt;p&gt;	String[] stringArray = new String[] { &amp;ldquo;StringA&amp;rdquo;, &amp;ldquo;StringB&amp;rdquo;, &amp;ldquo;StringC&amp;rdquo; };
	char[] charArray = new char[] { &amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;c&amp;rsquo;, &amp;rsquo;d&amp;rsquo;, &amp;lsquo;e&amp;rsquo; };
	List&lt;String&gt; listA = new ArrayList&lt;String&gt;();
	Map&lt;String, String&gt; mapA = new HashMap&lt;String, String&gt;();
	Properties properties = new Properties();
	List&lt;String&gt; singletonList;
	Map&lt;String, String&gt; singletonMap;&lt;/p&gt;

&lt;p&gt;	TreeMap&lt;String, String&gt; treeMap = new TreeMap&lt;String, String&gt;();
	TreeSet&lt;String&gt; treeSet = new TreeSet&lt;String&gt;();
	enum testEnum {testA, testB}
	testEnum testeEnumValue = testEnum.testA;
	EnumMap&lt;testEnum, String&gt; testEnumMap = new EnumMap&lt;CollectionConverterExample.testEnum, String&gt;(testEnum.class);
	EnumSet&lt;testEnum&gt; testEnumSet = EnumSet.range(testEnum.testA, testEnum.testB);&lt;/p&gt;

&lt;p&gt;	public void initialize() {
		listA.add(&amp;ldquo;testA&amp;rdquo;);
		mapA.put(&amp;ldquo;keyA&amp;rdquo;, &amp;ldquo;ValueA&amp;rdquo;);
		properties.put(&amp;ldquo;propertyA&amp;rdquo;, &amp;ldquo;valueA&amp;rdquo;);
		treeMap.put(&amp;ldquo;treeA&amp;rdquo;, &amp;ldquo;valueA&amp;rdquo;);
		treeMap.put(&amp;ldquo;treeB&amp;rdquo;, &amp;ldquo;valueB&amp;rdquo;);
		treeSet.add(&amp;ldquo;treeB&amp;rdquo;);
		treeSet.add(&amp;ldquo;treeA&amp;rdquo;);
		singletonList = Collections.singletonList(&amp;ldquo;singletonListA&amp;rdquo;);
		singletonMap = Collections.singletonMap(&amp;ldquo;key1&amp;rdquo;, &amp;ldquo;value1&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;		testEnumMap.put(testEnum.testA, &amp;ldquo;testEnumMapValue1&amp;rdquo;);
		testEnumMap.put(testEnum.testB, &amp;ldquo;testEnumMapValue2&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;	}
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
The resultant XML looks like this

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;		StringA
		StringB
		StringC&lt;/p&gt;

&lt;p&gt;	abcde&lt;/p&gt;

&lt;p&gt;		testA&lt;/p&gt;

&lt;p&gt;	  keyA
	  ValueA&lt;/p&gt;

&lt;p&gt;		singletonListA&lt;/p&gt;

&lt;p&gt;	  key1
	  value1&lt;/p&gt;

&lt;p&gt;	  treeA
	  valueA&lt;/p&gt;

&lt;p&gt;	  treeB
	  valueB&lt;/p&gt;

&lt;p&gt;		treeA
		treeB
```&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-collection-converters.jsp&#34; title=&#34;Collection Converters&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>XStream: Basic Built-in Converters</title>
      <link>http://alimy.me/post/dev_201603092100/</link>
      <pubDate>Wed, 09 Mar 2016 21:00:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092100/</guid>
      <description>&lt;p&gt;In the previous tutorials we saw an example of how to convert &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;parsing an xml&#34;&gt;java object to XML and back&lt;/a&gt;. That tutorial also explained the concept of aliases and implicit collection.In the last tutorial we show how to write a custom converter. In this tutorial, lets see some of the basic built in converters of XStream and how the resultant XML from those converters look like. We will look at how the following types are converted. XStream has converters for each of these. These are just a sample of the converters that XStream has. These converters only exist for a better and faster handling of a type compared to the generic converters.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BigDecimal&lt;/li&gt;
&lt;li&gt;BigInteger&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;byte&lt;/li&gt;
&lt;li&gt;char&lt;/li&gt;
&lt;li&gt;Date&lt;/li&gt;
&lt;li&gt;Double&lt;/li&gt;
&lt;li&gt;Float&lt;/li&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;Long&lt;/li&gt;
&lt;li&gt;Object&lt;/li&gt;
&lt;li&gt;StringBuffer&lt;/li&gt;
&lt;li&gt;StringBuilder&lt;/li&gt;
&lt;li&gt;URI&lt;/li&gt;
&lt;li&gt;URL&lt;/li&gt;
&lt;li&gt;UUID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the next tutorial we look at examples of arrays and Collections.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Date;
import java.util.TimeZone;
import java.util.UUID;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.basic.BooleanConverter;
import com.thoughtworks.xstream.converters.basic.DateConverter;

public class ConverterExample1 {

	public static void main(String[] args) throws MalformedURLException, URISyntaxException {
		ConverterExample1 converter = new ConverterExample1();
		converter.convert();
	}

	private void convert() throws MalformedURLException, URISyntaxException {

		BasicConverterFields basicConverterExample = new BasicConverterFields();
		basicConverterExample.initialize();

		XStream xStream = new XStream();

		xStream.registerLocalConverter(BasicConverterFields.class, &amp;quot;flag&amp;quot;, BooleanConverter.BINARY);

		DateConverter dateConverter = new DateConverter(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;, new String[] {}, TimeZone.getTimeZone(&amp;quot;UTC&amp;quot;));
		xStream.registerConverter(dateConverter);

		String xml = xStream.toXML(basicConverterExample);

		System.out.println(xml);

		BasicConverterFields basicConverterFromXML = (BasicConverterFields) xStream.fromXML(xml);
		System.out.println(basicConverterFromXML);

	}

	class BasicConverterFields {
		BigDecimal bigDecimal = new BigDecimal(10000000000.0);
		BigInteger bigInteger = new BigInteger(&amp;quot;1000000000&amp;quot;);
		boolean flag = true;
		byte byteA = &#39;a&#39;;
		char charA = &#39;a&#39;;
		Date date = new Date();
		Double doubleA = new Double(1000000000000.0);
		Float floatA = new Float(10000000000000f);
		int intA = 100;
		Long longA = new Long(100000);
		Object nullA = null;
		Short shortA = new Short((short) 1);
		StringBuffer stringBufferA = new StringBuffer(&amp;quot;test&amp;quot;);
		StringBuilder stringBuilderA = new StringBuilder().append(&amp;quot;test&amp;quot;);
		URI UriA = null;
		URL urlA = null;
		UUID uuidA = UUID.fromString(&amp;quot;0000000a-000b-000c-000d-00000000000e&amp;quot;);

		public void initialize() throws URISyntaxException, MalformedURLException {
			UriA = new URI(&amp;quot;file://C/work/fileA&amp;quot;);
			urlA = new URL(&amp;quot;http://www.google.com&amp;quot;);
		}

		@Override
		public String toString() {
			return &amp;quot;BasicConverterFields [bigDecimal=&amp;quot; + bigDecimal + &amp;quot;, bigInteger=&amp;quot; + bigInteger + &amp;quot;, flag=&amp;quot; + flag + &amp;quot;, byteA=&amp;quot; + byteA
					+ &amp;quot;, charA=&amp;quot; + charA + &amp;quot;, date=&amp;quot; + date + &amp;quot;, doubleA=&amp;quot; + doubleA + &amp;quot;, floatA=&amp;quot; + floatA + &amp;quot;, intA=&amp;quot; + intA + &amp;quot;, longA=&amp;quot; + longA
					+ &amp;quot;, nullA=&amp;quot; + nullA + &amp;quot;, shortA=&amp;quot; + shortA + &amp;quot;, stringBufferA=&amp;quot; + stringBufferA + &amp;quot;, stringBuilderA=&amp;quot; + stringBuilderA
					+ &amp;quot;, UriA=&amp;quot; + UriA + &amp;quot;, urlA=&amp;quot; + urlA + &amp;quot;, uuidA=&amp;quot; + uuidA + &amp;quot;]&amp;quot;;
		}

	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The toXML method prints this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10000000000
1000000000
1
97
a
2014-04-26 04:14:38
1.0E12
9.9999998E12
100
100000
1
test
test
file://C/work/fileA
http://www.google.com
0000000a-000b-000c-000d-00000000000e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fromXML method prints this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BasicConverterFields [bigDecimal=10000000000, bigInteger=1000000000, flag=true, byteA=97, charA=a,
date=Sat Apr 26 09:44:38 IST 2014, doubleA=1.0E12, floatA=9.9999998E12, intA=100, longA=100000,
nullA=null, shortA=1, stringBufferA=test, stringBuilderA=test, UriA=file://C/work/fileA,
urlA=http://www.google.com, uuidA=0000000a-000b-000c-000d-00000000000e]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-basic-converters.jsp&#34; title=&#34;Basic Built-in Converters&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XStream: Custom Converter for BufferedImage</title>
      <link>http://alimy.me/post/dev_201603092055/</link>
      <pubDate>Wed, 09 Mar 2016 20:55:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092055/</guid>
      <description>&lt;p&gt;In the previous tutorials we saw an example of how to convert a &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;parsing an xml&#34;&gt;java object to XML and back&lt;/a&gt;. That tutorial also explained the concept of aliases and implicit collection. While serializing a Java object to XML XStream uses custom converters. These converters specify how to create XML from a Java Object or how to create a Java Object from XML elements. In most cases the provided converters should suffice, however, in certain cases you may want to create your own converters. To do so create a class that implements com.thoughtworks.xstream.converters.Converter and implement the void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context); and Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context); The example below demonstrates a CustomConverter. To make the example more interesting we will write a converter to serialize a BufferedImage. The image for the example can be downloaded from here
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import javax.imageio.ImageIO;

import org.apache.commons.io.output.ByteArrayOutputStream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.core.util.Base64Encoder;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;

public class CustomConverterExample {

    public static void main(String[] args) throws IOException {
        CustomConverterExample customConverterExample = new CustomConverterExample();
        customConverterExample.showCustomConversionForBufferedImage();
    }

    private void showCustomConversionForBufferedImage() throws IOException {
        Company company = new Company();
        company.setName(&amp;quot;Study Trails&amp;quot;);
        BufferedImage in = ImageIO.read(new File(&amp;quot;st1_200.jpg&amp;quot;));
        BufferedImage newImage = new BufferedImage(in.getWidth(), in.getHeight(), BufferedImage.TYPE_INT_RGB);
        Graphics2D g = newImage.createGraphics();
        g.drawImage(in, 0, 0, null);
        g.dispose();
        company.setImage(newImage);
        XStream xStream = new XStream();
        xStream.registerConverter(new CustomBufferedImageConverter());
        String xml = xStream.toXML(company);

        Company company2 = (Company) xStream.fromXML(xml);
        File outputfile = new File(&amp;quot;st2_200.jpg&amp;quot;);
        ImageIO.write(company2.image, &amp;quot;jpg&amp;quot;, outputfile);

    }

}

class Company {
    String name;
    BufferedImage image;

    public void setName(String name) {
        this.name = name;
    }

    public void setImage(BufferedImage image) {
        this.image = image;
    }
}

class CustomBufferedImageConverter implements Converter {
    @Override
    public boolean canConvert(Class type) {

        return type.isAssignableFrom(BufferedImage.class);
    }

    @Override
    public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {
        BufferedImage bufferedImage = (BufferedImage) source;
        try {
            ByteArrayOutputStream outStream = new ByteArrayOutputStream();
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outStream);
            ImageIO.write(bufferedImage, &amp;quot;jpg&amp;quot;, objectOutputStream);
            outStream.flush();
            Base64Encoder encorder = new Base64Encoder();
            String imageString = encorder.encode(outStream.toByteArray());
            outStream.close();
            writer.setValue(imageString);
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

    @Override
    public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
        BufferedImage image = null;
        try {
            Base64Encoder encoder = new Base64Encoder();
            byte[] imageBytes = encoder.decode(reader.getValue());
            ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(imageBytes));
            image = ImageIO.read(inputStream);
            inputStream.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return image;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-custom-converter.jsp&#34; title=&#34;XStream custom converter&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>XStream: Referencing Objects</title>
      <link>http://alimy.me/post/dev_201603092051/</link>
      <pubDate>Wed, 09 Mar 2016 20:51:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092051/</guid>
      <description>&lt;p&gt;XStream allows you to store references while converting a java object to XML. Consider a case where you have an Artist Object. The object contains albums that the artist has released, but you also want to store a reference to a &amp;lsquo;similar artist&amp;rsquo;. People listening to an artist might be interested in listening to a similar artist. When you convert this object to XML, XStream preserves the reference to the similar artist. It also manages circular references, so if there are no similar artist then the &amp;lsquo;similar artist&amp;rsquo; field could store a reference to the Owner Artist.&lt;/p&gt;

&lt;p&gt;XStream has multiple ways to store references. you need to use the setMode(int mode) method to set the mode. XStream allows following modes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NO_REFERENCES&lt;/li&gt;
&lt;li&gt;ID_REFERENCES&lt;/li&gt;
&lt;li&gt;XPATH_RELATIVE_REFERENCES&lt;/li&gt;
&lt;li&gt;XPATH_ABSOLUTE_REFERENCES&lt;/li&gt;
&lt;li&gt;SINGLE_NODE_XPATH_RELATIVE_REFERENCES&lt;/li&gt;
&lt;li&gt;SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES

In the example below we see how each of the above looks We first create the XStream object instance, the Artist Class and the Album class. We also add appropriate aliases to make the XML more readable.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import com.thoughtworks.xstream.XStream;

public class ReferencingObjectsExample {

    public static void main(String[] args) {
        Artist artist = new Artist();
        AnotherAlbum album = new AnotherAlbum();
        artist.setAlbum(album);
        XStream xStream = new XStream();
        xStream.alias(&amp;quot;artist&amp;quot;, Artist.class);
        xStream.alias(&amp;quot;anotherAlbum&amp;quot;, AnotherAlbum.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are the classes. An Artist contains an album. It also contains object of type &amp;lsquo;Top10Album&amp;rsquo; which is a child of the class &amp;lsquo;Album&amp;rsquo; and contains the top10 songs of the Artist. We also store a reference to another artist which is similar to this artist. The aim is to see how the reference to the various objects are stored in the XML. The reference to Top10Album is a reference to a derived class. The reference to Artist is a reference to the Object&amp;rsquo;s own type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Artist {
    Top10Album album;
    Album album2;
    Artist similarArtist;

    public void setSimilarArtist(Artist similarArtist) {
        this.similarArtist = similarArtist;
    }

    public void setAlbum(Top10Album album) {
        this.album = album;
        album2 = (Top10Album) this.album;
    }
}

class Album {
}

class Top10Album extends Album {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;case 1: ID_REFERENCES&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.setMode(XStream.ID_REFERENCES);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist id=&amp;quot;1&amp;quot;&amp;gt;
  &amp;lt;album id=&amp;quot;2&amp;quot;&amp;gt;
    &amp;lt;album2 class=&amp;quot;anotherAlbum&amp;quot; reference=&amp;quot;2&amp;quot;&amp;gt;
    &amp;lt;/album2&amp;gt;
  &amp;lt;/album&amp;gt;
&amp;lt;/artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;case 2: NO_REFERENCES&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.setMode(XStream.NO_REFERENCES);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;album&amp;gt;
  &amp;lt;album2 class=&amp;quot;anotherAlbum&amp;quot;&amp;gt;
&amp;lt;/album2&amp;gt;&amp;lt;/album&amp;gt;&amp;lt;/artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;case 3: SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.setMode(XStream.SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;album&amp;gt;
  &amp;lt;album2 class=&amp;quot;anotherAlbum&amp;quot; reference=&amp;quot;/artist[1]/album[1]&amp;quot;&amp;gt;
&amp;lt;/album2&amp;gt;&amp;lt;/album&amp;gt;&amp;lt;/artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;case 4: SINGLE_NODE_XPATH_RELATIVE_REFERENCES&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.setMode(XStream.SINGLE_NODE_XPATH_RELATIVE_REFERENCES);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;album&amp;gt;
  &amp;lt;album2 class=&amp;quot;anotherAlbum&amp;quot; reference=&amp;quot;../album[1]&amp;quot;&amp;gt;
&amp;lt;/album2&amp;gt;&amp;lt;/album&amp;gt;&amp;lt;/artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;case 5: XPATH_ABSOLUTE_REFERENCES&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;album&amp;gt;
  &amp;lt;album2 class=&amp;quot;anotherAlbum&amp;quot; reference=&amp;quot;/artist/album&amp;quot;&amp;gt;
&amp;lt;/album2&amp;gt;&amp;lt;/album&amp;gt;&amp;lt;/artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;case 6: XPATH_RELATIVE_REFERENCES&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.setMode(XStream.XPATH_RELATIVE_REFERENCES);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;album&amp;gt;
  &amp;lt;album2 class=&amp;quot;anotherAlbum&amp;quot; reference=&amp;quot;../album&amp;quot;&amp;gt;
&amp;lt;/album2&amp;gt;&amp;lt;/album&amp;gt;&amp;lt;/artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-java-to-xml-referencing-Objects.jsp&#34; title=&#34;Referencing Objects&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>XStream: Handling Attributes in XML</title>
      <link>http://alimy.me/post/dev_201603092041/</link>
      <pubDate>Wed, 09 Mar 2016 20:41:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092041/</guid>
      <description>&lt;p&gt;In the previous tutorial we saw &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;Parsing An XML&#34;&gt;how to convert Java to XML and back&lt;/a&gt;. In this tutorial we look at different ways to handle XML attributes using XStream. However note that the attributes are only safe if you know that the written String values are not affected by the XML parser&amp;rsquo;s white space normalization. The XML specification requires that a parser does this and it means that an attribute value of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;element attr=&amp;quot;  foo\t\n   bar    &amp;quot;&amp;gt;
&amp;lt;/element&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will always be normalized and passed this assertion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertEquals(&amp;quot;foo bar&amp;quot;, element.getAttr());
XStream has no influence about this behavior.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
Case 1 : Element with attributes but no value - Using SingleValueConverter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?--&amp;gt;
&amp;lt;root&amp;gt;
    &amp;lt;child1 key1=&amp;quot;value1&amp;quot;&amp;gt;&amp;lt;/child1&amp;gt;
    &amp;lt;child2&amp;gt;This is child 2&amp;lt;/child2&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example we use a SingleValueConverter to convert the XML element containing an attribute. This method does not work if the element has a value&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.SingleValueConverter;

public class ElementWithAttribute {
    private String xml = &amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;UTF-8\&amp;quot;?&amp;gt;&amp;quot; + &amp;quot;&amp;lt;Root&amp;gt;&amp;quot; + &amp;quot;&amp;lt;child1 key1=\&amp;quot;value1\&amp;quot;&amp;gt;&amp;lt;/child1&amp;gt;&amp;quot;
            + &amp;quot;&amp;lt;child2&amp;gt;This is child 2&amp;lt;/child2&amp;gt;&amp;quot; + &amp;quot;&amp;lt;/Root&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        ElementWithAttribute unmarshaller = new ElementWithAttribute();
        unmarshaller.XMLToJavaObject();
    }

    public void XMLToJavaObject() {
        XStream xStream = new XStream();
        xStream.useAttributeFor(Child1.class, &amp;quot;key1&amp;quot;);
        xStream.registerConverter(new Key1SingleValueConverter());
        xStream.alias(&amp;quot;Root&amp;quot;, Root.class);
        xStream.alias(&amp;quot;child1&amp;quot;, Child1.class);
        Root root = (Root) xStream.fromXML(xml);
        System.out.println(root);
        // prints Root [child1=Child1 [key1=Key1 [value=value1]], child2=This is child 2]
    }

    public class Root {
        public Child1 child1;

        public String child2;

        @Override
        public String toString() {
            return &amp;quot;Root [child1=&amp;quot; + child1 + &amp;quot;, child2=&amp;quot; + child2 + &amp;quot;]&amp;quot;;
        }

    }

    public class Child1 {
        public Key1 key1;

        @Override
        public String toString() {
            return &amp;quot;Child1 [key1=&amp;quot; + key1 + &amp;quot;]&amp;quot;;
        }

    }

    public class Key1 {
        String value;

        public Key1(String value) {
            this.value = value;
        }

        @Override
        public String toString() {
            return &amp;quot;Key1 [value=&amp;quot; + value + &amp;quot;]&amp;quot;;
        }

    }

    public class Key1SingleValueConverter implements SingleValueConverter {
        @Override
        public boolean canConvert(Class type) {
            return (type.equals(Key1.class));
        }

        @Override
        public Object fromString(String str) {
            Key1 key = new Key1(str);
            return key;
        }

        @Override
        public String toString(Object obj) {
            return ((Key1) obj).value;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Case 2 : Element with attributes but no value - Using attribute alias&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?--&amp;gt;
&amp;lt;root&amp;gt;
    &amp;lt;child1 key1=&amp;quot;value1&amp;quot;&amp;gt;&amp;lt;/child1&amp;gt;
    &amp;lt;child2&amp;gt;This is child 2&amp;lt;/child2&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same result can be obtained by using an attribute alias.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import com.thoughtworks.xstream.XStream;

public class ElementWithAttribute2 {

    private String xml = &amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;UTF-8\&amp;quot;?&amp;gt;&amp;quot; + &amp;quot;&amp;lt;Root&amp;gt;&amp;quot; + &amp;quot;&amp;lt;child1 key1=\&amp;quot;value1\&amp;quot;&amp;gt;&amp;lt;/child1&amp;gt;&amp;quot;
            + &amp;quot;&amp;lt;child2&amp;gt;This is child 2&amp;lt;/child2&amp;gt;&amp;quot; + &amp;quot;&amp;lt;/Root&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        ElementWithAttribute2 unmarshaller = new ElementWithAttribute2();
        unmarshaller.XMLToJavaObject();
    }

    public void XMLToJavaObject() {
        XStream xStream = new XStream();
        xStream.alias(&amp;quot;Root&amp;quot;, Root.class);
        xStream.alias(&amp;quot;child1&amp;quot;, Child1.class);
        xStream.aliasAttribute(Child1.class, &amp;quot;key1&amp;quot;, &amp;quot;key1&amp;quot;);
        Root root = (Root) xStream.fromXML(xml);
        System.out.println(root);
        //prints Root [child1=Child1 [key1=value1], child2=This is child 2]
    }

    public class Root {
        public Child1 child1;

        public String child2;

        @Override
        public String toString() {
            return &amp;quot;Root [child1=&amp;quot; + child1 + &amp;quot;, child2=&amp;quot; + child2 + &amp;quot;]&amp;quot;;
        }

    }

    public class Child1 {
        public String key1;

        @Override
        public String toString() {
            return &amp;quot;Child1 [key1=&amp;quot; + key1 + &amp;quot;]&amp;quot;;
        }
    }

    public class Key1 {
        String value;

        public Key1(String value) {
            this.value = value;
        }

        @Override
        public String toString() {
            return &amp;quot;Key1 [value=&amp;quot; + value + &amp;quot;]&amp;quot;;
        }

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Case 3 : Element with attributes and value&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?--&amp;gt;
 &amp;lt;root&amp;gt;
       &amp;lt;child1 key1=&amp;quot;value1&amp;quot;&amp;gt;This is child 1&amp;lt;/child1&amp;gt;
       &amp;lt;child2&amp;gt;This is child 2&amp;lt;/child2&amp;gt;
 &amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the element has an attribute as well as a value then we use a special Converter called ToAttributedValueConverter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.extended.ToAttributedValueConverter;

public class ElementWithValueAndAttributes1 {


    private String xml = &amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;UTF-8\&amp;quot;?&amp;gt;&amp;quot; + &amp;quot;&amp;lt;Root&amp;gt;&amp;quot; + &amp;quot;&amp;lt;child1 key1=\&amp;quot;value1\&amp;quot;&amp;gt;This is child 1&amp;lt;/child1&amp;gt;&amp;quot;
            + &amp;quot;&amp;lt;child2&amp;gt;This is child 2&amp;lt;/child2&amp;gt;&amp;quot; + &amp;quot;&amp;lt;/Root&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        ElementWithValueAndAttributes1 converter = new ElementWithValueAndAttributes1();
        converter.XmlToJavaObjects();
    }

    private void XmlToJavaObjects() {
        XStream xStream = new XStream();
        xStream.alias(&amp;quot;Root&amp;quot;, Root.class);
        xStream.registerConverter(new ToAttributedValueConverter(Child1.class, xStream.getMapper(), xStream.getReflectionProvider(), xStream
                .getConverterLookup(), &amp;quot;value&amp;quot;));
        Root test = (Root) xStream.fromXML(xml);
        System.out.println(test);
        /*- prints Root [child1=Child1 [value=This is child 1, key1=value1],child2=This is child 2] */

    }

    public class Root {
        public Child1 child1;

        public String child2;

        @Override
        public String toString() {
            return &amp;quot;Root [child1=&amp;quot; + child1 + &amp;quot;, child2=&amp;quot; + child2 + &amp;quot;]&amp;quot;;
        }

    }

    public class Child1 {
        public String value;
        public String key1;

        @Override
        public String toString() {
            return &amp;quot;Child1 [value=&amp;quot; + value + &amp;quot;, key1=&amp;quot; + key1 + &amp;quot;]&amp;quot;;
        }

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-java-xml-attributes.jsp&#34; title=&#34;Handling Attributes in XML&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>XStream: Java to XML Using Annotation</title>
      <link>http://alimy.me/post/dev_201603081441/</link>
      <pubDate>Tue, 08 Mar 2016 14:41:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081441/</guid>
      <description>&lt;p&gt;In the previous tutorials we saw an example of how to &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34;&gt;create a java object from XML&lt;/a&gt;. That tutorial also explained the concept of aliases and implicit collection. In this tutorial we continue with that but use annotation on the java class. The advantage with annotation is that it is faster to code and develop. the disadvantage is that you bind the java class to XStream.&lt;/p&gt;

&lt;p&gt;In the example below we convert an object of type JazzArtist to XML. JazzArtist contains fields name, isAlive, a url and a list of albums. This example uses the following annotations&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@XStreamAlias - Used on the type, field or attribute. To understand &amp;lsquo;aliases&amp;rsquo; look at this tutorial&lt;/li&gt;
&lt;li&gt;@XStreamImplicit - Used on Collections or array. To understand &amp;lsquo;Implicit Collections/Arrays&amp;rsquo; look at the this tutorial.&lt;/li&gt;
&lt;li&gt;@XStreamAsAttribute - Used to mark a field as an attribute.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;@XStreamConverter - Use a specific converter for this field. We will look at Converters in detail in a later tutorial. In this example we use a Boolean converter for &amp;lsquo;isAlive&amp;rsquo; field, we want the XML to have values yes or no instead of true or false.

Here is the complete example. In this example we want to create an XML from an object of type JazzArtist2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We use annotation to first use an alias of &amp;lsquo;artist&amp;rsquo; for JazzArtist2. Each Jazz Artist has a list of albums.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the resulting XML we dont want the albums to appear under the element &amp;lsquo;albums&amp;rsquo;, rather we want each album to be the child of the artist element. We therefore mark &amp;lsquo;albums&amp;rsquo; as an implicit collection using the @XStreamImplicit annotation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We don&amp;rsquo;t want to include the &amp;lsquo;noOfRecords&amp;rsquo; in the resulting XML, we therefore use the @XStreamOmitField to omit that field.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We want genre to be an attribute of the album instead of a child. we use @XStreamAsAttribute to mark genre as an attribute.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In this example we also use an annotation for a Converter. There is a boolean field in the JazzArtist2 class called isAlive. We dont want the   XML to have values &amp;lsquo;true&amp;rsquo; or &amp;lsquo;false&amp;rsquo; but values &amp;lsquo;yes&amp;rsquo; or &amp;lsquo;no&amp;rsquo; since they are more human friendly. The @XStreamConverter can be used to specify a Converter and pass values to its constructor.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamConverter;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.annotations.XStreamOmitField;
import com.thoughtworks.xstream.converters.basic.BooleanConverter;

public class CreateXMLFromMusicArtistObjectAnnotated {

    public static void main(String[] args) throws MalformedURLException {
        CreateXMLFromMusicArtistObjectAnnotated marshaller =
                new CreateXMLFromMusicArtistObjectAnnotated();
        marshaller.createXMlFromObject();
    }

    private void createXMlFromObject() throws MalformedURLException {
        JazzArtist2 artist2 = new JazzArtist2(&amp;quot;Benny Goodman&amp;quot;,
                false, new URL(&amp;quot;http://www.bennygoodman.com/&amp;quot;));
        Album2 album3 = new Album2(&amp;quot;In Stockholm&amp;quot;, 5, 1959,&amp;quot;swing&amp;quot;);
        Album2 album4 = new Album2(&amp;quot;A Jazz Holiday&amp;quot;, 3, 1928,&amp;quot;swing&amp;quot;);
        artist2.addAlbum(album3);
        artist2.addAlbum(album4);
        XStream xStream2 = new XStream();
        xStream2.processAnnotations(JazzArtist2.class);
        System.out.println(xStream2.toXML(artist2));
    }
}

@XStreamAlias(&amp;quot;artist&amp;quot;)
class JazzArtist2 {
    public String name;
    @XStreamConverter(value = BooleanConverter.class,
            booleans = { true }/*is case sensitive*/,
            strings = { &amp;quot;Yes&amp;quot;, &amp;quot;No&amp;quot; })
    public boolean isAlive;
    public URL url;
    @XStreamImplicit
    public List&amp;lt;Album2&amp;gt; albums = new ArrayList&amp;lt;Album2&amp;gt;();

    public JazzArtist2(String name, boolean isAlive, URL url) {
        this.name = name;
        this.isAlive = isAlive;
        this.url = url;
    }

    public void addAlbum(Album2 album) {
        albums.add(album);
    }

}

@XStreamAlias(&amp;quot;album&amp;quot;)
class Album2 {
    public String title;
    @XStreamOmitField
    public int noOfRecords;
    public int year;
    @XStreamAsAttribute
    public String genre;

    public Album2(String title, int noOfRecords, int year,String genre) {
        this.title = title;
        this.noOfRecords = noOfRecords;
        this.year = year;
        this.genre = genre;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;name&amp;gt;Benny Goodman&amp;lt;/name&amp;gt;
  &amp;lt;isalive&amp;gt;No&amp;lt;/isalive&amp;gt;
  &amp;lt;url&amp;gt;http://www.bennygoodman.com/&amp;lt;/url&amp;gt;
  &amp;lt;album genre=&amp;quot;swing&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;In Stockholm&amp;lt;/title&amp;gt;
    &amp;lt;year&amp;gt;1959&amp;lt;/year&amp;gt;
  &amp;lt;/album&amp;gt;
  &amp;lt;album genre=&amp;quot;swing&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;A Jazz Holiday&amp;lt;/title&amp;gt;
    &amp;lt;year&amp;gt;1928&amp;lt;/year&amp;gt;
  &amp;lt;/album&amp;gt;
&amp;lt;/artist&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-java-to-xml-annotated.jsp&#34; title=&#34;Java to XML Using Annotation&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>XStream: Java to XML</title>
      <link>http://alimy.me/post/dev_201603081433/</link>
      <pubDate>Tue, 08 Mar 2016 14:33:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081433/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34;&gt;previous&lt;/a&gt; example we saw how to convert a Java Object to XML and back. In this example we look at another example of Java Object to XML Conversion. The example uses an object called a &amp;lsquo;JazzArtist&amp;rsquo;. This object has a list of &amp;lsquo;Album&amp;rsquo; objects besides some other properties. We see here another example of Alias and implicit collection. (To understand alias and implicit collections look at this tutorial) We divide the example in three parts. In the first part we do not use aliases or implicit collections. In the second part we use aliases and in the third part we use an implicit Collection. Note the output from the three parts and observe how aliases and implicit collection change the way the output xml looks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.ArrayList;
import java.util.List;

import com.thoughtworks.xstream.XStream;

public class CreateXMLFromMusicArtistObject {

    public static void main(String[] args) {
        CreateXMLFromMusicArtistObject marshaller = new CreateXMLFromMusicArtistObject();
        marshaller.createXMlFromObject();
        marshaller.createXMLFromObjectUsingAlias();
        marshaller.createXMLFromObjectUsingAliasAndImplicitCollection();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
The JazzArtist and Album classes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class JazzArtist {
    public String name;
    public boolean isAlive;
    public String url;
    public List&amp;lt;Album&amp;gt; albums = new ArrayList&amp;lt;Album&amp;gt;();

    public JazzArtist(String name, boolean isAlive, String url) {
        this.name = name;
        this.isAlive = isAlive;
        this.url = url;
    }

    public void addAlbum(Album album) {
        albums.add(album);
    }

}

class Album {
    public String title;
    public int noOfrecords;
    public int year;

    public Album(String title, int noOfrecords, int year) {
        this.title = title;
        this.noOfrecords = noOfrecords;
        this.year = year;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first method - without alias and Implicit Collection&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void createXMlFromObject() {
 JazzArtist artist = new JazzArtist(&amp;quot;Bix Beiderbecke&amp;quot;, false, null);
 Album album1 = new Album(&amp;quot;Bix Beiderbecke with the Paul Whiteman Orchestra&amp;quot;, 5, 1928);
 Album album2 = new Album(&amp;quot;Bix Beiderbecke and His Gang&amp;quot;, 6, 1927);
 artist.addAlbum(album1);
 artist.addAlbum(album2);
 XStream xStream = new XStream();
 System.out.println(xStream.toXML(artist));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output from the first method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;com.studytrails.xml.xstream.jazzartist&amp;gt;
  &amp;lt;name&amp;gt;Bix Beiderbecke&amp;lt;/name&amp;gt;
  &amp;lt;isalive&amp;gt;false&amp;lt;/isalive&amp;gt;
  &amp;lt;albums&amp;gt;
    &amp;lt;com.studytrails.xml.xstream.album&amp;gt;
      &amp;lt;title&amp;gt;Bix Beiderbecke with the Paul Whiteman Orchestra&amp;lt;/title&amp;gt;
      &amp;lt;noofrecords&amp;gt;5&amp;lt;/noofrecords&amp;gt;
      &amp;lt;year&amp;gt;1928&amp;lt;/year&amp;gt;
    &amp;lt;/com.studytrails.xml.xstream.album&amp;gt;
    &amp;lt;com.studytrails.xml.xstream.album&amp;gt;
      &amp;lt;title&amp;gt;Bix Beiderbecke and His Gang&amp;lt;/title&amp;gt;
      &amp;lt;noofrecords&amp;gt;6&amp;lt;/noofrecords&amp;gt;
      &amp;lt;year&amp;gt;1927&amp;lt;/year&amp;gt;
    &amp;lt;/com.studytrails.xml.xstream.album&amp;gt;
  &amp;lt;/albums&amp;gt;
&amp;lt;/com.studytrails.xml.xstream.jazzartist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second method - with aliases&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void createXMLFromObjectUsingAliasAndImplicitCollection() {
 JazzArtist artist2 = new JazzArtist(&amp;quot;Benny Goodman&amp;quot;, false, null);
 Album album3 = new Album(&amp;quot;In Stockholm&amp;quot;, 5, 1959);
 Album album4 = new Album(&amp;quot;A Jazz Holiday&amp;quot;, 3, 1928);
 artist2.addAlbum(album3);
 artist2.addAlbum(album4);
 XStream xStream2 = new XStream();
 xStream2.alias(&amp;quot;artist&amp;quot;, JazzArtist.class);
 xStream2.alias(&amp;quot;album&amp;quot;, Album.class);
 xStream2.addImplicitCollection(JazzArtist.class, &amp;quot;albums&amp;quot;);
 System.out.println(xStream2.toXML(artist2));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output from the second method, the long class names are replaced by the alias.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;name&amp;gt;Benny Goodman&amp;lt;/name&amp;gt;
  &amp;lt;isalive&amp;gt;false&amp;lt;/isalive&amp;gt;
  &amp;lt;albums&amp;gt;
    &amp;lt;album&amp;gt;
      &amp;lt;title&amp;gt;In Stockholm&amp;lt;/title&amp;gt;
      &amp;lt;noofrecords&amp;gt;5&amp;lt;/noofrecords&amp;gt;
      &amp;lt;year&amp;gt;1959&amp;lt;/year&amp;gt;
    &amp;lt;/album&amp;gt;
    &amp;lt;album&amp;gt;
      &amp;lt;title&amp;gt;A Jazz Holiday&amp;lt;/title&amp;gt;
      &amp;lt;noofrecords&amp;gt;3&amp;lt;/noofrecords&amp;gt;
      &amp;lt;year&amp;gt;1928&amp;lt;/year&amp;gt;
    &amp;lt;/album&amp;gt;
  &amp;lt;/albums&amp;gt;
&amp;lt;/artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third method - with alias and implicit collection&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void createXMLFromObjectUsingAlias() {
 JazzArtist artist2 = new JazzArtist(&amp;quot;Benny Goodman&amp;quot;, false, null);
 Album album3 = new Album(&amp;quot;In Stockholm&amp;quot;, 5, 1959);
 Album album4 = new Album(&amp;quot;A Jazz Holiday&amp;quot;, 3, 1928);
 artist2.addAlbum(album3);
 artist2.addAlbum(album4);
 XStream xStream2 = new XStream();
 xStream2.alias(&amp;quot;artist&amp;quot;, JazzArtist.class);
 xStream2.alias(&amp;quot;album&amp;quot;, Album.class);
 System.out.println(xStream2.toXML(artist2));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output from the third method, the &amp;lsquo;albums&amp;rsquo; element is not required and all the &amp;lsquo;album&amp;rsquo; elements are now directly children of the artist.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;name&amp;gt;Benny Goodman&amp;lt;/name&amp;gt;
  &amp;lt;isalive&amp;gt;false&amp;lt;/isalive&amp;gt;
  &amp;lt;album&amp;gt;
    &amp;lt;title&amp;gt;In Stockholm&amp;lt;/title&amp;gt;
    &amp;lt;noofrecords&amp;gt;5&amp;lt;/noofrecords&amp;gt;
    &amp;lt;year&amp;gt;1959&amp;lt;/year&amp;gt;
  &amp;lt;/album&amp;gt;
  &amp;lt;album&amp;gt;
    &amp;lt;title&amp;gt;A Jazz Holiday&amp;lt;/title&amp;gt;
    &amp;lt;noofrecords&amp;gt;3&amp;lt;/noofrecords&amp;gt;
    &amp;lt;year&amp;gt;1928&amp;lt;/year&amp;gt;
  &amp;lt;/album&amp;gt;
&amp;lt;/artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-xml-to-java.jsp&#34; title=&#34;XStream XML to Java&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>XStream: XML To Java</title>
      <link>http://alimy.me/post/dev_201603081427/</link>
      <pubDate>Tue, 08 Mar 2016 14:27:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081427/</guid>
      <description>&lt;p&gt;In the earlier tutorial we looked at a way to &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;Parsing an XML&#34;&gt;convert Java to XML and back&lt;/a&gt;. In this tutorial we look at some more examples of XML To Java Conversion. XStream can convert XML elements to multiple types depending on the type specified in the Java class. For example a series for similarly named elements can be converted to an array of String, a List of String or an enum. XStream uses an appropriate Converter based on type specified in the java class. Lets look at some examples.&lt;/p&gt;

&lt;p&gt;In this first example we have an XML that has a parent element called &amp;lsquo;Music&amp;rsquo;. It has a child element called type. We populate a Music object that has a &amp;lsquo;type&amp;rsquo; field which is an enum.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;

public class ConverterExample3 {
    static String xml1 = &amp;quot;&amp;lt;Music&amp;gt;&amp;lt;type&amp;gt;rock&amp;lt;/type&amp;gt;&amp;lt;/Music&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        XStream xStream = new XStream();
        xStream.processAnnotations(Music.class);
        Music musicObject = (Music) xStream.fromXML(xml1);
        System.out.println(musicObject);
        // prints Music [type=ROCK]
    }

}

@XStreamAlias(&amp;quot;Music&amp;quot;)
class Music {
    public enum genre {
        ROCK, JAZZ
    };

    genre type;

    @Override
    public String toString() {
        return &amp;quot;Music [type=&amp;quot; + type + &amp;quot;]&amp;quot;;
    }

}     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
In the next examples we convert the genre into a List of Strings&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.List;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamImplicit;

public class ConverterExample4 {

    static String xml = &amp;quot;&amp;lt;Music&amp;gt;&amp;lt;type&amp;gt;rock&amp;lt;/type&amp;gt;&amp;lt;type&amp;gt;jazz&amp;lt;/type&amp;gt;&amp;lt;/Music&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        XStream xStream = new XStream();
        xStream.processAnnotations(Music2.class);
        Music2 musicObject = (Music2) xStream.fromXML(xml);

        System.out.println(musicObject);
    }

}

@XStreamAlias(&amp;quot;Music&amp;quot;)
class Music2 {

    @XStreamImplicit
    List&amp;lt;String&amp;gt; type;

    @Override
    public String toString() {
        return &amp;quot;Music2 [type=&amp;quot; + type + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example The Music elements has a sequence of Artist elements each with an album name and a author name. We convert that to Music Object containing a map of Albums.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamImplicit;

public class ConverterExample6 {

    static String xml = &amp;quot;&amp;lt;Music&amp;gt;&amp;lt;album&amp;gt;&amp;lt;name&amp;gt;name1&amp;lt;/name&amp;gt;&amp;lt;author&amp;gt;author1&amp;lt;/author&amp;gt;&amp;lt;/album&amp;gt;&amp;lt;/Music&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        XStream xStream = new XStream();
        xStream.processAnnotations(Music4.class);
        xStream.alias(&amp;quot;name&amp;quot;, String.class);
        xStream.alias(&amp;quot;author&amp;quot;, String.class);
        xStream.alias(&amp;quot;album&amp;quot;, Entry.class);
        Music4 musicObject = (Music4) xStream.fromXML(xml);

        System.out.println(musicObject);
    }

}

@XStreamAlias(&amp;quot;Music&amp;quot;)
class Music4 {

    @XStreamImplicit
    Map&amp;lt;String, String&amp;gt; albums = new HashMap&amp;lt;String, String&amp;gt;();

    @Override
    public String toString() {
        return &amp;quot;Music4 [testMap=&amp;quot; + albums + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the last example lets look at how to deserialize a Date Object. We use a DateConverter where we can specify a format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.converters.basic.DateConverter;

public class ConverterExample7 {
    static String xml = &amp;quot;&amp;lt;Musician&amp;gt;&amp;lt;birthdate&amp;gt;04-20-1976 23:00:00&amp;lt;/birthdate&amp;gt;&amp;lt;/Musician&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        XStream xStream = new XStream();
        xStream.processAnnotations(Musician.class);
        xStream.registerConverter(new DateConverter(&amp;quot;MM-dd-yyyy HH:mm:ss&amp;quot;,
                new String[] {}, TimeZone.getTimeZone(&amp;quot;UTC&amp;quot;)));
        Musician musician = (Musician) xStream.fromXML(xml);
        System.out.println(musician);
    }

}

@XStreamAlias(&amp;quot;Musician&amp;quot;)
class Musician {
    private Date birthdate;

    @Override
    public String toString() {
        SimpleDateFormat format = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);
        format.setTimeZone(TimeZone.getTimeZone(&amp;quot;UTC&amp;quot;));
        return &amp;quot;Musician [birthdate=&amp;quot; + format.format(birthdate) + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-xml-to-java.jsp&#34; title=&#34;XStream XML to Java&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>XStream: Java to XML and Back</title>
      <link>http://alimy.me/post/dev_201603081411/</link>
      <pubDate>Tue, 08 Mar 2016 14:11:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081411/</guid>
      <description>&lt;h3 id=&#34;the-problem-statement&#34;&gt;The Problem Statement&lt;/h3&gt;

&lt;p&gt;XStream can be used to convert a Java Object to XML and back. This tutorial aims to create a java representation of the BBC RSS. We will start with a Simple java class and gradually start adding complexity to it so that it can be converted to the BBC RSS. Note that if you are looking at a way to parse an XML, it would be a good idea to first build a java class that XStream can convert to the required XML. XStream can then use the same class to deserialize the XML. First, have a look at the &lt;a href=&#34;http://feeds.bbci.co.uk/news/technology/rss.xml?edition=int&#34; title=&#34;BBC RSS&#34;&gt;BBC RSS&lt;/a&gt;. Your browser would have formatted it to html so look at the source to see the XML. The parent element is &amp;lsquo;rss&amp;rsquo;. It has a child element called &amp;lsquo;channel&amp;rsquo;. The &amp;lsquo;channel&amp;rsquo; has some properties (title, link, image etc) and a list of news &amp;lsquo;item&amp;rsquo;(s). Each &amp;lsquo;item&amp;rsquo; has properties set on it (title, description etc). The aim is to create a Java class that XStream can convert to the BBC RSS.&lt;/p&gt;

&lt;h3 id=&#34;creating-an-xstream-instance&#34;&gt;Creating an XStream Instance&lt;/h3&gt;

&lt;p&gt;The first step is to create an instance of com.thoughtworks.xstream.XStream. This class is a facade to the XStream API and provides all major functionalities. If this class does not solve your problem then you could directly call the API methods. After obtaining the instance of XStream use the fromXML method to convert the XML to a java object. Note that creating an XStream instance is an expensive operation. It is therefore advisable to create a proper instance once and then reuse it for multiple calls (even in parallel). The setup is not threadsafe but any subsequent marshalling/unmarshalling is threadsafe.
&lt;/p&gt;

&lt;h3 id=&#34;aliases&#34;&gt;Aliases&lt;/h3&gt;

&lt;p&gt;XStream provides a very useful functionality called aliases. In our example we want to convert an instance of com.studytrails.xml.xstream.Rss to an rss element. We tell XStream that the element &amp;lsquo;rss&amp;rsquo; is an &amp;lsquo;alias&amp;rsquo; to &amp;lsquo;com.studytrails.xml.xstream.Rss&amp;rsquo; so that XStream knows how to convert them. If we dont provide the alias while converting the object to XML then XStream would give the element the fully qualified name of the class. Aliases work for Classes as well as fields. The example below demonstrates the use of aliases.&lt;/p&gt;

&lt;h3 id=&#34;implicit-collection&#34;&gt;Implicit Collection&lt;/h3&gt;

&lt;p&gt;The Channel element in BBC has a list of items. However, note that the XML stream does not have an &lt;items&gt; element containing a list of &lt;item&gt; elements. The XML stream just has a list of &lt;item&gt; elements directly under the &lt;Channel&gt; element. We want to map them to the &amp;lsquo;items&amp;rsquo; java.util.List of the Channel Object. To accomplish this we use a concept in XStream called Implicit Collection. we say that &amp;lsquo;items&amp;rsquo; is an implicit collection. What that means is that there is actually no &amp;lsquo;items&amp;rsquo; element in the XML, but put all XML elements with name &amp;lsquo;item&amp;rsquo; (since the java property items is of type List&lt;Item&gt;) into the &amp;lsquo;items&amp;rsquo; property of the java object. Look at the example to see how it works.&lt;/p&gt;

&lt;h3 id=&#34;attributes&#34;&gt;Attributes&lt;/h3&gt;

&lt;p&gt;Handling attributes is a little tricky. In this example we provide one way to handle attributes, however, we have a dedicated tutorial to explain how attributes can be handled using XStream.&lt;/p&gt;

&lt;h3 id=&#34;namespaces&#34;&gt;Namespaces&lt;/h3&gt;

&lt;p&gt;Elements within a namespace can be handled by XStream by using aliases. In this example there is a link within the namespace atom. we just use an alias to read that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xstream.aliasField(&amp;quot;atom:link&amp;quot;, Channel.class, &amp;quot;a_link&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Lets start building the java example. As a first step create a Java class for the root element i.e. RSS&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import com.thoughtworks.xstream.XStream;

public class BBCRSSExample {
    public static void main(String[] args) {
        XStream xStream = new XStream();
        Rss bbcRss = new Rss();
        System.out.println(xStream.toXML(bbcRss));
    }
}

class Rss {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;com.studytrails.xml.xstream.Rss/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We dont want the fully qualified name of the class for Rss. Lets use alias to simplify the name. Add this line after creating the Rss instance&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.alias(&amp;quot;rss&amp;quot;, Rss.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output now becomes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;rss/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rss elmenent contains a Channel element. Lets create a Channel class. The channel element is a child of rss element. Create a field in the Rss class to hold an object of type Channel. Add these lines to the main method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Channel channel = new Channel();
bbcRss.channel = channel;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how the Rss and Channel class looks now&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Rss {
    public Channel channel;
}
class Channel {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how the XML looks now&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;rss&amp;gt;
  &amp;lt;channel/&amp;gt;
&amp;lt;/rss&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we start adding fields to the classes lets look at an important field. The channel element contains this :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;atom:link href=&amp;quot;http://feeds.bbci.co.uk/news/technology/rss.xml&amp;quot; rel=&amp;quot;self&amp;quot; type=&amp;quot;application/rss+xml&amp;quot;&amp;gt;
&amp;lt;/atom:link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the link element belongs to a different namespace. There is a neat little trick to handle this.
Create a class called AtomLink.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AtomLink {
    public String href;
    public String rel;
    public String type;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create an instance of AtomLink in the main class and assign it to a field in the Channel class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AtomLink atomLink = new AtomLink();
atomLink.href = &amp;quot;http://feeds.bbci.co.uk/news/technology/rss.xml&amp;quot;;
atomLink.rel = &amp;quot;self&amp;quot;;
atomLink.type = &amp;quot;application/rss+xml&amp;quot;;
channel.a_link = atomLink;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use alias to give the element a namespace prefix&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.aliasField(&amp;quot;atom:link&amp;quot;, Channel.class, &amp;quot;a_link&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now we want href, rel and type to be attributes instead of child elements, this is how we do that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xstream.aliasAttribute(AtomLink.class, &amp;quot;type&amp;quot;, &amp;quot;type&amp;quot;);
xstream.aliasAttribute(AtomLink.class, &amp;quot;href&amp;quot;, &amp;quot;href&amp;quot;);
xstream.aliasAttribute(AtomLink.class, &amp;quot;rel&amp;quot;, &amp;quot;rel&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see how our XML looks now&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;rss&amp;gt;
  &amp;lt;channel&amp;gt;
    &amp;lt;atom:link href=&amp;quot;http://feeds.bbci.co.uk/news/technology/rss.xml&amp;quot; rel=&amp;quot;self&amp;quot; type=&amp;quot;application/rss+xml&amp;quot;&amp;gt;
  &amp;lt;/atom:link&amp;gt;&amp;lt;/channel&amp;gt;
&amp;lt;/rss&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hope you are enjoying the example. It is important that you understand what&amp;rsquo;s happened so far. Go back to the example if you have any doubt since we will start picking up pace now.
The next important part is the item. The channel contains a list of items but the items are not included in a parent &amp;lsquo;items&amp;rsquo; element. XStream handles this using a concept called Implicit Collection. Lets see how it works, first lets create the Item class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Item {
    public String title;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;create a field in channel class to hold the list of items&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Channel {
    public AtomLink a_link;
    public List&amp;lt;Item&amp;gt; items;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the main class we create an alias for Item and then add an implicit Collection for items. We add two items to the list and see how the XML looks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.alias(&amp;quot;item&amp;quot;, Item.class);
xStream.addImplicitCollection(Channel.class, &amp;quot;items&amp;quot;);
channel.items = new ArrayList&amp;lt;Item&amp;gt;();
Item item = new Item();
item.title=&amp;quot;Item1&amp;quot;;
Item item2 = new Item();
item2.title=&amp;quot;Item2&amp;quot;;
channel.items.add(item);
channel.items.add(item2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;rss&amp;gt;
  &amp;lt;channel&amp;gt;
    &amp;lt;atom:link href=&amp;quot;http://feeds.bbci.co.uk/news/technology/rss.xml&amp;quot; rel=&amp;quot;self&amp;quot; type=&amp;quot;application/rss+xml&amp;quot;&amp;gt;
    &amp;lt;item&amp;gt;
      &amp;lt;title&amp;gt;Item1&amp;lt;/title&amp;gt;
    &amp;lt;/item&amp;gt;
    &amp;lt;item&amp;gt;
      &amp;lt;title&amp;gt;Item2&amp;lt;/title&amp;gt;
    &amp;lt;/item&amp;gt;
  &amp;lt;/atom:link&amp;gt;&amp;lt;/channel&amp;gt;
&amp;lt;/rss&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we add class for the Thumbnail which is part of the item element. An item can have multiple thumbnails. Lets use an array now instead of a Collection just to demonstrate how an ImplicitArray works.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Item {
    public String title;
    public MediaThumbnail[] media_thumbnails;
}

class MediaThumbnail {
    public int width;
    public int height;
    public String url;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main method creates the array and adds thumbnails to it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.addImplicitArray(Item.class, &amp;quot;media_thumbnails&amp;quot;, &amp;quot;media:thumbnail&amp;quot;);
xStream.aliasAttribute(MediaThumbnail.class, &amp;quot;width&amp;quot;,&amp;quot;width&amp;quot;);
xStream.aliasAttribute(MediaThumbnail.class, &amp;quot;height&amp;quot;,&amp;quot;height&amp;quot;);
xStream.aliasAttribute(MediaThumbnail.class, &amp;quot;url&amp;quot;,&amp;quot;url&amp;quot;);

MediaThumbnail thumbnail = new MediaThumbnail();
thumbnail.height=100;
thumbnail.width=50;
thumbnail.url=&amp;quot;thumbnail_link&amp;quot;;
MediaThumbnail thumbnail2 = new MediaThumbnail();
thumbnail2.height=100;
thumbnail2.width=50;
thumbnail2.url=&amp;quot;thumbnail_link2&amp;quot;;

item.media_thumbnails = new MediaThumbnail[2];
item.media_thumbnails[0] = thumbnail;
item.media_thumbnails[1] = thumbnail2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have almost built up the whole class. We can further add the Image class that stores the image in a channel. After creating all classes we start adding the other fields to them. Once the Rss class is ready you can then use it to read the BBC RRS! Heres the complete class and the main method that does the reading.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.net.MalformedURLException;
import java.net.URL;

import com.thoughtworks.xstream.XStream;

public class XStreamDeserializerExample1 {

    private String bbcUrl = &amp;quot;http://feeds.bbci.co.uk/news/technology/rss.xml?edition=int&amp;quot;;

    public static void main(String[] args) throws MalformedURLException {
        XStreamDeserializerExample1 serializer = new XStreamDeserializerExample1();
        serializer.basicSerialization();
    }

    private void basicSerialization() throws MalformedURLException {

        XStream xstream = new XStream();
        xstream.alias(&amp;quot;rss&amp;quot;, Rss.class);
        xstream.aliasField(&amp;quot;atom:link&amp;quot;, Channel.class, &amp;quot;a_link&amp;quot;);
        xstream.alias(&amp;quot;item&amp;quot;, Item.class);

        xstream.aliasAttribute(AtomLink.class, &amp;quot;type&amp;quot;, &amp;quot;type&amp;quot;);
        xstream.aliasAttribute(AtomLink.class, &amp;quot;href&amp;quot;, &amp;quot;href&amp;quot;);
        xstream.aliasAttribute(AtomLink.class, &amp;quot;rel&amp;quot;, &amp;quot;rel&amp;quot;);

        xstream.aliasAttribute(MediaThumbnail.class, &amp;quot;width&amp;quot;,&amp;quot;width&amp;quot;);
        xstream.aliasAttribute(MediaThumbnail.class, &amp;quot;height&amp;quot;,&amp;quot;height&amp;quot;);
        xstream.aliasAttribute(MediaThumbnail.class, &amp;quot;url&amp;quot;,&amp;quot;url&amp;quot;);

        xstream.addImplicitCollection(Channel.class, &amp;quot;items&amp;quot;);
        xstream.addImplicitArray(Item.class, &amp;quot;media_thumbnails&amp;quot;, &amp;quot;media:thumbnail&amp;quot;);
        Rss bbcFeed = (Rss) xstream.fromXML(new URL(bbcUrl));
        // bbcFeed now contains the Java representation of the BBC RSS
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The classes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.List;

public class Rss {
    public Channel channel;
}

class Channel {
    public String title;
    public String link;
    public String description;
    public String language;
    public String lastBuildDate;
    public String copyright;
    public Image4 image;
    public String ttl;
    public AtomLink a_link;
    public List&amp;lt;item&amp;gt; items;
}

class AtomLink {
    public String href;
    public String rel;
    public String type;
}

class Item {
    public String title;
    public String description;
    public String link;
    public String guid;
    public String pubDate;
    public MediaThumbnail[] media_thumbnails;
}

class MediaThumbnail {
    public int width;
    public int height;
    public String url;
}

class Image {
    public String url;
    public String title;
    public String link;
    public String width;
    public String height;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-java-to-xml-and-back.jsp&#34; title=&#34;XStream Parsing an XML&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Xstream: Introduction</title>
      <link>http://alimy.me/post/dev_201603081355/</link>
      <pubDate>Tue, 08 Mar 2016 13:58:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081355/</guid>
      <description>&lt;p&gt;What is XStream&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.codehaus.org/&#34; title=&#34;codehaus&#34;&gt;XStream&lt;/a&gt; is a java library to convert Java Object into XML and back. You can take nearly every arbitrary deeply nested object turn it to XML and read it back without further configuration. You&amp;rsquo;re done if all you want to have is a persisted object in XML. XStream&amp;rsquo;s power lies in its extensive list of &amp;lsquo;Converters&amp;rsquo; that help convert a wide variety of Java Objects to XML and vice versa. A Converter is a class that specifies how a Java Object should be serialized to XML. XStream comes bundled with a lot of Converters and you can also customize your own.&lt;/p&gt;

&lt;p&gt;XStream allows converting a class to XML without modifying the class. It can serialize private and final fields and also inner classes. It can serialize references to objects. XStream has also added security measures that allows you to selectively de-serialize and serialize based on type.

These tutorials provide an indepth look at all major XStream functionalities and presents examples as well as explanations that significantly reduce the learning curve that is generally experienced with any open source library.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;Parsing an XML&#34;&gt;Converting a Java Object to XML and back - Parsing an XML&lt;/a&gt;- In this tutorial we explain how to build a java object to read an XML. The objective is to create a java object and convert it to an XML which looks similar to the XML that we want to read. We then simply use this java object and XStream to parse our XML. This example introduces the basic XStream usage and also explains field and attribute &amp;lsquo;alias&amp;rsquo; and &amp;lsquo;ImplicitCollection&amp;rsquo;/&amp;lsquo;ImplicitArray&amp;rsquo;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603081427&#34; title=&#34;XML to Java&#34;&gt;XML to Java&lt;/a&gt; - We look at some more examples of XML to Java conversion. For example, we see how a piece of XML can be converted to either a List of String or a String array.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603081433&#34; title=&#34;Java to XML&#34;&gt;Java to XML&lt;/a&gt; - In this tutorial we learn how to serialize java to XML. The example demonstrates the use of aliases and implicit collection and also shows how the conversion looks if we dont use alias or implicit collectsion&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603081441&#34; title=&#34;Java to XML Usging Annotation&#34;&gt;Java to XML Using Annotation&lt;/a&gt; - This tutorial shows how to serialize Java to XML using annotations.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603092041&#34; title=&#34;Handling Attributes in XML&#34;&gt;Handling Attributes in XML&lt;/a&gt; - Handling attributes requires special methods since an element may contain an attribute with or without a value. In this tutorial we look at three ways of handling attributes - Element with attributes but no value, element with attributes but no value (using aliases), element with attribute and value (ToAttributedValueConverter)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603092051&#34; title=&#34;Referencing Objects&#34;&gt;Referencing Objects&lt;/a&gt; - A java class may have fields that store reference to other objects. There may be cases where a circular reference is encountered. XStream has multiple ways to store references to other objects. In this tutorial we look at all modes of storing references using XStream.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603092055&#34; title=&#34;Custom Converter for BufferedImage&#34;&gt;Custom Converter for BufferedImage&lt;/a&gt; - The power of XStream lies in its ability to convert a java class to XML and vice versa. Its does so using classes called &amp;lsquo;converters&amp;rsquo;. These converters have methods for marshalling and unmarshalling java and XML. XStream provides a lot of basic converters (basic java classes), Collection Converters and extended converters (converts third party java classes). However, if there is a class for which no converters are available then XStream provides a way to implement a custom converter. In this example we learn how to develop a custom converter for a BufferedImage.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603092100&#34; title=&#34;Basic Built-in Converters&#34;&gt;Basic Built-in Converters&lt;/a&gt; - This example shows some of the basic converters in XStream.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603092105&#34; title=&#34;Collection Converters&#34;&gt;Collection Converters&lt;/a&gt; - This example shows the collection converters in XStream.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603092115&#34; title=&#34;Json to Java&#34;&gt;Json to Java&lt;/a&gt; - XStream also provides a way to convert a Json to java object. It has two drivers to do so. In this tutorial we learn how to convert json to java using XStream.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603092120&#34; title=&#34;XML Transformation&#34;&gt;XML Transformation&lt;/a&gt; - XStream provides a TraxSource that can be used as a source for XSLT transformation. The TraxSource uses the Java Object that is to be transformed and an XStream object.&lt;/p&gt;

&lt;p&gt;We thank Jörg Schaible and Joe Walnes for their valuable feedback in making this tutorial better.&lt;/p&gt;

&lt;p&gt;We hope this tutorials help you in your work and we would appreciate if you could leave us your feedback and help us reach other developers by sharing our site on facebook and google.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-introduction.jsp&#34; title=&#34;XStream Introduction&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SimpleXML: Example</title>
      <link>http://alimy.me/post/dev_201603081313/</link>
      <pubDate>Tue, 08 Mar 2016 13:13:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081313/</guid>
      <description>&lt;p&gt;This page provides a series of examples illustrating how a class can be annotated. It acts as a quick and dirty overview of how the framework can be used and also acts as a reference page. All examples can be downloaded for convenience. For further information take a look at the &lt;a href=&#34;http://alimy.me/post/dev_201603032011&#34; title=&#34;SimpleXML Tutorial&#34;&gt;Tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-creating-nested-path-elements&#34;&gt;&amp;sect;Creating nested path elements&lt;/h3&gt;

&lt;p&gt;Here an example of how to use the &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/javadoc/org/simpleframework/xml/Path.html&#34;&gt;Path&lt;/a&gt; annotation to create nested elements and attributes using a single annotated class. Below is an example showing two elements nested within a XPath expression.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @Path(&amp;quot;a/b[1]&amp;quot;)
   @Element
   private String x;

   @Path(&amp;quot;a/b[2]&amp;quot;)
   @Element
   private String y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
The below snippet shows an example of the resulting XML that can be generated by this class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;a&amp;gt;
    &amp;lt;b&amp;gt;
      &amp;lt;x&amp;gt;foo&amp;lt;/x&amp;gt;
    &amp;lt;/b&amp;gt;
    &amp;lt;b&amp;gt;
      &amp;lt;y&amp;gt;bar&amp;lt;/y&amp;gt;
    &amp;lt;/b&amp;gt;
  &amp;lt;/a&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example1/example1.zip&#34; title=&#34;example1&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-dynamically-selecting-an-element-name&#34;&gt;&amp;sect;Dynamically selecting an element name&lt;/h3&gt;

&lt;p&gt;Here an example of how to use the ElementUnion annotation to specify a list of options to use for serialization. The union annotation pairs an element name with a type, this allows the element name to dictate selection of the type deserialized and also allows a known type to be serialized with a specific element name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @ElementUnion({
      @Element(name=&amp;quot;text&amp;quot;, type=String.class),
      @Element(name=&amp;quot;int&amp;quot;, type=Integer.class),
      @Element(name=&amp;quot;double&amp;quot;, type=Double.class)
   })
   private Object value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, here because the object value was an integer the resulting XML element is called int.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;int&amp;gt;12&amp;lt;/int&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example2/example2.zip&#34; title=&#34;example2&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-constructor-injection&#34;&gt;&amp;sect;Constructor injection&lt;/h3&gt;

&lt;p&gt;Constructor injection can be performed with any number of arguments using any of the XML annotations. In this example the Element annotation is used to identify two values to be injected in to a specific constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Point {

   @Element
   private final int x;

   @Element
   private final int y;

   public Point(@Element(name=&amp;quot;x&amp;quot;) int x, @Element(name=&amp;quot;y&amp;quot;) int y) {
      this.x = x;
      this.y = y;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, both the x and y values will be injected in to the annotated constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;point&amp;gt;
  &amp;lt;x&amp;gt;10&amp;lt;/x&amp;gt;
  &amp;lt;y&amp;gt;4&amp;lt;/y&amp;gt;
&amp;lt;/point&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example3/example3.zip&#34; title=&#34;example3&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-constructor-injection-with-nested-path-elements&#34;&gt;&amp;sect;Constructor injection with nested path elements&lt;/h3&gt;

&lt;p&gt;In this example constructor injection is performed on two elements which also have Path annotations. As can be seen if there is no ambiguity there is no need to specify the path annotations on the constructor. This reduces the clutter that can occur with excessive annotations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Point {

   @Path(&amp;quot;a/b[1]&amp;quot;)
   @Element
   private final int x;

   @Path(&amp;quot;a/b[1]&amp;quot;)
   @Element
   private final int y;

   public Point(@Element(name=&amp;quot;x&amp;quot;) int x, @Element(name=&amp;quot;y&amp;quot;) int y) {
      this.x = x;
      this.y = y;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, both the x and y values will be injected in to the annotated constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;point&amp;gt;
  &amp;lt;a&amp;gt;
    &amp;lt;b&amp;gt;
      &amp;lt;x&amp;gt;2&amp;lt;/x&amp;gt;
      &amp;lt;y&amp;gt;7&amp;lt;/y&amp;gt;
    &amp;lt;/b&amp;gt;
  &amp;lt;/a&amp;gt;
&amp;lt;/point&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example4/example4.zip&#34; title=&#34;example4&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-using-namespaces&#34;&gt;&amp;sect;Using namespaces&lt;/h3&gt;

&lt;p&gt;Below is an example of how to use namespaces with the Namespace annotation. Here two namespaces are declared without a prefix, this means they belong to the default namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @Namespace(reference=&amp;quot;http://www.blah.com/ns/a&amp;quot;)
   @Element
   private String a;

   @Namespace(reference=&amp;quot;http://www.blah.com/ns/b&amp;quot;)
   @Element
   private String b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, as can be seen the namespaces are used to qualify the resulting elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;a xmlns=&amp;quot;http://www.blah.com/ns/a&amp;quot;&amp;gt;foo&amp;lt;/a&amp;gt;
  &amp;lt;b xmlns=&amp;quot;http://www.blah.com/ns/b&amp;quot;&amp;gt;bar&amp;lt;/b&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example5/example5.zip&#34; title=&#34;example5&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-declaring-a-namespace-prefix&#34;&gt;&amp;sect;Declaring a namespace prefix&lt;/h3&gt;

&lt;p&gt;When using the Namespace annotation a prefix can be specified. This prefix is added to the qualified XML elements to ensure they are within a specific namespace, rather than the default namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @Namespace(prefix=&amp;quot;ns1&amp;quot;, reference=&amp;quot;http://www.blah.com/ns/a&amp;quot;)
   @Element
   private String a;

   @Namespace(prefix=&amp;quot;ns2&amp;quot;, reference=&amp;quot;http://www.blah.com/ns/b&amp;quot;)
   @Element
   private String b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting XML shows that both elements contain the namespace prefix declared in the annotation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;ns1:a xmlns:ns1=&amp;quot;http://www.blah.com/ns/a&amp;quot;&amp;gt;foo&amp;lt;/ns1:a&amp;gt;
  &amp;lt;ns2:b xmlns:ns2=&amp;quot;http://www.blah.com/ns/b&amp;quot;&amp;gt;bar&amp;lt;/ns2:b&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example6/example6.zip&#34; title=&#34;example6&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-namespace-prefix-inheritance&#34;&gt;&amp;sect;Namespace prefix inheritance&lt;/h3&gt;

&lt;p&gt;Here a class level namespace is declared using the Namespace annotation. The element declared with the same namespace reference does not need to declare a prefix as it will be inherited from the class level annotation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Namespace(prefix=&amp;quot;ns1&amp;quot;, reference=&amp;quot;http://www.blah.com/ns/a&amp;quot;)
public class Example {

   @Namespace(reference=&amp;quot;http://www.blah.com/ns/a&amp;quot;)
   @Path(&amp;quot;a/b&amp;quot;)
   @Element
   private String x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen in the resulting XML the namespace is declared only once, the child element inherits the original prefix reducing the verbosity of the XML.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example xmlns:ns1=&amp;quot;http://www.blah.com/ns/a&amp;quot;&amp;gt;
  &amp;lt;a&amp;gt;
    &amp;lt;b&amp;gt;
      &amp;lt;ns1:x&amp;gt;blah&amp;lt;/ns1:x&amp;gt;
    &amp;lt;/b&amp;gt;
  &amp;lt;/a&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example7/example7.zip&#34; title=&#34;example7&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-default-serialization&#34;&gt;&amp;sect;Default serialization&lt;/h3&gt;

&lt;p&gt;This example shows how the Default annotation can be used. When this annotation is used fields will be serialized without the need for annotations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Default
public class Example {

   private List&amp;lt;Double&amp;gt; a;
   private String b;
   private String c;
   private Date d;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen in the resulting XML is generated for all fields within the class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;a&amp;gt;
    &amp;lt;double&amp;gt;1.2&amp;lt;/double&amp;gt;
    &amp;lt;double&amp;gt;31.6&amp;lt;/double&amp;gt;
    &amp;lt;double&amp;gt;52.99&amp;lt;/double&amp;gt;
  &amp;lt;/a&amp;gt;
  &amp;lt;b&amp;gt;foo&amp;lt;/b&amp;gt;
  &amp;lt;c&amp;gt;bar&amp;lt;/c&amp;gt;
  &amp;lt;d&amp;gt;2012-05-22&amp;lt;/d&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example8/example8.zip&#34; title=&#34;example8&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-default-serialization-of-properties&#34;&gt;&amp;sect;Default serialization of properties&lt;/h3&gt;

&lt;p&gt;This example shows how the Default annotation can be configured to use bean methods instead of fields for serialization. When used in this manner all methods that follow the Java Bean naming conventions will be considered for serialization.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Default(DefaultType.PROPERTY)
public class Example {

   private String name;

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen in the resulting XML is generated for the Java Bean method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example9/example9.zip&#34; title=&#34;example9&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-collecting-various-types-in-a-single-list&#34;&gt;&amp;sect;Collecting various types in a single list&lt;/h3&gt;

&lt;p&gt;Here an example of how to use the ElementListUnion can be seen. This annotation allows a number of types to be declared to match a single list, all elements that match the declared names will be gathered in to the list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @ElementListUnion({
      @ElementList(entry=&amp;quot;int&amp;quot;, type=Integer.class, inline=true),
      @ElementList(entry=&amp;quot;date&amp;quot;, type=Date.class, inline=true),
      @ElementList(entry=&amp;quot;text&amp;quot;, type=String.class, inline=true)
   })
   private List&amp;lt;Object&amp;gt; list;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, each type is given a name according to its type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;int&amp;gt;12&amp;lt;/int&amp;gt;
  &amp;lt;date&amp;gt;2012-22-05&amp;lt;/date&amp;gt;
  &amp;lt;date&amp;gt;1977-18-11&amp;lt;/date&amp;gt;
  &amp;lt;text&amp;gt;blah&amp;lt;/text&amp;gt;
  &amp;lt;int&amp;gt;1&amp;lt;/int&amp;gt;
  &amp;lt;int&amp;gt;34525&amp;lt;/int&amp;gt;
  &amp;lt;date&amp;gt;2001-01-05&amp;lt;/date&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example10/example10.zip&#34; title=&#34;example10&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-dynamically-matching-a-constructor&#34;&gt;&amp;sect;Dynamically matching a constructor&lt;/h3&gt;

&lt;p&gt;Here an example of how to use the ElementUnion to dynamically select a constructor based on the value deserialized. Constructor matching will be done by examining the declared name and the instance type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @ElementUnion({
      @Element(name=&amp;quot;int&amp;quot;, type=Integer.class),
      @Element(name=&amp;quot;date&amp;quot;, type=Date.class),
      @Element(name=&amp;quot;text&amp;quot;, type=String.class)
   })
   private Object value;

   public Example(@Element(name=&amp;quot;int&amp;quot;) int value) {
      this.value = value;
   }

   public Example(@Element(name=&amp;quot;date&amp;quot;) Date value) {
      this.value = value;
   }

   public Example(@Element(name=&amp;quot;text&amp;quot;) String value) {
      this.value = value;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, here the constructor accepting a date will be invoked as that is what is deserialized from the file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;date&amp;gt;2001-01-05&amp;lt;/date&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example11/example11.zip&#34; title=&#34;example11&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/examples.php&#34; title=&#34;SimpleXML Examples&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SimpleXML: Tutorial</title>
      <link>http://alimy.me/post/dev_201603032011/</link>
      <pubDate>Thu, 03 Mar 2016 20:11:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603032011/</guid>
      <description>&lt;p&gt;This page provides a tutorial that will prepare users for using XML serialization. Before this tutorial is attempted it is advisable to have a look at the &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/javadoc/&#34;&gt;Javadoc&lt;/a&gt; documentation for the framework. Although there are only several annotations and objects involved in the serialization process the framework itself has many powerful features which this tutorial attempts to describe.

1. &lt;a href=&#34;#1&#34;&gt;Serializing a simple object&lt;/a&gt;
2. &lt;a href=&#34;#2&#34;&gt;Deserializing a simple object&lt;/a&gt;
3. &lt;a href=&#34;#3&#34;&gt;Nested object serialization&lt;/a&gt;
4. &lt;a href=&#34;#4&#34;&gt;Optional elements and attributes&lt;/a&gt;
5. &lt;a href=&#34;#5&#34;&gt;Reading a list of elements&lt;/a&gt;
6. &lt;a href=&#34;#6&#34;&gt;Overriding an annotated type&lt;/a&gt;
7. &lt;a href=&#34;#7&#34;&gt;Dealing with an inline list of elements&lt;/a&gt;
8. &lt;a href=&#34;#8&#34;&gt;Constructor injection&lt;/a&gt;
9. &lt;a href=&#34;#9&#34;&gt;Reading an array of elements&lt;/a&gt;
10. &lt;a href=&#34;#10&#34;&gt;Adding text and attributes to elements&lt;/a&gt;
11. &lt;a href=&#34;#11&#34;&gt;Dealing with map objects&lt;/a&gt;
12. &lt;a href=&#34;#12&#34;&gt;Scattering inline element entries&lt;/a&gt;
13. &lt;a href=&#34;#13&#34;&gt;Loose object mapping&lt;/a&gt;
14. &lt;a href=&#34;#14&#34;&gt;Java Bean serialization&lt;/a&gt;
15. &lt;a href=&#34;#15&#34;&gt;Default object serialization&lt;/a&gt;
16. &lt;a href=&#34;#16&#34;&gt;Example using template filters&lt;/a&gt;
17. &lt;a href=&#34;#17&#34;&gt;Receiving persister callbacks&lt;/a&gt;
18. &lt;a href=&#34;#18&#34;&gt;Maintaining state between persister callbacks&lt;/a&gt;
19. &lt;a href=&#34;#19&#34;&gt;Serializing with CDATA blocks&lt;/a&gt;
20. &lt;a href=&#34;#20&#34;&gt;Using XML namespaces&lt;/a&gt;
21. &lt;a href=&#34;#21&#34;&gt;Resolving object reference cycles&lt;/a&gt;
22. &lt;a href=&#34;#22&#34;&gt;Reusing XML elements&lt;/a&gt;
23. &lt;a href=&#34;#23&#34;&gt;Using utility collections&lt;/a&gt;
24. &lt;a href=&#34;#24&#34;&gt;Object substitution&lt;/a&gt;
25. &lt;a href=&#34;#25&#34;&gt;Serializing Java language types&lt;/a&gt;
26. &lt;a href=&#34;#26&#34;&gt;Styling serialized XML&lt;/a&gt;
27. &lt;a href=&#34;#27&#34;&gt;Version tolerant serialization&lt;/a&gt;
28. &lt;a href=&#34;#28&#34;&gt;Serializing static final fields&lt;/a&gt;
29. &lt;a href=&#34;#29&#34;&gt;Overriding serialization with converters&lt;/a&gt;
30. &lt;a href=&#34;#30&#34;&gt;Intercepting the serialization process&lt;/a&gt;
31. &lt;a href=&#34;#31&#34;&gt;Mapping with XPath expressions&lt;/a&gt;
32. &lt;a href=&#34;#32&#34;&gt;Dynamic serialization with unions&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-1-sect-serializing-a-simple-object&#34;&gt;&lt;a name=&#34;1&#34;/&gt; &amp;sect;Serializing a simple object&lt;/h3&gt;

&lt;p&gt;In order to serialize an object to XML a series of annotations must be placed within that object. These annotations tell the persister how the object should be serialized. For example take the class shown below. Here there are three different annotations, one used to describe the name of the root element, one that describes an XML message element, and a final annotation for an id attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @Element
   private String text;

   @Attribute
   private int index;

   public Example() {
      super();
   }  

   public Example(String text, int index) {
      this.text = text;
      this.index = index;
   }

   public String getMessage() {
      return text;
   }

   public int getId() {
      return index;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To serialize an instance of the above object a &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/javadoc/org/simpleframework/xml/core/Persister.html&#34;&gt;Persister&lt;/a&gt; is required. The persister object is then given an instance of the annotated object and an output result, which is a file in this example. Other output formats are possible with the persister object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Serializer serializer = new Persister();
Example example = new Example(&amp;quot;Example message&amp;quot;, 123);
File result = new File(&amp;quot;example.xml&amp;quot;);

serializer.write(example, result);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the above code is executed the object instance will have been transferred as an XML document to the specified file. The resulting XML file will contain the contents shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example index=&amp;quot;123&amp;quot;&amp;gt;
   &amp;lt;text&amp;gt;Example message&amp;lt;/text&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As well as the capability of using the field an object name to acquire the XML element and attribute names explicit naming is possible. Each annotation contains a name attribute, which can be given a string providing the name of the XML attribute or element. This ensures that should the object have unusable field or method names they can be overridden, also if your code is obfuscated explicit naming is the only reliable way to serialize and deserialize objects consistently. An example of the previous object with explicit naming is shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root(name=&amp;quot;root&amp;quot;)
public class Example {

   @Element(name=&amp;quot;message&amp;quot;)
   private String text;

   @Attribute(name=&amp;quot;id&amp;quot;)
   private int index;

   public Example() {
      super();
   }  

   public Example(String text, int index) {
      this.text = text;
      this.index = index;
   }

   public String getMessage() {
      return text;
   }

   public int getId() {
      return index;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above object the XML document constructed from an instance of the object results in a different format. Here the XML element and attribute names have been overridden with the annotation names. The resulting output is shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;root id=&amp;quot;123&amp;quot;&amp;gt;
   &amp;lt;message&amp;gt;Example message&amp;lt;/message&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-2-sect-deserializing-a-simple-object&#34;&gt;&lt;a name=&#34;2&#34; /&gt; &amp;sect;Deserializing a simple object&lt;/h3&gt;

&lt;p&gt;Taking the above example object the XML deserialization process is described in the code snippet shown below. As can be seen the deserialization process is just as simple. The persister is given the class representing the serialized object and the source of the XML document. To deserialize the object the read method is used, which produces an instance of the annotated object. Also, note that there is no need to cast the return value from the read method as the method is generic.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Serializer serializer = new Persister();
File source = new File(&amp;quot;example.xml&amp;quot;);

Example example = serializer.read(Example.class, source);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-sect-nested-object-serialization&#34;&gt;&lt;a name=&#34;3&#34; /&gt; &amp;sect;Nested object serialization&lt;/h3&gt;

&lt;p&gt;As well as simple object serialization, nested object serialization is possible. This is where a serializable object can contain any number of serializable objects, to any depth. Take the example shown in the code snippet below. This shows several objects that are linked together to form a single serializable entity. Here the root configuration object contains a server object, which in turn contains a security information object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Configuration {

   @Element
   private Server server;

   @Attribute
   private int id;

   public int getIdentity() {
      return id;
   }

   public Server getServer() {
      return server;           
   }
}

public class Server {

   @Attribute
   private int port;

   @Element
   private String host;

   @Element
   private Security security;

   public int getPort() {
      return port;           
   }

   public String getHost() {
      return host;           
   }

   public Security getSecurity() {
      return security;           
   }
}

public class Security {

   @Attribute
   private boolean ssl;

   @Element
   private String keyStore;

   public boolean isSSL() {
      return ssl;           
   }

   public String getKeyStore() {
      return keyStore;           
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to create an initialized configuration object an XML document can be used. This XML document needs to match the XML annotations for the object graph. So taking the above class schema the XML document would look like the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;configuration id=&amp;quot;1234&amp;quot;&amp;gt;
   &amp;lt;server port=&amp;quot;80&amp;quot;&amp;gt;
      &amp;lt;host&amp;gt;www.domain.com&amp;lt;/host&amp;gt;
      &amp;lt;security ssl=&amp;quot;true&amp;quot;&amp;gt;
         &amp;lt;keyStore&amp;gt;example keystore&amp;lt;/keyStore&amp;gt;
      &amp;lt;/security&amp;gt;
   &amp;lt;/server&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How the mapping is done can be seen by examining the XML document elements and attributes and comparing these to the annotations within the schema classes. The mapping is quite simple and can be picked up and understood in several minutes.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-sect-optional-elements-and-attributes&#34;&gt;&lt;a name=&#34;4&#34; /&gt;&amp;sect;Optional elements and attributes&lt;/h3&gt;

&lt;p&gt;At times it may be required to have an optional XML element or attribute as the source XML may not contain the attribute or element. Also, it may be that an object field is null and so cannot be serialized. In such scenarios the element or attribute can be set as not required. The following code example demonstrates an optional element and attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class OptionalExample {

   @Attribute(required=false)
   private int version;

   @Attribute
   private String id;

   @Element(required=false)
   private String name;   

   @Element
   private String address;

   public int getId() {
      return id;
   }

   public int getVersion() {
      return version;
   }

   public String getName() {
      return name;
   }

   public String getAddress() {
      return address;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above object the version and name are not required. So, and XML source document may not contain either of these details and the object can still be serialized safely. For example take the following XML document, which is a valid representation of the above object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;optionalExample id=&amp;quot;10&amp;quot;&amp;gt;
   &amp;lt;address&amp;gt;Some example address&amp;lt;/address&amp;gt;
&amp;lt;/optionalExample&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even without the name and version XML nodes this document can be deserialized in to an object. This feature is useful when your XML contains optional details and allows more flexible parsing. To further clarify the implementation of optional fields take the example shown below. This shows how the entry object is deserialized from the above document, which is contained within a file. Once deserialized the object values can be examined.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Serializer serializer = new Persister();
File source = new File(&amp;quot;example.xml&amp;quot;);
OptionalExample example = serializer.read(OptionalExample.class, source);

assert example.getVersion() == 0;
assert example.getName() == null;
assert example.getId() == 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-5-sect-reading-a-list-of-elements&#34;&gt;&lt;a name=&#34;5&#34; /&gt;&amp;sect;Reading a list of elements&lt;/h3&gt;

&lt;p&gt;In XML configuration and in Java objects there is often a one to many relationship from a parent to a child object. In order to support this common relationship an ElementList annotation has been provided. This allows an annotated schema class to be used as an entry to a Java collection object. Take the example shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class PropertyList {

   @ElementList
   private List&amp;lt;Entry&amp;gt; list;

   @Attribute
   private String name;

   public String getName() {
      return name;
   }

   public List getProperties() {
      return list;
   }
}

@Root
public class Entry {

   @Attribute
   private String key;

   @Element
   private String value;

   public String getName() {
      return name;
   }

   public String getValue() {
      return value;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above code snippet the element list annotation can be seen. The field type is reflectively instantiated as a matching concrete object from the Java collections framework, typically it is an array list, but can be any collection object if the field type declaration provides a concrete implementation type rather than the abstract list type shown in the above example.&lt;/p&gt;

&lt;p&gt;Below an XML document is shown that matches the schema class. Here each entry element will be deserialized using the declared entry class and inserted into the collection instance created. Once all entry objects have been deserialized the object instance contains a collection containing individual property objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;propertyList name=&amp;quot;example&amp;quot;&amp;gt;
   &amp;lt;list&amp;gt;
      &amp;lt;entry key=&amp;quot;one&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
      &amp;lt;entry key=&amp;quot;two&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
      &amp;lt;entry key=&amp;quot;three&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
      &amp;lt;entry key=&amp;quot;four&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
   &amp;lt;/list&amp;gt;
&amp;lt;/propertyList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above example it can be seen that the entry details are taken from the generic type of the collection. It declares a list with the entry class as its generic parameter. This type of declaration is often not possible, for example if a specialized list contains more than one generic type which one is the correct type to use for deserialization or serialization. In such scenarios the type must be provided explicitly. Take the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class ExampleList {

   @ElementList(type=C.class)
   private SpecialList&amp;lt;A, B, C&amp;gt; list;

   public SpecialList&amp;lt;A, B, C&amp;gt; getSpecialList() {
      return list;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example the special list takes three generic parameters, however only one is used as the generic parameter for the collection. As can be seen an explicit declaration of which type to use is required. This can be done with the type attribute of the ElementList annotation.&lt;/p&gt;

&lt;h3 id=&#34;a-name-6-sect-overriding-an-annotated-type&#34;&gt;&lt;a name=&#34;6&#34; /&gt;&amp;sect;Overriding an annotated type&lt;/h3&gt;

&lt;p&gt;In order to accommodate dynamic types within the deserialization process a class attribute can be added to an XML element, which will ensure that that element can be instantiated as the declared type. This ensures that field and method types can reference abstract classes and interfaces, it also allows multiple types to be added into an annotated collection.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package example.demo;

public interface Task {

   public double execute();
}

@Root
public class Example implements Task {

   @Element
   private Task task;

   public double execute() {
      return task.execute();
   }  
}

public class DivideTask implements Task {

   @Element(name=&amp;quot;left&amp;quot;)
   private float text;

   @Element(name=&amp;quot;right&amp;quot;)
   private float right;

   public double execute() {
      return left / right;
   }
}

public class MultiplyTask implements Task {

   @Element(name=&amp;quot;first&amp;quot;)
   private int first;

   @Element(name=&amp;quot;second&amp;quot;)
   private int second;

   public double execute() {
      return first * second;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class attribute must be a fully qualified class name so that the context class loader can load it. Also, the type can contain its own unique annotations and types which makes the deserialization and serialization process truly dynamic. Below is an example XML document declaring the class type for the task object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
   &amp;lt;task class=&amp;quot;example.demo.DivideTask&amp;quot;&amp;gt;
      &amp;lt;left&amp;gt;16.5&amp;lt;/left&amp;gt;
      &amp;lt;right&amp;gt;4.1&amp;lt;/right&amp;gt;
   &amp;lt;/task&amp;gt;
&amp;lt;/example&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to execute the task described in the XML document the following code can be used. Here it is assumed the XML source is contained within a file. Once the example object has been deserialized the task can be executed and the result acquired.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Serializer serializer = new Persister();
File example = new File(&amp;quot;example.xml&amp;quot;);
Example example = serializer.read(Example.class, example)

double value = example.execute();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-7-sect-dealing-with-an-inline-list-of-elements&#34;&gt;&lt;a name=&#34;7&#34; /&gt;&amp;sect;Dealing with an inline list of elements&lt;/h3&gt;

&lt;p&gt;When dealing with third party XML or with XML that contains a grouping of related elements a common format involves the elements to exist in a sequence with no wrapping parent element. In order to accomodate such structures the element list annotation can be configured to ignore the parent element for the list. For example take the following XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;propertyList&amp;gt;
   &amp;lt;name&amp;gt;example&amp;lt;/name&amp;gt;
   &amp;lt;entry key=&amp;quot;one&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
   &amp;lt;entry key=&amp;quot;two&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;second value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
   &amp;lt;entry key=&amp;quot;three&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;third value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
&amp;lt;/propertyList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above XML document there is a sequence of entry elements, however unlike the previous example these are not enclosed within a parent element. In order to achieve this the inline attribute of the ElementList annotation can be set to true. The following code snippet demonstrates how to use the inline attribute to process the above XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class PropertyList {

   @ElementList(inline=true)
   private List&amp;lt;Entry&amp;gt; list;

   @Element
   private String name;

   public String getName() {
      return name;
   }

   public List getProperties() {
      return list;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a number of conditions for the use of the inline element list. Firstly, each element within the inline list must be placed one after another. They cannot be dispersed in between other elements. Also, each entry type within the list must have the same root name, to clarify take the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package example.demo;

@Root
public class Entry {

    @Attribute
    protected String key;

    @Element
    protected String value;

    public String getKey() {
       return key;
    }
}

public class ValidEntry extends Entry {

   public String getValue() {
      return value;
   }
}

@Root
public class InvalidEntry extends Entry {

   public String getValue() {
      return value;
   }
}

@Root(name=&amp;quot;entry&amp;quot;)
public class FixedEntry extends InvalidEntry {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of the above types extend the same base type, and so all are candidates for use with the PropertyList described earlier. However, although all types could be successfully deserialized and serialized using a list which is not inline, only some can be serialized with an inline list. For instance the type InvalidEntry could not be serialized as it will be serialized with a different name from all the other entrie implementations. The InvalidEntry object has a Root annotation which means that its XML element name will be &amp;ldquo;invalidEntry&amp;rdquo;. In order to be used with the inline list all objects must have the same XML element name of &amp;ldquo;entry&amp;rdquo;. By extending the InvalidEntry type and explicitly specifying the name to be &amp;ldquo;entry&amp;rdquo; the FixedEntry subclass can be used without any issues. For example take the following XML document, which could represent a mixture of entry types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;propertyList&amp;gt;
   &amp;lt;name&amp;gt;example&amp;lt;/name&amp;gt;
   &amp;lt;entry key=&amp;quot;one&amp;quot; class=&amp;quot;example.demo.ValidEntry&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
   &amp;lt;entry key=&amp;quot;two&amp;quot; class=&amp;quot;example.demo.FixedEntry&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;second value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
   &amp;lt;entry key=&amp;quot;three&amp;quot; class=&amp;quot;example.demo.Entry&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;third value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
&amp;lt;/propertyList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of the above entry elements within the inline list contain the same XML element name. Also each type is specified as a subclass implementation of the root Entry object.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-sect-constructor-injection&#34;&gt;&lt;a name=&#34;8&#34; /&gt;&amp;sect;Constructor injection&lt;/h3&gt;

&lt;p&gt;All but the simplest of programs will have some form of immutable objects. These are objects that do not have setters and so will acquire data by using constructor injection. In this manner the object sets its internal state from the data provided to the constructor. This can also be achieved with serialization, if you would like to serialize and deserialize objects but do not want to provide setter methods this can be done, as illustrated in the example below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class OrderManager {

    private final List&amp;lt;Order&amp;gt; orders;

    public OrderManager(@ElementList(name=&amp;quot;orders&amp;quot;) List&amp;lt;Order&amp;gt; orders) {
        this.orders = orders;
    }

    @ElementList(name=&amp;quot;orders&amp;quot;)
    public List&amp;lt;Order&amp;gt; getOrders() {
        return orders;
    }
}

@Root
public class Order {

    @Attribute(name=&amp;quot;name&amp;quot;)
    private final String name;

    @Element(name=&amp;quot;product&amp;quot;)
    private final String product;

    public Order(@Attribute(name=&amp;quot;name&amp;quot;) String name,
                 @Element(name=&amp;quot;product&amp;quot;) String product)
    {
        this.product = product;
        this.name = name;
    }

    public String getProduct() {
        return product;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code illustrates an order manager that contains a list of immutable order objects. On deserialization the values are taken from the XML document and injected in to the constructor to instantiate the object. This is a very useful feature that is not often found in serialization frameworks. One restriction on the constructor injection is that it must be used with an annotated get method or field. This is required so that on serialization the persister knows where to get the data to write. Taking the above example if the getOrders method was not annotated then there would be no way to determine how to write the order manager object. Below is some example XML resulting from serialization of the order manager.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;orderManager&amp;gt;
    &amp;lt;order name=&amp;quot;AX101&amp;quot;&amp;gt;
        &amp;lt;product&amp;gt;Product A&amp;lt;/product&amp;gt;
    &amp;lt;/order&amp;gt;
    &amp;lt;order name=&amp;quot;AX102&amp;quot;&amp;gt;
        &amp;lt;product&amp;gt;Product B&amp;lt;/product&amp;gt;
    &amp;lt;/order&amp;gt;
    &amp;lt;order name=&amp;quot;AX103&amp;quot;&amp;gt;
        &amp;lt;product&amp;gt;Product C&amp;lt;/product&amp;gt;
    &amp;lt;/order&amp;gt;
&amp;lt;/orderManager&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-9-sect-reading-an-array-of-elements&#34;&gt;&lt;a name=&#34;9&#34; /&gt;&amp;sect;Reading an array of elements&lt;/h3&gt;

&lt;p&gt;As well as being able to deserialize elements in to a collection arrays can also be serialized and deserialized. However, unlike the @ElementList annotation the ElementArray annotation can also deserialize primitive values such as int arrays, char arrays, and so on. Below is an example object with an array of integer values and a parallel array of string values.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class AddressBook {

   @ElementArray
   private Address[] addresses;   

   @ElementArray
   private String[] names;        

   @ElementArray
   private int[] ages;   

   public Address[] getAddresses() {
      return addresses;           
   }

   public String[] getNames() {
      return names;           
   }

   public int[] getAges() {
      return ages;           
   }
}

@Root
public class Address {

   @Element(required=false)
   private String house;        

   @Element
   private String street;  

   @Element
   private String city;

   public String getHouse() {
      return house;           
   }

   public String getStreet() {
      return street;           
   }

   public String getCity() {
      return city;           
   }     
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above object both primitive arrays require an entry attribute, this is because primitives can not be annotated with the Root annotation. The entry attribute tells the persister than an extra XML element is required to wrap the entry. This entry element can also be applied to serializable objects that have the Root annotation, however it is typically only used for primitive arrays. The following XML is an example of what is produced by the above objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;addressBook&amp;gt;
   &amp;lt;addresses length=&amp;quot;3&amp;quot;&amp;gt;
      &amp;lt;address&amp;gt;
         &amp;lt;house&amp;gt;House 33&amp;lt;/house&amp;gt;
         &amp;lt;street&amp;gt;Sesame Street&amp;lt;/street&amp;gt;
         &amp;lt;city&amp;gt;City&amp;lt;/city&amp;gt;
      &amp;lt;/address&amp;gt;
      &amp;lt;address&amp;gt;
         &amp;lt;street&amp;gt;Some Street&amp;lt;/street&amp;gt;
         &amp;lt;city&amp;gt;The City&amp;lt;/city&amp;gt;
      &amp;lt;/address&amp;gt;
      &amp;lt;address&amp;gt;
         &amp;lt;house&amp;gt;Another House&amp;lt;/house&amp;gt;
         &amp;lt;street&amp;gt;My Street&amp;lt;/street&amp;gt;
         &amp;lt;city&amp;gt;Same City&amp;lt;/city&amp;gt;
      &amp;lt;/address&amp;gt;
   &amp;lt;/addresses&amp;gt;
   &amp;lt;names length=&amp;quot;3&amp;quot;&amp;gt;
      &amp;lt;string&amp;gt;Jonny Walker&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Jack Daniels&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Jim Beam&amp;lt;/string&amp;gt;
   &amp;lt;/names&amp;gt;
   &amp;lt;ages length=&amp;quot;3&amp;quot;&amp;gt;
      &amp;lt;int&amp;gt;30&amp;lt;/int&amp;gt;
      &amp;lt;int&amp;gt;42&amp;lt;/int&amp;gt;
      &amp;lt;int&amp;gt;31&amp;lt;/int&amp;gt;
   &amp;lt;/ages&amp;gt;
&amp;lt;/addressBook&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the above XML it can be seen that each entity within an array index is named the same as its type. So a string is wrapped in a &amp;lsquo;string&amp;rsquo; element and an int is wrapped in an &amp;lsquo;int&amp;rsquo; element. This is done because the default name for the ElementArray annotation is its type name, unless the Root annotation is used with a name. This can be overridden by providing an explicit entry name for the array. For example take the simple object below which contains an array of names as string objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class NameList {

   @ElementArray(entry=&amp;quot;name&amp;quot;)
   private String[] names;        

   public String[] getNames() {
      return names;           
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above XML the following document is a valid representation. Notice how each of the names within the XML document is wrapped in a &amp;lsquo;name&amp;rsquo; element. This element name is taken from the annotation provided.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;nameList&amp;gt;
   &amp;lt;names length=&amp;quot;3&amp;quot;&amp;gt;
      &amp;lt;name&amp;gt;Jonny Walker&amp;lt;/name&amp;gt;
      &amp;lt;name&amp;gt;Jack Daniels&amp;lt;/name&amp;gt;
      &amp;lt;name&amp;gt;Jim Beam&amp;lt;/name&amp;gt;
   &amp;lt;/names&amp;gt;
&amp;lt;/nameList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-10-sect-adding-text-and-attributes-to-elements&#34;&gt;&lt;a name=&#34;10&#34; /&gt;&amp;sect;Adding text and attributes to elements&lt;/h3&gt;

&lt;p&gt;As can be seen from the previous example annotating a primitive such as a String with the Element annotation will result in text been added to a names XML element. However it is also possible to add text to an element that contains attributes. An example of such a class schema is shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Entry {

   @Attribute
   private String name;

   @Attribute
   private int version;     

   @Text
   private String value;

   public int getVersion() {
      return version;           
   }

   public String getName() {
      return name;
   }

   public String getValue() {
      return value;              
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the class is annotated in such a way that an element contains two attributes named version and name. It also contains a text annotation which specifies text to add to the generated element. Below is an example XML document that can be generated using the specified class schema.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;entry version=&#39;1&#39; name=&#39;name&#39;&amp;gt;
   Some example text within an element
&amp;lt;/entry&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rules that govern the use of the Text annotation are that there can only be one per schema class. Also, this annotation cannot be used with the Element annotation. Only the Attribute annotation can be used with it as this annotation does not add any content within the owning element.&lt;/p&gt;

&lt;h3 id=&#34;a-name-11-sect-dealing-with-map-objects&#34;&gt;&lt;a name=&#34;11&#34; /&gt;&amp;sect;Dealing with map objects&lt;/h3&gt;

&lt;p&gt;Although it is possible to deal with most repetitive XML elements within documents using element lists it is often more convenient to use a Map object. In order to deal with maps the ElementMap annotation can be used. The element map annotation can be used with both primitive and composite objects. For example take the following XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
   &amp;lt;property key=&amp;quot;one&amp;quot;&amp;gt;first value&amp;lt;/property&amp;gt;
   &amp;lt;property key=&amp;quot;two&amp;quot;&amp;gt;second value&amp;lt;/property&amp;gt;
   &amp;lt;property key=&amp;quot;three&amp;quot;&amp;gt;third value&amp;lt;/property&amp;gt;
   &amp;lt;name&amp;gt;example name&amp;lt;/name&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above XML document the sequence of properties elements can be used to describe a map of strings, where the key attribute acts as the key for the value within the property element. The following code snipped demonstrates how to use the ElementMap annotation to process the above XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root(name=&amp;quot;properties&amp;quot;)
public class PropertyMap {

   @ElementMap(entry=&amp;quot;property&amp;quot;, key=&amp;quot;key&amp;quot;, attribute=true, inline=true)
   private Map&amp;lt;String, String&amp;gt; map;

   @Element
   private String name;  

   public String getName() {
      return name;
   }

   public Map&amp;lt;String, Entry&amp;gt; getMap() {
      return map;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-12-sect-scattering-inline-element-entries&#34;&gt;&lt;a name=&#34;12&#34; /&gt;&amp;sect;Scattering inline element entries&lt;/h3&gt;

&lt;p&gt;Elements that are scattered throughout an XML document can be collected by inline lists and inline maps. Simply provide an entry name for the XML element name the list or map is to collect and they will be extracted and placed in to the collection object. For example take the following XML element. It contains include and exclude XML elements which are in no specific order. Even though they are not in any order the deserialization process is able to gather the XML elements as thet are encountered.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;fileSet path=&amp;quot;/user/niall&amp;quot;&amp;gt;
   &amp;lt;include pattern=&amp;quot;.*.jar&amp;quot;/&amp;gt;
   &amp;lt;exclude pattern=&amp;quot;.*.bak&amp;quot;/&amp;gt;
   &amp;lt;exclude pattern=&amp;quot;~.*&amp;quot;/&amp;gt;
   &amp;lt;include pattern=&amp;quot;.*.class&amp;quot;/&amp;gt;
   &amp;lt;exclude pattern=&amp;quot;images/.*&amp;quot;/&amp;gt;
&amp;lt;/fileSet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to achieve this the following object can be used. This declares two inline collections which specify the name of the entry objects that they are collecting. If the entry attribute is not specified then the name of the object will be used instead.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class FileSet {

   @ElementList(entry=&amp;quot;include&amp;quot;, inline=true)
   private List&amp;lt;Match&amp;gt; include;

   @ElementList(entry=&amp;quot;exclude&amp;quot;, inline=true)
   private List&amp;lt;Match&amp;gt; exclude;

   @Attribute
   private File path;

   private List&amp;lt;File&amp;gt; files;

   public FileSet() {
      this.files = new ArrayList&amp;lt;File&amp;gt;();
   }

   @Commit
   public void commit() {
      scan(path);
   }

   private void scan(File path) {
      File[] list = path.listFiles();

      for(File file : list) {
         if(file.isDirectory()) {
            scan(path);
         } else {            
            if(matches(file)) {
               files.add(file);
            }
         }
      }
   }

   private boolean matches(File file) {
      for(Match match : exclude) {
         if(match.matches(file)) {
            return false;
         }
      }
      for(Match match : include) {
         if(match.matches(file)) {
            return true;
         }
      }
      return false;
   }

   public List&amp;lt;File&amp;gt; getFiles() {
      return files;
   }

   @Root
   private static class Match {

      @Attribute            
      private String pattern;            

      public boolean matches(File file) {
         Stirng path = file.getPath();

         if(!file.isFile()) {
            return false;
         }
         return path.matches(pattern);         
      }         
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-13-sect-loose-object-mapping&#34;&gt;&lt;a name=&#34;13&#34; /&gt;&amp;sect;Loose object mapping&lt;/h3&gt;

&lt;p&gt;An important feature for any XML tool is the ability to sift through the source XML to find particular XML attributes an elements of interest. It would not be very convinient if you had to write an object that accurately mapped every attribute an element in an XML document if all you are interested in is perhaps an element and several attributes. Take the following XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;contact id=&amp;quot;71&amp;quot; version=&amp;quot;1.0&amp;quot;&amp;gt;
   &amp;lt;name&amp;gt;
      &amp;lt;first&amp;gt;Niall&amp;lt;/first&amp;gt;
      &amp;lt;surname&amp;gt;Gallagher&amp;lt;/surname&amp;gt;
   &amp;lt;/name&amp;gt;
   &amp;lt;address&amp;gt;
      &amp;lt;house&amp;gt;House 33&amp;lt;/house&amp;gt;
      &amp;lt;street&amp;gt;Sesame Street&amp;lt;/street&amp;gt;
      &amp;lt;city&amp;gt;City&amp;lt;/city&amp;gt;
   &amp;lt;/address&amp;gt;
   &amp;lt;phone&amp;gt;
      &amp;lt;mobile&amp;gt;123456789&amp;lt;/mobile&amp;gt;
      &amp;lt;home&amp;gt;987654321&amp;lt;/home&amp;gt;
   &amp;lt;/phone&amp;gt;
&amp;lt;/contact&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If my object only required the some of the details of the specified contact, for example the phone contacts and the name then it needs to be able to ignore the address details safely. The following code shows how this can be done by setting strict to false within the Root annotation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root(strict=false)
public class Contact {

   @Element
   private Name name;

   @Element
   private Phone phone;

   public String getName() {
      return name.first;
   }

   public String getSurname() {
      return name.surname;
   }

   public String getMobilePhone() {
      return phone.mobile;
   }

   public String getHomePhone() {
      return phone.home;
   }

   @Root
   private static class Name {

      @Element
      private String first;

      @Element
      private String surname;
   }

   @Root
   private static class Phone {

      @Element(required=false)
      private String mobile;

      @Element
      private String home;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above object can be used to parse the contact XML source. This simple ignores any XML elements or attributes that do not appear in the class schema. To further clarify the implementation of loose mappings take the example shown below. This shows how the entry object is deserialized from the above document, which is contained within a file. Once deserialized the object values can be examined.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Serializer serializer = new Persister();
File source = new File(&amp;quot;contact.xml&amp;quot;);
Contact contact = serializer.read(Contact.class, source);

assert contact.getName().equals(&amp;quot;Niall&amp;quot;);
assert contact.getSurname().equals(&amp;quot;Gallagher&amp;quot;);
assert contact.getMobilePhone().equals(&amp;quot;123456789&amp;quot;);
assert contact.getHomePhone().equals(&amp;quot;987654321&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Should there be more than a single object that requires loose mapping then using the Root annotation might not be the ideal solution. In such a scenario the persister itself can be asked to perform loose mapping. Simply pass a boolean to the read method indicating the type of mapping required. By default the persister uses strict mapping, which can be overridden on an object by object basis using the Root annotation, as shown in the above example. However, this default can be overridden as can be seen in the code snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Contact contact = serializer.read(Contact.class, source, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the boolean passed to the overridden read method tells the serializer to perform a loose mapping. There is no need to specify anything in the annotations, the serializer will simply map every object loosely. This can be a much more convenient way to perform loose mapping, as you only need to annotate your objects with the elements or attributes you are interested in, all other elements and attributes will be ignored during deserialization. Such a solution is best suited to external XML documents where your annotated objects do not define the schema.&lt;/p&gt;

&lt;h3 id=&#34;a-name-14-sect-java-bean-serialization&#34;&gt;&lt;a name=&#34;14&#34; /&gt;&amp;sect;Java Bean serialization&lt;/h3&gt;

&lt;p&gt;Although field based serialization offers a simple and efficient means for serializing and deserializing an object it can often be benificial to use Java Bean getters and setters to read and write values. In particular annotating Java Bean setter and getter methods will allow for a cleaner means to override the serialization behaviour than using fields. It also allows for processing and validation to be performed as the object is being deserialized. Below is an example of how to annotate an objects methods for use in the serialization process, this example mixes annotated fields with annotated methods.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Message {

   private Collection&amp;lt;Entry&amp;gt; list;

   @Attribute
   private float version;        

   @ElementList
   public void setList(Collection&amp;lt;Entry&amp;gt; entry) {
      if(entry.isEmpty()) {
         throw new IllegalArgumentException(&amp;quot;Empty collection&amp;quot;);              
      }
      this.entry = entry;           
   }        

   @ElementList
   public Collection&amp;lt;Entry&amp;gt; getList() {
      return entry;           
   }
}

@Root
public class Entry {

   @Attribute
   public String name;    

   public String text;   

   @Text
   public String getText() {
      return text;           
   }

   @Text
   public void setText(String text){
      this.text = text;           
   }

   public String getName() {
      return name;           
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above code the message class will have its methods invoked when a list of entry objects is encountered. Here the method can perform some form of validation when the list of entry objects is deserialized. Such validation can also be peformed using the persister callback methods, which is described in a later section. The requirements for Java Bean method serialization are that both the setter and getter must be annotated with the same annotation, and both annotations must contain identical attributes. The object class schema could produce the following XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;message version=&amp;quot;1.2&amp;quot;&amp;gt;
   &amp;lt;list&amp;gt;
      &amp;lt;entry name=&amp;quot;a&amp;quot;&amp;gt;Example text one&amp;lt;/entry&amp;gt;
      &amp;lt;entry name=&amp;quot;b&amp;quot;&amp;gt;Example text two&amp;lt;/entry&amp;gt;
   &amp;lt;/list&amp;gt;
&amp;lt;/message&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-15-sect-default-object-serialization&#34;&gt;&lt;a name=&#34;15&#34; /&gt;&amp;sect;Default object serialization&lt;/h3&gt;

&lt;p&gt;If an object grows large it often becomes tedious to annotate each field or method that needs to be serialized. In such scenarios the Default annotation can be used. This will apply default annotations to either the fields or methods of an object that is to be serialized. To specify whether it is the fields or methods that will have default annotations, the DefaultType enumeration can be used. Take the code snippet below, this shows two objects with default annotations, one that will apply defaults to the object fields, and one that will apply defaults to the Java Bean methods of the object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Default(DefaultType.FIELD)
public class OrderItem {

   private Customer customer;

   private String name;

   @Attribute
   private double price;

   @Transient
   private String category;

   public String getName() {
      return name;
   }   

   public Customer getCustomer() {
      return customer;
   }
}

@Root
@Default(DefaultType.PROPERTY)
private class Customer {

   private String name;

   private String address;

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above object the Transient annotation is used to specify that even though default annotations should be applied to the objects fields, the field annotated as transient should not be serialized. Below is the XML that could be produced using the above classes, notice that if defaults apply to Java Bean methods, the fields will not be defaulted, instead they will be ignored.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;orderItem price=&amp;quot;10.99&amp;quot;&amp;gt;
    &amp;lt;customer&amp;gt;
        &amp;lt;name&amp;gt;Elvis Presley&amp;lt;/name&amp;gt;
    &amp;lt;/customer&amp;gt;
    &amp;lt;name&amp;gt;IRT452&amp;lt;/name&amp;gt;
&amp;lt;/orderItem&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above XML it is obvious, that defaults apply to only those fields or methods requested. If a field or method already has an annotation, that is the annotation that is used. If a field or method is to be omitted from serialization then it can be marked as transient. Applying defaults to an object, can often lead to a cleaner object structure, and makes it much easier to make objects serializable.&lt;/p&gt;

&lt;h3 id=&#34;a-name-16-sect-example-using-template-filters&#34;&gt;&lt;a name=&#34;16&#34; /&gt;&amp;sect;Example using template filters&lt;/h3&gt;

&lt;p&gt;Another very powerful feature with this XML serialization framework is the ability to use templating when deserializing an XML document. This allows values within elements and attributes to use template variables that can be replaced using a Filter object. The simplest filter object is the map filter, which allows the user to place a Java map within the filter object exposing the key value pairs to the templating system. The template system can now use the filter to find replacement values for template variables within the XML document. To clarify take the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Layout {

   @Element
   private String path;

   @Element
   private String user;

   @Attribute
   private int id;

   public String getPath() {
      return path;
   }

   public String getUser() {
      return user;
   }

   public int getId() {
      return id;
   }
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above object has declared two elements and an attribute to be deserialized from an XML document. These values are typically static values within the XML source. However using a template variable syntax the deserialization process will attempt to substitute the keys with values from the filter. Take the XML document below with two template variables declared ${home.path} and ${user.name}.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;layout id=&amp;quot;123&amp;quot;&amp;gt;
   &amp;lt;path&amp;gt;${home.path}&amp;lt;/path&amp;gt;
   &amp;lt;user&amp;gt;${user.name}&amp;lt;/user&amp;gt;
&amp;lt;/layout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To ensure that these values can be replaced with user specified mappings a map filter can be used. Below is an example of how to create a persister that can be given user specified key value pairs. Here the above XML source is deserialized from a file and the annotated fields are given filter mappings if there is a mapping specified.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Map map = new HashMap();

map.put(&amp;quot;home.path&amp;quot;, &amp;quot;/home/john.doe&amp;quot;);
map.put(&amp;quot;user.name&amp;quot;, &amp;quot;john.doe&amp;quot;);

Filter filter = new MapFilter(map);
Serializer serializer = new Persister(filter);
File source = new File(&amp;quot;layout.xml&amp;quot;);
Layout layout = serializer.read(Layout.class, source);

assert layout.getPath().equals(&amp;quot;/home/john.doe&amp;quot;);
assert layout.getUser().equals(&amp;quot;john.doe&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As well as the map filter there are several stock filters which can be used to substitute template variables with OS environment variables and JVM system properties. Also several template variables can exist within the values. For example take the following XML document, which could be used in the above example given that the mappings for ${first.name} and ${second.name} were added to the map filter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;layout id=&amp;quot;123&amp;quot;&amp;gt;
   &amp;lt;path&amp;gt;/home/${first.name}.${second.name}&amp;lt;/path&amp;gt;
   &amp;lt;user&amp;gt;${first.name}.${second.name}&amp;lt;/user&amp;gt;
&amp;lt;/layout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-17-sect-receiving-persister-callbacks&#34;&gt;&lt;a name=&#34;17&#34; /&gt;&amp;sect;Receiving persister callbacks&lt;/h3&gt;

&lt;p&gt;Of critical importance to the serialization and deserialization process is that the objects have some control or participation in the process. It is no good to have the persister deserialize the object tree from an XML document only to see that the data is not valid or that further data structures need to be created in many of the deserialized objects. To allow objects to participate in the deserialization process two annotations can be used, these are the Validate and Commit annotations.&lt;/p&gt;

&lt;p&gt;Both are involved in the deserialization process (not the serialization process) and are called immediately after an object has been deserialized. Validation is performed first, and if the deserialized object contains a method annotated with the validate annotation it is invoked. This allows the object to perform validation of its fields, if the object requirements are met the method returns quietly, if they are not met the object can throw an exception to terminate the deserialization process. The commit method is invoked in much the same way, the persister looks for a method marked with the commit annotation, if one exists it is invoked. However, unlike the validate method the commit method is typically used to build further data structures, for example hash tables or trees. Below is an example of an object making use of these annotations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class PropertyMap {

   private Map&amp;lt;String, Property&amp;gt; map;

   @ElementList
   private List&amp;lt;Property&amp;gt; list;

   public PropertyMap() {
      this.map = new HashMap&amp;lt;String, Entry&amp;gt;();
   }

   @Validate
   public void validate() {
      List&amp;lt;String&amp;gt; keys = new ArrayList&amp;lt;String&amp;gt;();

      for(Property entry : list) {
         String key = entry.getKey();

         if(keys.contains(key)) {
            throw new PersistenceException(&amp;quot;Duplicate key %s&amp;quot;, key);
         }
         keys.put(key);         
      }      
   }

   @Commit
   public void build() {
      for(Property entry : list) {
         insert(entry);
      }     
   }

   public void insert(Property entry) {
      map.put(entry.getName(), entry);      
   }  

   public String getProperty(String name) {
      return map.get(name).getValue();
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above object deserializes a list of property objects into a list. Once the property objects have been deserialized they are validated by checking that an entry with a specific key exists only once. After the validation process has completed the commit method is invoked by the persister, here the object uses the deserialized property object to build a hash table containing the property values keyed via the property key. Below is how the above object would be represented as an XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
   &amp;lt;list&amp;gt;
      &amp;lt;entry key=&amp;quot;one&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
      &amp;lt;entry key=&amp;quot;two&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
      &amp;lt;entry key=&amp;quot;three&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
   &amp;lt;/list&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As well as annotations involved in the deserialization process there are annotations that can be used to receive persister callbacks for the serialization process. Two annotations can be used, they are the Persist and Complete methods. To receive persister callbacks the methods must be no argument methods marked with the appropriate annotations.
The persist method is invoked before the serialization of the object. This allows the object to prepare in some implementation specific way for the serialization process. This method may throw an exception to terminate the serialization process. Once serialization has completed the complete method is invoked. This allows the object to revert to its previous state, that is, to undo what the persist method has done. Below is an example of how these annotations can be used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class MailMessage {

   @Attribute
   private Stirng format;

   @Element
   private String encoded;

   private byte[] content;

   private Encoder encoder;

   public MailMessage() {
      this.encoder = new Encoder();
   }

   public void setEncoding(String format) {
      this.format = format;
   }

   public String getEncoding() {
      return format;
   }

   public void setMessage(byte[] content) {
      this.content = content;
   }

   public byte[] getMessage() {
      return content;
   }

   @Commit
   public void commit() {
      decoded = encoder.decode(encoded, format);
      encoded = null;
   }

   @Persist
   public void prepare() {
      encoded = encoder.encode(decoded, format);      
   }

   @Complete
   public void release() {
      encoded = null;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example illustrates how the persist and complete methods can be used in a scenario where the serialization process needs to encode a byte array into a specific encoding format. Before the object is persisted the persistable field is set to an encoded string. When serialization has completed the encoded value is nulled to free the memory it holds. This example is somewhat contrived however it effectively demonstrates how the annotations can be used. Below is an example of what the XML document should look like.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;mailMessage format=&amp;quot;base64&amp;quot;&amp;gt;
    U2ltcGxlIGlzIGFuIFhNTCBzZXJpYWxpemF0aW9uIGZyYW1ld29yayBmb3IgSmF2YS4gSXRzIGdv
    YWwgaXMgdG8gcHJvdmlkZSBhbiBYTUwgZnJhbWV3b3JrIHRoYXQgZW5hYmxlcyByYXBpZCBkZXZl
    bG9wbWVudCBvZiBYTUwgY29uZmlndXJhdGlvbiBhbmQgY29tbXVuaWNhdGlvbiBzeXN0ZW1zLiBU
    aGlzIGZyYW1ld29yayBhaWRzIHRoZSBkZXZlbG9wbWVudCBvZiBYTUwgc3lzdGVtcyB3aXRoIG1p
    bmltYWwgZWZmb3J0IGFuZCByZWR1Y2VkIGVycm9ycy4gVGhlIGZyYW1ld29yayBib3Jyb3dzIGlk
    ZWFzIGFuZCBjb25jZXB0cyBmcm9tIGV4aXN0aW5nIFhNTCB0b29scyBzdWNoIGFzIEMjIFhNTCBz
    ZXJpYWxpemF0aW9uIGFuZCBvdGhlciBwcm9wcmlldGFyeSBmcmFtZXdvcmtzIGFuZCBjb21iaW5l
    cyB0aG9zZSBpZGVhcyByZXN1bHRpbmcgaW4gYSBzaW1wbGUgeWV0IGV4dHJlbWVseSBwb3dlcmZ1
    bCB0b29sIGZvciB1c2luZyBhbmQgbWFuaXB1bGF0aW5nIFhNTC4gQmVsb3cgaXMgYSBsaXN0IG9m
    IHNvbWUgb2YgdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgZnJhbWV3b3JrLiA=    
&amp;lt;/mailMessage&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above XML message the contents can be serialized and deserialized safely using persister callbacks. The object can prepare itself before serialization by encoding the contents of the message to the encoding format specified. Once it has been encoded and serialized any resources created for serialization can be released.&lt;/p&gt;

&lt;h3 id=&#34;a-name-18-sect-maintaining-state-between-persister-callbacks&#34;&gt;&lt;a name=&#34;18&#34; /&gt;&amp;sect;Maintaining state between persister callbacks&lt;/h3&gt;

&lt;p&gt;When serializing and deserializing objects there is often a need to share information between callbacks without affecting the object implementation. In order to achieve this the persister can provide a session map to the methods annotated for persister callbacks. Below is an example of a serializable object that can receive a persister session object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Person {

   @ElementList
   private List&amp;lt;Variable&amp;gt; details;

   @Element
   private Address address;

   private List names;

   @Validate
   public void validate(Map session) throws PersistenceException {
      if(session.isEmpty()) {
         throw new PersistenceException(&amp;quot;Map must not be empty&amp;quot;)
      }
   }

   @Commit
   public void commit(Map session) {
      Set keys = session.keySet();

      for(Object item : keys) {
         names.add(item);
      }
   }
}

@Address
public class Address {

   @Element
   private String street;

   @Element
   private String city;

   @Element
   private String state;

   public String getStreet() {
      return street;
   }

   public String getCity() {
      return city;
   }

   public String getState() {
      return state;
   }
}

@Root
public class Variable {

   @Attribute
   private String name;

   @Attribute
   private String value;

   @Commit
   public void commit(Map session) {
      session.put(name, value);
   }

   public String getName() {
      return name;
   }

   public String getValue() {
      return value;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example shows how entry objects can pass there names to its parent during the deserialization process. To clarify, deserialization is performed in a depth first manner so for this example the entry objects will be initialized and have their callback methods invoked before the root example class.
Although this may not seem like a very powerful feature, it offers great capabilities when paired with the templating system described earlier. The templating engine has access to all details placed into the session map object. So other values within the XML document can reference each other. For example take the XML document below for the above objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;person&amp;gt;
   &amp;lt;details&amp;gt;
      &amp;lt;var name=&amp;quot;name&amp;quot; value=&amp;quot;John Doe&amp;quot;/&amp;gt;
      &amp;lt;var name=&amp;quot;street&amp;quot; value=&amp;quot;Sesame Street&amp;quot;/&amp;gt;
      &amp;lt;var name=&amp;quot;city&amp;quot; value=&amp;quot;Metropolis&amp;quot;/&amp;gt;
      &amp;lt;var name=&amp;quot;state&amp;quot; value=&amp;quot;Some State&amp;quot;/&amp;gt;
   &amp;lt;/details&amp;gt;
   &amp;lt;address&amp;gt;
      &amp;lt;street&amp;gt;${street}&amp;lt;/street&amp;gt;
      &amp;lt;city&amp;gt;${city}&amp;lt;/city&amp;gt;
      &amp;lt;state&amp;gt;${state}&amp;lt;/state&amp;gt;
   &amp;lt;/address&amp;gt;   
&amp;lt;/person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above XML document illustrates how the variable objects values are accessible to the elements declared in the address element. The street, city, and state needed to be defined only once to be shared throughout the document&lt;/p&gt;

&lt;h3 id=&#34;a-name-19-sect-serializing-with-cdata-blocks&#34;&gt;&lt;a name=&#34;19&#34; /&gt;&amp;sect;Serializing with CDATA blocks&lt;/h3&gt;

&lt;p&gt;At times it is nessecary to serialize large text and element data values. Such values may also contain formatting that you wish to preserve. In such situations it is often best to wrap the values within XML CDATA blocks. The CDATA block can contain XML characters and formatting information which will not be modified by other XML parsers. For example take the following XML source.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;query type=&amp;quot;scrape&amp;quot; name=&amp;quot;title&amp;quot;&amp;gt;
   &amp;lt;data&amp;gt;&amp;lt;![CDATA[

         &amp;lt;news&amp;gt;
         {
            for $text in .//B
            return $text
         }
         &amp;lt;/news&amp;gt;

    ]]&amp;gt;&amp;lt;/data&amp;gt;
&amp;lt;/query&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above XML there is an embedded XQuery expression which is encapsulated within a CDATA block. Such a configuration allows the XQuery expression to exist within the XML document without any need to escape the XML characters. Also, if the XQuery expression was very large then this form of encoding would provide better performance. In order to ensure that the data is maintained within the CDATA block the following could be used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Query {

   @Attribute
   private String scrape;

   @Attribute
   private String title;

   @Element(data=true)
   private String data;  

   public String getData() {
      return data;
   }

   public String getTitle() {
      return title;
   }

   public String getScrape() {
      return scrape;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the Element annotation has the data attribute set to true. This tells the serialization process that any value stored within the data field must be written to the resulting XML document within a CDATA block. The data attribute can be used with the Text, ElementArray, and ElementList annotations also.&lt;/p&gt;

&lt;h3 id=&#34;a-name-20-sect-using-xml-namespaces&#34;&gt;&lt;a name=&#34;20&#34; /&gt;&amp;sect;Using XML namespaces&lt;/h3&gt;

&lt;p&gt;Namespaces are used to qualify an element or an attribute in an XML document. In order to use namespaces the Namespace annotation can be used. This allows the declaration of the namespace prefix and reference, often called the namespace URI. Namespace annotations can be used on fields, methods, and even classes. For example take the XML snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;parent xmlns=&amp;quot;http://domain/parent&amp;quot;&amp;gt;
   &amp;lt;pre:child xmlns:pre=&amp;quot;http://domain/child&amp;quot;&amp;gt;
      &amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;
      &amp;lt;address xmlns=&amp;quot;&amp;quot;&amp;gt;
          &amp;lt;street&amp;gt;Sin City&amp;lt;/street&amp;gt;
      &amp;lt;/address&amp;gt;
   &amp;lt;/pre:child&amp;gt;
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above XML document, the root element is qualified with a default namespace. A default namespace is a namespace that is inherited by all child elements, for further details see Section 6.2 of the namespaces in XML 1.0 specification. In order to annotate a field, method, or class with a default namespace the Namespace annotation can be declared using only the reference attribute. For example, see the annotated class below that produces the above XML.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Namespace(reference=&amp;quot;http://domain/parent&amp;quot;)
public class Parent {

   @Element
   @Namespace(reference=&amp;quot;http://domain/child&amp;quot;, prefix=&amp;quot;pre&amp;quot;)
   private Child child;

   public Child getChild() {
      return child;
   }
}

@Root
public class Child {

   @Element
   private String name;

   @Element
   @Namespace
   private Address address;

   public Address getAddress() {
      return address;
   }
}

@Root
public class Address {

   @Element
   private String street;

   public String getStreet() {
      return street;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code snippet also shows an annotation with both the namespace reference and prefix attributes declared. Such an annotation declaration will result in a namespace qualified with a prefix. As can be seen in the XML example a prefixed namespace qualifies the XML element with a string prefix followed by a colon.&lt;/p&gt;

&lt;p&gt;Should your document require more than one namespace declared in a single element the NamespaceList annotation can be used. This allows multiple namespaces to be declared in a single element. Declaring multiple namespaces in a single element can produce a cleaner more readable XML document. Take the XML snippet below from the namespaces in XML 1.0 specification, which shows an element with multiple namespaces.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;book xmlns=&amp;quot;urn:loc.gov:books&amp;quot; xmlns:isbn=&amp;quot;urn:ISBN:0-395-36341-6&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Cheaper by the Dozen&amp;lt;/title&amp;gt;
    &amp;lt;isbn:number&amp;gt;1568491379&amp;lt;/isbn:number&amp;gt;
&amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This XML snippet shows two namespaces declared in the root element. Here the root element will be qualified with the default namespace, and child elements can if desired be qualified by the prefixed namespace. To illustrate how such namespace declarations can be done, see the annotated class below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@NamespaceList({
@Namespace(reference=&amp;quot;urn:loc.gov:books&amp;quot;)
@Namespace(reference=&amp;quot;urn:ISBN:0-395-36341-6&amp;quot;, prefix=&amp;quot;isbn&amp;quot;)
})
public class Book {

   @Element
   @Namespace(reference=&amp;quot;urn:ISBN:0-395-36341-6&amp;quot;)
   private String number;

   @Element
   private String title;

   public String getTitle() {
      return title;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen above, there is no need to redeclare the prefix attribute once it has already been declared. This allows the annotation declarations to be less verbose and ensures a consistent use of a prefix for a given namespace reference. Also, once a namespace has been declared and is in scope then it will not be declared a second time in the resulting XML, this ensures the resulting XML document does not contain redundant namespace declarations.&lt;/p&gt;

&lt;h3 id=&#34;a-name-21-sect-resolving-object-reference-cycles&#34;&gt;&lt;a name=&#34;21&#34; /&gt;&amp;sect;Resolving object reference cycles&lt;/h3&gt;

&lt;p&gt;When there are cycles in your object graph this can lead to recursive serialization. However it is possible to resolve these references using a stock strategy. The CycleStrategy maintains the object graph during serialization and deserialization such that cyclical references can be traced and resolved. For example take the following object relationships.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Parent {

   private Collection&amp;lt;Child&amp;gt; children;

   private String name;

   @Attribute
   public String getName() {
      return name;                   
   }

   @Attribute
   public void setName(String name) {
      this.name = name;           
   }

   @Element
   public void setChildren(Collection&amp;lt;Child&amp;gt; children) {
      this.children = children;           
   }

   @Element   
   public Collection&amp;lt;Child&amp;gt; getChildren() {
      return children;           
   }        

   public void addChild(Child child) {
      children.add(child);           
   }
}

@Root
public class Child {

   private Parent parent;

   private String name;

   public Child() {
      super();           
   }

   public Child(Parent parent) {
      this.parent = parent;           
   }

   @Attribute
   public String getName() {
      return name;           
   }

   @Attribute
   public void setName(String name) {
      this.name = name;           
   }

   @Element
   public Parent getParent() {
      return parent;
   }

   @Element
   public void setParent(Parent parent) {
      this.parent = parent;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above code snippet the cyclic relation ship between the parent and child can be seen. A parent can have multiple children and a child can have a reference to its parent. This can cause problems for some XML binding and serialization frameworks. However this form of object relationship can be handled seamlessly using the CycleStrategy object. Below is an example of what a resulting XML document might look like.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;parent name=&amp;quot;john&amp;quot; id=&amp;quot;1&amp;quot;&amp;gt;
   &amp;lt;children&amp;gt;
      &amp;lt;child id=&amp;quot;2&amp;quot; name=&amp;quot;tom&amp;quot;&amp;gt;
         &amp;lt;parent ref=&amp;quot;1&amp;quot;/&amp;gt;
      &amp;lt;/child&amp;gt;
      &amp;lt;child id=&amp;quot;3&amp;quot; name=&amp;quot;dick&amp;quot;&amp;gt;
         &amp;lt;parent ref=&amp;quot;1&amp;quot;/&amp;gt;
      &amp;lt;/child&amp;gt;
      &amp;lt;child id=&amp;quot;4&amp;quot; name=&amp;quot;harry&amp;quot;&amp;gt;
         &amp;lt;parent ref=&amp;quot;1&amp;quot;/&amp;gt;
      &amp;lt;/child&amp;gt;
   &amp;lt;/children&amp;gt;
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen there are two extra attributes present, the id attribute and the ref attribute. These references are inserted into the serialized XML document when the object is persisted. They allow object relationships and references to be recreated during deserialization. To further clarify take the following code snippet which shows how to create a persister that can handle such references.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Strategy strategy = new CycleStrategy(&amp;quot;id&amp;quot;, &amp;quot;ref&amp;quot;);
Serializer serializer = new Persister(strategy);
File source = new File(&amp;quot;example.xml&amp;quot;);
Parent parent = serializer.read(Parent.class, source);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The strategy is created by specifying the identity attribute as id and the refering attribute as ref. For convinience these attributes have reasonable defaults and the no argument constructor can be used to create the strategy. Although the example shown here is very simple the cycle strategy is capable of serializing and deserializing large and complex relationships.&lt;/p&gt;

&lt;h3 id=&#34;a-name-22-sect-reusing-xml-elements&#34;&gt;&lt;a name=&#34;22&#34; /&gt;&amp;sect;Reusing XML elements&lt;/h3&gt;

&lt;p&gt;As can be seen from using the CycleStrategy in the previous section object references can easily be maintained regardless of complexity. Another benifit of using the cycle strategy is that you can conviniently reuse elements when creating configuration. For example take the following example of a task framework.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Workspace {

   @Attribute
   private File path;

   @Attribute
   private String name

   private File getPath() {
      return path;           
   }

   private String getName() {
      return name;           
   }
}

@Root
public abstract Task {

   @Element        
   private Workspace workspace;         

   public abstract void execute() throws Exception;
}

public class DeleteTask extends Task {

   @ElementList(inline=true, entry=&amp;quot;resource&amp;quot;)        
   private Collection&amp;lt;String&amp;gt; list;        

   public void execute() {
      File root = getPath();

      for(String path : list) {
         new File(root, path).delete();              
      }
   }  
}

public class MoveTask extends Task {

   @ElementList(inline=true, entry=&amp;quot;resource&amp;quot;)
   private Collection&amp;lt;String&amp;gt; list;

   @Attribute
   private File from;

   public void execute() {
      File root = getPath();

      for(String path : list) {
         File create = new File(root, path);
         File copy = new File(from, path);

         copy.renameTo(create);
      }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code snippet shows a very simple task framework that is used to perform actions on a workspace. Each task must contain details for the workspace it will perform its specific task on. So, making use of the cycle strategy it is possible to declare a specific object once, using a know identifier and referencing that object throughout a single XML document. This eases the configuration burden and ensures that less errors can creap in to large complex documents where may objects are declared.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;job&amp;gt;
   &amp;lt;workspace id=&amp;quot;default&amp;quot;&amp;gt;
      &amp;lt;path&amp;gt;c:\workspace\task&amp;lt;/path&amp;gt;
   &amp;lt;/workspace&amp;gt;
   &amp;lt;task class=&amp;quot;example.DeleteTask&amp;quot;&amp;gt;
      &amp;lt;workspace ref=&amp;quot;default&amp;quot;/&amp;gt;
      &amp;lt;resource&amp;gt;output.dat&amp;lt;/resource&amp;gt;
      &amp;lt;resource&amp;gt;result.log&amp;lt;/resource&amp;gt;
   &amp;lt;/task&amp;gt;
   &amp;lt;task class=&amp;quot;example.MoveTask&amp;quot;&amp;gt;
      &amp;lt;workspace ref=&amp;quot;default&amp;quot;/&amp;gt;
      &amp;lt;from&amp;gt;c:\workspace\data&amp;lt;/from&amp;gt;
      &amp;lt;resource&amp;gt;input.xml&amp;lt;/resource&amp;gt;
   &amp;lt;/task&amp;gt;
&amp;lt;/job&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-23-sect-using-utility-collections&#34;&gt;&lt;a name=&#34;23&#34; /&gt;&amp;sect;Using utility collections&lt;/h3&gt;

&lt;p&gt;For convinience there are several convinience collections which can be used. These collections only need to be annotated with the ElementList annotation to be used. The first stock collection resembles a map in that it will accept values that have a known key or name object, it is the Dictionary collection. This collection requires objects of type Entry to be inserted on deserialization as this object contains a known key value. To illustrate how to use this collection take the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class TextMap {

   @ElementList(inline=true)
   private Dictionary&amp;lt;Text&amp;gt; list;   

   public Text get(String name) {
      return list.get(name);           
   }
}

@Root
public class Text extends Entry {

   @Text          
   public String text;

   public String getText() {
      return text;           
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above objects show how the dictionary collection is annotated with the element list annotation. The containing object can not serialize and deserialize entry objects which can be retrieve by name. For example take the following XML which shows the serialized representation of the text map object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;textMap&amp;gt;
   &amp;lt;text name=&amp;quot;name&amp;quot;&amp;gt;Niall Gallagher&amp;lt;/text&amp;gt;
   &amp;lt;text name=&amp;quot;street&amp;quot;&amp;gt;Seasme Street&amp;lt;/text&amp;gt;
   &amp;lt;text name=&amp;quot;city&amp;quot;&amp;gt;Atlantis&amp;lt;/text&amp;gt;
&amp;lt;/textMap&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each text entry deserialized in to the dictionary can now be acquired by name. Although this offers a convinient map like structure of acquring objects based on a name there is often a need to match objects. For such a requirement the Resolver collection can be used. This offers a fast pattern matching collection that matches names or keys to patterns. Patterns are deserialized within Match objects, which are inserted in to the resolver on deserialization. An example of the resolver is shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
private static class ContentType extends Match {

   @Attribute
   private String value;        

   public ContentType() {
      super();                  
   }

   public ContentType(String pattern, String value) {
      this.pattern = pattern;
      this.value = value;        
   }
}

@Root
private static class ContentResolver implements Iterable {

   @ElementList
   private Resolver&amp;lt;ContentType&amp;gt; list;           

   @Attribute
   private String name;

   public Iterator&amp;lt;ContentType&amp;gt; iterator() {
      return list.iterator();
   }

   public ContentType resolve(String name) {
      return list.resolve(name);              
   }
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above content resolver will match a string with a content type. Such an arrangement could be used to resolve paths to content types. For example the following XML document illustrates how the resolver could be used to match URL paths to content types for a web application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;contentResolver name=&amp;quot;example&amp;quot;&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;*.html&amp;quot; value=&amp;quot;text/html&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;*.jpg&amp;quot; value=&amp;quot;image/jpeg&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;/images/*&amp;quot; value=&amp;quot;image/jpeg&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;/log/**&amp;quot; value=&amp;quot;text/plain&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;*.exe&amp;quot; value=&amp;quot;application/octetstream&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;**.txt&amp;quot; value=&amp;quot;text/plain&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;/html/*&amp;quot; value=&amp;quot;text/html&amp;quot;/&amp;gt;
&amp;lt;/contentResolver&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the resolver collection can only deal with wild card characters such as * and ? it is much faster than resolutions performed using Java regular expressions. Typically it is several orders of magnitude faster that regular expressions, particularly when it is used to match reoccuring values, such as URI paths.&lt;/p&gt;

&lt;h3 id=&#34;a-name-24-sect-object-substitution&#34;&gt;&lt;a name=&#34;24&#34; /&gt;&amp;sect;Object substitution&lt;/h3&gt;

&lt;p&gt;Often there is a need to substitute an object into the XML stream either during serialization or deserialization. For example it may be more convinient to use several XML documents to represent a configuration that can be deserialized in to a single object graph transparently. For example take the following XML.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;registry&amp;gt;
    &amp;lt;import name=&amp;quot;external.xml&amp;quot; class=&amp;quot;example.ExternalDefinition&amp;quot;/&amp;gt;
    &amp;lt;define name=&amp;quot;blah&amp;quot; class=&amp;quot;example.DefaultDefinition&amp;quot;&amp;gt;
       &amp;lt;property key=&amp;quot;a&amp;quot;&amp;gt;Some value&amp;lt;/property&amp;gt;
       &amp;lt;property key=&amp;quot;b&amp;quot;&amp;gt;Some other value&amp;lt;/property&amp;gt;
    &amp;lt;/define&amp;gt;
&amp;lt;/registry&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above XML document there is an import XML element, which references a file external.xml. Given that this external file contains further definitions it would be nice to be able to replace the import with the definition from the file. In such cases the Resolve annotation can be used. Below is an example of how to annotate your class to substitute the objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
private class Registry {

   @ElementList(inline=true)
   private Dictionary&amp;lt;Definition&amp;gt; import;

   @ElementList(inline=true)
   private Dictionary&amp;lt;Definition&amp;gt; define;

   public Definition getDefinition(String name) {
      Definition value = define.get(name);

      if(value == null) {
         value = import.get(name);
      }
      return value;
   }
}

public interface Definition {

   public String getProperty(String key);
}

@Root(name=&amp;quot;define&amp;quot;)
public class DefaultDefinition implements Definition {

   @ElementList(inline=true)
   private Dictionary&amp;lt;Property&amp;gt; list;

   public String getProperty(String key) {
      return list.get(key);
   }
}

@Root(name=&amp;quot;import&amp;quot;)
public class ExternalDefinition implements Definition {

   @Element
   private File name;

   public String getProperty(String key) {
      throw new IllegalStateException(&amp;quot;Method not supported&amp;quot;);
   }    

   @Resolve
   public Definition substitute() throws Exception {
      return new Persister().read(Definition.class, name);
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this form of substitution objects can be replaced in such a way that deserialized objects can be used as factories for other object instances. This is similar to the Java serialization concept of readResolve and writeReplace methods.&lt;/p&gt;

&lt;h3 id=&#34;a-name-25-sect-serializing-java-language-types&#34;&gt;&lt;a name=&#34;25&#34; /&gt;&amp;sect;Serializing Java language types&lt;/h3&gt;

&lt;p&gt;A common requirement of any serialization framework is to be able to serialize and deserialize existing types without modification. In particular types from the Java class libraries, like dates, locales, and files. For many of the Java class library types there is a corrosponding Transform implementation, which enables the serialization and deserialization of that type. For example the java.util.Date type has a transform that accepts a date instance and transforms that into a string, which can be embedded in to the generated XML document during serialization. For deserialization the same transform is used, however this time it converts the string value back in to a date instance. The code snippet below demonstrates how a such transformations make it possible to use such a type when implementing your class XML schema.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class DateList {

   @Attribute
   private Date created;

   @ElementList
   private List&amp;lt;Date&amp;gt; list;

   public Date getCreationDate() {
      retrun created;
   }

   public List&amp;lt;Date&amp;gt; getDates() {
      return list;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the date object is used like any other Java primitive, it can be used with any of the XML annotations. Such objects can also be used with the CycleStrategy so that references to a single instance within your object graph can be maintained throughout serialization and deserialization operations. Below is an example of the XML document generated.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dateList created=&amp;quot;2007-01-03 18:05:11.234 GMT&amp;quot;&amp;gt;
    &amp;lt;list&amp;gt;
        &amp;lt;date&amp;gt;2007-01-03 18:05:11.234 GMT&amp;lt;/date&amp;gt;
        &amp;lt;date&amp;gt;2007-01-03 18:05:11.234 GMT&amp;lt;/date&amp;gt;
    &amp;lt;/list&amp;gt;
&amp;lt;/dateList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using standard Java types, such as the Date type, can be used with any of the XML annotations. The set of supported types is shown below. Of particular note are the primitive array types, which when used with the ElementArray annotation enable support for multidimentional arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char
char[]
java.lang.Character
java.lang.Character[]
int
int[]
java.lang.Integer
java.lang.Integer[]
short
short[]
java.lang.Short
java.lang.Short[]
long        
long[]
java.lang.Long
java.lang.Long[]
double
double[]
java.lang.Double
java.lang.Double[]
byte
byte[]
java.lang.Byte
java.lang.Byte[]
float       
float[]        
java.lang.Float        
java.lang.Float[]        
boolean
boolean[]
java.lang.Boolean
java.lang.Boolean[]
java.lang.String
java.lang.String[]
java.util.Date
java.util.Locale
java.util.Currency
java.util.TimeZone
java.util.GregorianCalendar
java.net.URL
java.io.File
java.math.BigInteger
java.math.BigDecimal
java.sql.Date
java.sql.Time
java.sql.Timestamp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example take the following code snippet, here points on a graph are represented as a multidimentional array of integers. The array is annotated in such a way that it can be serialized and deserialized seamlessly. Each index of the array holds an array of type int, which is transformed using the Transformer in to a comma separated list of integer values. Obviously this is not of much use in a real world situation, however it does illustrate how the transformable types can be integrated seamlessly with existing XML annotations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Graph {

   @ElementArray(entry=&amp;quot;point&amp;quot;)
   private int[][] points;

   public Graph() {
      super();
   }

   @Validate
   private void validate() throws Exception {
      for(int[] array : points) {
         if(array.length != 2) {
            throw new InvalidPointException(&amp;quot;Point can not have %s values&amp;quot;, array.length);
         }
      }
   }

   public int[][] getPoints() {
      return points;      
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above code example the resulting XML generated would look like the XML document below. Here each index of the element array represents an array of integers within the comma separated list. Such structures also work well with the cycle strategy in maintaining references.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;graph&amp;gt;
   &amp;lt;points length=&amp;quot;4&amp;quot;&amp;gt;
      &amp;lt;point&amp;gt;3, 5&amp;lt;/point&amp;gt;
      &amp;lt;point&amp;gt;5, 6&amp;lt;/point&amp;gt;
      &amp;lt;point&amp;gt;5, 1&amp;lt;/point&amp;gt;
      &amp;lt;point&amp;gt;3, 2&amp;lt;/point&amp;gt;
   &amp;lt;/points&amp;gt;
&amp;lt;/graph&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-26-sect-styling-serialized-xml&#34;&gt;&lt;a name=&#34;26&#34; /&gt;&amp;sect;Styling serialized XML&lt;/h3&gt;

&lt;p&gt;In order to serialize objects in a consistent format a Style implementation can be used to format the elements and attributes written to the XML document. Styling of XML allows both serialization and deserialization to be performed. So once serialized in a styled XML format you can deserialize the same document back in to an object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class PersonProfile {

   @Attribute
   private String firstName;

   @Attribute
   private String lastName;

   @Element
   private PersonAddress personAddress;

   @Element
   private Date personDOB;

   public Date getDateOfBirth() {
      return personDOB;
   }

   public String getFirstName() {
      return firstName;
   }

   public String getLastName() {
      return lastName;
   }

   public PersonAddress getAddress() {
      return personAddress;
   }
}

@Root
public class PersonAddress {

   @Element
   private String houseNumber;

   @Element
   private String streetName;

   @Element
   private String city;

   public String getHouseNumber() {
      return houseNumber;
   }

   public String getStreetName() {
      return streetName;
   }

   public String getCity() {
      return city;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, taking the above annotated objects. An instance of the person profile can be serialized in to an XML document that is styled with a hyphenated format. This produces a consistently formated result which is just as deserializable as a serialization that is not styled.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;person-profile first-name=&amp;quot;Niall&amp;quot; last-name=&amp;quot;Gallagher&amp;quot;&amp;gt;
   &amp;lt;person-DOB&amp;gt;10/10/2008&amp;lt;/person-DOB&amp;gt;
   &amp;lt;person-address&amp;gt;
      &amp;lt;house-number&amp;gt;10&amp;lt;/house-number&amp;gt;
      &amp;lt;street-name&amp;gt;Sesame Street&amp;lt;/street-name&amp;gt;
      &amp;lt;city&amp;gt;Disney Land&amp;lt;/city&amp;gt;
   &amp;lt;/person-address&amp;gt;
&amp;lt;/person-profile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to serialize an object in a styled format either the HyphenStyle or CamelCaseStyle can be used. If neither suits one can always be implemented. Also, for convenience any of the elements or attributes can be overridden with a specific string by setting it to the style instance. The code snippet below shows how to serialize the object in the hyphenated style above.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Style style = new HyphenStyle();
Format format = new Format(style);
Serializer serializer = new Persister(format);

serializer.write(personDetail, file);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-27-sect-version-tolerant-serialization&#34;&gt;&lt;a name=&#34;27&#34; /&gt;&amp;sect;Version tolerant serialization&lt;/h3&gt;

&lt;p&gt;In order to serialize objects in a version tolerant format a Version annotation can be introduced to the class. This will allow a later, modified class to be read from XML generated by the original class. For example take the following code snippet showing an annotated class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Namespace(prefix=&amp;quot;p&amp;quot;, reference=&amp;quot;http://www.domain.com/person&amp;quot;)
public class Person {

  @Attribute
  private String name;

  @Element
  private String height;

  @Element
  private String weight;

  public String getName() {
     return name;
  }

  public String getHeight() {
     return height;
  }

  public String getWeight() {
     return weight;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above annotated class schema will generate XML in a format compatible with that class. For example, a serialization of the class could result in the following XML snippet. This shows the height and weight elements as well as the name attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p:person name=&amp;quot;John Doe&amp;quot; xmlns:p=&amp;quot;http://www.domain.com/person&amp;quot;&amp;gt;
    &amp;lt;height&amp;gt;185&amp;lt;/height&amp;gt;
    &amp;lt;weight&amp;gt;84&amp;lt;/height&amp;gt;
&amp;lt;/p:person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having used this class schema to serialize instances of the Person class, It could later be extended or modified as follows and still read and write in a format compatible with the old class schema like so, even though the resulting XML has changed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Namespace(prefix=&amp;quot;p&amp;quot;, reference=&amp;quot;http://www.domain.com/person&amp;quot;)
public class Person {

  @Version(revision=1.1)
  private double version;

  @Attribute
  private String name;

  @Attribute
  private int age;

  @Element
  private int height;

  public String getName() {
     return name;
  }

  public int getHeight() {
     return height;
  }

  public int getAge() {
     return age;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the version attribute is annotated with the special Version annotation. This will read the previously generated XML and compare the version attribute of the person element and compare it to the revision attribute of the annotation. If the version annotation does not exist the initial 2.0 version is assumed. So when using the new modified class, which is revision 1.1, with the old serialized XML the serializer will determine that the two have differing versions. So when deserializing it will ignore the excess weight element and ignore the fact that the age attribute does not exist. It will do this for all attributes and elements that do not match.&lt;/p&gt;

&lt;p&gt;This is quite similar to the C# XML serialization version capability. Where the initial version of each class is 1.0 (implicitly) and subsequent versions increase. This tells the serializer how it should approach deserialization of different versions. The later version of the class when serialized will explicitly write the version as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p:person version=&amp;quot;1.1&amp;quot; name=&amp;quot;John Doe&amp;quot; age=&amp;quot;60&amp;quot; xmlns:p=&amp;quot;http://www.domain.com/person&amp;quot;&amp;gt;
    &amp;lt;height&amp;gt;185&amp;lt;/height&amp;gt;
&amp;lt;/p:person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-28-sect-serializing-static-final-fields&#34;&gt;&lt;a name=&#34;28&#34; /&gt;&amp;sect;Serializing static final fields&lt;/h3&gt;

&lt;p&gt;Often there is a need to add elements and attributes to an XML document that do not change. In such an event it is often attractive to declare these fields as static final fields. When annotating static final fields they form part of the XML schema and contribute to the validation of the document but do not get set when deserializing the XML in to a object instance. So should a required static final field not exist in the source XML then an exception is thrown when deserializing, much like what would happen if the field was mutable. For example take the code snippet below, which shows an immutable static final field used with mutable fields.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Citation {

   @Element(name=&amp;quot;author&amp;quot;)
   private static final String AUTHOR = &amp;quot;Niall Gallagher&amp;quot;;

   @Element
   private String title;

   @Element   
   private String date;

   public Date getDate() {
      return date;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above annotated object describes a simple citation. The citation object itself contains a static final field that will be written to the resulting XML document when serialized. However, on deserialization the values read from the XML will not change the annotated final static field. Instead the deserialization process will simply validate the presence of the elements and attributes within the document. This results in an object that will always write the same value for the annotated final static elements or attributes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;citation&amp;gt;
   &amp;lt;author&amp;gt;Niall Gallagher&amp;lt;/author&amp;gt;
   &amp;lt;title&amp;gt;Simple XML Serialization&amp;lt;/author&amp;gt;
   &amp;lt;date&amp;gt;12 January 2010&amp;lt;/date&amp;gt;
&amp;lt;/citation&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-29-sect-overriding-serialization-with-converters&#34;&gt;&lt;a name=&#34;29&#34; /&gt;&amp;sect;Overriding serialization with converters&lt;/h3&gt;

&lt;p&gt;Often times there is a need to serialize an object that can not be annotated. Such objects may exist in third party dependencies or packages. To serialize these objects a Converter object can be implemented. A converter can be used to intercept the normal serialization process. Interception of the normal serialization process can be done in several different ways, for example take the code snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @Element
   @Convert(ExternalConverter.class)
   private External external;

   public External getExternal() {
      return external;
   }
}

public class ExternalConverter implements Converter&amp;lt;External&amp;gt; {

   public External read(InputNode node) {
      String name = node.getAttribute(&amp;quot;name&amp;quot;);
      String value = node.getAttribute(&amp;quot;value&amp;quot;);

      return new External(name, value);
   }

   public void write(OutputNode node, External external) {
      String name = external.getName();
      String value = external.getValue();

      node.setAttribute(&amp;quot;name&amp;quot;, name);
      node.setAttribute(&amp;quot;value&amp;quot;, value);
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code snippet also shows a field annotated with the Convert annotation. The converter specified by the annotation will be used to intercept the normal serialization process and produce a customized XML element. Take the XML below, this is produced when the example object is serialized.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
    &amp;lt;external name=&amp;quot;book&amp;quot; value=&amp;quot;Shantaram&amp;quot;/&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interception of the normal serialization process is performed using a Strategy implementation and so does not form part of the core serialization process. Instead a specific strategy needs to be provided to the persister as is shown in the code snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Strategy strategy = new AnnotationStrategy();
Serializer serializer = new Persister(strategy);

serializer.read(Example.class, file);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without the specification of the AnnotationStrategy the interception could not be performed, as the core serialization process will not acknowledge the Convert annotation. So in effect this strategy extends the core serialization process in an independent and transparent manner. Another even more transparent way to intercept the normal serialization process is to use another strategy implementation. The RegistryStrategy allows bindings to be registered between classes and converters, there is no need for additional annotations as was required for the previous example. Below is an example of how to establish bindings between a class and a converter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Registry registry = new Registry();
Strategy strategy = new RegistryStrategy(registry);
Serializer serializer = new Persister(strategy);

registry.bind(External.class, ExternalConverter.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As many bindings as is required can be established with a registry. Also, if more complex converters are required a converter instance can be registered. Such a converter could have a reference to the Persister object so that nested serialization can be performed. This registry strategy also ensures that objects within Java collection objects can be serialized with registered converters. To illustrate how a complex converter could be registered take a look at the snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Registry registry = new Registry();
Strategy strategy = new RegistryStrategy(registry);
Serializer serializer = new Persister(strategy);
ComplexConverter converter = new ComplexConverter(serializer);

registry.bind(ComplexObject.class, converter);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-30-sect-intercepting-the-serialization-process&#34;&gt;&lt;a name=&#34;30&#34; /&gt;&amp;sect;Intercepting the serialization process&lt;/h3&gt;

&lt;p&gt;Interception of the serialization process can be useful in several scenarios, for example if attributes are to be added or removed from an XML element then that element can be intercepted and modified during the serialization process. One useful application of interception is to change attribute names or values. For example, the &amp;ldquo;class&amp;rdquo; annotations added by the TreeStrategy could be intercepted and changed to a language neutral format that does not contain the Java class name. Below is an example of how to use a Visitor to add debug comments to an obect which is to be serialized.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Default
public class CommentExample {

    private String name;

    private BigDecimal number;

    private Date date;     
}

public class CommentVisitor implements Visitor {

   public void write(Type type, NodeMap&amp;lt;OutputNode&amp;gt; node) {
      OutputNode element = node.getNode();
      Class type = type.getType();
      String comment = type.getName();

      if(!element.isRoot()) {
         element.setComment(comment);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above visitor implementation will get the OutputNode that represents the XML element for the provided map of attributes. If the element does not represent the root element in the XML document then every element will have an associated comment, which descrives the class it represents. Such a visitor can be useful when serializing large document structures. The XML snippet below provides an example of what would be written.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;commentExample&amp;gt;
    &amp;lt;!-- java.lang.String --&amp;gt;
    &amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;
    &amp;lt;!-- java.math.BigDecimal --&amp;gt;
    &amp;lt;number&amp;gt;100.0&amp;lt;/number&amp;gt;
    &amp;lt;!-- java.lang.Integer --&amp;gt;
    &amp;lt;value&amp;gt;18&amp;lt;/value&amp;gt;
&amp;lt;/commentExample&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To add a visitor to serialization the VisitorStrategy must be used. This strategy takes a visitor implementation and if required a strategy to delegate to. As usual, this strategy implementation can then be used to construct a persister, which can then serialize and deserialize objects.&lt;/p&gt;

&lt;h3 id=&#34;a-name-31-sect-mapping-with-xpath-expressions&#34;&gt;&lt;a name=&#34;31&#34; /&gt;&amp;sect;Mapping with XPath expressions&lt;/h3&gt;

&lt;p&gt;At times it is useful to have your object model map to complex XML documents, without having to write an annotated class to map to the required elements and attributes. For such scenarios the Path annotation can be used. This requires the user to specify an XPath expression for a field or method. For example take annotated fields below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class ServerDeployment {

   @Attribute
   @Path(&amp;quot;group&amp;quot;)
   private ServerType type;

   @Element
   @Path(&amp;quot;group/server[1]/details&amp;quot;)
   private Server primary;

   @Element
   @Path(&amp;quot;group/server[2]/details&amp;quot;)
   private Server secondary;

   public Server getPrimary() {
      return primary;
   }

   public Server getSecondary() {
      return secondary;
   }
}

@Root
public class Server {

   @Attribute
   private String host;

   @Attribute
   private int port;
}

public enum ServerType {
   WINDOWS,
   LINUX,
   SOLARIS
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code shows annotations applied to two objects. One contains XPath expressions that tell the serialization process how to read and write the details to an from the document. Here the expression defines a server within wrapper elements. When serializing such objects, the following XML results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;serverDeployment&amp;gt;
   &amp;lt;group type=&amp;quot;LINUX&amp;quot;&amp;gt;
      &amp;lt;server&amp;gt;
         &amp;lt;details&amp;gt;
            &amp;lt;primary host=&amp;quot;host1.domain.com&amp;quot; port=&amp;quot;4567&amp;quot;/&amp;gt;
         &amp;lt;/details&amp;gt;
      &amp;lt;/server&amp;gt;
      &amp;lt;server&amp;gt;
         &amp;lt;details&amp;gt;
            &amp;lt;secondary host=&amp;quot;host2.domain.com&amp;quot; port=&amp;quot;4567&amp;quot;/&amp;gt;
         &amp;lt;/details&amp;gt;
      &amp;lt;/server&amp;gt;
   &amp;lt;/group&amp;gt;
&amp;lt;/serverDeployment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen the XPath expressions defined have been used to determine the structure of the XML document. Such expressions allow a complex XML format to be serialized in to two simple objects. This can greatly reduce the number of types required to map an object to an XML structure. Both attributes and elements can be mapped in this manner.&lt;/p&gt;

&lt;p&gt;When ordering elements with the Order annotation these wrapper elements can be sorted. To order wrapper elements an XPath expression can be used to identify the wrapper. Simply place the expression in the order annotation along with any element or attribute names and it is ordered as required. For example, take the following code snippet.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Default
@Order(elements={&amp;quot;name[1]/first&amp;quot;, &amp;quot;name[1]/surname&amp;quot;, &amp;quot;age/date&amp;quot;, &amp;quot;name[2]/nickname&amp;quot;})
public class Person {

   @Path(&amp;quot;name[1]&amp;quot;)
   private String first;

   @Path(&amp;quot;name[1]&amp;quot;)
   private String surname;

   @Path(&amp;quot;name[2]&amp;quot;)
   private String nickname;

   @Path(&amp;quot;age&amp;quot;)
   private String date;

   public String getName() {
      return first;
   }

   public String getSurname() {
      return surname;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like ordering of elements or attributes without XPath expressions, a reference is all that is needed to ensure order. For the above code the serialization of the object will result in the following XML.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;person&amp;gt;
   &amp;lt;name&amp;gt;
      &amp;lt;first&amp;gt;Jack&amp;lt;/first&amp;gt;
      &amp;lt;surname&amp;gt;Daniels&amp;lt;/surname&amp;gt;
   &amp;lt;/name&amp;gt;
   &amp;lt;age&amp;gt;
       &amp;lt;birth&amp;gt;19/10/1912&amp;lt;/birth&amp;gt;
   &amp;lt;/age&amp;gt;
   &amp;lt;name&amp;gt;
      &amp;lt;nickname&amp;gt;JD&amp;lt;/nickname&amp;gt;
   &amp;lt;/name&amp;gt;
&amp;lt;/person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above XML snippet we have serialized a single object in to multiple elements and ensured the order of the elements is as we required. Ordering can be applied to elements and attributes with Path annotations as easily as it can to those without, and both can be mixed within the same annotation. Using this type of ordering it is possible to generate very predictible results. One thing to note when using such annotations, is that only a subset of the XPath expression syntax is supported. For example, element and attribute references can not be taken from the root of the document, only references within the current context are allowed.&lt;/p&gt;

&lt;h3 id=&#34;a-name-32-sect-dynamic-serialization-with-unions&#34;&gt;&lt;a name=&#34;32&#34; /&gt;&amp;sect;Dynamic serialization with unions&lt;/h3&gt;

&lt;p&gt;In order to perform dynamic serialization where element names bind to specific types the ElementUnion annotation can be used. This allows different XML schema classes to be associated with a single annotated field or method. Serialization of the associated instance determines the XML element name using the instance type. On deserialization the XML element name is then used to determine the schema class to use. For example, take the following set of annotated classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Shape {

   public double area();
}

@Root
public class Circle implements Shape {

   @Element
   private double radius;

   public Circle(@Element(name=&amp;quot;radius&amp;quot;) double radius) {
      this.radius = radius;
   }

   public double area() {
      return Math.PI * Math.pow(radius, 2.0);
   }
}

@Root
public class Rectangle implements Shape {

   @Element
   private double width;

   @Element
   private double height;

   public Rectangle(
      @Element(name=&amp;quot;width&amp;quot;) double width,
      @Element(name=&amp;quot;height&amp;quot;) double height)
   {
      this.height = height;
      this.width = width;
   }

   public double area() {
      return width * height;
   }
}

@Root
public class Diagram {

   @ElementUnion({
      @Element(name=&amp;quot;circle&amp;quot;, type=Circle.class),
      @Element(name=&amp;quot;rectangle&amp;quot;, type=Rectangle.class)
   })
   private Shape shape;

   public Diagram() {
      super();
   }

   public void setShape(Shape shape){
      this.shape = shape;
   }

   public Shape getShape() {
      return shape;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above set of classes can now be used to dynamically deserialize different XML documents using a single schema class. For example, take the XML snippet below, this shows what is generated when the shape is assigned an instance of the circle type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;diagram&amp;gt;
   &amp;lt;circle&amp;gt;
      &amp;lt;radius&amp;gt;3.0&amp;lt;/radius&amp;gt;
   &amp;lt;/circle&amp;gt;
&amp;lt;/diagram&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if the shape field is assigned an instance of the square type then serialization of the diagram results in a different XML document. See the XML snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;diagram&amp;gt;
   &amp;lt;rectangle&amp;gt;
      &amp;lt;width&amp;gt;5.0&amp;lt;/width&amp;gt;
      &amp;lt;height&amp;gt;11.0&amp;lt;/heigth&amp;gt;
   &amp;lt;/rectangle&amp;gt;
&amp;lt;/diagram&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Providing dynamic serialization capabilities via the ElementUnion annotation ensures that more complex XML documents can be handled with ease. Typically, such unions will be required for a list of similar types. To tackle lists the ElementListUnion annotation can be used. This can be used as a union of inline lists to collect similar XML declarations in to a single list. For example, take the annotated classes below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Operation {

   public void execute();
}

@Default
public class Delete implements Operation {

   private File file;

   public Delete(@Element(name=&amp;quot;file&amp;quot;) File file) {
      this.file = file;
   }

   public void execute() {
      file.delete();
   }
}

@Default
public class MakeDirectory implements Operation {

   private File path;

   private MakeDirectory(@Element(name=&amp;quot;path&amp;quot;) File path) {
      this.path = path;
   }

   public void execute() {
      path.mkdirs();
   }
}

@Default
public class Move implements Operation {

   private File source;
   private File destination;

   public Move(
         @Element(name=&amp;quot;source&amp;quot;) File source,
         @Element(name=&amp;quot;destination&amp;quot;) File destination)
   {
      this.source = source;
      this.destination = destination;
   }

   public void execute() {
      source.renameTo(destination);
   }
}

@Root
public class Task {

   @ElementListUnion({
      @ElementList(entry=&amp;quot;delete&amp;quot;, inline=true, type=Delete.class),
      @ElementList(entry=&amp;quot;mkdir&amp;quot;, inline=true, type=MakeDirectory.class),
      @ElementList(entry=&amp;quot;move&amp;quot;, inline=true, type=Move.class)
   })
   private List&amp;lt;Operation&amp;gt; operations;

   @Attribute
   private String name;

   public Task(@Attribute(name=&amp;quot;name&amp;quot;) String name) {
      this.operations = new LinkedList&amp;lt;Operation&amp;gt;();
      this.name = name;
   }

   public void add(Operation operation) {
      operations.add(operation);
   }

   public void execute() {
      for(Operation operation : operations) {
         operation.execute();
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above set of annotated classes a list of operations can be defined in an XML document. Each type inserted in to the list can be resolved using the XML element name. Below is an example XML document generated from the annotated classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;task name=&amp;quot;setup&amp;quot;&amp;gt;
   &amp;lt;delete&amp;gt;
      &amp;lt;file&amp;gt;C:\workspace\classes&amp;lt;/file&amp;gt;
   &amp;lt;/delete&amp;gt;
   &amp;lt;mkdir&amp;gt;
      &amp;lt;path&amp;gt;C:\workspace\classes&amp;lt;/path&amp;gt;
   &amp;lt;/mkdir&amp;gt;
   &amp;lt;move&amp;gt;
      &amp;lt;source&amp;gt;C:\worksace\classes&amp;lt;/source&amp;gt;
      &amp;lt;destination&amp;gt;C:\workspace\build&amp;lt;/destination&amp;gt;
   &amp;lt;/move&amp;gt;
&amp;lt;/task&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/tutorial/tutorial.php&#34; title=&#34;SimpleXML Tutorial&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
