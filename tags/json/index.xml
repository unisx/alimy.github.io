<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Json on 北 野</title>
    <link>http://alimy.me/tags/json/</link>
    <description>Recent content in Json on 北 野</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy;2018, Alimy; all rights reserved.</copyright>
    <lastBuildDate>Sun, 13 Mar 2016 20:25:00 +0800</lastBuildDate>
    
	<atom:link href="http://alimy.me/tags/json/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java: org.json</title>
      <link>http://alimy.me/post/dev_201603132025/</link>
      <pubDate>Sun, 13 Mar 2016 20:25:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603132025/</guid>
      <description>&lt;h3 id=&#34;overview-of-the-api-classes&#34;&gt;Overview of The API Classes&lt;/h3&gt;

&lt;p&gt;org.json has classes to parse and write json string. It also converts between json and xml, HTTP header, Cookies, and CDF. The main classes are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;org.json.JSONObject - This class stores unordered key value pairs. The value can be Boolean, JSONArray, Number, String or JSONObject.NULL. It has constructors to take in a json string and store it as key value pairs. It also has constructors that take in a Map, a bean or a String&lt;/li&gt;
&lt;li&gt;org.json.JSONTokener - This class parses a JSON string and is also used internally by the JSONObject and JSONArray classes to parse JSON Strings&lt;/li&gt;
&lt;li&gt;org.json.JSONArray - This class stores an ordered sequence of values. Externally it represents a JSON Array&lt;/li&gt;
&lt;li&gt;org.json.JSONWriter - This class represents method to produce json text. It has an append(String) method to append a string to a json text, key(String) and value(String) method to add key and values to json string. It can also write an array.&lt;/li&gt;
&lt;li&gt;org.json.CDL- This class has methods to convert comma delimited text to JSONArray and a JSONArray to a comma delimited text. The array contains rows of comma separed strings, with rows separated by newline. The first row contains names.&lt;/li&gt;
&lt;li&gt;org.json.Cookie - This class has method to convert a web browser cookie to a JSONObject and back.&lt;/li&gt;
&lt;li&gt;org.json.CookieList - This class has method to convert a list of cookies to JSONObject and back.
Lets see some examples&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;parse-json&#34;&gt;Parse JSON&lt;/h3&gt;

&lt;p&gt;This examples shows how to parse a JSON string. The JSON string in this example is a list of genres (limited to 2) from freemusicarchive.org&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java: Json Simple</title>
      <link>http://alimy.me/post/dev_201603132015/</link>
      <pubDate>Sun, 13 Mar 2016 20:15:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603132015/</guid>
      <description>&lt;p&gt;Json Simple is, as the name suggest, a very simple API. The API itself is made up of around 13 classes. The main classes are :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSONParser - This parses Json text. It takes in a java.io.Reader or a String Object. It is also possible to pass a ContentHandler or ContainerHandler to the parser.&lt;/li&gt;
&lt;li&gt;JSONObject - This is a java representation of JSON string. It stores key value pairs. JsonObject extends HashMap. It has method to encode a map to a JSON text (writeJSONString(Map map, Writer out))&lt;/li&gt;
&lt;li&gt;JSONArray - Represents a collection. It extends an ArrayList. It implements the JSONAware and JSONStreamAware interface&lt;/li&gt;
&lt;li&gt;JSONValue - This class has methods to parse JSON string into Java objects. It uses the JSONParser to do so. It has methods to write JSON string from many java types (writeJSONString(Object value, Writer out)). It also has methods to escapte special characters using the escape(String s) method. This method escapes quotes, \, /, \r, \n, \b, \f, \t and other control characters (U+0000 through U+001F)&lt;/li&gt;
&lt;li&gt;JSONAware - Beans that support output to JSON form should implement this interface.
Lets see some examples&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;parse-json&#34;&gt;Parse JSON&lt;/h3&gt;

&lt;p&gt;This examples shows how to parse a JSON string. The JSON string in this example is a list of genres (limited to 2) from freemusicarchive.org&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: User Guide</title>
      <link>http://alimy.me/post/dev_201603122045/</link>
      <pubDate>Sat, 12 Mar 2016 20:45:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122045/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Goals-for-Gson&#34;&gt;Goals for Gson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Gson-Performance-and-Scalability&#34;&gt;Gson Performance and Scalability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Gson-Users&#34;&gt;Gson Users&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Using-Gson&#34;&gt;Using Gson&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Gson-With-Maven&#34;&gt;Using Gson with Maven&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Primitives-Examples&#34;&gt;Primitives Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Object-Examples&#34;&gt;Object Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Finer-Points-with-Objects&#34;&gt;Finer Points with Objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Nested-Classes-including-Inner-Classes-&#34;&gt;Nested Classes (including Inner Classes)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Array-Examples&#34;&gt;Array Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Collections-Examples&#34;&gt;Collections Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Collections-Limitations&#34;&gt;Collections Limitations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Serializing-and-Deserializing-Generic-Types&#34;&gt;Serializing and Deserializing Generic Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types&#34;&gt;Serializing and Deserializing Collection with Objects of Arbitrary Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Built-in-Serializers-and-Deserializers&#34;&gt;Built-in Serializers and Deserializers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Custom-Serialization-and-Deserialization&#34;&gt;Custom Serialization and Deserialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Writing-a-Serializer&#34;&gt;Writing a Serializer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Writing-a-Deserializer&#34;&gt;Writing a Deserializer&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Gson: Exclusion Strategy</title>
      <link>http://alimy.me/post/dev_201603122040/</link>
      <pubDate>Sat, 12 Mar 2016 20:40:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122040/</guid>
      <description>&lt;p&gt;In this tutorial we look at how to selectively include fields from a java object to a json string. By default, Gson tries to map all fields in the java object to the corresponding property in json. However, in certain cases we may want to control that. There are a few ways to do this. It is also possible to excluse fields from third party packages where we have no access to the source code. The different ways to exclude fields are :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;By defining a custom annotation and ignoring fields that are annotated with that.&lt;/li&gt;
&lt;li&gt;By Defining a custom exclusion class by extending the ExclusionStrategy interface and implementing the public boolean shouldSkipField(FieldAttributes f); and public boolean shouldSkipClass(Class clazz); methods&lt;/li&gt;
&lt;li&gt;By using the @Expose annotations and then using the excludeFieldsWithoutExposeAnnotation() method on the GsonBuilder. This will ignore all fields except the ones that have been exposed using the @Expose annotation.&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Gson: Custom Serializer</title>
      <link>http://alimy.me/post/dev_201603122035/</link>
      <pubDate>Sat, 12 Mar 2016 20:35:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122035/</guid>
      <description>&lt;p&gt;Just as we saw in the &lt;a href=&#34;http://alimy.me/post/dev_201603122030&#34;&gt;previous&lt;/a&gt; tutorial, Gson provides way to specify custom serializers and deserializers. Register a custom serializer with the GsonBuilder if you need you own way to convert a java object to json and you a custom deserializer if you dont like Gson&amp;rsquo;s way of converting json to the java object. The first example below shows a custom serializer and the second example shows a custom deserializer.&lt;/p&gt;

&lt;h3 id=&#34;custom-serializer&#34;&gt;Custom Serializer&lt;/h3&gt;

&lt;p&gt;Create a custom serializer by implementing a com.studytrails.json.gson.JsonSerializer and implementing the public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); method. src is the source object and Type is the type of the source object. The example below demonstrates a custom Serializer.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: Custom Type Adapter</title>
      <link>http://alimy.me/post/dev_201603122030/</link>
      <pubDate>Sat, 12 Mar 2016 20:30:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122030/</guid>
      <description>&lt;p&gt;In the earlier tutorials we have seen how gson can serialize and deserialize java classes with or without hierarchies. By default, it introspects the classes and comes with with a strategy for serializing and deserializing it. However, in some cases, you want to specify your own conversion strategy. That is, you want to control how the java object is converted to json string and the other way round. Gson provides a capability to specify a custom type adapter. You tell Gson that for a particular class, use the conversion strategy specified by your custom adapter. Lets look at how to write the type adapter :
To write a custom adapter extend the com.google.gson.TypeAdapter abstract class. Implement the public abstract T read(JsonReader in) throws IOException; and public abstract void write(JsonWriter out, T value) throws IOException; methods. The adapter should also handle nulls. Create the Type adapter instance and then register it with the GsonBuilder. Create the Gson object from the GsonBuilder and then use that to serialize and deserialize. Lets look at an example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.commons.io.IOUtils;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class DatasetTypeAdapterExample8 {

	public static void main(String[] args) throws MalformedURLException, IOException {
		String url = &amp;quot;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=5&amp;quot;;
		String json = IOUtils.toString(new URL(url));
		// Create the custom type adapter and register it with the GsonBuilder
		// class.
		Gson gson = new GsonBuilder().registerTypeAdapter(Dataset.class, new DatasetTypeAdapter()).create();
		// deserialize the json to Albums class. The Dataset objects are part of
		// the Albums class. Whenever Gson encounters an object of type DataSet
		// it calls the DatasetTypeAdapter to read and write json.
		Albums albums = gson.fromJson(json, Albums.class);
		System.out.println(albums.getDataset()[1].getAlbum_title());
		// prints
		// http://freemusicarchive.org/music/The_Yes_Sirs/Through_The_Cracks_Mix_Vol_1/
	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Gson: Serializing Inner Classes</title>
      <link>http://alimy.me/post/dev_201603122028/</link>
      <pubDate>Sat, 12 Mar 2016 20:28:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122028/</guid>
      <description>&lt;h3 id=&#34;serializing-inner-classes&#34;&gt;Serializing inner classes&lt;/h3&gt;

&lt;p&gt;Gson can serialize inner classes and static nested classes. The detailed example below demonstrates the following things.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Serializing class containing static nested class&lt;/li&gt;
&lt;li&gt;Serializing class containing non static nested class (Inner class)&lt;/li&gt;
&lt;li&gt;De-serializing json to a class containing static and non static inner class&lt;/li&gt;
&lt;li&gt;Serializing static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;Serializing non static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;De-serializing json to a static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;De-serializing json to a non static nested class (without the enclosing type)&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Gson: Serializing and deserializing Java Generic Classes</title>
      <link>http://alimy.me/post/dev_201603122025/</link>
      <pubDate>Sat, 12 Mar 2016 20:25:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122025/</guid>
      <description>&lt;h3 id=&#34;serializing-list&#34;&gt;Serializing list&lt;/h3&gt;

&lt;p&gt;As we saw in the previous tutorial serializing and deserializing classes with generic types is non trivial since generic type information is lost while serializing. Gson provides a class called com.google.gson.reflect.TypeToken to store generic types. The example below shows how to use the TypeToken class to serialize and deserialize Classes with generic types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class GenericTypesExample8 {
	public static void main(String[] args) {
		// create an animal class that is of type dog.
		Animal animal = new Animal&amp;lt;Dog&amp;gt;();
		// Create a Dog instance
		Dog dog = new Dog(&amp;quot;I am a dog&amp;quot;);

		animal.setAnimal(dog);
		Gson gson = new Gson();
		// Define a Type that is an Animal of type dog.
		Type animalType = new TypeToken&amp;lt;Animal&amp;lt;Dog&amp;gt;&amp;gt;() {
		}.getType();

		// we first convert the animal object to a json and then read the json
		// back. However we define the json to be of Animal type
		Animal animal1 = gson.fromJson(gson.toJson(animal, animalType), Animal.class);
		System.out.println(animal1.get().getClass()); // prints class

    // com.google.gson.internal.LinkedTreeMap
		// In contrast to above where we read the json back using the Animal
		// type, here we read the json back as the custom animalType Type. This
		// gives Gson an idea of what
		// the generic type should be.
		Animal animal2 = gson.fromJson(gson.toJson(animal), animalType);
		System.out.println(animal2.get().getClass());
		// prints class com.studytrails.json.gson.Dog

	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Gson: Serializing Collections</title>
      <link>http://alimy.me/post/dev_201603122022/</link>
      <pubDate>Sat, 12 Mar 2016 20:22:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122022/</guid>
      <description>&lt;h3 id=&#34;serializing-list&#34;&gt;Serializing list&lt;/h3&gt;

&lt;p&gt;Serializing Collections should have been similar to serializing other objects. However, the problem is that Collections are generic and the generic type information is not maintained in the json. We therefore pass the type while deserializing list. Note that if the Collection has different types of objects then there is no way to serialize it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Type;
import java.util.Collection;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class DeSerializeListExample5 {
	public static void main(String[] args) {
		String json = &amp;quot;[{album_id:1,album_title:&#39;album1&#39;},{album_id:2,album_title:&#39;album2&#39;}]&amp;quot;;

		Gson gson = new Gson();
		// create the type for the collection. In this case define that the collection is of type Dataset
		Type datasetListType = new TypeToken&amp;lt;Collection&amp;lt;Dataset&amp;gt;&amp;gt;() {}.getType();
		List&amp;lt;Dataset&amp;gt; datasets = gson.fromJson(json, datasetListType);
		for (Dataset dataset : datasets) {
			System.out.println(dataset.getAlbum_title());
			System.out.println(dataset.getAlbum_id());
		}
		// Prints
		//album1
		//1
		//album2
		//2

	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Gson: Convert json to a java object tree</title>
      <link>http://alimy.me/post/dev_201603122020/</link>
      <pubDate>Sat, 12 Mar 2016 20:20:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122020/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;http://alimy.me/post/dev_201603122010&#34; title=&#34;Convert json to a java object&#34;&gt;Earlier&lt;/a&gt; tutorial we saw how to convert json to a java object. In this tutorial, we build a tree of com.google.gson.JsonElement from the json string. The tree can then be traversed to build java objects. JsonElement has methods such as isJsonObject(), isJsonNull(), etc that can be used to figure out the type of JsonElement. Then to get the actual object use the getAsJsonObject(), getAsJsonPrimitive() etc methods. We parse the response from the free music archive json API. Here&amp;rsquo;s the class&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: parsing json to java token by token</title>
      <link>http://alimy.me/post/dev_201603122015/</link>
      <pubDate>Sat, 12 Mar 2016 20:15:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122015/</guid>
      <description>&lt;p&gt;In the earlier tutorials we saw how to &lt;a href=&#34;http://alimy.me/post/dev_201603122010&#34; title=&#34;Convert json to a java object&#34;&gt;convert json to a java object&lt;/a&gt;. In This tutorial we see how to parse json and obtain individual tokens. Although this may seem like a cumbersome way to build java object from json, however it is extremely powerful and may be a good choice if you need a very high level of control over the parsing. We use the JsonReader class to read the json as a stream of tokens. The beginning of an object or an array is also a token. Here&amp;rsquo;s a detailed example.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: Convert json to a java object</title>
      <link>http://alimy.me/post/dev_201603122010/</link>
      <pubDate>Sat, 12 Mar 2016 20:10:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122010/</guid>
      <description>&lt;p&gt;Google json provides methods to convert the json string to java objects. The Java object may be hierarchical. For this example we consider java objects of non generic type only. Gson uses the name to match the json property to the java field. There are two ways to convert json to java.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Using the com.google.gson.Gson class. Create a new instance of this class and use the method public &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT). classOfT is the java object to which the json is to be converted to.&lt;/li&gt;
&lt;li&gt;The other way is to use the com.google.gson.GsonBuilder class. This class allows setting up certain features, such as - allowing null serialization or setting up custom serializing policies. Create a GsonBuilder, apply the features and then obtain the Gson class from the builder.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this tutorial we look at the Gson class to de-serialize json from &lt;a href=&#34;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=5&#34; title=&#34;free music archive&#34;&gt;free music archive&lt;/a&gt;. The main class is the Albums class and it contains the list of Datasets. Each Dataset is one album. The way to approach the problem of deserialization is to build a java class such that the when Gson converts the Java class to JSON, the resultant JSON resembles the one we are trying to parse. Lets see this in action. If you look at the JSON, it starts with a root object that has properties such as title, message, errors, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
title: &amp;quot;Free Music Archive - Albums&amp;quot;,
message: &amp;quot;&amp;quot;,
errors: [ ],
total: &amp;quot;11259&amp;quot;,
total_pages: 2252,
page: 1,
limit: &amp;quot;5&amp;quot;,
dataset: [
{
......
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Gson: Introduction</title>
      <link>http://alimy.me/post/dev_201603122005/</link>
      <pubDate>Sat, 12 Mar 2016 20:05:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122005/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/google/gson&#34; title=&#34;Gson@github&#34;&gt;google json&lt;/a&gt; - gson is an open source java api for parsing and building json. It has extensive support for java generics. It also provides support for converting third party classes to json. It can be used to serialize and deserialize complex objects with deep hierarchies that may contain generic classes. In these tutorials we demonstrate, with examples, the following functionalities of gson.&lt;/p&gt;

&lt;p&gt;Gson 2.3: Look at &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-new-2.3.jsp&#34; title=&#34;gson tutorial&#34;&gt;this tutorial&lt;/a&gt; to see the
latest additions in Gson 2.3 (TypeAdapter Annotation, JsonPath support and new methods in JsonArray)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122010&#34; title=&#34;Java to JSON and Back - Data Binding&#34;&gt;Java to JSON and Back - Data Binding&lt;/a&gt; - In this example we look at how to bind a Json to a java object. Gson is quite powerful when it comes to binding a json to Java since it has a lot of built in serializers and deserializers. A serializer has code that helps in converting a Json string to corresponding java type. For example if you have an array in JSON (elements enclosed in &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;) and you want to convert that to a Java array then Gson would internally use an ArrayTypeAdapter to convert the Json Array to Java Array and back. If you are looking at Gson primarily to parse JSON then we would suggest that you start with a simple Java class, convert that to JSON and make sure it looks like the JSON that you want to parse. You can then gradually start adding complexities to the java class and at each step convert it to a JSON and ensure that the JSON is similar to the one that you are trying to parse. It is good to think of parsing a JSON as creating a java class that can give you the JSON that you want to parse. Also note that you have certain flexibility while creating the java object. You could represent a Json Array as a Java array or a Java List. The choice may be driven more by how you want to use the class. If you map a Json property to a java array Gson would use an Array adapter but if you map it to a List it would use the collection adapter and you, the user, does not have to worry about that. Gson also handles null gracefully&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122015&#34; title=&#34;Java to JSON and Back - Streaming&#34;&gt;Java to JSON and Back - Streaming&lt;/a&gt; - At certain times you want more control on the way the parsing is done. Also there may be times when Gson automated conversion does not give you the result that you are looking for. For example, if you have a List that contains multiple kinds of Object then Gson may not be able to deserialize or parse the Json for you. In such cases Gson provides a streaming API. You can use the Streaming API and handle a token at a time. The token may be start and end of Json Object, start and end of json array, the key of a property and the String or Number value of a property.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Jackson: Json Polymorphism</title>
      <link>http://alimy.me/post/dev_201603112105/</link>
      <pubDate>Fri, 11 Mar 2016 21:05:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112105/</guid>
      <description>&lt;p&gt;Jackson provides a way to maintain sub type information while serializing java objects. It is possible to recreate the exact sub type. The type information can be embedded into the json as a property. In the example below we create a zoo, that has a list of animals. The animal may be an elephant or a lion, and they both extend the Animal abstract class. While deserializing we want to create the exact animal type. We also demonstrate the use of @JsonTypeInfo and @JsonSubTypes annotations.&lt;/p&gt;

&lt;h3 id=&#34;data-serialization-and-polymorphism-example&#34;&gt;Data Serialization and Polymorphism Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class SerializeExample1 {
    private static String outputFile = &amp;quot;zoo.json&amp;quot;;

    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {
        // let start creating the zoo
        Zoo zoo = new Zoo(&amp;quot;Samba Wild Park&amp;quot;, &amp;quot;Paz&amp;quot;);
        Lion lion = new Lion(&amp;quot;Simba&amp;quot;);
        Elephant elephant = new Elephant(&amp;quot;Manny&amp;quot;);
        List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;();
        animals.add(lion);
        animals.add(elephant);
        zoo.setAnimals(animals);

        ObjectMapper mapper = new ObjectMapper();
        mapper.writerWithDefaultPrettyPrinter().writeValue(new FileWriter(new File(outputFile)), zoo);
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Jackson: jackson Mix- In Annotations</title>
      <link>http://alimy.me/post/dev_201603112100/</link>
      <pubDate>Fri, 11 Mar 2016 21:00:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112100/</guid>
      <description>&lt;p&gt;Annotations are a great way to manage serialization and deserialization in Jackson. However, what do you do if you want to annotate a third party class, or if you dont want to tightly couple your POJOs to jackson annotations. This is where Mix-in comes into play. You define a mix-in abstract class that is kind of a proxy to the actual class. Annotations are then definied over this proxy class&lt;/p&gt;

&lt;h3 id=&#34;jackson-mix-in-example&#34;&gt;Jackson Mix-In Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.File;
import java.io.IOException;

import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class SerializeExample3 {
    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {
        ObjectMapper mapper = new ObjectMapper();
        mapper.addMixInAnnotations(Bird.class, BirdMixIn.class);
        Bird bird = new Bird(&amp;quot;scarlet Ibis&amp;quot;);
        bird.setSound(&amp;quot;eee&amp;quot;);
        bird.setHabitat(&amp;quot;water&amp;quot;);

        mapper.writerWithDefaultPrettyPrinter().writeValue(new File(&amp;quot;bird.json&amp;quot;), bird);
    }

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Jackson: Json data binding filters</title>
      <link>http://alimy.me/post/dev_201603112055/</link>
      <pubDate>Fri, 11 Mar 2016 20:55:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112055/</guid>
      <description>&lt;p&gt;Jackson provides an effective an efficient way to bind json to POJOs. However, at times, certain properties may need to be ignored while converting a json to java ojbect and a java object to json string. Jackson provides three ways to filter properties.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;@JsonIgnoreProperties- This annotation can be used at the type level to ignore json properties. In the example below we ignore the &amp;lsquo;tags&amp;rsquo; property from the albums dataset.&lt;/li&gt;
&lt;li&gt;@JsonIgnore - This annotation can be set at property level to ignore certain properties.&lt;/li&gt;
&lt;li&gt;Using Custom filters&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The example below shows method 1 and 2. Also note the use of the @JsonAutoDetect annotation.&lt;/p&gt;

&lt;h3 id=&#34;data-binding-filters-example&#34;&gt;Data Binding Filters Example&lt;/h3&gt;

&lt;h4 id=&#34;databinding&#34;&gt;Databinding&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.JsonProperty;

// Do not use fields to autodetect. use the public getter methods to autodetect properties
@JsonAutoDetect(fieldVisibility = Visibility.NONE, getterVisibility = Visibility.PUBLIC_ONLY)
public class AlbumsFilter {

    private String title;
    private DatasetFilter[] datasetFilter;
    public String total_pages;

    protected String getTotal_pages() {
        return total_pages;
    }

    public String getTitle() {
        return title;
    }

    // this getter method is for the &#39;dataset&#39; property
    @JsonProperty(&amp;quot;dataset&amp;quot;)
    public DatasetFilter[] getDatasetFilter() {
        return datasetFilter;
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Jackson: Json annotations and dyna beans</title>
      <link>http://alimy.me/post/dev_201603112050/</link>
      <pubDate>Fri, 11 Mar 2016 20:50:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112050/</guid>
      <description>&lt;p&gt;The json string at times have a lot of properties. It seems a waste creating a POJO with all those properties. Wouldnt it be great if there was a catch&amp;rsquo;all that could read all properties in a map? Jackson provides annotations to do just that. In the example below we have set two properties in the bean and the other properties are read into a map. These example also introduces some common annotations using in Jackson. Lets look at them briefly:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;@JsonProperty-This annotation is used to mark a method as a getter or setter for a property. In other words, it associates a json field with a java property. If a name is specified (@JsonProperty(&amp;ldquo;age&amp;rdquo;)) then the java property that is annotated with this annotation is mapped to the &amp;lsquo;age&amp;rsquo; field of the json, If no name is specified the java property name is used.&lt;/li&gt;
&lt;li&gt;@JsonCreator-This annotation is used the define constructors that are used to create java objects from json string. It is used during data binding and specifies properties that will be used to create java objects during deserialization.&lt;/li&gt;
&lt;li&gt;@JsonAnyGetter and @JsonAnySetter - This annotations are used to mark methods that set or read fields that are not handled by any other java property. These act like catch-all and handle all fields that are not handled by any other java property. The fields are stored in a map as key value pairs.&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Jackson: List serialization</title>
      <link>http://alimy.me/post/dev_201603112045/</link>
      <pubDate>Fri, 11 Mar 2016 20:45:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112045/</guid>
      <description>&lt;p&gt;In this tutorial we will see how to convert a java List to JSON. Serializing list is a little tricky since by default the type info is not stored while serializing and deserializing lists. In this tutorial we look at two examples. In the first example we serialize an Object that has a java List as one of its properties. In the second example we try and serialize the List directly. In both examples we use special configuration to preserve type info.&lt;/p&gt;

&lt;h3 id=&#34;example-1-serializing-object-containing-a-list&#34;&gt;Example 1 : Serializing Object containing a list&lt;/h3&gt;

&lt;p&gt;The example converts a Zoo class to json. the zoo class contains the name of zoo, its city and a list of animals. The list is of type &amp;lsquo;Animal&amp;rsquo;, i.e. the list contains elements that are subclass of the Abstract class Animal. Lets see what happens when we try to serialize zoo. First we create the Zoo class. Notice how the constructor looks. When we try to get the Zoo Object back from the JSON, Jackson has to know that it should create the Zoo Object using the constructor that takes in the name and city properties.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Zoo {
    public String name;
    public String city;


    @JsonCreator
    public Zoo(@JsonProperty(&amp;quot;name&amp;quot;) String name,@JsonProperty(&amp;quot;city&amp;quot;) String city) {
        this.name = name;
        this.city = city;
    }

    public List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;Animal&amp;gt;();

    public List&amp;lt;Animal&amp;gt; addAnimal(Animal animal) {
        animals.add(animal);
        return animals;
    }

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Jackson: Json Data Binding</title>
      <link>http://alimy.me/post/dev_201603112040/</link>
      <pubDate>Fri, 11 Mar 2016 20:40:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112040/</guid>
      <description>&lt;p&gt;A thing that most java developers love to deal with is &amp;hellip;. Java POJO. Wouldn&amp;rsquo;t you love a black box where you can see JSON string entering from one side and POJOs coming out from the other. That&amp;rsquo;s what Jackson data binding does. This can be best explained by an example. We use the json from free music archive. It has an API to get latest albums in the form of JSON. we would read that json string (Click on this link to see the json) into Albums object. The Albums object contains an array of Dataset.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how The JSON to Java conversion works&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The first step is to create the Java class that would hold the JSON data. Look at the json. we create an Albums object to hold the entire json. The json contains an array of &amp;lsquo;dataset&amp;rsquo; elements. We create a Java Object of type DataSet and in the Albums object we create a dataset property that is an array of type DataSet.&lt;/li&gt;
&lt;li&gt;Create an instance of the com.fasterxml.jackson.databind.ObjectMapper class. This is the class that maps a JSON to a Java Object.&lt;code&gt;ObjectMapper mapper = new ObjectMapper();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;We use the &lt;em&gt;readValue&lt;/em&gt; method of the ObjectMapper to read. There are multiple versions of this method and we use the method that takes in a URL. However, there are method that read from a file, inputstream, String or a ByteArray.&lt;/li&gt;
&lt;li&gt;The ObjectMapper caches serializers and deserializers so it would be a good idea to reuse an ObjectMapper instance for multiple conversions&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Jackson: build java tree model from json</title>
      <link>http://alimy.me/post/dev_201603112035/</link>
      <pubDate>Fri, 11 Mar 2016 20:35:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112035/</guid>
      <description>&lt;p&gt;Jackson provides a tree node called com.fasterxml.jackson.databind.JsonNode. The ObjectMapper provides a method to read the json into a tree with the root being a JsonNode. This can be thought of as being similar to DOM nodes in XML DOM trees. The example below demonstrates building a tree from the json string&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Jackson: json and java - Streaming</title>
      <link>http://alimy.me/post/dev_201603112030/</link>
      <pubDate>Fri, 11 Mar 2016 20:30:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112030/</guid>
      <description>&lt;h3 id=&#34;streaming-parser-and-generator&#34;&gt;Streaming Parser and Generator&lt;/h3&gt;

&lt;p&gt;Jackson provides a low level API to parse json string. The API provides token for each json object. For example, the start of json &amp;lsquo;{&amp;rsquo; is the first object that the parser provides. The key value pair is another single object. The client code can use the tokens and get the json properties or build a java object out of it if required. This low level API is extremely powerful but needs a lot of coding. For most cases, Jackson&amp;rsquo;s tree traversing and data binding capability should be explored instead. We provide two examples below. The first example demonstrates json parsing and the second demonstrated json generation.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Jackson: Java to JSON and back</title>
      <link>http://alimy.me/post/dev_201603112025/</link>
      <pubDate>Fri, 11 Mar 2016 20:25:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112025/</guid>
      <description>&lt;h3 id=&#34;creating-json-from-java&#34;&gt;Creating JSON from Java&lt;/h3&gt;

&lt;p&gt;Jackson provides classes that can be used to convert a Java Object to JSON and back. In this example we look at how to build a JSON construct from a Java Object. We will start with a simple class and gradually start adding complexities to it. Lets say that we are a music company and we want to publish an api where users can query for Album. We first build an Album class with a single property title.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Album {
    private String title;

    public Album(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Jackson: Introduction</title>
      <link>http://alimy.me/post/dev_201603112020/</link>
      <pubDate>Fri, 11 Mar 2016 20:20:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112020/</guid>
      <description>&lt;h3 id=&#34;overview-of-the-jackson-api&#34;&gt;Overview of The Jackson API&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.fasterxml.com/JacksonHome&#34; title=&#34;Jackson Api&#34;&gt;Jackson Api&lt;/a&gt; contains a lot of functionalities to read and build json using java. It has very powerful data binding capabilities and provides a framework to serialize custom java objects to json string and deserialize json string back to java objects. Json written with jackson can contain embedded class information that helps in creating the complete object tree during deserialization.&lt;/p&gt;

&lt;h3 id=&#34;creating-json-from-java&#34;&gt;Creating JSON from JAVA&lt;/h3&gt;

&lt;p&gt;There are three ways to create JSON from JAVA:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;From a Java Object (The Same object can also be then used to read the JSON)&lt;/li&gt;
&lt;li&gt;From a JsonNode Tree&lt;/li&gt;
&lt;li&gt;Building a Json Stream&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the &lt;a href=&#34;http://alimy.me/post/dev_201603112025&#34; title=&#34;Java to JSON and back&#34;&gt;first tutorial&lt;/a&gt; we look at all the three ways of creating JSON. Note that if you are new to Jackson this is probably the best place to begin even if you are looking at a way to parse JSON.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>