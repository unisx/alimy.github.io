<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Development on Alimy </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://alimy.me/tags/development/</link>
    
    
    <copyright>&amp;copy;2016, Alimy; all rights reserved.</copyright>
    <updated>Sat, 12 Mar 2016 20:40:00 CST</updated>
    
    <item>
      <title>Gson: Exclusion Strategy</title>
      <link>http://alimy.me/post/dev_201603122040/</link>
      <pubDate>Sat, 12 Mar 2016 20:40:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122040/</guid>
      <description>

&lt;p&gt;In this tutorial we look at how to selectively include fields from a java object to a json string. By default, Gson tries to map all fields in the java object to the corresponding property in json. However, in certain cases we may want to control that. There are a few ways to do this. It is also possible to excluse fields from third party packages where we have no access to the source code. The different ways to exclude fields are :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;By defining a custom annotation and ignoring fields that are annotated with that.&lt;/li&gt;
&lt;li&gt;By Defining a custom exclusion class by extending the ExclusionStrategy interface and implementing the public boolean shouldSkipField(FieldAttributes f); and public boolean shouldSkipClass(Class clazz); methods&lt;/li&gt;
&lt;li&gt;By using the @Expose annotations and then using the excludeFieldsWithoutExposeAnnotation() method on the GsonBuilder. This will ignore all fields except the ones that have been exposed using the @Expose annotation.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;the-example-below-demonstrates-all-three:328ca424640a9366d8b50d13fb24324f&#34;&gt;The example below demonstrates all three&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.awt.Color;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class ExclusionExample {
	public static void main(String[] args) {
		// We create an instance of type CAT.
		Cat cat = new Cat();
		cat.setName(&amp;quot;Cat&amp;quot;);
		cat.setAge(1);
		cat.setColor(Color.BLACK);
		cat.setCountry(&amp;quot;US&amp;quot;);
		// we allow serializing null. therefore although the fields lazy is
		// null, it will be serialized. We add a CustomExclusionStrategy that
		// will exclude the Color class. We also allow only those fields that
		// have been exposed using the @Expore annotation
		Gson gson = new GsonBuilder().serializeNulls().setExclusionStrategies(new CustomExclusionStrategy(Color.class))
				.excludeFieldsWithoutExposeAnnotation().create();
		System.out.println(gson.toJson(cat));
		// prints {&amp;quot;name&amp;quot;:&amp;quot;Cat&amp;quot;,&amp;quot;lazy&amp;quot;:null}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-cat-class:328ca424640a9366d8b50d13fb24324f&#34;&gt;The Cat class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.awt.Color;

import com.google.gson.annotations.Expose;

public class Cat {
	@Expose
	private String name;
	private int age;
	private Color color;
	@Expose
	@Country
	private String country;
	@Expose
	private Boolean lazy = null;

	public void setAge(int age) {
		this.age = age;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void setColor(Color color) {
		this.color = color;
	}

	public int getAge() {
		return age;
	}

	public String getName() {
		return name;
	}

	public Color getColor() {
		return color;
	}

	public void setCountry(String country) {
		this.country = country;
	}

	public String getCountry() {
		return country;
	}

	public void setLazy(Boolean lazy) {
		this.lazy = lazy;
	}

	public Boolean getLazy() {
		return lazy;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-exclusion-strategy:328ca424640a9366d8b50d13fb24324f&#34;&gt;The Exclusion Strategy&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import com.google.gson.ExclusionStrategy;
import com.google.gson.FieldAttributes;

/**
 * This class defines custom exclusion policy. We want to ignore all fields that
 * have been annotated with the Country annotation. Note that we can also ignore
 * fields based on name or type. This same policy can be applied to any class.
 * In this example we apply to the CAT class, but it is not limited to the cat
 * class.
 *
 */
public class CustomExclusionStrategy implements ExclusionStrategy {

	private Class classToExclude;

	public CustomExclusionStrategy(Class classToExclude) {
		this.classToExclude = classToExclude;
	}

	// This method is called for all fields. if the method returns false the
	// field is excluded from serialization
	@Override
	public boolean shouldSkipField(FieldAttributes f) {
		if (f.getAnnotation(Country.class) == null)
			return false;

		return true;
	}

	// This method is called for all classes. If the method returns false the
	// class is excluded.
	@Override
	public boolean shouldSkipClass(Class&amp;lt;?&amp;gt; clazz) {
		if (clazz.equals(classToExclude))
			return true;
		return false;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-exclusion-strategy.jsp&#34; title=&#34;Excluding certain fields from Java classes&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gson: Custom Serializer</title>
      <link>http://alimy.me/post/dev_201603122035/</link>
      <pubDate>Sat, 12 Mar 2016 20:35:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122035/</guid>
      <description>

&lt;p&gt;Just as we saw in the &lt;a href=&#34;http://alimy.me/post/dev_201603122030&#34;&gt;previous&lt;/a&gt; tutorial, Gson provides way to specify custom serializers and deserializers. Register a custom serializer with the GsonBuilder if you need you own way to convert a java object to json and you a custom deserializer if you dont like Gson&amp;rsquo;s way of converting json to the java object. The first example below shows a custom serializer and the second example shows a custom deserializer.&lt;/p&gt;

&lt;h3 id=&#34;custom-serializer:111b3d40cae40f94b365983d1c03789a&#34;&gt;Custom Serializer&lt;/h3&gt;

&lt;p&gt;Create a custom serializer by implementing a com.studytrails.json.gson.JsonSerializer and implementing the public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); method. src is the source object and Type is the type of the source object. The example below demonstrates a custom Serializer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.reflect.TypeToken;

public class DogSerializer implements JsonSerializer {
	@Override
	public JsonElement serialize(Dog src, Type typeOfSrc, JsonSerializationContext context) {
		// This method gets involved whenever the parser encounters the Dog
		// object (for which this serializer is registered)
		JsonObject object = new JsonObject();
		String name = src.getName().replaceAll(&amp;quot; &amp;quot;, &amp;quot;_&amp;quot;);
		object.addProperty(&amp;quot;name&amp;quot;, name);
		// we create the json object for the dog and send it back to the
		// Gson serializer
		return object;
	}

	public static void main(String[] args) {
		Animall&amp;lt;Dog&amp;gt; animal = new Animall&amp;lt;Dog&amp;gt;();
		Dog dog = new Dog(&amp;quot;I am a dog&amp;quot;);
		animal.setAnimal(dog);
		// Create the GsonBuilder and register a serializer for the Dog class.
		// Whenever the Dog class is encountered Gson calls the DogSerializer
		// we set pretty printing own to format the json
		Gson gson = new GsonBuilder().registerTypeAdapter(Dog.class, new DogSerializer()).setPrettyPrinting().create();
		// Since Animal contains generic type create the type using TypeToken
		// class.
		Type animalType = new TypeToken&amp;lt;Animal&amp;lt;Dog&amp;gt;&amp;gt;() {
		}.getType();
		System.out.println(gson.toJson(animal, animalType));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Animal class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

public class Animal {

	public T animal;

	public void setAnimal(T animal) {
		this.animal = animal;
	}

	public T get() {
		return animal;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Dog class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

public class Dog {
	private String name;

	public Dog(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;custom-deserializer:111b3d40cae40f94b365983d1c03789a&#34;&gt;Custom DeSerializer&lt;/h4&gt;

&lt;p&gt;Use a custome De serializer to create a Dog Object from the json. To create a deserializer implement the public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;

public class DogDeserialiser implements JsonDeserializer&amp;lt;Dog&amp;gt; {
	@Override
	public Dog deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
		String name = json.getAsJsonObject().get(&amp;quot;name&amp;quot;).getAsString();
		name = name.replace(&amp;quot; &amp;quot;, &amp;quot;_&amp;quot;);
		Dog dog = new Dog(name);

		return dog;
	}

	public static void main(String[] args) {
		String json = &amp;quot;{\&amp;quot;animal\&amp;quot;:{\&amp;quot;name\&amp;quot;:\&amp;quot;I am a dog\&amp;quot;}}&amp;quot;;
		Gson gson = new GsonBuilder().registerTypeAdapter(Dog.class, new DogDeserialiser()).create();
		Type animalType = new TypeToken&amp;lt;Animal&amp;lt;Dog&amp;gt;&amp;gt;() {
		}.getType();
		Animal&amp;lt;Dog&amp;gt; animal = gson.fromJson(json, animalType);
		System.out.println(animal.get().getName());
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-introduction.jsp&#34; title=&#34;Using Custom Serialization and Deserialization classes&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gson: Custom Type Adapter</title>
      <link>http://alimy.me/post/dev_201603122030/</link>
      <pubDate>Sat, 12 Mar 2016 20:30:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122030/</guid>
      <description>&lt;p&gt;In the earlier tutorials we have seen how gson can serialize and deserialize java classes with or without hierarchies. By default, it introspects the classes and comes with with a strategy for serializing and deserializing it. However, in some cases, you want to specify your own conversion strategy. That is, you want to control how the java object is converted to json string and the other way round. Gson provides a capability to specify a custom type adapter. You tell Gson that for a particular class, use the conversion strategy specified by your custom adapter. Lets look at how to write the type adapter :
To write a custom adapter extend the com.google.gson.TypeAdapter abstract class. Implement the public abstract T read(JsonReader in) throws IOException; and public abstract void write(JsonWriter out, T value) throws IOException; methods. The adapter should also handle nulls. Create the Type adapter instance and then register it with the GsonBuilder. Create the Gson object from the GsonBuilder and then use that to serialize and deserialize. Lets look at an example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.commons.io.IOUtils;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class DatasetTypeAdapterExample8 {

	public static void main(String[] args) throws MalformedURLException, IOException {
		String url = &amp;quot;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=5&amp;quot;;
		String json = IOUtils.toString(new URL(url));
		// Create the custom type adapter and register it with the GsonBuilder
		// class.
		Gson gson = new GsonBuilder().registerTypeAdapter(Dataset.class, new DatasetTypeAdapter()).create();
		// deserialize the json to Albums class. The Dataset objects are part of
		// the Albums class. Whenever Gson encounters an object of type DataSet
		// it calls the DatasetTypeAdapter to read and write json.
		Albums albums = gson.fromJson(json, Albums.class);
		System.out.println(albums.getDataset()[1].getAlbum_title());
		// prints
		// http://freemusicarchive.org/music/The_Yes_Sirs/Through_The_Cracks_Mix_Vol_1/
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Adapter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.io.IOException;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;

/**
 * The Dataset class contains the information about a particular Album.
 * album_title and album_url are two distinct fields in the json. The Dataset
 * object contains the field album_title. Normally Gson would map the
 * album_title property in the json the the album_title field in the Dataset
 * object. However, we dont want that. We want to use the album_url property
 * from the json object to populate the album_title field in the Dataset object.
 * we build a custom TypeAdapter to do that. This is just a trivial case, you
 * could also combine album_url and album_title properties and set it to the
 * album_title field of the Dataset Object.
 *
 */
public class DatasetTypeAdapter extends TypeAdapter&amp;lt;Dataset&amp;gt; {
	@Override
	public Dataset read(JsonReader reader) throws IOException {
		// the first token is the start object
		JsonToken token = reader.peek();
		Dataset dataset = new Dataset();
		if (token.equals(JsonToken.BEGIN_OBJECT)) {
			reader.beginObject();
			while (!reader.peek().equals(JsonToken.END_OBJECT)) {
				if (reader.peek().equals(JsonToken.NAME)) {
					if (reader.nextName().equals(&amp;quot;album_url&amp;quot;))
						dataset.setAlbum_title(reader.nextString());
					else
						reader.skipValue();

				}
			}
			reader.endObject();

		}
		return dataset;
	}

	@Override
	public void write(JsonWriter out, Dataset value) throws IOException {

	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Albums class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;


public class Albums {

	private String title;
	private Dataset[] dataset;

	public void setTitle(String title) {
		this.title = title;
	}

	public void setDataset(Dataset[] dataset) {
		this.dataset = dataset;
	}

	public String getTitle() {
		return title;
	}

	public Dataset[] getDataset() {
		return dataset;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Dataset class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.util.HashMap;
import java.util.Map;

public class Dataset {
	private String album_id;
	private String album_title;
	private Map&amp;lt;String , Object&amp;gt; otherProperties = new HashMap&amp;lt;String , Object&amp;gt;();

	public String getAlbum_id() {
		return album_id;
	}

	public void setAlbum_id(String album_id) {
		this.album_id = album_id;
	}

	public String getAlbum_title() {
		return album_title;
	}

	public void setAlbum_title(String album_title) {
		this.album_title = album_title;
	}

	public Object get(String name) {
		return otherProperties.get(name);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-type-adapter.jsp&#34; title=&#34;Using Custom type adapters&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gson: Serializing Inner Classes</title>
      <link>http://alimy.me/post/dev_201603122028/</link>
      <pubDate>Sat, 12 Mar 2016 20:28:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122028/</guid>
      <description>

&lt;h3 id=&#34;serializing-inner-classes:94d200a9b12cc728e29eb582b49f7787&#34;&gt;Serializing inner classes&lt;/h3&gt;

&lt;p&gt;Gson can serialize inner classes and static nested classes. The detailed example below demonstrates the following things.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Serializing class containing static nested class&lt;/li&gt;
&lt;li&gt;Serializing class containing non static nested class (Inner class)&lt;/li&gt;
&lt;li&gt;De-serializing json to a class containing static and non static inner class&lt;/li&gt;
&lt;li&gt;Serializing static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;Serializing non static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;De-serializing json to a static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;De-serializing json to a non static nested class (without the enclosing type)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;the-example:94d200a9b12cc728e29eb582b49f7787&#34;&gt;The Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Modifier;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.studytrails.json.gson.AlbumsWithInnerClass.Dataset;
import com.studytrails.json.gson.AlbumsWithInnerClass.Dataset2;

public class SerializeInnerClassExample4 {
    public static void main(String[] args) {
        // create an Albums class with a static nested class and a non static
        // nested class
        AlbumsWithInnerClass albums = new AlbumsWithInnerClass();
        albums.setName(&amp;quot;SerializeInnerClass&amp;quot;);
        // create a dataset. we need the enclosing type since this is a non
        // static nested class (inner class)
        Dataset dataset = albums.new Dataset();
        dataset.setAlbum_id(&amp;quot;1&amp;quot;);
        dataset.setAlbum_name(&amp;quot;albums1&amp;quot;);
        // assign the datasets to albums
        albums.setDatasetsInner(new Dataset[] { dataset });

        // static inner class can be created without the enclosing type
        Dataset2 dataset2 = new Dataset2();
        dataset2.setAlbum_id(&amp;quot;2&amp;quot;);
        dataset2.setAlbum_name(&amp;quot;albums2&amp;quot;);
        albums.setDatasetsStatic(new Dataset2[] { dataset2 });

        // create the GsonBuilder
        GsonBuilder builder = new GsonBuilder();
        // we ignore Private fields
        builder.excludeFieldsWithModifiers(Modifier.PRIVATE);
        Gson gson = builder.create();

        // serialize the albums object
        String json = gson.toJson(albums);
        System.out.println(json);
        // prints
        // {&amp;quot;name&amp;quot;:&amp;quot;SerializeInnerClass&amp;quot;,&amp;quot;datasetsInner&amp;quot;:[{&amp;quot;album_name&amp;quot;:&amp;quot;SerializeInnerClass_albums1&amp;quot;,&amp;quot;album_id&amp;quot;:&amp;quot;1&amp;quot;}],
        // &amp;quot;datasetsStatic&amp;quot;:[{&amp;quot;album_name&amp;quot;:&amp;quot;albums2&amp;quot;,&amp;quot;album_id&amp;quot;:&amp;quot;2&amp;quot;}]}

        // We read the json string now and recreate the AlbumsWithInnerClass class
        Gson gson3 = new Gson();
        AlbumsWithInnerClass parsedAlbums = gson3.fromJson(json, AlbumsWithInnerClass.class);
        System.out.println(parsedAlbums.datasetsInner[0].album_name);
        // prints SerializeInnerClass_albums1
        System.out.println(parsedAlbums.datasetsStatic[0].album_name);
        // prints albums2

        // now lets try and serialize only the object of inner class
        Gson gson2 = new Gson();
        String json2 = gson2.toJson(dataset);
        System.out.println(json2);
        // prints {&amp;quot;album_name&amp;quot;:&amp;quot;SerializeInnerClass_albums1&amp;quot;,&amp;quot;album_id&amp;quot;:&amp;quot;1&amp;quot;}

        // serialize nested static class
        String json3 = gson2.toJson(dataset2);
        System.out.println(json3);
        // prints {&amp;quot;album_name&amp;quot;:&amp;quot;albums2&amp;quot;,&amp;quot;album_id&amp;quot;:&amp;quot;2&amp;quot;}

        // let us now create the inner class from the json string
        Gson gson4 = new Gson();
        Dataset parsedDataset = gson4.fromJson(json2, Dataset.class);
        System.out.println(parsedDataset.getClass());
        // prints class com.studytrails.json.gson.AlbumsWithInnerClass$Dataset
        System.out.println(parsedDataset.album_name);
        // prints SerializeInnerClass_albums1

        // create nested static class from the json string
        Dataset2 parsedStaticNestedClass = gson4.fromJson(json3, Dataset2.class);
        System.out.println(parsedStaticNestedClass.getClass());
        // prints class com.studytrails.json.gson.AlbumsWithInnerClass$Dataset2
        System.out.println(parsedStaticNestedClass.album_name);
        // prints albums2

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-albumswithinnerclass:94d200a9b12cc728e29eb582b49f7787&#34;&gt;The AlbumsWithInnerClass&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

public class AlbumsWithInnerClass {
    public String name;
    private String year;
    public Dataset[] datasetsInner;
    public Dataset2[] datasetsStatic;

    public void setDatasetsInner(Dataset[] datasetsInner) {
        this.datasetsInner = datasetsInner;
    }

    public void setDatasetsStatic(Dataset2[] datasetsStatic) {
        this.datasetsStatic = datasetsStatic;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setYear(String year) {
        this.year = year;
    }

    class Dataset {
        public String album_name;
        public String album_id;

        public void setAlbum_id(String album_id) {
            this.album_id = album_id;
        }

        public void setAlbum_name(String album_name) {
            this.album_name = name + &amp;quot;_&amp;quot; + album_name;
        }
    }

    static class Dataset2 {
        public String album_name;
        public String album_id;

        public void setAlbum_id(String album_id) {
            this.album_id = album_id;
        }

        public void setAlbum_name(String album_name) {
            this.album_name = album_name;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-serialize-inner-classes.jsp&#34; title=&#34;Serializing Inner Classes&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gson: Serializing and deserializing Java Generic Classes</title>
      <link>http://alimy.me/post/dev_201603122025/</link>
      <pubDate>Sat, 12 Mar 2016 20:25:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122025/</guid>
      <description>

&lt;h3 id=&#34;serializing-list:48eff8845146e9414ebbce90bbfb026f&#34;&gt;Serializing list&lt;/h3&gt;

&lt;p&gt;As we saw in the previous tutorial serializing and deserializing classes with generic types is non trivial since generic type information is lost while serializing. Gson provides a class called com.google.gson.reflect.TypeToken to store generic types. The example below shows how to use the TypeToken class to serialize and deserialize Classes with generic types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class GenericTypesExample8 {
	public static void main(String[] args) {
		// create an animal class that is of type dog.
		Animal animal = new Animal&amp;lt;Dog&amp;gt;();
		// Create a Dog instance
		Dog dog = new Dog(&amp;quot;I am a dog&amp;quot;);

		animal.setAnimal(dog);
		Gson gson = new Gson();
		// Define a Type that is an Animal of type dog.
		Type animalType = new TypeToken&amp;lt;Animal&amp;lt;Dog&amp;gt;&amp;gt;() {
		}.getType();

		// we first convert the animal object to a json and then read the json
		// back. However we define the json to be of Animal type
		Animal animal1 = gson.fromJson(gson.toJson(animal, animalType), Animal.class);
		System.out.println(animal1.get().getClass()); // prints class

    // com.google.gson.internal.LinkedTreeMap
		// In contrast to above where we read the json back using the Animal
		// type, here we read the json back as the custom animalType Type. This
		// gives Gson an idea of what
		// the generic type should be.
		Animal animal2 = gson.fromJson(gson.toJson(animal), animalType);
		System.out.println(animal2.get().getClass());
		// prints class com.studytrails.json.gson.Dog

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;animal-class:48eff8845146e9414ebbce90bbfb026f&#34;&gt;Animal class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

public class Animal {

	public T animal;

	public void setAnimal(T animal) {
		this.animal = animal;
	}

	public T get() {
		return animal;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dog-class:48eff8845146e9414ebbce90bbfb026f&#34;&gt;Dog Class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

public class Dog {
	private String name;

	public Dog(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-introduction.jsp&#34; title=&#34;Serializing and deserializing Java Generic Classes&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gson: Serializing Collections</title>
      <link>http://alimy.me/post/dev_201603122022/</link>
      <pubDate>Sat, 12 Mar 2016 20:22:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122022/</guid>
      <description>

&lt;h3 id=&#34;serializing-list:0245d903820e8dfe5f649eea2e56a9f6&#34;&gt;Serializing list&lt;/h3&gt;

&lt;p&gt;Serializing Collections should have been similar to serializing other objects. However, the problem is that Collections are generic and the generic type information is not maintained in the json. We therefore pass the type while deserializing list. Note that if the Collection has different types of objects then there is no way to serialize it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Type;
import java.util.Collection;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class DeSerializeListExample5 {
	public static void main(String[] args) {
		String json = &amp;quot;[{album_id:1,album_title:&#39;album1&#39;},{album_id:2,album_title:&#39;album2&#39;}]&amp;quot;;

		Gson gson = new Gson();
		// create the type for the collection. In this case define that the collection is of type Dataset
		Type datasetListType = new TypeToken&amp;lt;Collection&amp;lt;Dataset&amp;gt;&amp;gt;() {}.getType();
		List&amp;lt;Dataset&amp;gt; datasets = gson.fromJson(json, datasetListType);
		for (Dataset dataset : datasets) {
			System.out.println(dataset.getAlbum_title());
			System.out.println(dataset.getAlbum_id());
		}
		// Prints
		//album1
		//1
		//album2
		//2

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-dataset-class:0245d903820e8dfe5f649eea2e56a9f6&#34;&gt;The Dataset Class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.util.HashMap;
import java.util.Map;

public class Dataset {
	private String album_id;
	private String album_title;
	private Map&amp;lt;String , Object&amp;gt; otherProperties = new HashMap&amp;lt;String , Object&amp;gt;();

	public String getAlbum_id() {
		return album_id;
	}

	public void setAlbum_id(String album_id) {
		this.album_id = album_id;
	}

	public String getAlbum_title() {
		return album_title;
	}

	public void setAlbum_title(String album_title) {
		this.album_title = album_title;
	}

	public Object get(String name) {
		return otherProperties.get(name);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-serializing-collections.jsp&#34; title=&#34;Serializing Collections&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gson: Convert json to a java object tree</title>
      <link>http://alimy.me/post/dev_201603122020/</link>
      <pubDate>Sat, 12 Mar 2016 20:20:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122020/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;http://alimy.me/post/dev_201603122010&#34; title=&#34;Convert json to a java object&#34;&gt;Earlier&lt;/a&gt; tutorial we saw how to convert json to a java object. In this tutorial, we build a tree of com.google.gson.JsonElement from the json string. The tree can then be traversed to build java objects. JsonElement has methods such as isJsonObject(), isJsonNull(), etc that can be used to figure out the type of JsonElement. Then to get the actual object use the getAsJsonObject(), getAsJsonPrimitive() etc methods. We parse the response from the free music archive json API. Here&amp;rsquo;s the class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.commons.io.IOUtils;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class ParseTreeExample6 {
	public static void main(String[] args) throws MalformedURLException, IOException {
		String url = &amp;quot;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=5&amp;quot;;
		String json = IOUtils.toString(new URL(url));
		JsonParser parser = new JsonParser();
		// The JsonElement is the root node. It can be an object, array, null or
		// java primitive.
		JsonElement element = parser.parse(json);
		// use the isxxx methods to find out the type of jsonelement. In our
		// example we know that the root object is the Albums object and
		// contains an array of dataset objects
		if (element.isJsonObject()) {
			JsonObject albums = element.getAsJsonObject();
			System.out.println(albums.get(&amp;quot;title&amp;quot;).getAsString());
			JsonArray datasets = albums.getAsJsonArray(&amp;quot;dataset&amp;quot;);
			for (int i = 0; i &amp;lt; datasets.size(); i++) {
				JsonObject dataset = datasets.get(i).getAsJsonObject();
				System.out.println(dataset.get(&amp;quot;album_title&amp;quot;).getAsString());
			}
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-parse-json-to-java-tree.jsp&#34; title=&#34;Convert json to a java object tree&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gson: parsing json to java token by token</title>
      <link>http://alimy.me/post/dev_201603122015/</link>
      <pubDate>Sat, 12 Mar 2016 20:15:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122015/</guid>
      <description>&lt;p&gt;In the earlier tutorials we saw how to &lt;a href=&#34;http://alimy.me/post/dev_201603122010&#34; title=&#34;Convert json to a java object&#34;&gt;convert json to a java object&lt;/a&gt;. In This tutorial we see how to parse json and obtain individual tokens. Although this may seem like a cumbersome way to build java object from json, however it is extremely powerful and may be a good choice if you need a very high level of control over the parsing. We use the JsonReader class to read the json as a stream of tokens. The beginning of an object or an array is also a token. Here&amp;rsquo;s a detailed example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.io.IOException;
import java.io.StringReader;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.commons.io.IOUtils;

import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;

public class ParseTokenExample7
{
	public static void main(String[] args) throws MalformedURLException, IOException
	{
		String url = &amp;quot;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=1&amp;quot;;
		String json = IOUtils.toString(new URL(url));
		// use the reader to read the json to a stream of tokens
		JsonReader reader = new JsonReader(new StringReader(json));
		// we call the handle object method to handle the full json object. This
		// implies that the first token in JsonToken.BEGIN_OBJECT, which is
		// always true.
		handleObject(reader);
	}

	/**
	 * Handle an Object. Consume the first token which is BEGIN_OBJECT. Within
	 * the Object there could be array or non array tokens. We write handler
	 * methods for both. Noe the peek() method. It is used to find out the type
	 * of the next token without actually consuming it.
	 *
	 * @param reader
	 * @throws IOException
	 */
	private static void handleObject(JsonReader reader) throws IOException
	{
		reader.beginObject();
		while (reader.hasNext()) {
			JsonToken token = reader.peek();
			if (token.equals(JsonToken.BEGIN_ARRAY))
				handleArray(reader);
			else if (token.equals(JsonToken.END_OBJECT)) {
				reader.endObject();
				return;
			} else
				handleNonArrayToken(reader, token);
		}

	}

	/**
	 * Handle a json array. The first token would be JsonToken.BEGIN_ARRAY.
	 * Arrays may contain objects or primitives.
	 *
	 * @param reader
	 * @throws IOException
	 */
	public static void handleArray(JsonReader reader) throws IOException
	{
		reader.beginArray();
		while (true) {
			JsonToken token = reader.peek();
			if (token.equals(JsonToken.END_ARRAY)) {
				reader.endArray();
				break;
			} else if (token.equals(JsonToken.BEGIN_OBJECT)) {
				handleObject(reader);
			} else if (token.equals(JsonToken.END_OBJECT)) {
				reader.endObject();
			} else
				handleNonArrayToken(reader, token);
		}
	}

	/**
	 * Handle non array non object tokens
	 *
	 * @param reader
	 * @param token
	 * @throws IOException
	 */
	public static void handleNonArrayToken(JsonReader reader, JsonToken token) throws IOException
	{
		if (token.equals(JsonToken.NAME))
			System.out.println(reader.nextName());
		else if (token.equals(JsonToken.STRING))
			System.out.println(reader.nextString());
		else if (token.equals(JsonToken.NUMBER))
			System.out.println(reader.nextDouble());
		else
			reader.skipValue();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-parse-json-token-by-token.jsp&#34; title=&#34;parsing json to java token by token&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gson: Convert json to a java object</title>
      <link>http://alimy.me/post/dev_201603122010/</link>
      <pubDate>Sat, 12 Mar 2016 20:10:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122010/</guid>
      <description>&lt;p&gt;Google json provides methods to convert the json string to java objects. The Java object may be hierarchical. For this example we consider java objects of non generic type only. Gson uses the name to match the json property to the java field. There are two ways to convert json to java.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Using the com.google.gson.Gson class. Create a new instance of this class and use the method public &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT). classOfT is the java object to which the json is to be converted to.&lt;/li&gt;
&lt;li&gt;The other way is to use the com.google.gson.GsonBuilder class. This class allows setting up certain features, such as - allowing null serialization or setting up custom serializing policies. Create a GsonBuilder, apply the features and then obtain the Gson class from the builder.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this tutorial we look at the Gson class to de-serialize json from &lt;a href=&#34;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=5&#34; title=&#34;free music archive&#34;&gt;free music archive&lt;/a&gt;. The main class is the Albums class and it contains the list of Datasets. Each Dataset is one album. The way to approach the problem of deserialization is to build a java class such that the when Gson converts the Java class to JSON, the resultant JSON resembles the one we are trying to parse. Lets see this in action. If you look at the JSON, it starts with a root object that has properties such as title, message, errors, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
title: &amp;quot;Free Music Archive - Albums&amp;quot;,
message: &amp;quot;&amp;quot;,
errors: [ ],
total: &amp;quot;11259&amp;quot;,
total_pages: 2252,
page: 1,
limit: &amp;quot;5&amp;quot;,
dataset: [
{
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets ignore the dataset for now. Lets just build a java class to hold the root. We call that class Albums. We will make the fields public for brevity, but you might want to make them private and use setters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Albums {
	public String title;
	public String message;
	public String[] errors = new String[]{};
	public String total;
	public int total_pages;
	public int page;
	public String limit;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets convert this to JSON and see how it looks&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import com.google.gson.Gson;

public class JavaToJsonAndBack {

	public static void main(String[] args) {
		Albums albums = new Albums();
		albums.title = &amp;quot;Free Music Archive - Albums&amp;quot;;
		albums.message = &amp;quot;&amp;quot;;
		albums.total = &amp;quot;11259&amp;quot;;
		albums.total_pages = 2252;
		albums.page = 1;
		albums.limit = &amp;quot;5&amp;quot;;
		GsonBuilder builder = new GsonBuilder();
		Gson gson = builder.create();
		System.out.println(gson.toJson(albums));

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how the resulting JSON looks like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;title&amp;quot;:&amp;quot;Free Music Archive - Albums&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;errors&amp;quot;:[],
&amp;quot;total&amp;quot;:&amp;quot;11259&amp;quot;,&amp;quot;total_pages&amp;quot;:2252,&amp;quot;page&amp;quot;:1,&amp;quot;limit&amp;quot;:&amp;quot;5&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a good beginning. Notice how we initialized errors to an empty array. Otherwise Gson would think its null and either ignore it or print null if we allow null serialization. In this case, it looks like we are better off with using a List for errors. Lets change the errors variable to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public List&amp;lt;String&amp;gt; errors = new ArrayList&amp;lt;String&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have used a GsonBuilder since that allows us to customize the conversion. we will see its benefit later in the example. The next step is to build a class for the dataset. Lets see how the dataset JSON looks&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dataset: [
{
album_id: &amp;quot;7596&amp;quot;,
album_title: &amp;quot;!!! - Live @ KEXP 7/24/2010&amp;quot;,
......
album_images: [
{
image_id: &amp;quot;10574&amp;quot;,
user_id: null,
.....
}
],
tags: [ ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this tutorial we will be considering only some fields from &amp;lsquo;dataset&amp;rsquo; and &amp;lsquo;album_images&amp;rsquo;. The other fields can be added similarly. The dataset contains an array of album and each album contains, besides other fields, an array of album_images. We build a java class for each JSON object. We have already built a java class for albums. Now lets built classes for dataset and album_image.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Dataset {
	public String album_id;
	public String album_title;
}

class AlbumImages {
	public String image_id;
	public String user_id;
}
Lets create a Dataset.
Dataset dataset = new Dataset();
dataset.album_id = &amp;quot;7596&amp;quot;;
dataset.album_title = &amp;quot;Album 1&amp;quot;;
System.out.println(gson.toJson(dataset));
the json
{&amp;quot;album_id&amp;quot;:&amp;quot;7596&amp;quot;,&amp;quot;album_title&amp;quot;:&amp;quot;Album 1&amp;quot;}
The album image
AlbumImages image = new AlbumImages();
image.image_id = &amp;quot;1&amp;quot;;
System.out.println(gson.toJson(image));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The album image json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;image_id&amp;quot;:&amp;quot;1&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See how gson has not printed user_id since its null. We need to be able to tell json to serialize null fields too. GsonBuilder helps us do that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;builder.serializeNulls();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The album image json now looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;image_id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;user_id&amp;quot;:null}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets now wire up the dataset into the albums class and the AlbumImage into the dataset class. To the Albums class we add the List of Dataset&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Dataset&amp;gt; dataset  = new ArrayList&amp;lt;Dataset&amp;gt;();
To the Dataset class we add a List of images
List&amp;lt;AlbumImages&amp;gt; images = new ArrayList&amp;lt;AlbumImages&amp;gt;();
Lets change the main method to add dataset to the album and image to the dataset
dataset.images.add(image);
albums.dataset.add(dataset);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how our JSON looks now&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;title&amp;quot;:&amp;quot;Free Music Archive - Albums&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;errors&amp;quot;:[],&amp;quot;total&amp;quot;:&amp;quot;11259&amp;quot;,
&amp;quot;total_pages&amp;quot;:2252,&amp;quot;page&amp;quot;:1,&amp;quot;limit&amp;quot;:&amp;quot;5&amp;quot;,
&amp;quot;dataset&amp;quot;:[{&amp;quot;album_id&amp;quot;:&amp;quot;7596&amp;quot;,&amp;quot;album_title&amp;quot;:&amp;quot;Album 1&amp;quot;,
&amp;quot;images&amp;quot;:[{&amp;quot;image_id&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;user_id&amp;quot;:null}]}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets turn on pretty printing so that our JSON looks better. However, we do that only during developement. If you are actually designing a server that provides JSON data, then make the JSON as compact as possible.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;builder.setPrettyPrinting().serializeNulls();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s our formatted JSON now&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;title&amp;quot;: &amp;quot;Free Music Archive - Albums&amp;quot;,
  &amp;quot;message&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;errors&amp;quot;: [],
  &amp;quot;total&amp;quot;: &amp;quot;11259&amp;quot;,
  &amp;quot;total_pages&amp;quot;: 2252,
  &amp;quot;page&amp;quot;: 1,
  &amp;quot;limit&amp;quot;: &amp;quot;5&amp;quot;,
  &amp;quot;dataset&amp;quot;: [
    {
      &amp;quot;album_id&amp;quot;: &amp;quot;7596&amp;quot;,
      &amp;quot;album_title&amp;quot;: &amp;quot;Album 1&amp;quot;,
      &amp;quot;images&amp;quot;: [
        {
          &amp;quot;image_id&amp;quot;: &amp;quot;1&amp;quot;,
          &amp;quot;user_id&amp;quot;: null
        }
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks good, however we want to change the name of the &amp;lsquo;images&amp;rsquo; element in dataset to &amp;lsquo;album_images&amp;rsquo;. Lets assume we cant change the java name because it follows the java naming policy. We can use annotation on the field to specify the json name to use for a particular java property. Here&amp;rsquo;s how to do that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@SerializedName(&amp;quot;album_images&amp;quot;)
List&amp;lt;AlbumImages&amp;gt; images = new ArrayList&amp;lt;AlbumImages&amp;gt;();
our JSON now contains the name &#39;album_images&#39;
&amp;quot;dataset&amp;quot;: [
    {
      &amp;quot;album_id&amp;quot;: &amp;quot;7596&amp;quot;,
      &amp;quot;album_title&amp;quot;: &amp;quot;Album 1&amp;quot;,
      &amp;quot;album_images&amp;quot;: [
        {
          &amp;quot;image_id&amp;quot;: &amp;quot;1&amp;quot;,
     .........
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you dont want to bind your java class to GSON then there is another way to do this. Lets add one more field to the AlbumImage class. We call it albumId. However, we want to name the field album_id in the JSON. To do that we need to specify a NamingStrategy in the GsonBuilder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;builder.setFieldNamingStrategy(new FieldNamingStrategy() {

			@Override
			public String translateName(Field f) {
				if (f.getName().equals(&amp;quot;albumId&amp;quot;))
					return &amp;quot;album_id&amp;quot;;
				else
					return f.getName();
			}
		});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The translateName method is called for all fields and if the name matches albumId we convert the name to album_id and send it back otherwise we send the default. the album_images element now looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;quot;album_images&amp;quot;: [
        {
          &amp;quot;image_id&amp;quot;: &amp;quot;1&amp;quot;,
          &amp;quot;user_id&amp;quot;: null,
          &amp;quot;album_id&amp;quot;: &amp;quot;10&amp;quot;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GsonBuilder provides a lot of other customization. You can disable HTML escaping, exclude fields with specific modifiers (e.g. exclude all protected fields), set custom type adapters, set exclusion policies etc. Look at the GsonBuilder JavaDoc for the complete list. You can now use the Albums class and parse the JSON using the fromJson method (you will have to add the other properties)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// url is the free music archive url.
Albums albums = gson.fromJson(IOUtils.toString(new URL(url)), Albums.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we close the tutorial lets look at the complete class. we would appreciate if you could &amp;lsquo;Like us&amp;rsquo; on Facebook and &amp;lsquo;Follow us&amp;rsquo; on Google. The Albums class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Albums {
	public String title;
	public String message;
	public List errors = new ArrayList();
	public String total;
	public int total_pages;
	public int page;
	public String limit;
	List dataset = new ArrayList();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Dataset class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Dataset {
	public String album_id;
	public String album_title;
	@SerializedName(&amp;quot;album_images&amp;quot;)
	List&amp;lt;&amp;lt;AlbumImages&amp;gt; images = new ArrayList&amp;lt;AlbumImages&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The AlbumImage class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AlbumImages {
	public String image_id;
	public String user_id;
	public String albumId;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
		Albums albums = new Albums();
		albums.title = &amp;quot;Free Music Archive - Albums&amp;quot;;
		albums.message = &amp;quot;&amp;quot;;
		albums.total = &amp;quot;11259&amp;quot;;
		albums.total_pages = 2252;
		albums.page = 1;
		albums.limit = &amp;quot;5&amp;quot;;
		GsonBuilder builder = new GsonBuilder();
		builder.setPrettyPrinting().serializeNulls();
		builder.setFieldNamingStrategy(new FieldNamingStrategy() {

			@Override
			public String translateName(Field f) {
				if (f.getName().equals(&amp;quot;albumId&amp;quot;))
					return &amp;quot;album_id&amp;quot;;
				else
					return f.getName();
			}
		});
		Gson gson = builder.create();

		Dataset dataset = new Dataset();
		dataset.album_id = &amp;quot;7596&amp;quot;;
		dataset.album_title = &amp;quot;Album 1&amp;quot;;

		AlbumImages image = new AlbumImages();
		image.image_id = &amp;quot;1&amp;quot;;
		image.albumId = &amp;quot;10&amp;quot;;
		dataset.images.add(image);
		albums.dataset.add(dataset);

		System.out.println(gson.toJson(albums));

	}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-parse-json-to-java.jsp&#34; title=&#34;Convert json to a java object&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gson: Introduction</title>
      <link>http://alimy.me/post/dev_201603122005/</link>
      <pubDate>Sat, 12 Mar 2016 20:05:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122005/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/google/gson&#34; title=&#34;Gson@github&#34;&gt;google json&lt;/a&gt; - gson is an open source java api for parsing and building json. It has extensive support for java generics. It also provides support for converting third party classes to json. It can be used to serialize and deserialize complex objects with deep hierarchies that may contain generic classes. In these tutorials we demonstrate, with examples, the following functionalities of gson.&lt;/p&gt;

&lt;p&gt;Gson 2.3: Look at &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-new-2.3.jsp&#34; title=&#34;gson tutorial&#34;&gt;this tutorial&lt;/a&gt; to see the
latest additions in Gson 2.3 (TypeAdapter Annotation, JsonPath support and new methods in JsonArray)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122010&#34; title=&#34;Java to JSON and Back - Data Binding&#34;&gt;Java to JSON and Back - Data Binding&lt;/a&gt; - In this example we look at how to bind a Json to a java object. Gson is quite powerful when it comes to binding a json to Java since it has a lot of built in serializers and deserializers. A serializer has code that helps in converting a Json string to corresponding java type. For example if you have an array in JSON (elements enclosed in &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;) and you want to convert that to a Java array then Gson would internally use an ArrayTypeAdapter to convert the Json Array to Java Array and back. If you are looking at Gson primarily to parse JSON then we would suggest that you start with a simple Java class, convert that to JSON and make sure it looks like the JSON that you want to parse. You can then gradually start adding complexities to the java class and at each step convert it to a JSON and ensure that the JSON is similar to the one that you are trying to parse. It is good to think of parsing a JSON as creating a java class that can give you the JSON that you want to parse. Also note that you have certain flexibility while creating the java object. You could represent a Json Array as a Java array or a Java List. The choice may be driven more by how you want to use the class. If you map a Json property to a java array Gson would use an Array adapter but if you map it to a List it would use the collection adapter and you, the user, does not have to worry about that. Gson also handles null gracefully&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122015&#34; title=&#34;Java to JSON and Back - Streaming&#34;&gt;Java to JSON and Back - Streaming&lt;/a&gt; - At certain times you want more control on the way the parsing is done. Also there may be times when Gson automated conversion does not give you the result that you are looking for. For example, if you have a List that contains multiple kinds of Object then Gson may not be able to deserialize or parse the Json for you. In such cases Gson provides a streaming API. You can use the Streaming API and handle a token at a time. The token may be start and end of Json Object, start and end of json array, the key of a property and the String or Number value of a property.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122020&#34; title=&#34;Java to JSON and Back - Tree representation&#34;&gt;Java to JSON and Back - Tree representation&lt;/a&gt; - The first two examples look at how to convert JSON to Java using data binding and a Streaming API. This tutorial explains a third way to parse JSON, i.e. by building a Java tree representation of the JSON. The nodes of the tree may either be a JsonObject or a JsonArray. The JsonObject has methods to retrive the key-value pairs of the JSON. The JsonArray provides way to iterate over the elements of the array which are themselves either a JsonObject or a JsonArray.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122022&#34; title=&#34;Serializing a list&#34;&gt;Serializing a list&lt;/a&gt; - Serializing Collections require special treatment since the Collections are of generic type and the type information is lost while converting to JSON due to java type erasure. Gson handles this by embedding the type in the serialized json. This tutorial explains how to do that.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122025&#34; title=&#34;Serializing and deserializing Java Generic Classes&#34;&gt;Serializing and deserializing Java Generic Classes&lt;/a&gt; - In the first example we saw how to bind a java Object to JSON. However, the example there did not show how Gson can handle classes with generic type. In this example we see how a class with a generic type can be handled. the idea is to embed the type information in the json itself so that Gson can recreate the Java Object along with the correct generic type while deserializing the JSON.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122028&#34; title=&#34;Serializing Inner Classes&#34;&gt;Serializing Inner Classes&lt;/a&gt; - GSON provides ways to serialize inner classes. The example in this tutorial explains the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Serializing class containing static nested class&lt;/li&gt;
&lt;li&gt;Serializing class containing non static nested class (Inner class)&lt;/li&gt;
&lt;li&gt;De-serializing json to a class containing static and non static inner class&lt;/li&gt;
&lt;li&gt;Serializing static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;Serializing non static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;De-serializing json to a static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;De-serializing json to a non static nested class (without the enclosing type)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122030&#34; title=&#34;Using Custom type adapters&#34;&gt;Using Custom type adapters&lt;/a&gt; - GSON provides pre definied type adapters that are called when serializing or deserializing certain java types. For example an ArrayTypeAdapter is called when Gson encounters a Java Array that needs to be converted to JSON. In most cases the TypeAdapters provided by GSON would suffice, however in certain cases you may want to write your own adapters. There are two reasons for doing that i) You want to change the default behavious ii) GSON does not provide adapter for your class.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122035&#34; title=&#34;Using Custom Serialization and Deserialization classes&#34;&gt;Using Custom Serialization and Deserialization classes&lt;/a&gt; - In the previous example we saw how JSON provides a way to write a custom adapter. In this example we see how to write a custom serializer or deserializer.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603122040&#34; title=&#34;Excluding certain fields from Java classes&#34;&gt;Excluding certain fields from Java classes&lt;/a&gt; - Your java class may be used by various other layers of the application. In some cases your java class may have properties that you want GSON to ignore from serialization. This example provides three ways to exclude properties from serialization and de serialization.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Custom annotations&lt;/li&gt;
&lt;li&gt;Using custom Exclusion Strategies&lt;/li&gt;
&lt;li&gt;Using @Expose annotation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-introduction.jsp&#34; title=&#34;Java Google Json Introduction&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: Json Polymorphism</title>
      <link>http://alimy.me/post/dev_201603112105/</link>
      <pubDate>Fri, 11 Mar 2016 21:05:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112105/</guid>
      <description>

&lt;p&gt;Jackson provides a way to maintain sub type information while serializing java objects. It is possible to recreate the exact sub type. The type information can be embedded into the json as a property. In the example below we create a zoo, that has a list of animals. The animal may be an elephant or a lion, and they both extend the Animal abstract class. While deserializing we want to create the exact animal type. We also demonstrate the use of @JsonTypeInfo and @JsonSubTypes annotations.&lt;/p&gt;

&lt;h3 id=&#34;data-serialization-and-polymorphism-example:46b64fca9632a887d3524460bdf45d73&#34;&gt;Data Serialization and Polymorphism Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class SerializeExample1 {
    private static String outputFile = &amp;quot;zoo.json&amp;quot;;

    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {
        // let start creating the zoo
        Zoo zoo = new Zoo(&amp;quot;Samba Wild Park&amp;quot;, &amp;quot;Paz&amp;quot;);
        Lion lion = new Lion(&amp;quot;Simba&amp;quot;);
        Elephant elephant = new Elephant(&amp;quot;Manny&amp;quot;);
        List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;();
        animals.add(lion);
        animals.add(elephant);
        zoo.setAnimals(animals);

        ObjectMapper mapper = new ObjectMapper();
        mapper.writerWithDefaultPrettyPrinter().writeValue(new FileWriter(new File(outputFile)), zoo);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we look at the various classes, lets also see how to deserialize this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.File;
import java.io.IOException;

import org.apache.commons.io.FileUtils;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class DeSerializeExample1 {

    public static void main(String[] args) throws JsonParseException, JsonMappingException, IOException {
        ObjectMapper mapper = new ObjectMapper();
        Zoo zoo = mapper.readValue(FileUtils.readFileToByteArray(new File(&amp;quot;zoo.json&amp;quot;)), Zoo.class);
        System.out.println(zoo);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;zoo-class:46b64fca9632a887d3524460bdf45d73&#34;&gt;Zoo class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeInfo.As;

@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS, include = As.PROPERTY, property = &amp;quot;@class&amp;quot;)
public class Zoo {

    public String name;
    public String city;
    public List&amp;lt;Animal&amp;gt; animals;

    @JsonCreator
    public Zoo(@JsonProperty(&amp;quot;name&amp;quot;) String name, @JsonProperty(&amp;quot;city&amp;quot;) String city) {
        this.name = name;
        this.city = city;
    }

    public void setAnimals(List&amp;lt;animal&amp;gt; animals) {
        this.animals = animals;
    }

    @Override
    public String toString() {
        return &amp;quot;Zoo [name=&amp;quot; + name + &amp;quot;, city=&amp;quot; + city + &amp;quot;, animals=&amp;quot; + animals + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;animal-abstract-class:46b64fca9632a887d3524460bdf45d73&#34;&gt;Animal Abstract class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeInfo.As;

@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = As.PROPERTY, property = &amp;quot;@class&amp;quot;)
@JsonSubTypes({ @Type(value = Lion.class, name = &amp;quot;lion&amp;quot;), @Type(value = Elephant.class, name = &amp;quot;elephant&amp;quot;) })
public abstract class Animal {
    @JsonProperty(&amp;quot;name&amp;quot;)
    String name;
    @JsonProperty(&amp;quot;sound&amp;quot;)
    String sound;
    @JsonProperty(&amp;quot;type&amp;quot;)
    String type;
    @JsonProperty(&amp;quot;endangered&amp;quot;)
    boolean endangered;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;lion-class:46b64fca9632a887d3524460bdf45d73&#34;&gt;Lion class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class Lion extends Animal {

    private String name;

    @JsonCreator
    public Lion(@JsonProperty(&amp;quot;name&amp;quot;) String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getSound() {
        return &amp;quot;Roar&amp;quot;;
    }

    public String getType() {
        return &amp;quot;carnivorous&amp;quot;;
    }

    public boolean isEndangered() {
        return true;
    }

    @Override
    public String toString() {
        return &amp;quot;Lion [name=&amp;quot; + name + &amp;quot;, getName()=&amp;quot; + getName() + &amp;quot;, getSound()=&amp;quot; + getSound() + &amp;quot;, getType()=&amp;quot; + getType() + &amp;quot;, isEndangered()=&amp;quot;
                + isEndangered() + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;elephant-class:46b64fca9632a887d3524460bdf45d73&#34;&gt;Elephant class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class Elephant extends Animal {

    @JsonProperty
    private String name;

    @JsonCreator
    public Elephant(@JsonProperty(&amp;quot;name&amp;quot;) String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getSound() {
        return &amp;quot;trumpet&amp;quot;;
    }

    public String getType() {
        return &amp;quot;herbivorous&amp;quot;;
    }

    public boolean isEndangered() {
        return false;
    }

    @Override
    public String toString() {
        return &amp;quot;Elephant [name=&amp;quot; + name + &amp;quot;, getName()=&amp;quot; + getName() + &amp;quot;, getSound()=&amp;quot; + getSound() + &amp;quot;, getType()=&amp;quot; + getType()
                + &amp;quot;, isEndangered()=&amp;quot; + isEndangered() + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-Serialization-polymorphism.jsp&#34; title=&#34;Json Polymorphism&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: jackson Mix- In Annotations</title>
      <link>http://alimy.me/post/dev_201603112100/</link>
      <pubDate>Fri, 11 Mar 2016 21:00:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112100/</guid>
      <description>

&lt;p&gt;Annotations are a great way to manage serialization and deserialization in Jackson. However, what do you do if you want to annotate a third party class, or if you dont want to tightly couple your POJOs to jackson annotations. This is where Mix-in comes into play. You define a mix-in abstract class that is kind of a proxy to the actual class. Annotations are then definied over this proxy class&lt;/p&gt;

&lt;h3 id=&#34;jackson-mix-in-example:7634bf28f621093315cf4d8b563f8a36&#34;&gt;Jackson Mix-In Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.File;
import java.io.IOException;

import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class SerializeExample3 {
    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {
        ObjectMapper mapper = new ObjectMapper();
        mapper.addMixInAnnotations(Bird.class, BirdMixIn.class);
        Bird bird = new Bird(&amp;quot;scarlet Ibis&amp;quot;);
        bird.setSound(&amp;quot;eee&amp;quot;);
        bird.setHabitat(&amp;quot;water&amp;quot;);

        mapper.writerWithDefaultPrettyPrinter().writeValue(new File(&amp;quot;bird.json&amp;quot;), bird);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-bird-class:7634bf28f621093315cf4d8b563f8a36&#34;&gt;The Bird class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

public class Bird {

    private String name;
    private String sound;
    private String habitat;

    public Bird(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getSound() {
        return sound;
    }

    public String getHabitat() {
        return habitat;
    }

    public void setSound(String sound) {
        this.sound = sound;
    }

    public void setHabitat(String habitat) {
        this.habitat = habitat;
    }

    @Override
    public String toString() {
        return &amp;quot;Bird [name=&amp;quot; + name + &amp;quot;, sound=&amp;quot; + sound + &amp;quot;, habitat=&amp;quot; + habitat + &amp;quot;]&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-mix-in-class:7634bf28f621093315cf4d8b563f8a36&#34;&gt;The Mix-in class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonProperty;

public abstract class BirdMixIn {
    BirdMixIn(@JsonProperty(&amp;quot;name&amp;quot;) String name) {
    };

    @JsonProperty(&amp;quot;sound&amp;quot;)
    abstract String getSound();

    @JsonProperty(&amp;quot;habitat&amp;quot;)
    abstract String getHabitat();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-mix-in-annotation.jsp&#34; title=&#34;jackson Mix- In Annotations&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: Json data binding filters</title>
      <link>http://alimy.me/post/dev_201603112055/</link>
      <pubDate>Fri, 11 Mar 2016 20:55:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112055/</guid>
      <description>

&lt;p&gt;Jackson provides an effective an efficient way to bind json to POJOs. However, at times, certain properties may need to be ignored while converting a json to java ojbect and a java object to json string. Jackson provides three ways to filter properties.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;@JsonIgnoreProperties- This annotation can be used at the type level to ignore json properties. In the example below we ignore the &amp;lsquo;tags&amp;rsquo; property from the albums dataset.&lt;/li&gt;
&lt;li&gt;@JsonIgnore - This annotation can be set at property level to ignore certain properties.&lt;/li&gt;
&lt;li&gt;Using Custom filters&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The example below shows method 1 and 2. Also note the use of the @JsonAutoDetect annotation.&lt;/p&gt;

&lt;h3 id=&#34;data-binding-filters-example:36264cd232902e18141acc789ff21fa2&#34;&gt;Data Binding Filters Example&lt;/h3&gt;

&lt;h4 id=&#34;databinding:36264cd232902e18141acc789ff21fa2&#34;&gt;Databinding&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.JsonProperty;

// Do not use fields to autodetect. use the public getter methods to autodetect properties
@JsonAutoDetect(fieldVisibility = Visibility.NONE, getterVisibility = Visibility.PUBLIC_ONLY)
public class AlbumsFilter {

    private String title;
    private DatasetFilter[] datasetFilter;
    public String total_pages;

    protected String getTotal_pages() {
        return total_pages;
    }

    public String getTitle() {
        return title;
    }

    // this getter method is for the &#39;dataset&#39; property
    @JsonProperty(&amp;quot;dataset&amp;quot;)
    public DatasetFilter[] getDatasetFilter() {
        return datasetFilter;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;datasetfilter-class:36264cd232902e18141acc789ff21fa2&#34;&gt;DatasetFilter class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

// ignore the property with name &#39;tags&#39;.
@JsonIgnoreProperties({ &amp;quot;tags&amp;quot; })
public class DatasetFilter {
    private String album_id;
    private String album_title;
    private Map&amp;lt;String , Object&amp;gt; otherProperties = new HashMap&amp;lt;String , Object&amp;gt;();
    private String album_comments;

    @JsonCreator
    public DatasetFilter(@JsonProperty(&amp;quot;album_id&amp;quot;) String album_id, @JsonProperty(&amp;quot;album_title&amp;quot;) String album_title) {
        this.album_id = album_id;
        this.album_title = album_title;
    }

    // ignore the property specified by this getter.
    @JsonIgnore
    public String getAlbum_comments() {
        return album_comments;
    }

    public String getAlbum_id() {
        return album_id;
    }

    public void setAlbum_id(String album_id) {
        this.album_id = album_id;
    }

    public String getAlbum_title() {
        return album_title;
    }

    public void setAlbum_title(String album_title) {
        this.album_title = album_title;
    }

    public Object get(String name) {
        return otherProperties.get(name);
    }

    // this method is used to get all properties not specified earlier.
    @JsonAnyGetter
    public Map&amp;lt;String , Object&amp;gt; any() {
        return otherProperties;
    }

    @JsonAnySetter
    public void set(String name, Object value) {
        otherProperties.put(name, value);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-data-binding-filters.jsp&#34; title=&#34;Json data binding filters&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: Json annotations and dyna beans</title>
      <link>http://alimy.me/post/dev_201603112050/</link>
      <pubDate>Fri, 11 Mar 2016 20:50:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112050/</guid>
      <description>

&lt;p&gt;The json string at times have a lot of properties. It seems a waste creating a POJO with all those properties. Wouldnt it be great if there was a catch&amp;rsquo;all that could read all properties in a map? Jackson provides annotations to do just that. In the example below we have set two properties in the bean and the other properties are read into a map. These example also introduces some common annotations using in Jackson. Lets look at them briefly:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;@JsonProperty-This annotation is used to mark a method as a getter or setter for a property. In other words, it associates a json field with a java property. If a name is specified (@JsonProperty(&amp;ldquo;age&amp;rdquo;)) then the java property that is annotated with this annotation is mapped to the &amp;lsquo;age&amp;rsquo; field of the json, If no name is specified the java property name is used.&lt;/li&gt;
&lt;li&gt;@JsonCreator-This annotation is used the define constructors that are used to create java objects from json string. It is used during data binding and specifies properties that will be used to create java objects during deserialization.&lt;/li&gt;
&lt;li&gt;@JsonAnyGetter and @JsonAnySetter - This annotations are used to mark methods that set or read fields that are not handled by any other java property. These act like catch-all and handle all fields that are not handled by any other java property. The fields are stored in a map as key value pairs.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;data-binding-example:bbe5bd370d848e969f04326afa884de3&#34;&gt;Data Binding Example&lt;/h3&gt;

&lt;h4 id=&#34;databinding:bbe5bd370d848e969f04326afa884de3&#34;&gt;Databinding&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

public class AlbumsDynamic {

    private String title;
    private DatasetDynamic[] dataset;

    public void setTitle(String title) {
        this.title = title;
    }

    public void setDataset(DatasetDynamic[] dataset) {
        this.dataset = dataset;
    }

    public String getTitle() {
        return title;
    }

    public DatasetDynamic[] getDataset() {
        return dataset;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dataset-class:bbe5bd370d848e969f04326afa884de3&#34;&gt;Dataset class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class DatasetDynamic {
    private String album_id;
    private String album_title;
    private Map&amp;lt;String , Object&amp;gt; otherProperties = new HashMap&amp;lt;String , Object&amp;gt;();

    @JsonCreator
    public DatasetDynamic(@JsonProperty(&amp;quot;album_id&amp;quot;) String album_id, @JsonProperty(&amp;quot;album_title&amp;quot;) String album_title) {
        this.album_id = album_id;
        this.album_title = album_title;
    }

    public String getAlbum_id() {
        return album_id;
    }

    public void setAlbum_id(String album_id) {
        this.album_id = album_id;
    }

    public String getAlbum_title() {
        return album_title;
    }

    public void setAlbum_title(String album_title) {
        this.album_title = album_title;
    }

    public Object get(String name) {
        return otherProperties.get(name);
    }

    @JsonAnyGetter
    public Map&amp;lt;String , Object&amp;gt; any() {
        return otherProperties;
    }

    @JsonAnySetter
    public void set(String name, Object value) {
        otherProperties.put(name, value);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-Annotations-Dynamic-Beans.jsp&#34; title=&#34;Json annotations and dyna beans&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: List serialization</title>
      <link>http://alimy.me/post/dev_201603112045/</link>
      <pubDate>Fri, 11 Mar 2016 20:45:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112045/</guid>
      <description>

&lt;p&gt;In this tutorial we will see how to convert a java List to JSON. Serializing list is a little tricky since by default the type info is not stored while serializing and deserializing lists. In this tutorial we look at two examples. In the first example we serialize an Object that has a java List as one of its properties. In the second example we try and serialize the List directly. In both examples we use special configuration to preserve type info.&lt;/p&gt;

&lt;h3 id=&#34;example-1-serializing-object-containing-a-list:cbcae65ab0364befdb15ef6b14f2b41b&#34;&gt;Example 1 : Serializing Object containing a list&lt;/h3&gt;

&lt;p&gt;The example converts a Zoo class to json. the zoo class contains the name of zoo, its city and a list of animals. The list is of type &amp;lsquo;Animal&amp;rsquo;, i.e. the list contains elements that are subclass of the Abstract class Animal. Lets see what happens when we try to serialize zoo. First we create the Zoo class. Notice how the constructor looks. When we try to get the Zoo Object back from the JSON, Jackson has to know that it should create the Zoo Object using the constructor that takes in the name and city properties.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Zoo {
    public String name;
    public String city;


    @JsonCreator
    public Zoo(@JsonProperty(&amp;quot;name&amp;quot;) String name,@JsonProperty(&amp;quot;city&amp;quot;) String city) {
        this.name = name;
        this.city = city;
    }

    public List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;Animal&amp;gt;();

    public List&amp;lt;Animal&amp;gt; addAnimal(Animal animal) {
        animals.add(animal);
        return animals;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Animal is an abstract class. It is further extended to create the Elephant and the Lion class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Elephant extends Animal {

    @JsonCreator
    public Elephant(@JsonProperty(&amp;quot;name&amp;quot;) String name) {
        super.name = name;
    }

    @Override
    public String toString() {
        return &amp;quot;Elephant : &amp;quot; + name;
    }
}

class Lion extends Animal {
    @JsonCreator
    public Lion(@JsonProperty(&amp;quot;name&amp;quot;) String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &amp;quot;Lion: &amp;quot; + name;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets now create a serializer for Zoo. Imagine that the London zoo needs to shift to a larger area. We will have to serialize the zoo from its current location and deserialize it at the target location. (a teleportation machine)&lt;/p&gt;

&lt;p&gt;We use the ObjectMapper class to do the serialization and print the json to console. You could also print it to a file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class SerializeZoo {
    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {
         Zoo zoo = new Zoo(&amp;quot;London Zoo&amp;quot;, &amp;quot;London&amp;quot;);
         Lion lion = new Lion(&amp;quot;Simba&amp;quot;);
         Elephant elephant = new Elephant(&amp;quot;Manny&amp;quot;);
         zoo.addAnimal(elephant).add(lion);
         ObjectMapper mapper = new ObjectMapper();
         mapper.writeValue(System.out, zoo);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok so lets see how our zoo looks like. Remember, we should be able to re create the zoo (along with all its animals) when we deserialize it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;London Zoo&amp;quot;,&amp;quot;city&amp;quot;:&amp;quot;London&amp;quot;,&amp;quot;animals&amp;quot;:[{&amp;quot;name&amp;quot;:&amp;quot;Manny&amp;quot;},{&amp;quot;name&amp;quot;:&amp;quot;Simba&amp;quot;}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clearly our teleporter is not ready. Manny and Simba are in there, but there is nothing in the json that says that Manny is an elephant and Simba is a lion. Lets see what happens when we try to deserialize the zoo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.IOException;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class DeserializeZoo {

    public static void main(String[] args) throws JsonParseException, JsonMappingException, IOException {
        String json = &amp;quot;{\&amp;quot;name\&amp;quot;:\&amp;quot;London Zoo\&amp;quot;,\&amp;quot;city\&amp;quot;:\&amp;quot;London\&amp;quot;,&amp;quot; + &amp;quot;\&amp;quot;animals\&amp;quot;:[{\&amp;quot;name\&amp;quot;:\&amp;quot;Manny\&amp;quot;},{\&amp;quot;name\&amp;quot;:\&amp;quot;Simba\&amp;quot;}]}&amp;quot;;
        ObjectMapper mapper = new ObjectMapper();
        mapper.readValue(json, Zoo.class);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get an error! the error says &amp;ldquo;Can not construct instance of com.studytrails.json.jackson.Animal, problem: abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information&amp;rdquo; . Ok, we were expecting this. Lets see how to resolve it. We need to be able to put the information about the type in the json. There are two things you need
to do this&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Tell Jackson that we need to include the type info for Animal class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = As.PROPERTY, property = &amp;quot;@class&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tell Jackson that Animal can have subclasses Elephant and Lion&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@JsonSubTypes({ @Type(value = Lion.class, name = &amp;quot;lion&amp;quot;), @Type(value = Elephant.class, name = &amp;quot;elephant&amp;quot;) })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see how our json looks now&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;London Zoo&amp;quot;,&amp;quot;city&amp;quot;:&amp;quot;London&amp;quot;,
&amp;quot;animals&amp;quot;:[{&amp;quot;@class&amp;quot;:&amp;quot;com.studytrails.json.jackson.Elephant&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Manny&amp;quot;},
           {&amp;quot;@class&amp;quot;:&amp;quot;com.studytrails.json.jackson.Lion&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Simba&amp;quot;}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks much better. Now, if you read the json back using the Zoo class then it works well and the Zoo class would have a list of animals.&lt;/p&gt;

&lt;h3 id=&#34;example-2-serializing-a-list:cbcae65ab0364befdb15ef6b14f2b41b&#34;&gt;Example 2 : Serializing a list&lt;/h3&gt;

&lt;p&gt;In the previous example we saw how to serialize a class that has a List. In this example lets see how to serialize a list directly. We will use the same Animal, Lion and Elephant classes. Lets see what happens when we try to serialize the list directly (note that we have added the typeinfo annotations to the Animal class)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SerializeAnimals {
    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {
        List&amp;lt;animal&amp;gt; animals = new ArrayList&amp;lt;animal&amp;gt;();
        Lion lion = new Lion(&amp;quot;Samba&amp;quot;);
        Elephant elephant = new Elephant(&amp;quot;Manny&amp;quot;);
        animals.add(lion);
        animals.add(elephant);
        ObjectMapper mapper = new ObjectMapper();

        mapper.writeValue(System.out, animals);
    }
}  



&amp;lt;/animal&amp;gt;&amp;lt;/animal&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives the following json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{&amp;quot;name&amp;quot;:&amp;quot;Samba&amp;quot;},{&amp;quot;name&amp;quot;:&amp;quot;Manny&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No type info! To add type info while serializing Lists directly you need to configure the mapper in this way&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapper.writerWithType(new TypeReference&amp;lt;List
        &amp;lt;Animal&amp;gt;&amp;gt;() {
        }).writeValue(System.out, animals);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This now produces the correct json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{&amp;quot;@class&amp;quot;:&amp;quot;com.studytrails.json.jackson.Lion&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Samba&amp;quot;},
{&amp;quot;@class&amp;quot;:&amp;quot;com.studytrails.json.jackson.Elephant&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Manny&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So to recap, in this tutorial we saw how to i. serialize a Java object containing a List and ii. serialize a list (root object)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-Serialization-list.jsp&#34; title=&#34;jackson List serialization&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
