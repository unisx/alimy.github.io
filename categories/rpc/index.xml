<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rpc on 北 野</title>
    <link>http://alimy.me/categories/rpc/</link>
    <description>Recent content in Rpc on 北 野</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy;2018, Alimy; all rights reserved.</copyright>
    <lastBuildDate>Sat, 21 Sep 2019 16:45:00 +0800</lastBuildDate>
    
	<atom:link href="http://alimy.me/categories/rpc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Protocol Buffers Messages Encoding</title>
      <link>http://alimy.me/post/dev_201909211645/</link>
      <pubDate>Sat, 21 Sep 2019 16:45:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201909211645/</guid>
      <description>&lt;p&gt;This document describes the binary wire format for protocol buffer messages. You don&amp;rsquo;t need to understand this to use protocol buffers in your applications, but it can be very useful to know how different protocol buffer formats affect the size of your encoded messages.&lt;/p&gt;

&lt;h3 id=&#34;a-simple-message&#34;&gt;A Simple Message&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say you have the following very simple message definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;message Test1 {
  optional int32 a = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In an application, you create a &lt;code&gt;Test1&lt;/code&gt; message and set &lt;code&gt;a&lt;/code&gt; to 150. You then serialize the message to an output stream. If you were able to examine the encoded message, you&amp;rsquo;d see three bytes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;08 96 01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, so small and numeric – but what does it mean? Read on&amp;hellip;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cap&#39;n Proto Encoding Spec</title>
      <link>http://alimy.me/post/dev_201909211630/</link>
      <pubDate>Sat, 21 Sep 2019 16:30:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201909211630/</guid>
      <description>&lt;h3 id=&#34;sect-organization&#34;&gt;&amp;sect;Organization&lt;/h3&gt;

&lt;h4 id=&#34;64-bit-words&#34;&gt;64-bit Words&lt;/h4&gt;

&lt;p&gt;For the purpose of Cap’n Proto, a “word” is defined as 8 bytes, or 64 bits. Since alignment of data is important, all objects (structs, lists, and blobs) are aligned to word boundaries, and sizes are usually expressed in terms of words. (Primitive values are aligned to a multiple of their size within a struct or list.)&lt;/p&gt;

&lt;h4 id=&#34;messages&#34;&gt;Messages&lt;/h4&gt;

&lt;p&gt;The unit of communication in Cap’n Proto is a “message”. A message is a tree of objects, with the root always being a struct.&lt;/p&gt;

&lt;p&gt;Physically, messages may be split into several “segments”, each of which is a flat blob of bytes. Typically, a segment must be loaded into a contiguous block of memory before it can be accessed, so that the relative pointers within the segment can be followed quickly. However, when a message has multiple segments, it does not matter where those segments are located in memory relative to each other; inter-segment pointers are encoded differently, as we’ll see later.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tars语言与协议</title>
      <link>http://alimy.me/post/dev_201909211556/</link>
      <pubDate>Sat, 21 Sep 2019 15:56:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201909211556/</guid>
      <description>&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#main-chapter-1&#34;&gt;Tars语言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#main-chapter-2&#34;&gt;Tars协议&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-tars语言-a-id-main-chapter-1-a&#34;&gt;1. Tars语言 &lt;a id=&#34;main-chapter-1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-1-接口文件&#34;&gt;1.1. 接口文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Tars语言是一种类c++标识符的语言，用于生成具体的服务接口文件&lt;/li&gt;
&lt;li&gt;Tars文件是Tars框架中客户端和服务端的通信接口，通过Tars的映射实现远程对象调用&lt;/li&gt;
&lt;li&gt;Tars文件的扩展名必须以.tars为扩展名&lt;/li&gt;
&lt;li&gt;对于结构定义，可以支持扩展字段，即可以增加字段而不影响原有结构的解析，可以在存储/协议等地方单独使用&lt;/li&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Protocol Buffers Version 3 Language Specification</title>
      <link>http://alimy.me/post/dev_201909211536/</link>
      <pubDate>Sat, 21 Sep 2019 15:36:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201909211536/</guid>
      <description>&lt;p&gt;This is a language specification reference for version 3 of the Protocol Buffers language (proto3). The syntax is specified using Extended &lt;a href=&#34;https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form&#34; title=&#34;EBNF in WIKI&#34;&gt;Backus-Naur Form (EBNF)&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|   alternation
()  grouping
[]  option (zero or one time)
{}  repetition (any number of times)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information about using proto3, see the language guide.&lt;/p&gt;

&lt;h3 id=&#34;lexical-elements&#34;&gt;Lexical elements&lt;/h3&gt;

&lt;h4 id=&#34;letters-and-digits&#34;&gt;Letters and digits&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;letter = &amp;quot;A&amp;quot; … &amp;quot;Z&amp;quot; | &amp;quot;a&amp;quot; … &amp;quot;z&amp;quot;
decimalDigit = &amp;quot;0&amp;quot; … &amp;quot;9&amp;quot;
octalDigit   = &amp;quot;0&amp;quot; … &amp;quot;7&amp;quot;
hexDigit     = &amp;quot;0&amp;quot; … &amp;quot;9&amp;quot; | &amp;quot;A&amp;quot; … &amp;quot;F&amp;quot; | &amp;quot;a&amp;quot; … &amp;quot;f&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Protocol Buffers Version 2 Language Specification</title>
      <link>http://alimy.me/post/dev_201909211516/</link>
      <pubDate>Sat, 21 Sep 2019 15:16:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201909211516/</guid>
      <description>&lt;p&gt;This is a language specification reference for version 2 of the Protocol Buffers language (proto2). The syntax is specified using Extended &lt;a href=&#34;https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form&#34; title=&#34;EBNF in WIKI&#34;&gt;Backus-Naur Form (EBNF)&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|   alternation
()  grouping
[]  option (zero or one time)
{}  repetition (any number of times)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information about using proto2, see the language guide.&lt;/p&gt;

&lt;h3 id=&#34;lexical-elements&#34;&gt;Lexical elements&lt;/h3&gt;

&lt;h4 id=&#34;letters-and-digits&#34;&gt;Letters and digits&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;letter = &amp;quot;A&amp;quot; … &amp;quot;Z&amp;quot; | &amp;quot;a&amp;quot; … &amp;quot;z&amp;quot;
capitalLetter =  &amp;quot;A&amp;quot; … &amp;quot;Z&amp;quot;
decimalDigit = &amp;quot;0&amp;quot; … &amp;quot;9&amp;quot;
octalDigit   = &amp;quot;0&amp;quot; … &amp;quot;7&amp;quot;
hexDigit     = &amp;quot;0&amp;quot; … &amp;quot;9&amp;quot; | &amp;quot;A&amp;quot; … &amp;quot;F&amp;quot; | &amp;quot;a&amp;quot; … &amp;quot;f&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Cap&#39;n Proto Schema Language</title>
      <link>http://alimy.me/post/dev_201909211159/</link>
      <pubDate>Sat, 21 Sep 2019 11:59:00 +0800</pubDate>
      
      <guid>http://alimy.me/post/dev_201909211159/</guid>
      <description>&lt;h2 id=&#34;schema-language&#34;&gt;Schema Language&lt;/h2&gt;

&lt;p&gt;Like Protocol Buffers and Thrift (but unlike JSON or MessagePack), Cap’n Proto messages are strongly-typed and not self-describing. You must define your message structure in a special language, then invoke the Cap’n Proto compiler (&lt;code&gt;capnp compile&lt;/code&gt;) to generate source code to manipulate that message type in your desired language.&lt;/p&gt;

&lt;h4 id=&#34;for-example&#34;&gt;For example:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;@0xdbb9ad1f14bf0b36;  # unique file ID, generated by `capnp id`

struct Person {
  name @0 :Text;
  birthdate @3 :Date;

  email @1 :Text;
  phones @2 :List(PhoneNumber);

  struct PhoneNumber {
    number @0 :Text;
    type @1 :Type;

    enum Type {
      mobile @0;
      home @1;
      work @2;
    }
  }
}

struct Date {
  year @0 :Int16;
  month @1 :UInt8;
  day @2 :UInt8;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>