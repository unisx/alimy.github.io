<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Transport on 牧 野 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://alimy.me/categories/transport/</link>
    
    
    <copyright>&amp;copy;2018, Alimy; all rights reserved.</copyright>
    <updated>Thu, 24 Mar 2016 22:55:00 CST</updated>
    
    <item>
      <title>Makefile:简介</title>
      <link>http://alimy.me/post/dev_201603242255/</link>
      <pubDate>Thu, 24 Mar 2016 22:55:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603242255/</guid>
      <description>&lt;p&gt;Make 可以简化编译过程，如果有一个近百个源文件的项目，如果有个文件更改后工程需要重新编译，那么一直用gcc -c a.c这些个命令敲来敲去会屎人的。运行make时候，他会寻找指定目录下（默认是 .）的 Makefile 文件并且分析依赖关系进行必要的编译。&lt;/p&gt;

&lt;h3 id=&#34;makefile文件的基本格式很简单&#34;&gt;Makefile文件的基本格式很简单：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;目标文件： 依赖文件1 依赖文件2 依赖文件3 。。。。
[tab]编译命令
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他的意思是目标文件是依赖于冒号后面几个文件的，如果这些依赖文件有更新的，那么其目标文件也需要更新。&lt;/p&gt;

&lt;p&gt;Makefile 中可能有很多以上条目，他们共同组成了一个有向无回路图（DAG图），这样可以传递依赖。make 命令会把 Makefile 文件的第一个目标文件作为默认目标，当执行 make 命令时，make 会考察这个目标文件的依赖关系，进行编译。也可以指定，比如这个 Makefile：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main: a.o b.o
[tab]gcc -o main a.o b.o
a.o : a.c c.h
[tab]gcc -c a.c -o a.o
b.o: b.c c.h
[tab]gcc -c b.c -o b.o
// [tab]的意思是这里用tab字符代替，不能有其他的什么字符
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在命令行里执行make，分析关系并生成main，如果是make a.o那么他只会编译到 a.o 。

当然我们还可以设定伪目标，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clean：
[tab]rm a.o b.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样执行make clean的时候就把.o文件清除了,这里不会生成什么文件,只进行一些操作,更清楚的做法是在前面加上以下语句:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.PHONY : clean install dest [其他伪目标]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来说下变量，Makefile 里的变量按惯例是大写，包括数字字母下划线。当我们需要一个变量的值的时候，通常用 ${NAME} 或者 $(NAME)。他有好几种变量定义的方法。&lt;/p&gt;

&lt;p&gt;首先是常规法，就是&lt;code&gt;A=content&lt;/code&gt;，等号两边可以有空格，和shell不一样。&lt;/p&gt;

&lt;p&gt;其次是递归法，比如&lt;code&gt;A=$(B)，B=$(C)，C=haha&lt;/code&gt;，那么当寻找A的定义的时候就会去找B，然后再找C，变量展开的时候就是当他被引用的时候，这种方法效率比较低，因为如果他引用了函数，那么每次展开都要调用函数，而且可能会出现无限递归&lt;code&gt;（A=$(B),B=$(A)）&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后是直接展开法。这个很容易理解，就像是c语言是按照顺序执行的，当变量定义的时候这个变量就已经展开了（如果他引用了变量A，引用的是他定义时候A的值），当被引用的时候就直接用他代表的字符串替代。但是他用的不是等号 是 := ,比如 &lt;code&gt;A:=hello，A:=$(B)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;还有嵌套定义： &lt;code&gt;A=B,B=haha,V=$($(A))&lt;/code&gt;类似于这种的V的值是haha&lt;/p&gt;

&lt;p&gt;最后是替换引用定义，他会替换后缀，有个例子很好 &lt;code&gt;foo := a.o b.o c.o ,bar := $(foo:.o=.c)&lt;/code&gt;,我们可以知道bar的值就是&lt;code&gt;a.c b.c c.c&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;变量还有分类&#34;&gt;变量还有分类：&lt;/h3&gt;

&lt;p&gt;1.预定义变量，当使用隐式规则的时候他会派上用场，常用的有以下几个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CC   c编译器的名称（默认gcc？）
CPP    c预编译器名称（默认$(CC) -E）
CXX c++编译器的名称(默认g++)
CFLAGS c编译器选项,无默认值
CXXFLAGS c++编译器选项,无默认值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.自动变量,常用有以下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$@:表示当前规则中的完整目标文件名
$*:不包含扩展名的目标文件名
$&amp;lt;:当前规则中第一个依赖文件名
$^:当前规则所有文件列表
$%:当目标为库文件时,表示库文件名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.环境变量,Makefile对环境变量是可见的,可以引用.&lt;/p&gt;

&lt;p&gt;Makefile还有个常用的东东就是隐式规则,make会自己推导.比如说&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c：a.o b.o
[tab]gcc -o c a.o b.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时我们可以省略下面的命令，直接用第一行就行。make自动分析生成a，此时预定义变量就有用了，CC，CFLAGS等也派上了用场。&lt;/p&gt;

&lt;p&gt;由于把握不了隐式规则的底线和能力，我还是觉得隐式规则应用的不要太多太复杂影响阅读为好。。&lt;/p&gt;

&lt;h3 id=&#34;make的工作过程大概是以下几步&#34;&gt;make的工作过程大概是以下几步&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;读取Makefile，根据make的选项查找Makefile
初始化Makefile，将Makefile中的变量进行替换，如果Makefile中包含其他文件，则加载他&lt;/li&gt;
&lt;li&gt;解释规则，对其中的执行规则进行解析，推导隐藏规则，为目标建立关系链&lt;/li&gt;
&lt;li&gt;分析变更，根据依赖关系和时间戳，判断有木有变化。&lt;/li&gt;
&lt;li&gt;执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;编译的基本流程&#34;&gt;编译的基本流程&lt;/h3&gt;

&lt;p&gt;基本过程是以下四步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;c(.c) 和 c++(.cc, .cpp, .cxx) 的源文件&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;gcc -E a.c -o a.i   // 如果不加-o参数，gcc会把处理过的源文件放到标准输出中
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.预处理后的源文件。c源文件预处理后后缀为 .i , c++为 .ii 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -S a.i  //会在当前文件夹下生成a.s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.编译后生成的汇编源代码。后缀为 .s , .S 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -c a.s
//只进行汇编生成目标文件,.o结尾的目标文件可以用
//(ar crv libabc.a a.o b.o c.o )打包成形如lib×××.a的静态库
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.目标文件与库文件进行链接，生成可执行文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc a.o //在当前文件夹下生成a.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中任何一种状态，用 gcc 如果不加 -c ， -E ， -S 选项都会直接生成可执行文件，如果加上了选项，可以由之前任一状态生成所需要的文件（如 gcc -S a.c 可以直接生成 a.s，gcc -c a.i 可以直接生成 a.o ）。如果是c++直接换用g++命令就行。&lt;/p&gt;

&lt;p&gt;另外 &lt;code&gt;gcc -v&lt;/code&gt;可以输出编译过程的配置和版本信息。&lt;/p&gt;

&lt;h3 id=&#34;gcc-警告提示&#34;&gt;gcc 警告提示&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;-fsyntax-only   检查程序中的语法错误，不产生输出信息
-w 禁止所有警告信息
-Wunused 声明了木有用
-Wmain main函数定义不常规
-Wall 提供所有警告
-pedantic-errors 允许ansi c标准列出的全部信息
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;其他常用选项&#34;&gt;其他常用选项&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;-g 加入调试信息，gdb调试的时候要用。&lt;/li&gt;
&lt;li&gt;-On 优化选项。这里的n可以用0-3来替代。数字越大优化效果越好，-O0表示不进行优化。优化可能针对硬件进行优化，也可能针对代码优化（删除公共表达式，循环优化，删除无用信息）。优化可能大大增加编译时间和内存，他通常会将循环或函数展开，使他们以内联的方式进行，不是通过函数调用，这样可以显著提高性能，不过调试最好不要用优化选项。&lt;/li&gt;
&lt;li&gt;-l 指定要用到的库，注意这里之后要加的是库的名字，如果是多线程，可能要用到pthread库，那么此时就要加上 -lpthread ，这样gcc就会到库目录中找名为libpthread.so（lib×××.so）的文件，如果是静态库的话是libpthread.a( lib×××.a)（貌似gcc先找动态库，再找静态库？）。&lt;/li&gt;
&lt;li&gt;-L 指定所需要的库所在的文件夹。系统先寻找标准位置，再寻找指定位置（标准库一般在/lib或/usr/lib）。&lt;/li&gt;
&lt;li&gt;-I 指定头文件的寻找路径。先找标准的，后找指定的（标准的一般在/usr/include）。&lt;/li&gt;
&lt;li&gt;-static 只用静态库,再拿上面那个例子，如果加上-static，系统就会只寻找libpthread.a文件。&lt;/li&gt;
&lt;li&gt;-shared 生成动态库（共享库）文件，形如 libxxx.so （gcc -shared dang.o -o libdang.so）&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;(注意: 原文的链接在 &lt;a href=&#34;http://wdxtub.com/2016/03/20/make-gcc-guide/&#34; title=&#34;GCC Makefile&#34;&gt;&lt;em&gt;这里&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Intro to BoltDB: Painless Performant Persistence</title>
      <link>http://alimy.me/post/dev_201603192255/</link>
      <pubDate>Sat, 19 Mar 2016 22:55:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603192255/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/boltdb/bolt&#34; title=&#34;BoltDB&#34;&gt;BoltDB&lt;/a&gt; is a pure Go persistence solution that saves data to a memory mapped file. I call it a persistence solution and not a database, because the word database has a lot of baggage associated with it that doesn’t apply to bolt. And that lack of baggage is what makes bolt so awesome.&lt;/p&gt;

&lt;p&gt;Bolt is just a Go package. There’s nothing you need to install on the system, no configuration to figure out before you can start coding, nothing. You just go get github.com/boltdb/bolt and then import “github.com/boltdb/bolt”.&lt;/p&gt;

&lt;p&gt;All you need to fully use bolt as storage is a file name. This is fantastic from both a developer’s point of view, and a user’s point of view. I don’t know about you, but I’ve spent months of work time over my career configuring and setting up databases and debugging configuration problems, users and permissions and all the other crap you get from more traditional databases like Postgres and Mongo. There’s none of that with bolt. No users, no setup, just a file name. This is also a boon for users of your application, because they don’t have to futz with all that crap either.&lt;/p&gt;

&lt;p&gt;Bolt is not a relational database. It’s not even a document store, though you can sort of use it that way. It’s really just a key/value store… but don’t worry if you don’t really know what that means or how you’d use that for storage. It’s super simple and it’s incredibly flexible. Let’s take a look.&lt;/p&gt;

&lt;p&gt;Storage in bolt is divided into buckets. A bucket is simply a named collection of key/value pairs, just like Go’s map. The name of the bucket, the keys, and the values are all of type []byte. Buckets can contain other buckets, also keyed by a []byte name.

… that’s it. No, really, that’s it. Bolt is basically a bunch of nested maps. And this simplicity is what makes it so easy to use. There’s no tables to set up, no schemas, no complex querying language to struggle with. Let’s look at a bolt hello world:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    “fmt”
    “log”

    “github.com/boltdb/bolt”
)

var world = []byte(“world”)

func main() {
    db, err := bolt.Open(“/home/nate/foo/bolt.db”, 0644, nil)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    key := []byte(“hello”)
    value := []byte(“Hello World!”)

    // store some data
    err = db.Update(func(tx *bolt.Tx) error {
        bucket, err := tx.CreateBucketIfNotExists(world)
        if err != nil {
            return err
        }

        err = bucket.Put(key, value)
        if err != nil {
            return err
        }
        return nil
    })

    if err != nil {
        log.Fatal(err)
    }

    // retrieve the data
    err = db.View(func(tx *bolt.Tx) error {
        bucket := tx.Bucket(world)
        if bucket == nil {
            return fmt.Errorf(“Bucket %q not found!”, world)
        }

        val := bucket.Get(key)
        fmt.Println(string(val))

        return nil
    })

    if err != nil {
        log.Fatal(err)
    }
}

// output:
// Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I know what you’re thinking - that seems kinda long. But keep in mind, I fully handled all errors in at least a semi-proper way, and we’re doing all this:&lt;/p&gt;

&lt;p&gt;1.) creating a database&lt;br /&gt;
2.) creating some structure (the “world” bucket)&lt;br /&gt;
3.) storing data to the structure&lt;br /&gt;
4.) retrieving data from the structure.&lt;/p&gt;

&lt;p&gt;I think that’s not too bad in 54 lines of code.&lt;/p&gt;

&lt;p&gt;So let’s look at what that example is really doing. First we call bolt.Open to get the database. This will create the file if necessary, or open it if it exists.&lt;/p&gt;

&lt;p&gt;All reads from or writes to the bolt database must be done within a transaction. You can have as many Readers in read-only transactions at the same time as you want, but only one Writer in a writable transaction at a time (readers maintain a consistent view of the DB while writers are writing).&lt;/p&gt;

&lt;p&gt;To begin, we call db.Update, which takes a function to which it’ll pass a bolt.Tx - bolt’s transaction object. We then create a Bucket (since all data in bolt lives in buckets), and add our key/value pair to it. After the write transaction finishes, we start a read- only transaction with DB.View, and get the values back out.&lt;/p&gt;

&lt;p&gt;What’s great about bolt’s transaction mechanism is that it’s super simple - the scope of the function is the scope of the transaction. If the function passed to Update returns nil, all updates from the transaction are atomically stored to the database. If the function passed to Update returns an error, the transaction is rolled back. This makes bolt’s transactions completely intuitive from a Go developer’s point of view. You just exit early out of your function by returning an error as usual, and bolt Does The Right Thing. No need to worry about manually rolling back updates or anything, just return an error.&lt;/p&gt;

&lt;p&gt;The only other basic thing you may need is to iterate over key/value pairs in a Bucket, in which case, you just call bucket.Cursor(), which returns a Cursor value, which has functions like Next(), Prev() etc that return a key/value pair and work like you’d expect.&lt;/p&gt;

&lt;p&gt;There’s a lot more to the bolt API, but most of the rest of it is more about database statistics and some stuff for more advanced usage scenarios… but the above is all you really need to know to start storing data in a bolt database.&lt;/p&gt;

&lt;p&gt;For a more complex application, just storing strings in the database may not be sufficient, but that’s ok, Go has your back there, too. You can easily use encoding/json or encoding/gob to serialize structs into the database, keyed by a unique name or id. This is what makes it easy for bolt to go from a key/value store to a document store - just have one bucket per document type. Again, the benefit of bolt is low barrier of entry. You don’t have to figure out a whole database schema or install anything to be able to just start dumping data to disk in a performant and manageable way.&lt;/p&gt;

&lt;p&gt;The main drawback of bolt is that there are no queries. You can’t say “give me all foo objects with a name that starts with bar”. You could make your own index in the database and keep it up to date manually. This could be as easy as a slice of IDs serialized into an “indices” bucket for a particular query. Obviously, this is where you start getting into the realm of developing your own relational database, but if you don’t go overboard, it can be nice that all this code is just that - code. It’s not queries in some external DSL, it’s just code like you’d write for an in-memory data store.&lt;/p&gt;

&lt;p&gt;Bolt is not for every application. You must understand your application’s needs and if bolt’s key/value style will be sufficient to fulfill those needs. If it is, I think you’ll be very happy to use such a simple data store with so little mental overhead.&lt;/p&gt;

&lt;p&gt;[edited to clarify reader/writer relationship] Bonus Gob vs. Json benchmark for storing structs in Bolt:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BenchmarkGobEncode  1000000       2191 ns/op
BenchmarkJsonEncode   500000       4738 ns/op
BenchmarkGobDecode  1000000       2019 ns/op
BenchmarkJsonDecode   200000      12993 ns/op
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/&#34; title=&#34;Intro to BoltDB&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android: Volley&#43;OkHttp with https</title>
      <link>http://alimy.me/post/dev_201603192245/</link>
      <pubDate>Sat, 19 Mar 2016 22:45:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603192245/</guid>
      <description>&lt;h3 id=&#34;android-network-simple&#34;&gt;Android Network Simple&lt;/h3&gt;

&lt;p&gt;This article shows how to use volley with OkHttp and security your api with https.
本文可以在&lt;a href=&#34;http://www.jianshu.com/p/e58161cbc3a4&#34; title=&#34;Android 网络--我是怎么做的: Volley+OkHttp+Https&#34;&gt;简书&lt;/a&gt;浏览。&lt;/p&gt;

&lt;h3 id=&#34;使用-okhttp-作为传输层的实现&#34;&gt;使用 OkHttp 作为传输层的实现.&lt;/h3&gt;

&lt;p&gt;Volley 默认根据 Android 系统版本使用不同的 Http 传输协议实现. 3.0 以上使用HttpUrlConnection, 2.3 以下使用 ApacheHttpStack, 参考&lt;a href=&#34;http://android-developers.blogspot.com/2011/09/androids-http-clients.html&#34;&gt;Android Http Client&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;OkHttp 相较于其它的实现有以下的优点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持&lt;a href=&#34;http://zh.wikipedia.org/wiki/SPDY&#34;&gt;SPDY&lt;/a&gt;，允许连接同一主机的所有请求分享一个socket。&lt;/li&gt;
&lt;li&gt;如果SPDY不可用，会使用连接池减少请求延迟。&lt;/li&gt;
&lt;li&gt;使用GZIP压缩下载内容，且压缩操作对用户是透明的。&lt;/li&gt;
&lt;li&gt;利用响应缓存来避免重复的网络请求。&lt;/li&gt;
&lt;li&gt;当网络出现问题的时候，OKHttp会依然有效，它将从常见的连接问题当中恢复。&lt;/li&gt;
&lt;li&gt;如果你的服务端有多个IP地址，当第一个地址连接失败时，OKHttp会尝试连接其他的地址，这对IPV4和IPV6以及寄宿在多个数据中心的服务而言，是非常有必要的。

因此使用 OkHttp 作为替代是好的选择.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先用 OkHttp 实现一个新的 &lt;code&gt;HurlStack&lt;/code&gt; 用于构建 Volley 的 requestQueue.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class OkHttpStack extends HurlStack {

    private OkHttpClient okHttpClient;

    /**
     * Create a OkHttpStack with default OkHttpClient.
     */
    public OkHttpStack() {
        this(new OkHttpClient());
    }

    /**
     * Create a OkHttpStack with a custom OkHttpClient
     * @param okHttpClient Custom OkHttpClient, NonNull
     */
    public OkHttpStack(OkHttpClient okHttpClient) {
        this.okHttpClient = okHttpClient;
    }

    @Override
    protected HttpURLConnection createConnection(URL url) throws IOException {
        OkUrlFactory okUrlFactory = new OkUrlFactory(okHttpClient);
        return okUrlFactory.open(url);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用 OkHttpStack 创建新的 Volley requestQueue.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;requestQueue = Volley.newRequestQueue(getContext(), new OkHttpStack());
requestQueue.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就行了.&lt;/p&gt;

&lt;h3 id=&#34;使用-https&#34;&gt;使用 Https&lt;/h3&gt;

&lt;p&gt;作为一个有节操的开发者应该使用 Https 来保护用户的数据, Android 开发者网站上文章&lt;a href=&#34;https://developer.android.com/training/articles/security-ssl.html&#34;&gt;Security with HTTPS and SSL&lt;/a&gt;做了详尽的阐述.&lt;/p&gt;

&lt;p&gt;OkHttp 自身是支持 Https 的. 参考文档 &lt;a href=&#34;https://github.com/square/okhttp/wiki/HTTPS&#34;&gt;OkHttp Https&lt;/a&gt;, 直接使用上面的 &lt;code&gt;OkHttpStack&lt;/code&gt; 就可以了, 但是如果遇到服务器开发哥哥使用了自签名的证书(不要问我为什么要用自签名的), 就无法正常访问了.&lt;/p&gt;

&lt;p&gt;网上有很多文章给出的方案是提供一个什么事情都不做的&lt;code&gt;TrustManager&lt;/code&gt; 跳过 &lt;code&gt;SSL&lt;/code&gt; 的验证, 这样做很容受到攻击, Https 也就形同虚设了.&lt;/p&gt;

&lt;p&gt;我采用的方案是将自签名的证书打包入 APK 加入信任.&lt;/p&gt;

&lt;p&gt;好处:
* 应用难以逆向, 应用不再依赖系统的 trust store, 使得 Charles 抓包等工具失效. 要分析应用 API 必须反编译 APK.
* 不用额外购买证书, 省钱&amp;hellip;.
缺点:
* 证书部署灵活性降低, 一旦变更证书必须升级程序.&lt;/p&gt;

&lt;h3 id=&#34;实现步骤&#34;&gt;实现步骤&lt;/h3&gt;

&lt;p&gt;以最著名的自签名网站12306为例说明&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;导出证书&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo | openssl s_client -connect kyfw.12306.cn:443 2&amp;gt;&amp;amp;1 |  sed -ne &#39;/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p&#39; &amp;gt; kyfw.12306.cn.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将证书转为 bks 格式
下载最新的bcprov-jdk, 执行下面的命令. storepass 是导出密钥文件的密码.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -importcert -v \
    -trustcacerts \
    -alias 0 \
    -file &amp;lt;(openssl x509 -in kyfw.12306.cn.pem) \
    -keystore kyfw.bks -storetype BKS \
    -providerclass     org.bouncycastle.jce.provider.BouncyCastleProvider \
    -providerpath ./bcprov-jdk16-1.46.jar \
    -storepass asdfqaz
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将导出的 kyfw.bks 文件放入 res/raw 文件夹下.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建  &lt;code&gt;SelfSignSslOkHttpStack&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; // A HttpStack implement witch can verify specified self-signed certification.
public class SelfSignSslOkHttpStack extends HurlStack {

  private OkHttpClient okHttpClient;

  private Map&amp;lt;String, SSLSocketFactory&amp;gt; socketFactoryMap;


   // Create a OkHttpStack with default OkHttpClient.
  public SelfSignSslOkHttpStack(Map&amp;lt;String, SSLSocketFactory&amp;gt; factoryMap) {
    this(new OkHttpClient(), factoryMap);
  }


  // Create a OkHttpStack with a custom OkHttpClient
  // @param okHttpClient Custom OkHttpClient, NonNull
  public SelfSignSslOkHttpStack(OkHttpClient okHttpClient, Map&amp;lt;String, SSLSocketFactory&amp;gt; factoryMap) {
    this.okHttpClient = okHttpClient;
    this.socketFactoryMap = factoryMap;
  }

  @Override
  protected HttpURLConnection createConnection(URL url) throws IOException {
    if (&amp;quot;https&amp;quot;.equals(url.getProtocol()) &amp;amp;&amp;amp; socketFactoryMap.containsKey(url.getHost())) {
        HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(okHttpClient).open(url);
        connection.setSSLSocketFactory(socketFactoryMap.get(url.getHost()));
        return connection;
    } else {
        return  new OkUrlFactory(okHttpClient).open(url);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后用 &lt;code&gt;SelfSignSslOkHttpStack&lt;/code&gt; 创建 Volley 的 RequestQueue.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String[] hosts = {&amp;quot;kyfw.12306.cn&amp;quot;};
int[] certRes = {R.raw.kyfw};
String[] certPass = {&amp;quot;asdfqaz&amp;quot;};
socketFactoryMap = new Hashtable&amp;lt;&amp;gt;(hosts.length);

for (int i = 0; i &amp;lt; certRes.length; i++) {
    int res = certRes[i];
    String password = certPass[i];
    SSLSocketFactory sslSocketFactory = createSSLSocketFactory(context, res, password);
    socketFactoryMap.put(hosts[i], sslSocketFactory);
}

HurlStack stack = new SelfSignSslOkHttpStack(socketFactoryMap);

requestQueue = Volley.newRequestQueue(context, stack);
requestQueue.start();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;done&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;https://github.com/dodocat/AndroidNetworkdemo&#34; title=&#34;android network demo&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>50 Shades of Go</title>
      <link>http://alimy.me/post/dev_201603182045/</link>
      <pubDate>Fri, 18 Mar 2016 20:45:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603182045/</guid>
      <description>&lt;p&gt;Go is a simple and fun language, but, like any other language, it has a few gotchas&amp;hellip; Many of those gotchas are not entirely Go&amp;rsquo;s fault. Some of these mistakes are natural traps if you are coming from another language. Others are due to faulty assumptions and missing details.&lt;/p&gt;

&lt;p&gt;A lot of these gotchas may seem obvious if you took the time to learn the language reading the official spec, wiki, mailing list discussions, many great posts and presentations by Rob Pike, and the source code. Not everybody starts the same way though and that&amp;rsquo;s OK. If you are new to Go the information here will save you hours debugging your code.&lt;/p&gt;

&lt;p&gt;This post covers Go 1.5 and below.&lt;/p&gt;

&lt;h3 id=&#34;total-beginner&#34;&gt;Total Beginner:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Opening Brace Can&amp;rsquo;t Be Placed on a Separate Line&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Unused Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;Unused Imports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;Short Variable Declarations Can Be Used Only Inside Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;Redeclaring Variables Using Short Variable Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;Can&amp;rsquo;t Use Short Variable Declarations to Set Field Values&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;Accidental Variable Shadowing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;Can&amp;rsquo;t Use &amp;ldquo;nil&amp;rdquo; to Initialize a Variable Without an Explicit Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9&#34;&gt;Using &amp;ldquo;nil&amp;rdquo; Slices and Maps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10&#34;&gt;Map Capacity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;Strings Can&amp;rsquo;t Be &amp;ldquo;nil&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12&#34;&gt;Array Function Arguments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13&#34;&gt;Unexpected Values in Slice and Array &amp;ldquo;range&amp;rdquo; Clauses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14&#34;&gt;Slices and Arrays Are One-Dimensional&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15&#34;&gt;Accessing Non-Existing Map Keys&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#16&#34;&gt;Strings Are Immutable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#17&#34;&gt;Conversions Between Strings and Byte Slices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#18&#34;&gt;Strings and Index Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#19&#34;&gt;Strings Are Not Always UTF8 Text&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#20&#34;&gt;String Length&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#21&#34;&gt;Missing Comma In Multi-Line Slice/Array/Map Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22&#34;&gt;log.Fatal and log.Panic Do More Than Log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23&#34;&gt;Built-in Data Structure Operations Are Not Synchronized&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24&#34;&gt;Iteration Values For Strings in &amp;ldquo;range&amp;rdquo; Clauses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25&#34;&gt;Iterating Through a Map Using a &amp;ldquo;for range&amp;rdquo; Clause&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26&#34;&gt;Fallthrough Behavior in &amp;ldquo;switch&amp;rdquo; Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27&#34;&gt;Increments and Decrements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#28&#34;&gt;Bitwise NOT Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#29&#34;&gt;Operator Precedence Differences&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#30&#34;&gt;Unexported Structure Fields Are Not Encoded&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#31&#34;&gt;App Exits With Active Goroutines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32&#34;&gt;Sending to an Unbuffered Channel Returns As Soon As the Target Receiver Is Ready&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33&#34;&gt;Sending to an Closed Channel Causes a Panic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#34&#34;&gt;Using &amp;ldquo;nil&amp;rdquo; Channels&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#35&#34;&gt;Methods with Value Receivers Can&amp;rsquo;t Change the Original Value&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;intermediate-beginner&#34;&gt;Intermediate Beginner:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#36&#34;&gt;Closing HTTP Response Body&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#37&#34;&gt;Closing HTTP Connections&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#38&#34;&gt;Unmarshalling JSON Numbers into Interface Values&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#39&#34;&gt;Comparing Structs, Arrays, Slices, and Maps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#40&#34;&gt;Recovering From a Panic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#41&#34;&gt;Updating and Referencing Item Values in Slice, Array, and Map &amp;ldquo;for range&amp;rdquo; Clauses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42&#34;&gt;&amp;ldquo;Hidden&amp;rdquo; Data in Slices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43&#34;&gt;Slice Data Corruption&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44&#34;&gt;&amp;ldquo;Stale&amp;rdquo; Slices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#45&#34;&gt;Type Declarations and Methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#46&#34;&gt;Breaking Out of &amp;ldquo;for switch&amp;rdquo; and &amp;ldquo;for select&amp;rdquo; Code Blocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#47&#34;&gt;Iteration Variables and Closures in &amp;ldquo;for&amp;rdquo; Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#48&#34;&gt;Deferred Function Call Argument Evaluation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#49&#34;&gt;Deferred Function Call Execution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#50&#34;&gt;Failed Type Assertions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#51&#34;&gt;Blocked Goroutines and Resource Leaks&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;advanced-beginner&#34;&gt;Advanced Beginner:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#52&#34;&gt;Using Pointer Receiver Methods On Value Instances&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53&#34;&gt;Updating Map Value Fields&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#54&#34;&gt;&amp;ldquo;nil&amp;rdquo; Interfaces and &amp;ldquo;nil&amp;rdquo; Interfaces Values&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#55&#34;&gt;Stack and Heap Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#56&#34;&gt;GOMAXPROCS, Concurrency, and Parallelism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#57&#34;&gt;Read and Write Operation Reordering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#58&#34;&gt;Preemptive Scheduling&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;a-name-1-a-opening-brace-can-t-be-placed-on-a-separate-line&#34;&gt;&lt;a name=&#34;1&#34;&gt;&lt;/a&gt;Opening Brace Can&amp;rsquo;t Be Placed on a Separate Line&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In most other languages that use braces you get to choose where you place them. Go is different. You can thank automatic semicolon injection (without lookahead) for this behavior. Yes, Go does have semicolons :-)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main()  
{ //error, can&#39;t have the opening brace on a separate line
    fmt.Println(&amp;quot;hello there!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Error:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox826898458/main.go:6: syntax error: unexpected semicolon or newline before {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    fmt.Println(&amp;quot;works!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-2-a-unused-variables&#34;&gt;&lt;a name=&#34;2&#34;&gt;&lt;/a&gt;Unused Variables&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you have an unused variable your code will fail to compile. There&amp;rsquo;s an exception though. You must use variables you declare inside functions, but it&amp;rsquo;s OK if you have unused global variables. It&amp;rsquo;s also OK to have unused function arguments.&lt;/p&gt;

&lt;p&gt;If you assign a new value to the unused variable your code will still fail to compile. You need to use the variable value somehow to make the compiler happy.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

var gvar int //not an error

func main() {  
    var one int   //error, unused variable
    two := 2      //error, unused variable
    var three int //error, even though it&#39;s assigned 3 on the next line
    three = 3

    func(unused string) {
        fmt.Println(&amp;quot;Unused arg. No compile error&amp;quot;)
    }(&amp;quot;what?&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Errors:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox473116179/main.go:6: one declared and not used /tmp/sandbox473116179/main.go:7: two declared and not used /tmp/sandbox473116179/main.go:8: three declared and not used
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    var one int
    _ = one

    two := 2
    fmt.Println(two)

    var three int
    three = 3
    one = three

    var four int
    four = four
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another option is to comment out or remove the unused variables :-)&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-a-unused-imports&#34;&gt;&lt;a name=&#34;3&#34;&gt;&lt;/a&gt;Unused Imports&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Your code will fail to compile if you import a package without using any of its exported functions, interfaces, structures, or variables.&lt;/p&gt;

&lt;p&gt;If you really need the imported package you can use the blank identifier, _ , as its package name to avoid this compilation failure. The blank identifier is used to import packages for their side effects.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Errors:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox627475386/main.go:4: imported and not used: &amp;quot;fmt&amp;quot; /tmp/sandbox627475386/main.go:5: imported and not used: &amp;quot;log&amp;quot; /tmp/sandbox627475386/main.go:6: imported and not used: &amp;quot;time&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    _ &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;time&amp;quot;
)

var _ = log.Println

func main() {  
    _ = time.Now
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another option is to remove or comment out the unused imports :-) The goimports tool can help you with that.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-a-short-variable-declarations-can-be-used-only-inside-functions&#34;&gt;&lt;a name=&#34;4&#34;&gt;&lt;/a&gt;Short Variable Declarations Can Be Used Only Inside Functions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

myvar := 1 //error

func main() {  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Error:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox265716165/main.go:3: non-declaration statement outside function body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

var myvar = 1

func main() {  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-5-a-redeclaring-variables-using-short-variable-declarations&#34;&gt;&lt;a name=&#34;5&#34;&gt;&lt;/a&gt;Redeclaring Variables Using Short Variable Declarations&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can&amp;rsquo;t redeclare a variable in a standalone statement, but it is allowed in multi-variable declarations where at least one new variable is also declared.&lt;/p&gt;

&lt;p&gt;The redeclared variable has to be in the same block or you&amp;rsquo;ll end up with a shadowed variable.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    one := 0
    one := 1 //error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Error:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox706333626/main.go:5: no new variables on left side of :=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    one := 0
    one, two := 1,2

    one,two = two,one
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-6-a-can-t-use-short-variable-declarations-to-set-field-values&#34;&gt;&lt;a name=&#34;6&#34;&gt;&lt;/a&gt;Can&amp;rsquo;t Use Short Variable Declarations to Set Field Values&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
  &amp;quot;fmt&amp;quot;
)

type info struct {  
  result int
}

func work() (int,error) {  
    return 13,nil  
  }

func main() {  
  var data info

  data.result, err := work() //error
  fmt.Printf(&amp;quot;info: %+v\n&amp;quot;,data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Error:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prog.go:18: non-name data.result on left side of :=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though there&amp;rsquo;s a ticket to address this gotcha it&amp;rsquo;s unlikely to change because Rob Pike likes it &amp;ldquo;as is&amp;rdquo; :-)&lt;/p&gt;

&lt;p&gt;Use temporary variables or predeclare all your variables and use the standard assignment operator.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
  &amp;quot;fmt&amp;quot;
)

type info struct {  
  result int
}

func work() (int,error) {  
    return 13,nil  
  }

func main() {  
  var data info

  var err error
  data.result, err = work() //ok
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Printf(&amp;quot;info: %+v\n&amp;quot;,data) //prints: info: {result:13}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-7-a-accidental-variable-shadowing&#34;&gt;&lt;a name=&#34;7&#34;&gt;&lt;/a&gt;Accidental Variable Shadowing&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The short variable declaration syntax is so convenient (especially for those coming from a dynamic language) that it&amp;rsquo;s easy to treat it like a regular assignment operation. If you make this mistake in a new code block there will be no compiler error, but your app will not do what you expect.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := 1
    fmt.Println(x)     //prints 1
    {
        fmt.Println(x) //prints 1
        x := 2
        fmt.Println(x) //prints 2
    }
    fmt.Println(x)     //prints 1 (bad if you need 2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a very common trap even for experienced Go developers. It&amp;rsquo;s easy to make and it could be hard to spot.&lt;/p&gt;

&lt;p&gt;You can use the vet command to find some of these problems. By default, vet will not perform any shadowed variable checks. Make sure to use the -shadow flag: go tool vet -shadow your_file.go&lt;/p&gt;

&lt;p&gt;Note that the vet command will not report all shadowed variables. Use go-nyet for more aggressive shadowed variable detection.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-a-can-t-use-nil-to-initialize-a-variable-without-an-explicit-type&#34;&gt;&lt;a name=&#34;8&#34;&gt;&lt;/a&gt;Can&amp;rsquo;t Use &amp;ldquo;nil&amp;rdquo; to Initialize a Variable Without an Explicit Type&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &amp;ldquo;nil&amp;rdquo; identifier can be used as the &amp;ldquo;zero value&amp;rdquo; for interfaces, functions, pointers, maps, slices, and channels. If you don&amp;rsquo;t specify the variable type the compiler will fail to compile your code because it can&amp;rsquo;t guess the type.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    var x = nil //error

    _ = x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Error:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox188239583/main.go:4: use of untyped nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    var x interface{} = nil

    _ = x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-9-a-using-nil-slices-and-maps&#34;&gt;&lt;a name=&#34;9&#34;&gt;&lt;/a&gt;Using &amp;ldquo;nil&amp;rdquo; Slices and Maps&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s OK to add items to a &amp;ldquo;nil&amp;rdquo; slice, but doing the same with a map will produce a runtime panic.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    var s []int
    s = append(s,1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    var m map[string]int
    m[&amp;quot;one&amp;quot;] = 1 //error

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-10-a-map-capacity&#34;&gt;&lt;a name=&#34;10&#34;&gt;&lt;/a&gt;Map Capacity&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can specify the map capacity when it&amp;rsquo;s created, but you can&amp;rsquo;t use the cap() function on maps.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    m := make(map[string]int,99)
    cap(m) //error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Error:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox326543983/main.go:5: invalid argument m (type map[string]int) for cap
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-11-a-strings-can-t-be-nil&#34;&gt;&lt;a name=&#34;11&#34;&gt;&lt;/a&gt;Strings Can&amp;rsquo;t Be &amp;ldquo;nil&amp;rdquo;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is a gotcha for developers who are used to assigning &amp;ldquo;nil&amp;rdquo; identifiers to string variables.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    var x string = nil //error

    if x == nil { //error
        x = &amp;quot;default&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Errors:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox630560459/main.go:4: cannot use nil as type string in assignment /tmp/sandbox630560459/main.go:6: invalid operation: x == nil (mismatched types string and nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    var x string //defaults to &amp;quot;&amp;quot; (zero value)

    if x == &amp;quot;&amp;quot; {
        x = &amp;quot;default&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-12-a-array-function-arguments&#34;&gt;&lt;a name=&#34;12&#34;&gt;&lt;/a&gt;Array Function Arguments&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you are a C or C++ developer arrays for you are pointers. When you pass arrays to functions the functions reference the same memory location, so they can update the original data. Arrays in Go are values, so when you pass arrays to functions the functions get a copy of the original array data. This can be a problem if you are trying to update the array data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := [3]int{1,2,3}

    func(arr [3]int) {
        arr[0] = 7
        fmt.Println(arr) //prints [7 2 3]
    }(x)

    fmt.Println(x) //prints [1 2 3] (not ok if you need [7 2 3])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need to update the original array data use array pointer types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := [3]int{1,2,3}

    func(arr *[3]int) {
        (*arr)[0] = 7
        fmt.Println(arr) //prints &amp;amp;[7 2 3]
    }(&amp;amp;x)

    fmt.Println(x) //prints [7 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another option is to use slices. Even though your function gets a copy of the slice variable it still references the original data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := []int{1,2,3}

    func(arr []int) {
        arr[0] = 7
        fmt.Println(arr) //prints [7 2 3]
    }(x)

    fmt.Println(x) //prints [7 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-13-a-unexpected-values-in-slice-and-array-range-clauses&#34;&gt;&lt;a name=&#34;13&#34;&gt;&lt;/a&gt;Unexpected Values in Slice and Array &amp;ldquo;range&amp;rdquo; Clauses&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This can happen if you are used to the &amp;ldquo;for-in&amp;rdquo; or &amp;ldquo;foreach&amp;rdquo; statements in other languages. The &amp;ldquo;range&amp;rdquo; clause in Go is different. It generates two values: the first value is the item index while the second value is the item data.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Bad:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := []string{&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;}

    for v := range x {
        fmt.Println(v) //prints 0, 1, 2
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Good:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := []string{&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;}

    for _, v := range x {
        fmt.Println(v) //prints a, b, c
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-14-a-slices-and-arrays-are-one-dimensional&#34;&gt;&lt;a name=&#34;14&#34;&gt;&lt;/a&gt;Slices and Arrays Are One-Dimensional&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It may seem like Go supports multi-dimensional arrays and slices, but it doesn&amp;rsquo;t. Creating arrays of arrays or slices of slices is possible though. For numerical computation apps that rely on dynamic multi-dimensional arrays it&amp;rsquo;s far from ideal in terms of performance and complexity.&lt;/p&gt;

&lt;p&gt;You can build dynamic multi-dimensional arrays using raw one-dimensional arrays, slices of &amp;ldquo;independent&amp;rdquo; slices, and slices of &amp;ldquo;shared data&amp;rdquo; slices.&lt;/p&gt;

&lt;p&gt;If you are using raw one-dimensional arrays you are responsible for indexing, bounds checking, and memory reallocations when the arrays need to grow.&lt;/p&gt;

&lt;p&gt;Creating a dynamic multi-dimensional array using slices of &amp;ldquo;independent&amp;rdquo; slices is a two step process. First, you have to create the outer slice. Then, you have to allocate each inner slice. The inner slices are independent of each other. You can grow and shrink them without affecting other inner slices.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    x := 2
    y := 4

    table := make([][]int,x)
    for i:= range table {
        table[i] = make([]int,y)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Creating a dynamic multi-dimensional array using slices of &amp;ldquo;shared data&amp;rdquo; slices is a three step process. First, you have to create the data &amp;ldquo;container&amp;rdquo; slice that will hold raw data. Then, you create the outer slice. Finally, you initialize each inner slice by reslicing the raw data slice.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    h, w := 2, 4

    raw := make([]int,h*w)
    for i := range raw {
        raw[i] = i
    }
    fmt.Println(raw,&amp;amp;raw[4])
    //prints: [0 1 2 3 4 5 6 7] &amp;lt;ptr_addr_x&amp;gt;

    table := make([][]int,h)
    for i:= range table {
        table[i] = raw[i*w:i*w + w]
    }

    fmt.Println(table,&amp;amp;table[1][0])
    //prints: [[0 1 2 3] [4 5 6 7]] &amp;lt;ptr_addr_x&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a spec/proposal for multi-dimensional arrays and slices, but it looks like it&amp;rsquo;s a low priority feature at this point in time.&lt;/p&gt;

&lt;h3 id=&#34;a-name-15-a-accessing-non-existing-map-keys&#34;&gt;&lt;a name=&#34;15&#34;&gt;&lt;/a&gt;Accessing Non-Existing Map Keys&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner
This is a gotcha for developers who expect to get &amp;ldquo;nil&amp;rdquo; identifiers (like it&amp;rsquo;s done in other languages). The returned value will be &amp;ldquo;nil&amp;rdquo; if the &amp;ldquo;zero value&amp;rdquo; for the corresponding data type is &amp;ldquo;nil&amp;rdquo;, but it&amp;rsquo;ll be different for other data types. Checking for the appropriate &amp;ldquo;zero value&amp;rdquo; can be used to determine if the map record exists, but it&amp;rsquo;s not always reliable (e.g., what do you do if you have a map of booleans where the &amp;ldquo;zero value&amp;rdquo; is false). The most reliable way to know if a given map record exists is to check the second value returned by the map access operation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Bad:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := map[string]string{&amp;quot;one&amp;quot;:&amp;quot;a&amp;quot;,&amp;quot;two&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;three&amp;quot;:&amp;quot;c&amp;quot;}

    if v := x[&amp;quot;two&amp;quot;]; v == &amp;quot;&amp;quot; { //incorrect
        fmt.Println(&amp;quot;no entry&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Good:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := map[string]string{&amp;quot;one&amp;quot;:&amp;quot;a&amp;quot;,&amp;quot;two&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;three&amp;quot;:&amp;quot;c&amp;quot;}

    if _,ok := x[&amp;quot;two&amp;quot;]; !ok {
        fmt.Println(&amp;quot;no entry&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-16-a-strings-are-immutable&#34;&gt;&lt;a name=&#34;16&#34;&gt;&lt;/a&gt;Strings Are Immutable&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trying to update an individual character in a string variable using the index operator will result in a failure. Strings are read-only byte slices (with a few extra properties). If you do need to update a string then use a byte slice instead converting it to a string type when necessary.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := &amp;quot;text&amp;quot;
    x[0] = &#39;T&#39;

    fmt.Println(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Error:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox305565531/main.go:7: cannot assign to x[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := &amp;quot;text&amp;quot;
    xbytes := []byte(x)
    xbytes[0] = &#39;T&#39;

    fmt.Println(string(xbytes)) //prints Text
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this isn&amp;rsquo;t really the right way to update characters in a text string because a given character could be stored in multiple bytes. If you do need to make updates to a text string convert it to a rune sclice first. Even with rune slices a single character might span multiple runes, which can happen if you have characters with grave accent, for example. This complicated and ambiguous nature of &amp;ldquo;characters&amp;rdquo; is the reason why Go strings are represented as byte sequences.&lt;/p&gt;

&lt;h3 id=&#34;a-name-17-a-conversions-between-strings-and-byte-slices&#34;&gt;&lt;a name=&#34;17&#34;&gt;&lt;/a&gt;Conversions Between Strings and Byte Slices&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When you convert a string to a byte slice (and vice versa) you get a complete copy of the orginal data. It&amp;rsquo;s not like a cast operation in other languages and it&amp;rsquo;s not like reslicing where the new slice variable points to the same underlying array used by the original byte slice.&lt;/p&gt;

&lt;p&gt;Go does have a couple of optimizations for []byte to string and string to []byte conversions to avoid extra allocations (with more optimizations on the todo list).&lt;/p&gt;

&lt;p&gt;The first optimization avoids extra allocations when []byte keys are used to lookup entries in map[string] collections: m[string(key)].&lt;/p&gt;

&lt;p&gt;The second optimization avoids extra allocations in for range clauses where strings are converted to []byte: for i,v := range []byte(str) {&amp;hellip;}.&lt;/p&gt;

&lt;h3 id=&#34;a-name-18-a-strings-and-index-operator&#34;&gt;&lt;a name=&#34;18&#34;&gt;&lt;/a&gt;Strings and Index Operator&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The index operator on a string returns a byte value, not a character (like it&amp;rsquo;s done in other languages).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    x := &amp;quot;text&amp;quot;
    fmt.Println(x[0]) //print 116
    fmt.Printf(&amp;quot;%T&amp;quot;,x[0]) //prints uint8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need to access specific string &amp;ldquo;characters&amp;rdquo; (unicode code points/runes) use the for range clause. The official &amp;ldquo;unicode/utf8&amp;rdquo; package and the experimental utf8string package (golang.org/x/exp/utf8string) are also useful. The utf8string package includes a convenient At() method. Converting the string to a slice of runes is an option too.&lt;/p&gt;

&lt;h3 id=&#34;a-name-19-a-strings-are-not-always-utf8-text&#34;&gt;&lt;a name=&#34;19&#34;&gt;&lt;/a&gt;Strings Are Not Always UTF8 Text&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;String values are not required to be UTF8 text. They can contain arbitrary bytes. The only time strings are UTF8 is when string literals are used. Even then they can include other data using escape sequences.&lt;/p&gt;

&lt;p&gt;To know if you have a UTF8 text string use the ValidString() function from the &amp;ldquo;unicode/utf8&amp;rdquo; package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;unicode/utf8&amp;quot;
)

func main() {  
    data1 := &amp;quot;ABC&amp;quot;
    fmt.Println(utf8.ValidString(data1)) //prints: true

    data2 := &amp;quot;A\xfeC&amp;quot;
    fmt.Println(utf8.ValidString(data2)) //prints: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-20-a-string-length&#34;&gt;&lt;a name=&#34;20&#34;&gt;&lt;/a&gt;String Length&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s say you are a python developer and you have the following piece of code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data = u&#39;♥&#39;  
print(len(data)) #prints: 1  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you convert it to a similar Go code snippet you might be surprised.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    data := &amp;quot;♥&amp;quot;
    fmt.Println(len(data)) //prints: 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The built-in len() function returns the number of bytes instead of the number of characters like it&amp;rsquo;s done for unicode strings in Python.&lt;/p&gt;

&lt;p&gt;To get the same results in Go use the RuneCountInString() function from the &amp;ldquo;unicode/utf8&amp;rdquo; package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;unicode/utf8&amp;quot;
)

func main() {  
    data := &amp;quot;♥&amp;quot;
    fmt.Println(utf8.RuneCountInString(data)) //prints: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Technically the RuneCountInString() function doesn&amp;rsquo;t return the number of characters because a single character may span multiple runes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;unicode/utf8&amp;quot;
)

func main() {  
    data := &amp;quot;é&amp;quot;
    fmt.Println(len(data))                    //prints: 3
    fmt.Println(utf8.RuneCountInString(data)) //prints: 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-21-a-missing-comma-in-multi-line-slice-array-and-map-literals&#34;&gt;&lt;a name=&#34;21&#34;&gt;&lt;/a&gt;Missing Comma In Multi-Line Slice, Array, and Map Literals&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    x := []int{
    1,
    2 //error
    }
    _ = x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Errors:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox367520156/main.go:6: syntax error: need trailing comma before newline in composite literal /tmp/sandbox367520156/main.go:8: non-declaration statement outside function body /tmp/sandbox367520156/main.go:9: syntax error: unexpected }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

func main() {  
    x := []int{
    1,
    2,
    }
    x = x

    y := []int{3,4,} //no error
    y = y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You won&amp;rsquo;t get a compiler error if you leave the trailing comma when you collapse the declaration to be on a single line.&lt;/p&gt;

&lt;h3 id=&#34;a-name-22-a-log-fatal-and-log-panic-do-more-than-log&#34;&gt;&lt;a name=&#34;22&#34;&gt;&lt;/a&gt;log.Fatal and log.Panic Do More Than Log&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Logging libraries often provide different log levels. Unlike those logging libraries, the log package in Go does more than log if you call its Fatal&lt;em&gt;() and Panic&lt;/em&gt;() functions. When your app calls those functions Go will also terminate your app :-)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;log&amp;quot;

func main() {  
    log.Fatalln(&amp;quot;Fatal Level: log entry&amp;quot;) //app exits here
    log.Println(&amp;quot;Normal Level: log entry&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-23-a-built-in-data-structure-operations-are-not-synchronized&#34;&gt;&lt;a name=&#34;23&#34;&gt;&lt;/a&gt;Built-in Data Structure Operations Are Not Synchronized&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even though Go has a number of features to support concurrency natively, concurrency safe data collections are not one them :-) It&amp;rsquo;s your responsibility to ensure the data collection updates are atomic. Goroutines and channels are the recommended way to implement those atomic operations, but you can also leverage the &amp;ldquo;sync&amp;rdquo; package if it makes sense for your application.&lt;/p&gt;

&lt;h3 id=&#34;a-name-24-a-iteration-values-for-strings-in-range-clauses&#34;&gt;&lt;a name=&#34;24&#34;&gt;&lt;/a&gt;Iteration Values For Strings in &amp;ldquo;range&amp;rdquo; Clauses&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The index value (the first value returned by the &amp;ldquo;range&amp;rdquo; operation) is the index of the first byte for the current &amp;ldquo;character&amp;rdquo; (unicode code point/rune) returned in the second value. It&amp;rsquo;s not the index for the current &amp;ldquo;character&amp;rdquo; like it&amp;rsquo;s done in other languages. Note that an actual character might be represented by multiple runes. Make sure to check out the &amp;ldquo;norm&amp;rdquo; package (golang.org/x/text/unicode/norm) if you need to work with characters.&lt;/p&gt;

&lt;p&gt;The for range clauses with string variables will try to interpret the data as UTF8 text. For any byte sequences it doesn&amp;rsquo;t understand it will return 0xfffd runes (aka unicode replacement characters) instead of the actual data. If you have arbitrary (non-UTF8 text) data stored in your string variables, make sure to convert them to byte slices to get all stored data as is.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    data := &amp;quot;A\xfe\x02\xff\x04&amp;quot;
    for _,v := range data {
        fmt.Printf(&amp;quot;%#x &amp;quot;,v)
    }
    //prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)

    fmt.Println()
    for _,v := range []byte(data) {
        fmt.Printf(&amp;quot;%#x &amp;quot;,v)
    }
    //prints: 0x41 0xfe 0x2 0xff 0x4 (good)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-25-a-iterating-through-a-map-using-a-for-range-clause&#34;&gt;&lt;a name=&#34;25&#34;&gt;&lt;/a&gt;Iterating Through a Map Using a &amp;ldquo;for range&amp;rdquo; Clause&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is a gotcha if you expect the items to be in a certain order (e.g., ordered by the key value). Each map iteration will produce different results. The Go runtime tries to go an extra mile randomizing the iteration order, but it doesn&amp;rsquo;t always succeed so you may get several identical map iterations. Don&amp;rsquo;t be surprised to see 5 identical iterations in a row.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    m := map[string]int{&amp;quot;one&amp;quot;:1,&amp;quot;two&amp;quot;:2,&amp;quot;three&amp;quot;:3,&amp;quot;four&amp;quot;:4}
    for k,v := range m {
        fmt.Println(k,v)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if you use the Go Playground (&lt;a href=&#34;https://play.golang.org/&#34;&gt;https://play.golang.org/&lt;/a&gt;) you&amp;rsquo;ll always get the same results because it doesn&amp;rsquo;t recompile the code unless you make a change.&lt;/p&gt;

&lt;h3 id=&#34;a-name-26-a-fallthrough-behavior-in-switch-statements&#34;&gt;&lt;a name=&#34;26&#34;&gt;&lt;/a&gt;Fallthrough Behavior in &amp;ldquo;switch&amp;rdquo; Statements&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &amp;ldquo;case&amp;rdquo; blocks in &amp;ldquo;switch&amp;rdquo; statements break by default. This is different from other languages where the default behavior is to fall through to the next &amp;ldquo;case&amp;rdquo; block.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    isSpace := func(ch byte) bool {
        switch(ch) {
        case &#39; &#39;: //error
        case &#39;\t&#39;:
            return true
        }
        return false
    }

    fmt.Println(isSpace(&#39;\t&#39;)) //prints true (ok)
    fmt.Println(isSpace(&#39; &#39;))  //prints false (not ok)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can force the &amp;ldquo;case&amp;rdquo; blocks to fall through by using the &amp;ldquo;fallthrough&amp;rdquo; statement at the end of each &amp;ldquo;case&amp;rdquo; block. You can also rewrite your switch statement to use expression lists in the &amp;ldquo;case&amp;rdquo; blocks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    isSpace := func(ch byte) bool {
        switch(ch) {
        case &#39; &#39;, &#39;\t&#39;:
            return true
        }
        return false
    }

    fmt.Println(isSpace(&#39;\t&#39;)) //prints true (ok)
    fmt.Println(isSpace(&#39; &#39;))  //prints true (ok)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-27-a-increments-and-decrements&#34;&gt;&lt;a name=&#34;27&#34;&gt;&lt;/a&gt;Increments and Decrements&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Many languages have increment and decrement operators. Unlike other languages, Go doesn&amp;rsquo;t support the prefix version of the operations. You also can&amp;rsquo;t use these two operators in expressions.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    data := []int{1,2,3}
    i := 0
    ++i //error
    fmt.Println(data[i++]) //error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Errors:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox101231828/main.go:8: syntax error: unexpected ++ /tmp/sandbox101231828/main.go:9: syntax error: unexpected ++, expecting :
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    data := []int{1,2,3}
    i := 0
    i++
    fmt.Println(data[i])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-28-a-bitwise-not-operator&#34;&gt;&lt;a name=&#34;28&#34;&gt;&lt;/a&gt;Bitwise NOT Operator&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Many languages use ~ as the unary NOT operator (aka bitwise complement), but Go reuses the XOR operator (^) for that.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    fmt.Println(~2) //error
}
Compile Error:

/tmp/sandbox965529189/main.go:6: the bitwise complement operator is ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    var d uint8 = 2
    fmt.Printf(&amp;quot;%08b\n&amp;quot;,^d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go still uses ^ as the XOR operator, which may be confusing for some people.&lt;/p&gt;

&lt;p&gt;If you want you can represent a unary NOT operation (e.g, NOT 0x02) with a binary XOR operation (e.g., 0x02 XOR 0xff). This could explain why ^ is reused to represent unary NOT operations.&lt;/p&gt;

&lt;p&gt;Go also has a special &amp;lsquo;AND NOT&amp;rsquo; bitwise operator (&amp;amp;^), which adds to the NOT operator confusion. It looks like a special feature/hack to support A AND (NOT B) without requiring parentheses.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    var a uint8 = 0x82
    var b uint8 = 0x02
    fmt.Printf(&amp;quot;%08b [A]\n&amp;quot;,a)
    fmt.Printf(&amp;quot;%08b [B]\n&amp;quot;,b)

    fmt.Printf(&amp;quot;%08b (NOT B)\n&amp;quot;,^b)
    fmt.Printf(&amp;quot;%08b ^ %08b = %08b [B XOR 0xff]\n&amp;quot;,b,0xff,b ^ 0xff)

    fmt.Printf(&amp;quot;%08b ^ %08b = %08b [A XOR B]\n&amp;quot;,a,b,a ^ b)
    fmt.Printf(&amp;quot;%08b &amp;amp; %08b = %08b [A AND B]\n&amp;quot;,a,b,a &amp;amp; b)
    fmt.Printf(&amp;quot;%08b &amp;amp;^%08b = %08b [A &#39;AND NOT&#39; B]\n&amp;quot;,a,b,a &amp;amp;^ b)
    fmt.Printf(&amp;quot;%08b&amp;amp;(^%08b)= %08b [A AND (NOT B)]\n&amp;quot;,a,b,a &amp;amp; (^b))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-29-a-operator-precedence-differences&#34;&gt;&lt;a name=&#34;29&#34;&gt;&lt;/a&gt;Operator Precedence Differences&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Aside from the &amp;ldquo;bit clear&amp;rdquo; operators (&amp;amp;^) Go has a set of standard operators shared by many other languages. The operator precedence is not always the same though.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    fmt.Printf(&amp;quot;0x2 &amp;amp; 0x2 + 0x4 -&amp;gt; %#x\n&amp;quot;,0x2 &amp;amp; 0x2 + 0x4)
    //prints: 0x2 &amp;amp; 0x2 + 0x4 -&amp;gt; 0x6
    //Go:    (0x2 &amp;amp; 0x2) + 0x4
    //C++:    0x2 &amp;amp; (0x2 + 0x4) -&amp;gt; 0x2

    fmt.Printf(&amp;quot;0x2 + 0x2 &amp;lt;&amp;lt; 0x1 -&amp;gt; %#x\n&amp;quot;,0x2 + 0x2 &amp;lt;&amp;lt; 0x1)
    //prints: 0x2 + 0x2 &amp;lt;&amp;lt; 0x1 -&amp;gt; 0x6
    //Go:     0x2 + (0x2 &amp;lt;&amp;lt; 0x1)
    //C++:   (0x2 + 0x2) &amp;lt;&amp;lt; 0x1 -&amp;gt; 0x8

    fmt.Printf(&amp;quot;0xf | 0x2 ^ 0x2 -&amp;gt; %#x\n&amp;quot;,0xf | 0x2 ^ 0x2)
    //prints: 0xf | 0x2 ^ 0x2 -&amp;gt; 0xd
    //Go:    (0xf | 0x2) ^ 0x2
    //C++:    0xf | (0x2 ^ 0x2) -&amp;gt; 0xf
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-30-a-unexported-structure-fields-are-not-encoded&#34;&gt;&lt;a name=&#34;30&#34;&gt;&lt;/a&gt;Unexported Structure Fields Are Not Encoded&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The struct fields starting with lowercase letters will not be (json, xml, gob, etc.) encoded, so when you decode the structure you&amp;rsquo;ll end up with zero values in those unexported fields.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;encoding/json&amp;quot;
)

type MyData struct {  
    One int
    two string
}

func main() {  
    in := MyData{1,&amp;quot;two&amp;quot;}
    fmt.Printf(&amp;quot;%#v\n&amp;quot;,in) //prints main.MyData{One:1, two:&amp;quot;two&amp;quot;}

    encoded,_ := json.Marshal(in)
    fmt.Println(string(encoded)) //prints {&amp;quot;One&amp;quot;:1}

    var out MyData
    json.Unmarshal(encoded,&amp;amp;out)

    fmt.Printf(&amp;quot;%#v\n&amp;quot;,out) //prints main.MyData{One:1, two:&amp;quot;&amp;quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-31-a-app-exits-with-active-goroutines&#34;&gt;&lt;a name=&#34;31&#34;&gt;&lt;/a&gt;App Exits With Active Goroutines&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The app will not wait for all your goroutines to complete. This is a common mistake for beginners in general. Everybody starts somewhere, so there&amp;rsquo;s no shame in making rookie mistakes :-)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {  
    workerCount := 2

    for i := 0; i &amp;lt; workerCount; i++ {
        go doit(i)
    }
    time.Sleep(1 * time.Second)
    fmt.Println(&amp;quot;all done!&amp;quot;)
}

func doit(workerId int) {  
    fmt.Printf(&amp;quot;[%v] is running\n&amp;quot;,workerId)
    time.Sleep(3 * time.Second)
    fmt.Printf(&amp;quot;[%v] is done\n&amp;quot;,workerId)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[0] is running
[1] is running
all done!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the most common solutions is to use a &amp;ldquo;WaitGroup&amp;rdquo; variable. It will allow the main goroutine to wait until all worker goroutines are done. If your app has long running workers with message processing loops you&amp;rsquo;ll also need a way to signal those goroutines that it&amp;rsquo;s time to exit. You can send a &amp;ldquo;kill&amp;rdquo; message to each worker. Another option is to close a channel all workers are receiving from. It&amp;rsquo;s a simple way to signal all goroutines at once.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;
)

func main() {  
    var wg sync.WaitGroup
    done := make(chan struct{})
    workerCount := 2

    for i := 0; i &amp;lt; workerCount; i++ {
        wg.Add(1)
        go doit(i,done,wg)
    }

    close(done)
    wg.Wait()
    fmt.Println(&amp;quot;all done!&amp;quot;)
}

func doit(workerId int,done &amp;lt;-chan struct{},wg sync.WaitGroup) {  
    fmt.Printf(&amp;quot;[%v] is running\n&amp;quot;,workerId)
    defer wg.Done()
    &amp;lt;- done
    fmt.Printf(&amp;quot;[%v] is done\n&amp;quot;,workerId)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run this app you&amp;rsquo;ll see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[0] is running
[0] is done
[1] is running
[1] is done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks like the workers are done before the main goroutine exists. Great! However, you&amp;rsquo;ll also see this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fatal error: all goroutines are asleep - deadlock!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s not so great :-) What&amp;rsquo;s going on? Why is there a deadlock? The workers exited and they executed wg.Done(). The app should work.&lt;/p&gt;

&lt;p&gt;The deadlock happens because each worker gets a copy of the original &amp;ldquo;WaitGroup&amp;rdquo; variable. When workers execute wg.Done() it has no effect on the &amp;ldquo;WaitGroup&amp;rdquo; variable in the main goroutine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;
)

func main() {  
    var wg sync.WaitGroup
    done := make(chan struct{})
    wq := make(chan interface{})
    workerCount := 2

    for i := 0; i &amp;lt; workerCount; i++ {
        wg.Add(1)
        go doit(i,wq,done,&amp;amp;wg)
    }

    for i := 0; i &amp;lt; workerCount; i++ {
        wq &amp;lt;- i
    }

    close(done)
    wg.Wait()
    fmt.Println(&amp;quot;all done!&amp;quot;)
}

func doit(workerId int, wq &amp;lt;-chan interface{},done &amp;lt;-chan struct{},wg * sync.WaitGroup) {  
    fmt.Printf(&amp;quot;[%v] is running\n&amp;quot;,workerId)
    defer wg.Done()
    for {
        select {
        case m := &amp;lt;- wq:
            fmt.Printf(&amp;quot;[%v] m =&amp;gt; %v\n&amp;quot;,workerId,m)
        case &amp;lt;- done:
            fmt.Printf(&amp;quot;[%v] is done\n&amp;quot;,workerId)
            return
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it works as expected :-)&lt;/p&gt;

&lt;h3 id=&#34;a-name-32-a-sending-to-an-unbuffered-channel-returns-as-soon-as-the-target-receiver-is-ready&#34;&gt;&lt;a name=&#34;32&#34;&gt;&lt;/a&gt;Sending to an Unbuffered Channel Returns As Soon As the Target Receiver Is Ready&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The sender will not be blocked until your message is processed by the receiver. Depending on the machine where you are running the code, the receiver goroutine may or may not have enough time to process the message before the sender continues its execution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    ch := make(chan string)

    go func() {
        for m := range ch {
            fmt.Println(&amp;quot;processed:&amp;quot;,m)
        }
    }()

    ch &amp;lt;- &amp;quot;cmd.1&amp;quot;
    ch &amp;lt;- &amp;quot;cmd.2&amp;quot; //won&#39;t be processed
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-33-a-sending-to-an-closed-channel-causes-a-panic&#34;&gt;&lt;a name=&#34;33&#34;&gt;&lt;/a&gt;Sending to an Closed Channel Causes a Panic&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Receiving from a closed channel is safe. The ok return value in a receive statement will be set to false indicating that no data was received. If you are receiving from a buffered channel you&amp;rsquo;ll get the buffered data first and once it&amp;rsquo;s empty the ok return value will be false.&lt;/p&gt;

&lt;p&gt;Sending data to a closed channel causes a panic. It is a documented behavior, but it&amp;rsquo;s not very intuitive for new Go developers who might expect the send behavior to be similar to the receive behavior.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {  
    ch := make(chan int)
    for i := 0; i &amp;lt; 3; i++ {
        go func(idx int) {
            ch &amp;lt;- (idx + 1) * 2
        }(i)
    }

    //get the first result
    fmt.Println(&amp;lt;-ch)
    close(ch) //not ok (you still have other senders)
    //do other work
    time.Sleep(2 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on your application the fix will be different. It might be a minor code change or it might require a change in your application design. Either way, you&amp;rsquo;ll need to make sure your application doesn&amp;rsquo;t try to send data to a closed channel.&lt;/p&gt;

&lt;p&gt;The buggy example can be fixed by using a special cancellation channel to signal the remaining workers that their results are no longer neeeded.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {  
    ch := make(chan int)
    done := make(chan struct{})
    for i := 0; i &amp;lt; 3; i++ {
        go func(idx int) {
            select {
            case ch &amp;lt;- (idx + 1) * 2: fmt.Println(idx,&amp;quot;sent result&amp;quot;)
            case &amp;lt;- done: fmt.Println(idx,&amp;quot;exiting&amp;quot;)
            }
        }(i)
    }

    //get first result
    fmt.Println(&amp;quot;result:&amp;quot;,&amp;lt;-ch)
    close(done)
    //do other work
    time.Sleep(3 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-34-a-using-nil-channels&#34;&gt;&lt;a name=&#34;34&#34;&gt;&lt;/a&gt;Using &amp;ldquo;nil&amp;rdquo; Channels&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Send and receive operations on a nil channel block forver. It&amp;rsquo;s a well documented behavior, but it can be a surprise for new Go developers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {  
    var ch chan int
    for i := 0; i &amp;lt; 3; i++ {
        go func(idx int) {
            ch &amp;lt;- (idx + 1) * 2
        }(i)
    }

    //get first result
    fmt.Println(&amp;quot;result:&amp;quot;,&amp;lt;-ch)
    //do other work
    time.Sleep(2 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run the code you&amp;rsquo;ll see a runtime error like this: fatal error: all goroutines are asleep - deadlock!&lt;/p&gt;

&lt;p&gt;This behavior can be used as a way to dynamically enable and disable case blocks in a select statement.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;  
import &amp;quot;time&amp;quot;

func main() {  
    inch := make(chan int)
    outch := make(chan int)

    go func() {
        var in &amp;lt;- chan int = inch
        var out chan &amp;lt;- int
        var val int
        for {
            select {
            case out &amp;lt;- val:
                out = nil
                in = inch
            case val = &amp;lt;- in:
                out = outch
                in = nil
            }
        }
    }()

    go func() {
        for r := range outch {
            fmt.Println(&amp;quot;result:&amp;quot;,r)
        }
    }()

    time.Sleep(0)
    inch &amp;lt;- 1
    inch &amp;lt;- 2
    time.Sleep(3 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-35-a-methods-with-value-receivers-can-t-change-the-original-value&#34;&gt;&lt;a name=&#34;35&#34;&gt;&lt;/a&gt;Methods with Value Receivers Can&amp;rsquo;t Change the Original Value&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: beginner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Method receivers are like regular function arguments. If it&amp;rsquo;s declared to be a value then your function/method gets a copy of your receiver argument. This means making changes to the receiver will not affect the original value unless your receiver is a map or slice variable and you are updating the items in the collection or the fields you are updating in the receiver are pointers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type data struct {  
    num int
    key *string
    items map[string]bool
}

func (this *data) pmethod() {  
    this.num = 7
}

func (this data) vmethod() {  
    this.num = 8
    *this.key = &amp;quot;v.key&amp;quot;
    this.items[&amp;quot;vmethod&amp;quot;] = true
}

func main() {  
    key := &amp;quot;key.1&amp;quot;
    d := data{1,&amp;amp;key,make(map[string]bool)}

    fmt.Printf(&amp;quot;num=%v key=%v items=%v\n&amp;quot;,d.num,*d.key,d.items)
    //prints num=1 key=key.1 items=map[]

    d.pmethod()
    fmt.Printf(&amp;quot;num=%v key=%v items=%v\n&amp;quot;,d.num,*d.key,d.items)
    //prints num=7 key=key.1 items=map[]

    d.vmethod()
    fmt.Printf(&amp;quot;num=%v key=%v items=%v\n&amp;quot;,d.num,*d.key,d.items)
    //prints num=7 key=v.key items=map[vmethod:true]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-36-a-closing-http-response-body&#34;&gt;&lt;a name=&#34;36&#34;&gt;&lt;/a&gt;Closing HTTP Response Body&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When you make requests using the standard http library you get a http response variable. If you don&amp;rsquo;t read the response body you still need to close it. Note that you must do it for empty responses too. It&amp;rsquo;s very easy to forget especially for new Go developers.&lt;/p&gt;

&lt;p&gt;Some new Go developers do try to close the response body, but they do it in the wrong place.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
)

func main() {  
    resp, err := http.Get(&amp;quot;https://api.ipify.org?format=json&amp;quot;)
    defer resp.Body.Close()//not ok
    if err != nil {
        fmt.Println(err)
        return
    }

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Println(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code works for successful requests, but if the http request fails the resp variable might be nil, which will cause a runtime panic.&lt;/p&gt;

&lt;p&gt;The most common why to close the response body is by using a defer call after the http response error check.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
)

func main() {  
    resp, err := http.Get(&amp;quot;https://api.ipify.org?format=json&amp;quot;)
    if err != nil {
        fmt.Println(err)
        return
    }

    defer resp.Body.Close()//ok, most of the time :-)
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Println(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the time when your http request fails the resp variable will be nil and the err variable will be non-nil. However, when you get a redirection failure both variables will be non-nil. This means you can still end up with a leak.&lt;/p&gt;

&lt;p&gt;You can fix this leak by adding a call to close non-nil response bodies in the http response error handling block. Another option is to use one defer call to close response bodies for all failed and successful requests.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
)

func main() {  
    resp, err := http.Get(&amp;quot;https://api.ipify.org?format=json&amp;quot;)
    if resp != nil {
        defer resp.Body.Close()
    }

    if err != nil {
        fmt.Println(err)
        return
    }

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Println(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The orignal implementation for resp.Body.Close() also reads and discards the remaining response body data. This ensured that the http connection could be reused for another request if the keepalive http connection behavior is enabled. The latest http client behavior is different. Now it&amp;rsquo;s your responsibility to read and discard the remaining response data. If you don&amp;rsquo;t do it the http connection might be closed instead of being reused. This little gotcha is supposed to be documented in Go 1.5.&lt;/p&gt;

&lt;p&gt;If reusing the http connection is important for your application you might need to add something like this at the end of your response processing logic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_, err = io.Copy(ioutil.Discard, resp.Body)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will be necessary if you don&amp;rsquo;t read the entire response body right away, which might happen if you are processing json API responses with code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;json.NewDecoder(resp.Body).Decode(&amp;amp;data)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-37-a-closing-http-connections&#34;&gt;&lt;a name=&#34;37&#34;&gt;&lt;/a&gt;Closing HTTP Connections&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some HTTP servers keep network connections open for a while (based on the HTTP 1.1 spec and the server &amp;ldquo;keep-alive&amp;rdquo; configurations). By default, the standard http library will close the network connections only when the target HTTP server asks for it. This means your app may run out of sockets/file descriptors under certain conditions.&lt;/p&gt;

&lt;p&gt;You can ask the http library to close the connection after your request is done by setting the Close field in the request variable to true.&lt;/p&gt;

&lt;p&gt;Another option is to add a Connection request header and set it to close. The target HTTP server should respond with a Connection: close header too. When the http library sees this response header it will also close the connection.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
)

func main() {  
    req, err := http.NewRequest(&amp;quot;GET&amp;quot;,&amp;quot;http://golang.org&amp;quot;,nil)
    if err != nil {
        fmt.Println(err)
        return
    }

    req.Close = true
    //or do this:
    //req.Header.Add(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;)

    resp, err := http.DefaultClient.Do(req)
    if resp != nil {
        defer resp.Body.Close()
    }

    if err != nil {
        fmt.Println(err)
        return
    }

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Println(len(string(body)))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also disable http connection reuse globally. You&amp;rsquo;ll need to create a custom http transport configuration for it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
)

func main() {  
    tr := &amp;amp;http.Transport{DisableKeepAlives: true}
    client := &amp;amp;http.Client{Transport: tr}

    resp, err := client.Get(&amp;quot;http://golang.org&amp;quot;)
    if resp != nil {
        defer resp.Body.Close()
    }

    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Println(resp.StatusCode)

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Println(len(string(body)))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you send a lot of requests to the same HTTP server it&amp;rsquo;s ok to keep the network connection open. However, if your app sends one or two requests to many different HTTP servers in a short period of time it&amp;rsquo;s a good idea to close the network connections right after your app receives the responses. Increasing the open file limit might be a good idea too. The correct solution depends on your application though.&lt;/p&gt;

&lt;h3 id=&#34;a-name-38-a-unmarshalling-json-numbers-into-interface-values&#34;&gt;&lt;a name=&#34;38&#34;&gt;&lt;/a&gt;Unmarshalling JSON Numbers into Interface Values&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By default, Go treats numeric values in JSON as float64 numbers when you decode/unmarshal JSON data into an interface. This means the following code will fail with a panic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
  &amp;quot;encoding/json&amp;quot;
  &amp;quot;fmt&amp;quot;
)

func main() {  
  var data = []byte(`{&amp;quot;status&amp;quot;: 200}`)

  var result map[string]interface{}
  if err := json.Unmarshal(data, &amp;amp;result); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
  }

  var status = result[&amp;quot;status&amp;quot;].(int) //error
  fmt.Println(&amp;quot;status value:&amp;quot;,status)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Runtime Panic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;panic: interface conversion: interface is float64, not int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the JSON value you are trying to decode is an integer you have serveral options.&lt;/p&gt;

&lt;p&gt;Option one: use the float value as-is :-)&lt;/p&gt;

&lt;p&gt;Option two: convert the float value to the integer type you need.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
  &amp;quot;encoding/json&amp;quot;
  &amp;quot;fmt&amp;quot;
)

func main() {  
  var data = []byte(`{&amp;quot;status&amp;quot;: 200}`)

  var result map[string]interface{}
  if err := json.Unmarshal(data, &amp;amp;result); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
  }

  var status = uint64(result[&amp;quot;status&amp;quot;].(float64)) //ok
  fmt.Println(&amp;quot;status value:&amp;quot;,status)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Option three: use a Decoder type to unmarshal JSON and tell it to represent JSON numbers using the Number interface type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
  &amp;quot;encoding/json&amp;quot;
  &amp;quot;bytes&amp;quot;
  &amp;quot;fmt&amp;quot;
)

func main() {  
  var data = []byte(`{&amp;quot;status&amp;quot;: 200}`)

  var result map[string]interface{}
  var decoder = json.NewDecoder(bytes.NewReader(data))
  decoder.UseNumber()

  if err := decoder.Decode(&amp;amp;result); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
  }

  var status,_ = result[&amp;quot;status&amp;quot;].(json.Number).Int64() //ok
  fmt.Println(&amp;quot;status value:&amp;quot;,status)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use the string representation of your Number value to unmarshal it to a different numeric type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
  &amp;quot;encoding/json&amp;quot;
  &amp;quot;bytes&amp;quot;
  &amp;quot;fmt&amp;quot;
)

func main() {  
  var data = []byte(`{&amp;quot;status&amp;quot;: 200}`)

  var result map[string]interface{}
  var decoder = json.NewDecoder(bytes.NewReader(data))
  decoder.UseNumber()

  if err := decoder.Decode(&amp;amp;result); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
  }

  var status uint64
  if err := json.Unmarshal([]byte(result[&amp;quot;status&amp;quot;].(json.Number).String()), &amp;amp;status); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
  }

  fmt.Println(&amp;quot;status value:&amp;quot;,status)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Option four: use a struct type that maps your numeric value to the numeric type you need.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
  &amp;quot;encoding/json&amp;quot;
  &amp;quot;bytes&amp;quot;
  &amp;quot;fmt&amp;quot;
)

func main() {  
  var data = []byte(`{&amp;quot;status&amp;quot;: 200}`)

  var result struct {
    Status uint64 `json:&amp;quot;status&amp;quot;`
  }

  if err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;amp;result); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
  }

  fmt.Printf(&amp;quot;result =&amp;gt; %+v&amp;quot;,result)
  //prints: result =&amp;gt; {Status:200}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Option five: use a struct that maps your numeric value to the json.RawMessage type if you need to defer the value decoding.&lt;/p&gt;

&lt;p&gt;This option is useful if you have to perform conditional JSON field decoding where the field type or structure might change.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
  &amp;quot;encoding/json&amp;quot;
  &amp;quot;bytes&amp;quot;
  &amp;quot;fmt&amp;quot;
)

func main() {  
  records := [][]byte{
    []byte(`{&amp;quot;status&amp;quot;: 200, &amp;quot;tag&amp;quot;:&amp;quot;one&amp;quot;}`),
    []byte(`{&amp;quot;status&amp;quot;:&amp;quot;ok&amp;quot;, &amp;quot;tag&amp;quot;:&amp;quot;two&amp;quot;}`),
  }

  for idx, record := range records {
    var result struct {
      StatusCode uint64
      StatusName string
      Status json.RawMessage `json:&amp;quot;status&amp;quot;`
      Tag string             `json:&amp;quot;tag&amp;quot;`
    }

    if err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;amp;result); err != nil {
      fmt.Println(&amp;quot;error:&amp;quot;, err)
      return
    }

    var sstatus string
    if err := json.Unmarshal(result.Status, &amp;amp;sstatus); err == nil {
      result.StatusName = sstatus
    }

    var nstatus uint64
    if err := json.Unmarshal(result.Status, &amp;amp;nstatus); err == nil {
      result.StatusCode = nstatus
    }

    fmt.Printf(&amp;quot;[%v] result =&amp;gt; %+v\n&amp;quot;,idx,result)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-39-a-comparing-structs-arrays-slices-and-maps&#34;&gt;&lt;a name=&#34;39&#34;&gt;&lt;/a&gt;Comparing Structs, Arrays, Slices, and Maps&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can use the equality operator, ==, to compare struct variables if each structure field can be compared with the equality operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type data struct {  
    num int
    fp float32
    complex complex64
    str string
    char rune
    yes bool
    events &amp;lt;-chan string
    handler interface{}
    ref *byte
    raw [10]byte
}

func main() {  
    v1 := data{}
    v2 := data{}
    fmt.Println(&amp;quot;v1 == v2:&amp;quot;,v1 == v2) //prints: v1 == v2: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If any of the struct fields are not comparable then using the equality operator will result in compile time errors. Note that arrays are comparable only if their data items are comparable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type data struct {  
    num int                //ok
    checks [10]func() bool //not comparable
    doit func() bool       //not comparable
    m map[string] string   //not comparable
    bytes []byte           //not comparable
}

func main() {  
    v1 := data{}
    v2 := data{}
    fmt.Println(&amp;quot;v1 == v2:&amp;quot;,v1 == v2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go does provide a number of helper functions to compare variables that can&amp;rsquo;t be compared using the comparison operators.&lt;/p&gt;

&lt;p&gt;The most generic solution is to use the DeepEqual() function in the reflect package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;reflect&amp;quot;
)

type data struct {  
    num int                //ok
    checks [10]func() bool //not comparable
    doit func() bool       //not comparable
    m map[string] string   //not comparable
    bytes []byte           //not comparable
}

func main() {  
    v1 := data{}
    v2 := data{}
    fmt.Println(&amp;quot;v1 == v2:&amp;quot;,reflect.DeepEqual(v1,v2)) //prints: v1 == v2: true

    m1 := map[string]string{&amp;quot;one&amp;quot;: &amp;quot;a&amp;quot;,&amp;quot;two&amp;quot;: &amp;quot;b&amp;quot;}
    m2 := map[string]string{&amp;quot;two&amp;quot;: &amp;quot;b&amp;quot;, &amp;quot;one&amp;quot;: &amp;quot;a&amp;quot;}
    fmt.Println(&amp;quot;m1 == m2:&amp;quot;,reflect.DeepEqual(m1, m2)) //prints: m1 == m2: true

    s1 := []int{1, 2, 3}
    s2 := []int{1, 2, 3}
    fmt.Println(&amp;quot;s1 == s2:&amp;quot;,reflect.DeepEqual(s1, s2)) //prints: s1 == s2: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aside from being slow (which may or may not be a deal breaker for your application), DeepEqual() also has its own gotchas.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;reflect&amp;quot;
)

func main() {  
    var b1 []byte = nil
    b2 := []byte{}
    fmt.Println(&amp;quot;b1 == b2:&amp;quot;,reflect.DeepEqual(b1, b2)) //prints: b1 == b2: false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DeepEqual() doesn&amp;rsquo;t consider an empty slice to be equal to a &amp;ldquo;nil&amp;rdquo; slice. This behavior is different from the behavior you get using the bytes.Equal() function. bytes.Equal() considers &amp;ldquo;nil&amp;rdquo; and empty slices to be equal.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;bytes&amp;quot;
)

func main() {  
    var b1 []byte = nil
    b2 := []byte{}
    fmt.Println(&amp;quot;b1 == b2:&amp;quot;,bytes.Equal(b1, b2)) //prints: b1 == b2: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DeepEqual() isn&amp;rsquo;t always perfect comparing slices.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;reflect&amp;quot;
    &amp;quot;encoding/json&amp;quot;
)

func main() {  
    var str string = &amp;quot;one&amp;quot;
    var in interface{} = &amp;quot;one&amp;quot;
    fmt.Println(&amp;quot;str == in:&amp;quot;,str == in,reflect.DeepEqual(str, in))
    //prints: str == in: true true

    v1 := []string{&amp;quot;one&amp;quot;,&amp;quot;two&amp;quot;}
    v2 := []interface{}{&amp;quot;one&amp;quot;,&amp;quot;two&amp;quot;}
    fmt.Println(&amp;quot;v1 == v2:&amp;quot;,reflect.DeepEqual(v1, v2))
    //prints: v1 == v2: false (not ok)

    data := map[string]interface{}{
        &amp;quot;code&amp;quot;: 200,
        &amp;quot;value&amp;quot;: []string{&amp;quot;one&amp;quot;,&amp;quot;two&amp;quot;},
    }
    encoded, _ := json.Marshal(data)
    var decoded map[string]interface{}
    json.Unmarshal(encoded, &amp;amp;decoded)
    fmt.Println(&amp;quot;data == decoded:&amp;quot;,reflect.DeepEqual(data, decoded))
    //prints: data == decoded: false (not ok)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your byte slices (or strings) contain text data you might be tempted to use ToUpper() or ToLower() from the &amp;ldquo;bytes&amp;rdquo; and &amp;ldquo;strings&amp;rdquo; packages when you need to compare values in a case insensitive manner (before using ==,bytes.Equal(), or bytes.Compare()). It will work for English text, but it will not work for text in many other languages. strings.EqualFold() and bytes.EqualFold() should be used instead.&lt;/p&gt;

&lt;p&gt;If your byte slices contain secrets (e.g., cryptographic hashes, tokens, etc.) that need to be validated against user-provided data, don&amp;rsquo;t use reflect.DeepEqual(), bytes.Equal(), or bytes.Compare() because those functions will make your application vulnerable to timing attacks. To avoid leaking the timing information use the functions from the &amp;lsquo;crypto/subtle&amp;rsquo; package (e.g., subtle.ConstantTimeCompare()).&lt;/p&gt;

&lt;h3 id=&#34;a-name-40-a-recovering-from-a-panic&#34;&gt;&lt;a name=&#34;40&#34;&gt;&lt;/a&gt;Recovering From a Panic&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The recover() function can be used to catch/intercept a panic. Calling recover() will do the trick only when it&amp;rsquo;s done in a deferred function.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Incorrect:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    recover() //doesn&#39;t do anything
    panic(&amp;quot;not good&amp;quot;)
    recover() //won&#39;t be executed :)
    fmt.Println(&amp;quot;ok&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    defer func() {
        fmt.Println(&amp;quot;recovered:&amp;quot;,recover())
    }()

    panic(&amp;quot;not good&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to recover() works only if it&amp;rsquo;s called directly in your deferred function.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func doRecover() {  
    fmt.Println(&amp;quot;recovered =&amp;gt;&amp;quot;,recover()) //prints: recovered =&amp;gt; &amp;lt;nil&amp;gt;
}

func main() {  
    defer func() {
        doRecover() //panic is not recovered
    }()

    panic(&amp;quot;not good&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-41-a-updating-and-referencing-item-values-in-slice-array-and-map-range-clauses&#34;&gt;&lt;a name=&#34;41&#34;&gt;&lt;/a&gt;Updating and Referencing Item Values in Slice, Array, and Map &amp;ldquo;range&amp;rdquo; Clauses&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The data values generated in the &amp;ldquo;range&amp;rdquo; clause are copies of the actual collection elements. They are not references to the original items. This means that updating the values will not change the original data. It also means that taking the address of the values will not give you pointers to the original data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    data := []int{1,2,3}
    for _,v := range data {
        v *= 10 //original item is not changed
    }

    fmt.Println(&amp;quot;data:&amp;quot;,data) //prints data: [1 2 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need to update the original collection record value use the index operator to access the data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    data := []int{1,2,3}
    for i,_ := range data {
        data[i] *= 10
    }

    fmt.Println(&amp;quot;data:&amp;quot;,data) //prints data: [10 20 30]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your collection holds pointer values then the rules are slightly different. You still need to use the index operator if you want the original record to point to another value, but you can update the data stored at the target location using the second value in the &amp;ldquo;for range&amp;rdquo; clause.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    data := []*struct{num int} {{1},{2},{3}}

    for _,v := range data {
        v.num *= 10
    }

    fmt.Println(data[0],data[1],data[2]) //prints &amp;amp;{10} &amp;amp;{20} &amp;amp;{30}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-42-a-hidden-data-in-slices&#34;&gt;&lt;a name=&#34;42&#34;&gt;&lt;/a&gt;&amp;ldquo;Hidden&amp;rdquo; Data in Slices&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When you reslice a slice, the new slice will reference the array of the original slice. If you forget about this behavior it can lead to unexpected memory usage if your application allocates large temporary slices creating new slices from them to refer to small sections of the original data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func get() []byte {  
    raw := make([]byte,10000)
    fmt.Println(len(raw),cap(raw),&amp;amp;raw[0]) //prints: 10000 10000 &amp;lt;byte_addr_x&amp;gt;
    return raw[:3]
}

func main() {  
    data := get()
    fmt.Println(len(data),cap(data),&amp;amp;data[0]) //prints: 3 10000 &amp;lt;byte_addr_x&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To avoid this trap make sure to copy the data you need from the temporary slice (instead of reslicing it).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func get() []byte {  
    raw := make([]byte,10000)
    fmt.Println(len(raw),cap(raw),&amp;amp;raw[0]) //prints: 10000 10000 &amp;lt;byte_addr_x&amp;gt;
    res := make([]byte,3)
    copy(res,raw[:3])
    return res
}

func main() {  
    data := get()
    fmt.Println(len(data),cap(data),&amp;amp;data[0]) //prints: 3 3 &amp;lt;byte_addr_y&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-43-a-slice-data-corruption&#34;&gt;&lt;a name=&#34;43&#34;&gt;&lt;/a&gt;Slice Data &amp;ldquo;Corruption&amp;rdquo;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s say you need to rewrite a path (stored in a slice). You reslice the path to reference each directory modifying the first folder name and then you combine the names to create a new path.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;bytes&amp;quot;
)

func main() {  
    path := []byte(&amp;quot;AAAA/BBBBBBBBB&amp;quot;)
    sepIndex := bytes.IndexByte(path,&#39;/&#39;)
    dir1 := path[:sepIndex]
    dir2 := path[sepIndex+1:]
    fmt.Println(&amp;quot;dir1 =&amp;gt;&amp;quot;,string(dir1)) //prints: dir1 =&amp;gt; AAAA
    fmt.Println(&amp;quot;dir2 =&amp;gt;&amp;quot;,string(dir2)) //prints: dir2 =&amp;gt; BBBBBBBBB

    dir1 = append(dir1,&amp;quot;suffix&amp;quot;...)
    path = bytes.Join([][]byte{dir1,dir2},[]byte{&#39;/&#39;})

    fmt.Println(&amp;quot;dir1 =&amp;gt;&amp;quot;,string(dir1)) //prints: dir1 =&amp;gt; AAAAsuffix
    fmt.Println(&amp;quot;dir2 =&amp;gt;&amp;quot;,string(dir2)) //prints: dir2 =&amp;gt; uffixBBBB (not ok)

    fmt.Println(&amp;quot;new path =&amp;gt;&amp;quot;,string(path))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It didn&amp;rsquo;t work as you expected. Instead of &amp;ldquo;AAAAsuffix/BBBBBBBBB&amp;rdquo; you ended up with &amp;ldquo;AAAAsuffix/uffixBBBB&amp;rdquo;. It happened because both directory slices referenced the same underlying array data from the original path slice. This means that the original path is also modified. Depending on your application this might be a problem too.&lt;/p&gt;

&lt;p&gt;This problem can fixed by allocating new slices and copying the data you need. Another option is to use the full slice expression.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;bytes&amp;quot;
)

func main() {  
    path := []byte(&amp;quot;AAAA/BBBBBBBBB&amp;quot;)
    sepIndex := bytes.IndexByte(path,&#39;/&#39;)
    dir1 := path[:sepIndex:sepIndex] //full slice expression
    dir2 := path[sepIndex+1:]
    fmt.Println(&amp;quot;dir1 =&amp;gt;&amp;quot;,string(dir1)) //prints: dir1 =&amp;gt; AAAA
    fmt.Println(&amp;quot;dir2 =&amp;gt;&amp;quot;,string(dir2)) //prints: dir2 =&amp;gt; BBBBBBBBB

    dir1 = append(dir1,&amp;quot;suffix&amp;quot;...)
    path = bytes.Join([][]byte{dir1,dir2},[]byte{&#39;/&#39;})

    fmt.Println(&amp;quot;dir1 =&amp;gt;&amp;quot;,string(dir1)) //prints: dir1 =&amp;gt; AAAAsuffix
    fmt.Println(&amp;quot;dir2 =&amp;gt;&amp;quot;,string(dir2)) //prints: dir2 =&amp;gt; BBBBBBBBB (ok now)

    fmt.Println(&amp;quot;new path =&amp;gt;&amp;quot;,string(path))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The extra parameter in the full slice expression controls the capacity for the new slice. Now appending to that slice will trigger a new buffer allocation instead of overwriting the data in the second slice.&lt;/p&gt;

&lt;h3 id=&#34;a-name-44-a-stale-slices&#34;&gt;&lt;a name=&#34;44&#34;&gt;&lt;/a&gt;&amp;ldquo;Stale&amp;rdquo; Slices&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Multiple slices can reference the same data. This can happen when you create a new slice from an existing slice, for example. If your application relies on this behavior to function properly then you&amp;rsquo;ll need to worry about &amp;ldquo;stale&amp;rdquo; slices.&lt;/p&gt;

&lt;p&gt;At some point adding data to one of the slices will result in a new array allocation when the original array can&amp;rsquo;t hold any more new data. Now other slices will point to the old array (with old data).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import &amp;quot;fmt&amp;quot;

func main() {  
    s1 := []int{1,2,3}
    fmt.Println(len(s1),cap(s1),s1) //prints 3 3 [1 2 3]

    s2 := s1[1:]
    fmt.Println(len(s2),cap(s2),s2) //prints 2 2 [2 3]

    for i := range s2 { s2[i] += 20 }

    //still referencing the same array
    fmt.Println(s1) //prints [1 22 23]
    fmt.Println(s2) //prints [22 23]

    s2 = append(s2,4)

    for i := range s2 { s2[i] += 10 }

    //s1 is now &amp;quot;stale&amp;quot;
    fmt.Println(s1) //prints [1 22 23]
    fmt.Println(s2) //prints [32 33 14]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-45-type-declarations-and-methods&#34;&gt;&lt;a name=&#34;45&#34;&gt;&amp;lt;/&amp;gt;Type Declarations and Methods&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When you create a type declaration by defining a new type from an existing (non-interface) type, you don&amp;rsquo;t inherit the methods defined for that existing type.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;sync&amp;quot;

type myMutex sync.Mutex

func main() {  
    var mtx myMutex
    mtx.Lock() //error
    mtx.Unlock() //error  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Errors:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox106401185/main.go:9: mtx.Lock undefined (type myMutex has no field or method Lock) /tmp/sandbox106401185/main.go:10: mtx.Unlock undefined (type myMutex has no field or method Unlock)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you do need the methods from the original type you can define a new struct type embedding the original type as an anonymous field.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;sync&amp;quot;

type myLocker struct {  
    sync.Mutex
}

func main() {  
    var lock myLocker
    lock.Lock() //ok
    lock.Unlock() //ok
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interface type declarations also retain their method sets.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;sync&amp;quot;

type myLocker sync.Locker

func main() {  
    var lock myLocker = new(sync.Mutex)
    lock.Lock() //ok
    lock.Unlock() //ok
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-46-a-breaking-out-of-for-switch-and-for-select-code-blocks&#34;&gt;&lt;a name=&#34;46&#34;&gt;&lt;/a&gt;Breaking Out of &amp;ldquo;for switch&amp;rdquo; and &amp;ldquo;for select&amp;rdquo; Code Blocks&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A &amp;ldquo;break&amp;rdquo; statement without a label only gets you out of the inner switch/select block. If using a &amp;ldquo;return&amp;rdquo; statement is not an option then defining a label for the outer loop is the next best thing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    loop:
        for {
            switch {
            case true:
                fmt.Println(&amp;quot;breaking out...&amp;quot;)
                break loop
            }
        }

    fmt.Println(&amp;quot;out!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &amp;ldquo;goto&amp;rdquo; statement will do the trick too&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;a-name-47-a-iteration-variables-and-closures-in-for-statements&#34;&gt;&lt;a name=&#34;47&#34;&gt;&lt;/a&gt;Iteration Variables and Closures in &amp;ldquo;for&amp;rdquo; Statements&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is the most common gotcha in Go. The iteration variables in for statements are reused in each iteration. This means that each closure (aka function literal) created in your for loop will reference the same variable (and they&amp;rsquo;ll get that variable&amp;rsquo;s value at the time those goroutines start executing).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Incorrect:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {  
    data := []string{&amp;quot;one&amp;quot;,&amp;quot;two&amp;quot;,&amp;quot;three&amp;quot;}

    for _,v := range data {
        go func() {
            fmt.Println(v)
        }()
    }

    time.Sleep(3 * time.Second)
    //goroutines print: three, three, three
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The easiest solution (that doesn&amp;rsquo;t require any changes to the goroutine) is to save the current iteration variable value in a local variable inside the for loop block.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {  
    data := []string{&amp;quot;one&amp;quot;,&amp;quot;two&amp;quot;,&amp;quot;three&amp;quot;}

    for _,v := range data {
        vcopy := v //
        go func() {
            fmt.Println(vcopy)
        }()
    }

    time.Sleep(3 * time.Second)
    //goroutines print: one, two, three
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another solution is to pass the current iteration variable as a parameter to the anonymous goroutine.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {  
    data := []string{&amp;quot;one&amp;quot;,&amp;quot;two&amp;quot;,&amp;quot;three&amp;quot;}

    for _,v := range data {
        go func(in string) {
            fmt.Println(in)
        }(v)
    }

    time.Sleep(3 * time.Second)
    //goroutines print: one, two, three
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a slightly more complicated version of the trap.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Incorrect:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

type field struct {  
    name string
}

func (p *field) print() {  
    fmt.Println(p.name)
}

func main() {  
    data := []field{{&amp;quot;one&amp;quot;},{&amp;quot;two&amp;quot;},{&amp;quot;three&amp;quot;}}

    for _,v := range data {
        go v.print()
    }

    time.Sleep(3 * time.Second)
    //goroutines print: three, three, three
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

type field struct {  
    name string
}

func (p *field) print() {  
    fmt.Println(p.name)
}

func main() {  
    data := []field{{&amp;quot;one&amp;quot;},{&amp;quot;two&amp;quot;},{&amp;quot;three&amp;quot;}}

    for _,v := range data {
        v := v
        go v.print()
    }

    time.Sleep(3 * time.Second)
    //goroutines print: one, two, three
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What do you think you&amp;rsquo;ll see when you run this code (and why)?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

type field struct {  
    name string
}

func (p *field) print() {  
    fmt.Println(p.name)
}

func main() {  
    data := []*field{{&amp;quot;one&amp;quot;},{&amp;quot;two&amp;quot;},{&amp;quot;three&amp;quot;}}

    for _,v := range data {
        go v.print()
    }

    time.Sleep(3 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-48-a-deferred-function-call-argument-evaluation&#34;&gt;&lt;a name=&#34;48&#34;&gt;&lt;/a&gt;Deferred Function Call Argument Evaluation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Arguments for a deferred function call are evaluated when the defer statement is evaluated (not when the function is actually executing).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    var i int = 1

    defer fmt.Println(&amp;quot;result =&amp;gt;&amp;quot;,func() int { return i * 2 }())
    i++
    //prints: result =&amp;gt; 2 (not ok if you expected 4)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-49-a-deferred-function-call-execution&#34;&gt;&lt;a name=&#34;49&#34;&gt;&lt;/a&gt;Deferred Function Call Execution&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The deferred calls are executed at the end of the containing function and not at the end of the containing code block. It&amp;rsquo;s an easy mistake to make for new Go developers confusing the deferred code execution rules with the variable scoping rules. It can become a problem if you have a long running function with a for loop that tries to defer resource cleanup calls in each iteration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;path/filepath&amp;quot;
)

func main() {  
    if len(os.Args) != 2 {
        os.Exit(-1)
    }

    start, err := os.Stat(os.Args[1])
    if err != nil || !start.IsDir(){
        os.Exit(-1)
    }

    var targets []string
    filepath.Walk(os.Args[1], func(fpath string, fi os.FileInfo, err error) error {
        if err != nil {
            return err
        }

        if !fi.Mode().IsRegular() {
            return nil
        }

        targets = append(targets,fpath)
        return nil
    })

    for _,target := range targets {
        f, err := os.Open(target)
        if err != nil {
            fmt.Println(&amp;quot;bad target:&amp;quot;,target,&amp;quot;error:&amp;quot;,err) //prints error: too many open files
            break
        }
        defer f.Close() //will not be closed at the end of this code block
        //do something with the file...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One way to solve the problem is by wrapping the code block in a function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;path/filepath&amp;quot;
)

func main() {  
    if len(os.Args) != 2 {
        os.Exit(-1)
    }

    start, err := os.Stat(os.Args[1])
    if err != nil || !start.IsDir(){
        os.Exit(-1)
    }

    var targets []string
    filepath.Walk(os.Args[1], func(fpath string, fi os.FileInfo, err error) error {
        if err != nil {
            return err
        }

        if !fi.Mode().IsRegular() {
            return nil
        }

        targets = append(targets,fpath)
        return nil
    })

    for _,target := range targets {
        func() {
            f, err := os.Open(target)
            if err != nil {
                fmt.Println(&amp;quot;bad target:&amp;quot;,target,&amp;quot;error:&amp;quot;,err)
                return
            }
            defer f.Close() //ok
            //do something with the file...
        }()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another option is to get rid of the defer statement :-)&lt;/p&gt;

&lt;h3 id=&#34;a-name-50-a-failed-type-assertions&#34;&gt;&lt;a name=&#34;50&#34;&gt;&lt;/a&gt;Failed Type Assertions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Failed type assertions return the &amp;ldquo;zero value&amp;rdquo; for the target type used in the assertion statement. This can lead to unexpected behavior when it&amp;rsquo;s mixed with variable shadowing.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Incorrect:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    var data interface{} = &amp;quot;great&amp;quot;

    if data, ok := data.(int); ok {
        fmt.Println(&amp;quot;[is an int] value =&amp;gt;&amp;quot;,data)
    } else {
        fmt.Println(&amp;quot;[not an int] value =&amp;gt;&amp;quot;,data)
        //prints: [not an int] value =&amp;gt; 0 (not &amp;quot;great&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    var data interface{} = &amp;quot;great&amp;quot;

    if res, ok := data.(int); ok {
        fmt.Println(&amp;quot;[is an int] value =&amp;gt;&amp;quot;,res)
    } else {
        fmt.Println(&amp;quot;[not an int] value =&amp;gt;&amp;quot;,data)
        //prints: [not an int] value =&amp;gt; great (as expected)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-51-a-blocked-goroutines-and-resource-leaks&#34;&gt;&lt;a name=&#34;51&#34;&gt;&lt;/a&gt;Blocked Goroutines and Resource Leaks&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: intermediate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rob Pike talked about a number of fundamental concurrency patterns in his &amp;ldquo;Go Concurrency Patterns&amp;rdquo; presentation at Google I/O in 2012. Fetching the first result from a number of targets is one of them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func First(query string, replicas ...Search) Result {  
    c := make(chan Result)
    searchReplica := func(i int) { c &amp;lt;- replicas[i](query) }
    for i := range replicas {
        go searchReplica(i)
    }
    return &amp;lt;-c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function starts a goroutines for each search replica. Each goroutine sends its search result to the result channel. The first value from the result channel is returned.&lt;/p&gt;

&lt;p&gt;What about the results from the other goroutines? What about the goroutines themselves?&lt;/p&gt;

&lt;p&gt;The result channel in the First() function is unbuffered. This means that only the first goroutine returns. All other goroutines are stuck trying to send their results. This means if you have more than one replica each call will leak resources.&lt;/p&gt;

&lt;p&gt;To avoid the leaks you need to make sure all goroutines exit. One potential solution is to use a buffered result channel big enough to hold all results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func First(query string, replicas ...Search) Result {  
    c := make(chan Result,len(replicas))
    searchReplica := func(i int) { c &amp;lt;- replicas[i](query) }
    for i := range replicas {
        go searchReplica(i)
    }
    return &amp;lt;-c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another potential solution is to use a select statement with a default case and a buffered result channel that can hold one value. The default case ensures that the goroutines don&amp;rsquo;t get stuck even when the result channel can&amp;rsquo;t receive messages.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func First(query string, replicas ...Search) Result {  
    c := make(chan Result,1)
    searchReplica := func(i int) {
        select {
        case c &amp;lt;- replicas[i](query):
        default:
        }
    }
    for i := range replicas {
        go searchReplica(i)
    }
    return &amp;lt;-c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use a special cancellation channel to interrupt the workers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func First(query string, replicas ...Search) Result {  
    c := make(chan Result)
    done := make(chan struct{})
    defer close(done)
    searchReplica := func(i int) {
        select {
        case c &amp;lt;- replicas[i](query):
        case &amp;lt;- done:
        }
    }
    for i := range replicas {
        go searchReplica(i)
    }

    return &amp;lt;-c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why did the presentation contain these bugs? Rob Pike simply didn&amp;rsquo;t want to comlicate the slides. It makes sense, but it can be a problem for new Go developers who would use the code as is without thinking that it might have problems.&lt;/p&gt;

&lt;h3 id=&#34;a-name-52-a-using-pointer-receiver-methods-on-value-instances&#34;&gt;&lt;a name=&#34;52&#34;&gt;&lt;/a&gt;Using Pointer Receiver Methods On Value Instances&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: advanced&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s OK to call a pointer receiver method on a value as long as the value is addressable. In other words, you don&amp;rsquo;t need to have a value receiver version of the method in some cases.&lt;/p&gt;

&lt;p&gt;Not every variable is addressable though. Map elements are not addressable. Variables referenced through interfaces are also not addressable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type data struct {  
    name string
}

func (p *data) print() {  
    fmt.Println(&amp;quot;name:&amp;quot;,p.name)
}

type printer interface {  
    print()
}

func main() {  
    d1 := data{&amp;quot;one&amp;quot;}
    d1.print() //ok

    var in printer = data{&amp;quot;two&amp;quot;} //error
    in.print()

    m := map[string]data {&amp;quot;x&amp;quot;:data{&amp;quot;three&amp;quot;}}
    m[&amp;quot;x&amp;quot;].print() //error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Errors:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox017696142/main.go:21: cannot use data literal (type data) as type printer in assignment: data does not implement printer (print method has pointer receiver)
/tmp/sandbox017696142/main.go:25: cannot call pointer method on m[&amp;quot;x&amp;quot;] /tmp/sandbox017696142/main.go:25: cannot take the address of m[&amp;quot;x&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-53-a-updating-map-value-fields&#34;&gt;&lt;a name=&#34;53&#34;&gt;&lt;/a&gt;Updating Map Value Fields&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: advanced&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you have a map of struct values you can&amp;rsquo;t update individual struct fields.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fails:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

type data struct {  
    name string
}

func main() {  
    m := map[string]data {&amp;quot;x&amp;quot;:{&amp;quot;one&amp;quot;}}
    m[&amp;quot;x&amp;quot;].name = &amp;quot;two&amp;quot; //error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Compile Error:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/tmp/sandbox380452744/main.go:9: cannot assign to m[&amp;quot;x&amp;quot;].name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It doesn&amp;rsquo;t work because map elements are not addressable.&lt;/p&gt;

&lt;p&gt;What can be extra confusing for new Go devs is the fact that slice elements are addressable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type data struct {  
    name string
}

func main() {  
    s := []data {{&amp;quot;one&amp;quot;}}
    s[0].name = &amp;quot;two&amp;quot; //ok
    fmt.Println(s)    //prints: [{two}]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that a while ago it was possible to update map element fields in one of the Go compilers (gccgo), but that behavior was quickly fixed :-) It was also considered as a potential feature for Go 1.3. It wasn&amp;rsquo;t important enough to support at that point in time, so it&amp;rsquo;s still on the todo list.&lt;/p&gt;

&lt;p&gt;The first work around is to use a temporary variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type data struct {  
    name string
}

func main() {  
    m := map[string]data {&amp;quot;x&amp;quot;:{&amp;quot;one&amp;quot;}}
    r := m[&amp;quot;x&amp;quot;]
    r.name = &amp;quot;two&amp;quot;
    m[&amp;quot;x&amp;quot;] = r
    fmt.Printf(&amp;quot;%v&amp;quot;,m) //prints: map[x:{two}]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another workaround is to use a map of pointers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type data struct {  
    name string
}

func main() {  
    m := map[string]*data {&amp;quot;x&amp;quot;:{&amp;quot;one&amp;quot;}}
    m[&amp;quot;x&amp;quot;].name = &amp;quot;two&amp;quot; //ok
    fmt.Println(m[&amp;quot;x&amp;quot;]) //prints: &amp;amp;{two}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, what happens when you run this code?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

type data struct {  
    name string
}

func main() {  
    m := map[string]*data {&amp;quot;x&amp;quot;:{&amp;quot;one&amp;quot;}}
    m[&amp;quot;z&amp;quot;].name = &amp;quot;what?&amp;quot; //???
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-54-a-nil-interfaces-and-nil-interfaces-values&#34;&gt;&lt;a name=&#34;54&#34;&gt;&lt;/a&gt;&amp;ldquo;nil&amp;rdquo; Interfaces and &amp;ldquo;nil&amp;rdquo; Interfaces Values&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: advanced&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is the second most common gotcha in Go because interfaces are not pointers even though they may look like pointers. Interface variables will be &amp;ldquo;nil&amp;rdquo; only when their type and value fields are &amp;ldquo;nil&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The interface type and value fields are populated based on the type and value of the variable used to create the corresponding interface variable. This can lead to unexpected behavior when you are trying to check if an interface variable equals to &amp;ldquo;nil&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    var data *byte
    var in interface{}

    fmt.Println(data,data == nil) //prints: &amp;lt;nil&amp;gt; true
    fmt.Println(in,in == nil)     //prints: &amp;lt;nil&amp;gt; true

    in = data
    fmt.Println(in,in == nil)     //prints: &amp;lt;nil&amp;gt; false
    //&#39;data&#39; is &#39;nil&#39;, but &#39;in&#39; is not &#39;nil&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Watch out for this trap when you have a function that returns interfaces.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Incorrect:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    doit := func(arg int) interface{} {
        var result *struct{} = nil

        if(arg &amp;gt; 0) {
            result = &amp;amp;struct{}{}
        }

        return result
    }

    if res := doit(-1); res != nil {
        fmt.Println(&amp;quot;good result:&amp;quot;,res) //prints: good result: &amp;lt;nil&amp;gt;
        //&#39;res&#39; is not &#39;nil&#39;, but its value is &#39;nil&#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Works:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    doit := func(arg int) interface{} {
        var result *struct{} = nil

        if(arg &amp;gt; 0) {
            result = &amp;amp;struct{}{}
        } else {
            return nil //return an explicit &#39;nil&#39;
        }

        return result
    }

    if res := doit(-1); res != nil {
        fmt.Println(&amp;quot;good result:&amp;quot;,res)
    } else {
        fmt.Println(&amp;quot;bad result (res is nil)&amp;quot;) //here as expected
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-55-a-stack-and-heap-variables&#34;&gt;&lt;a name=&#34;55&#34;&gt;&lt;/a&gt;Stack and Heap Variables&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: advanced&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You don&amp;rsquo;t always know if your variable is allocated on the stack or heap. In C++ creating variables using the new operator always means that you have a heap variable. In Go the compiler decides where the variable will be allocated even if the new() or make() functions are used. The compiler picks the location to store the variable based on its size and the result of &amp;ldquo;escape analysis&amp;rdquo;. This also means that it&amp;rsquo;s ok to return references to local variables, which is not ok in other languages like C or C++.&lt;/p&gt;

&lt;p&gt;If you need to know where your variables are allocated pass the &amp;ldquo;-m&amp;rdquo; gc flag to &amp;ldquo;go build&amp;rdquo; or &amp;ldquo;go run&amp;rdquo; (e.g., go run -gcflags -m app.go).&lt;/p&gt;

&lt;h3 id=&#34;a-name-56-a-gomaxprocs-concurrency-and-parallelism&#34;&gt;&lt;a name=&#34;56&#34;&gt;&lt;/a&gt;GOMAXPROCS, Concurrency, and Parallelism&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: advanced&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go 1.4 and below uses only one execution context / OS thread. This means that only one goroutine can execute at any given time. Starting with 1.5 Go sets the number of execution contexts to the number of logical CPU cores returned by runtime.NumCPU(). That number may or may not match the total number of logical CPU cores on your system depending on the CPU affinity settings of your process. You can adjust this number by changing the GOMAXPROCS environment variable or by calling the runtime.GOMAXPROCS() function.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a common misconception that GOMAXPROCS represents the number of CPUs Go will use to run goroutines. The runtime.GOMAXPROCS() function documentation adds more to the confusion. The GOMAXPROCS variable description (&lt;a href=&#34;https://golang.org/pkg/runtime/&#34;&gt;https://golang.org/pkg/runtime/&lt;/a&gt;) does a better job talking about OS threads.&lt;/p&gt;

&lt;p&gt;You can set GOMAXPROCS to more than the number of your CPUs. The max value for GOMAXPROCS is 256.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;runtime&amp;quot;
)

func main() {  
    fmt.Println(runtime.GOMAXPROCS(-1)) //prints: X (1 on play.golang.org)
    fmt.Println(runtime.NumCPU())       //prints: X (1 on play.golang.org)
    runtime.GOMAXPROCS(20)
    fmt.Println(runtime.GOMAXPROCS(-1)) //prints: 20
    runtime.GOMAXPROCS(300)
    fmt.Println(runtime.GOMAXPROCS(-1)) //prints: 256
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-57-a-read-and-write-operation-reordering&#34;&gt;&lt;a name=&#34;57&#34;&gt;&lt;/a&gt;Read and Write Operation Reordering&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: advanced&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go may reorder some operations, but it ensures that the overall behavior in the goroutine where it happens doesn&amp;rsquo;t change. However, it doesn&amp;rsquo;t guarantee the order of execution across multiple goroutines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;runtime&amp;quot;
    &amp;quot;time&amp;quot;
)

var _ = runtime.GOMAXPROCS(3)

var a, b int

func u1() {  
    a = 1
    b = 2
}

func u2() {  
    a = 3
    b = 4
}

func p() {  
    println(a)
    println(b)
}

func main() {  
    go u1()
    go u2()
    go p()
    time.Sleep(1 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run this code a few times you might see these a and b variable combinations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1
2

3
4

0
2

0
0

1
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most interesting combination for a and b is &amp;ldquo;02&amp;rdquo;. It shows that b was updated before a.&lt;/p&gt;

&lt;p&gt;If you need to preserve the order of read and write operations across multiple goroutines you&amp;rsquo;ll need to use channels or the appropriate constructs from the &amp;ldquo;sync&amp;rdquo; package.&lt;/p&gt;

&lt;h3 id=&#34;a-name-58-a-preemptive-scheduling&#34;&gt;&lt;a name=&#34;58&#34;&gt;&lt;/a&gt;Preemptive Scheduling&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;level: advanced&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s possible to have a rogue goroutine that prevents other goroutines from running. It can happen if you have a for loop that doesn&amp;rsquo;t allow the scheduler to run.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    done := false

    go func(){
        done = true
    }()

    for !done {
    }
    fmt.Println(&amp;quot;done!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The for loop doesn&amp;rsquo;t have to be empty. It&amp;rsquo;ll be a problem as long as it contains code that doesn&amp;rsquo;t trigger the scheduler execution.&lt;/p&gt;

&lt;p&gt;The scheduler will run after GC, &amp;ldquo;go&amp;rdquo; statements, blocking channel operations, blocking system calls, and lock operations. It may also run when a non-inlined function is called.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {  
    done := false

    go func(){
        done = true
    }()

    for !done {
        fmt.Println(&amp;quot;not done!&amp;quot;) //not inlined
    }
    fmt.Println(&amp;quot;done!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To find out if the function you call in the for loop is inlined pass the &amp;ldquo;-m&amp;rdquo; gc flag to &amp;ldquo;go build&amp;rdquo; or &amp;ldquo;go run&amp;rdquo; (e.g., go build -gcflags -m).&lt;/p&gt;

&lt;p&gt;Another option is to invoke the scheduler explicitly. You can do it with the Gosched() function from the &amp;ldquo;runtime&amp;rdquo; package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;runtime&amp;quot;
)

func main() {  
    done := false

    go func(){
        done = true
    }()

    for !done {
        runtime.Gosched()
    }
    fmt.Println(&amp;quot;done!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you made it here and you have comments or ideas feel free to add a note to this Reddit discussion.&lt;/p&gt;

&lt;p&gt;Thank you for your feedback and suggestions!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&#34; title=&#34;50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Intro to TOML</title>
      <link>http://alimy.me/post/dev_201603132045/</link>
      <pubDate>Sun, 13 Mar 2016 20:45:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603132045/</guid>
      <description>&lt;h3 id=&#34;overview-of-date-and-calendar-classes&#34;&gt;Overview of Date and Calendar classes&lt;/h3&gt;

&lt;p&gt;TOML stands for Tom’s Own Minimal Language. It is a configuration language vaguely similar to YAML or property lists, but far, far better. But before we get into it in detail, let’s look back at what came before.&lt;/p&gt;

&lt;h3 id=&#34;long-ago-in-a-galaxy-far-far-away&#34;&gt;Long Ago, In A Galaxy Far, Far Away&lt;/h3&gt;

&lt;p&gt;Since the beginning of computing, people have needed a way to configure their software. On Linux, this generally is done in text files. For simple configurations, good old foo = bar works pretty well. One setting per line, name on the left, value on the right, separated by an equals. Great. But when your configuration gets more complicated, this quickly breaks down. What if you need a value that is more than one line? How do you indicate a value should be parsed as a number instead of a string? How do you namespace related configuration values so you don’t need ridiculously long names to prevent collisions?&lt;/p&gt;

&lt;h3 id=&#34;the-dark-ages&#34;&gt;The Dark Ages&lt;/h3&gt;

&lt;p&gt;In the 90’s, we used XML. And it sucked. XML is verbose, it’s hard for humans to read and write, and it still doesn’t solve a lot of the problems above (like how to specify the type of a value). In addition, the XML spec is huge, processing is very complicated, and all the extra features invite abuse and overcomplication.
&lt;/p&gt;

&lt;h3 id=&#34;enlightenment&#34;&gt;Enlightenment&lt;/h3&gt;

&lt;p&gt;In the mid 2000’s, JSON came to popularity as a data exchange format, and it was so much better than XML. It had real types, it was easy for programs to process, and you didn’t have to write a spec on what values should get processed in what way (well, mostly). It was sigificantly less verbose than XML. But it is a format intended for computers to read and write, not humans. It is a pain to write by hand, and even pretty-printed, it can be hard to read and the compact data format turns into a nested mess of curly braces. Also, JSON is not without its problems… for example, there’s no date type, there’s no support for comments, and all numbers are floats.&lt;/p&gt;

&lt;h3 id=&#34;a-false-start&#34;&gt;A False Start&lt;/h3&gt;

&lt;p&gt;YAML came to popularity some time after JSON as a more human-readable format, and its key: value syntax and pretty indentation is definitely a lot easier on the eyes than JSON’s nested curly-braces. However, YAML trades ease of reading for difficulty in writing. Indentation as delimiters is fraught with error… figuring out how to get multiple lines of data into any random value is an exercise in googling and trial &amp;amp; error.&lt;/p&gt;

&lt;p&gt;The YAML spec is also ridiculously long. 100% compatible parsers are very difficult to write. Writing YAML by hand is a ridden with landmines of corner cases where your choice of names or values happens to hit a reserved word or special marker. It does support comments, though.&lt;/p&gt;

&lt;h3 id=&#34;the-savior&#34;&gt;The Savior&lt;/h3&gt;

&lt;p&gt;On February 23, 2013, Tom Preston-Werner (former CEO of GitHub) made his first commit to &lt;a href=&#34;https://github.com/toml-lang/toml&#34;&gt;https://github.com/toml-lang/toml&lt;/a&gt;. TOML stands for Tom’s Obvious, Minimal Language. It is a language designed for configuring software. Finally.&lt;/p&gt;

&lt;p&gt;TOML takes inspiration from all of the above (well, except XML) and even gets some of its syntax from Microsoft’s INI files. It is easy to write by hand and easy to read. The spec is short and understandable by mere humans, and it’s fairly easy for computers to parse. It supports comments, has first class dates, and supports both integers and floats. It is generally insensitive to whitespace, without requiring a ton of delimiters.&lt;/p&gt;

&lt;p&gt;Let’s dive in.&lt;/p&gt;

&lt;h3 id=&#34;the-basics&#34;&gt;The Basics&lt;/h3&gt;

&lt;p&gt;The basic form is key = value&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Comments start with hash
foo = &amp;quot;strings are in quotes and are always UTF8 with escape codes: \n \u00E9&amp;quot;

bar = &amp;quot;&amp;quot;&amp;quot;multi-line strings
use three quotes&amp;quot;&amp;quot;&amp;quot;

baz = &#39;literal\strings\use\single\quotes&#39;

bat = &#39;&#39;&#39;multiline\literals\use
three\quotes&#39;&#39;&#39;

int = 5 # integers are just numbers
float = 5.0 # floats have a decimal point with numbers on both sides

date = 2006-05-27T07:32:00Z # dates are ISO 8601 full zulu form

bool = true # good old true and false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One cool point: If the first line of a multiline string (either literal or not) is a line return, it will be trimmed. So you can make your big blocks of text start on the line after the name of the value and not need to worry about the extraneous newline at the beginning of your text:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;preabmle = &amp;quot;&amp;quot;&amp;quot;
We the people of the United States, in order to form a more perfect union,
establish justice, insure domestic tranquility, provide for the common defense,
promote the general welfare, and secure the blessings of liberty to ourselves
and our posterity, do ordain and establish this Constitution for the United
States of America.&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lists&#34;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Lists (arrays) are signified with brackets and delimited with commas. Only primitives are allowed in this form, though you may have nested lists. The format is forgiving, ignoring whitespace and newlines, and yes, the last comma is optional (thank you!):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo = [ &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;
        &amp;quot;bat&amp;quot;
]

nums = [ 1, 2, ]

nested = [[ &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;], [1, 2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I love that the format is forgiving of whitespace and that last comma. I like that the arrays are all of a single type, but allowing mixed types of sub-arrays bugs the heck out of me.&lt;/p&gt;

&lt;h3 id=&#34;now-we-get-crazy&#34;&gt;Now we get crazy&lt;/h3&gt;

&lt;p&gt;What’s left? In JSON there are objects, in YAML there are associative arrays… in common parlance they are maps or dictionaries or hash tables. Named collections of key/value pairs.&lt;/p&gt;

&lt;p&gt;In TOML they are called tables and look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# some config above
[table_name]
foo = 1
bar = 2
Foo and bar are keys in the table called table_name. Tables have to be at the end of the config file. Why? because there’s no end delimiter. All keys under a table declaration are associated with that table, until a new table is declared or the end of the file. So declaring two tables looks like this:

# some config above
[table1]
foo = 1
bar = 2

[table2]
	foo = 1
	baz = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The declaration of table2 defines where table1 ends. Note that you can indent the values if you want, or not. TOML doesn’t care.&lt;/p&gt;

&lt;p&gt;If you want nested tables, you can do that, too. It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[table1]
	foo = &amp;quot;bar&amp;quot;

[table1.nested_table]
	baz = &amp;quot;bat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nested_table&lt;/code&gt; is defined as a value in &lt;code&gt;table1&lt;/code&gt; because its name starts with &lt;code&gt;table1..&lt;/code&gt; Again, the table goes until the next table definition, so &lt;code&gt;baz=&amp;quot;bat&amp;quot;&lt;/code&gt; is a value in &lt;code&gt;table1.nested_table&lt;/code&gt;. You can indent the nested table to make it more obvious, but again, all whitespace is optional:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[table1]
	foo = &amp;quot;bar&amp;quot;

	[table1.nested_table]
		baz = &amp;quot;bat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is equivalent to the JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
	&amp;quot;table1&amp;quot; : {
		&amp;quot;foo&amp;quot; : &amp;quot;bar&amp;quot;,
		&amp;quot;nested_table&amp;quot; : {
			&amp;quot;baz&amp;quot; : &amp;quot;bat&amp;quot;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having to retype the parent table name for each sub-table is kind of annoying, but I do like that it is very explicit. It also means that ordering and indenting and delimiters don’t matter. You don’t have to declare parent tables if they’re empty, so you can do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[foo.bar.baz]
bat = &amp;quot;hi&amp;quot;
Which is the equivalent to this JSON:

{
	&amp;quot;foo&amp;quot; : {
		&amp;quot;bar&amp;quot; : {
			&amp;quot;baz&amp;quot; : {
				&amp;quot;bat&amp;quot; : &amp;quot;hi&amp;quot;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;last-but-not-least&#34;&gt;Last but not least&lt;/h3&gt;

&lt;p&gt;The last thing is arrays of tables, which are declared with double brackets thusly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[comments]]
author = &amp;quot;Nate&amp;quot;
text = &amp;quot;Great Article!&amp;quot;

[[comments]]
author = &amp;quot;Anonymous&amp;quot;
text = &amp;quot;Love it!&amp;quot;
This is equivalent to the JSON:

{
	&amp;quot;comments&amp;quot; : [
		{
			&amp;quot;author&amp;quot; : &amp;quot;Nate&amp;quot;,
			&amp;quot;text&amp;quot; : Great Article!&amp;quot;
		},
		{
			&amp;quot;author&amp;quot; : &amp;quot;Anonymous&amp;quot;,
			&amp;quot;text&amp;quot; : Love It!&amp;quot;
		}
	]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arrays of tables inside another table get combined in the way you’d expect, like [[table1.array]].&lt;/p&gt;

&lt;p&gt;TOML is very permissive here. Because all tables have very explicitly defined parentage, the order they’re defined in doesn’t matter. You can have tables (and entries in an array of tables) in whatever order you want. This is totally acceptable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[comments]]
author = &amp;quot;Anonymous&amp;quot;
text = &amp;quot;Love it!&amp;quot;

[foo.bar.baz]
bat = &amp;quot;hi&amp;quot;

[foo.bar]
howdy = &amp;quot;neighbor&amp;quot;

[[comments]]
author = &amp;quot;Anonymous&amp;quot;
text = &amp;quot;Love it!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, it generally makes sense to actually order things in a more organized fashion, but it’s nice that you can’t shoot yourself in the foot if you reorder things “incorrectly”.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That’s TOML. It’s pretty awesome.&lt;/p&gt;

&lt;p&gt;There’s a &lt;a href=&#34;https://github.com/toml-lang/toml#implementations&#34; title=&#34;list of parsers&#34;&gt;list of parsers&lt;/a&gt; on the TOML page on github for pretty much whatever language you want. I recommend &lt;a href=&#34;https://github.com/BurntSushi/toml &#39;BurntSushi&#34;&gt;BurntSushi’s for Go&lt;/a&gt;, since it works just like the built-in parsers.&lt;/p&gt;

&lt;p&gt;It is now my default configuration language for all the applications I write.&lt;/p&gt;

&lt;p&gt;The next time you write an application that needs some configuration, take a look at TOML. I think your users will thank you.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;https://npf.io/2014/08/intro-to-toml/&#34; title=&#34;Intro to TOML&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java: Date And Calendar</title>
      <link>http://alimy.me/post/dev_201603132030/</link>
      <pubDate>Sun, 13 Mar 2016 20:30:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603132030/</guid>
      <description>&lt;h3 id=&#34;overview-of-date-and-calendar-classes&#34;&gt;Overview of Date and Calendar classes&lt;/h3&gt;

&lt;p&gt;In this tutorial we look at the classes in java that are helpful in manipulating dates. Manipulating dates in java can be challenging, especially if you are building applications that cater to multiple timezones. Parsing dates, printing a date in UTC, printing a date in a different timezone, comparing dates, adding time to date&amp;hellip; we will be looking at all of these in this tutorial. We first begin with the introduction to the classes and then follow up with examples. You may want to directly jump to the examples, however, we strongly recommend that you understand the classes first, since that will make the examples very easy to understand.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java.util.Date - This class is used to represent a specific time with a precision of millisecond. If you create a new Date object, it obtains the current system time using System.currentTimeMillis(). This is the number of milliseconds since epoch time (midnight, January 1, 1970 UTC). Here&amp;rsquo;s the tricky part, date stores time as number of seconds since epoch, it is a UTC time. However, when you print the date, you get the string representation of the date in the local timezone. Also note that the Date class is not designed to manipulate hour, month, year etc or retrieve them. Use this class only to create data or compare two dates. For all other uses, see the Calendar or GregorianCalendar class.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;java.util.Calendar - Calendar class allows manipulating data using its various fields such as minute, hour, day etc. As in the java.util.Date object, time is represented as number of milliseconds since epoch time. To get an instance of the Calendar use the Calendar.getInstance() method which returns a locale sensitive Calendar instance. Various set and get methods can be used to set and get time values. The current time is represented in two ways - 1. as number of milliseconds since epoch and 2. as local fields such as YEAR, MONTH, DAY, HOUR, MINUTE etc. The conversion between the two types is achieved by using the timezone offset (getOffset()) and the daylight savings fields.&lt;br /&gt;
the MONTH fields starts from 0 (JANUARY).&lt;br /&gt;
The DAY_OF_MONTH starts from 1&lt;br /&gt;
the DAY_OF_WEEK starts from SUNDAY with a value of 1.&lt;br /&gt;
HOUR starts from 0&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;java.util.GregorialCalendar - A GregorianCalendar is the default implementation of the Abstract Calendar class. Next let us look at examples
&lt;/p&gt;

&lt;h4 id=&#34;create-a-date-object-and-print-it&#34;&gt;Create a Date object and print it&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public void createDateAndPrintIt() {
// create and prints the current date. It prints the data in the local
// timezone
System.out.println(new java.util.Date());
// prints Sun Jul 28 20:09:36 IST 2013
// get the number of milli seconds since epock
System.out.println(new java.util.Date().getTime());
// prints 1375022617792
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;get-an-instance-of-calendar-object-and-print-it&#34;&gt;get an instance of Calendar object and print it&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public void createCalendarAndPrintIt() {
Calendar cal = Calendar.getInstance();
System.out.println(cal);
// java.util.GregorianCalendar[time=1375025205859,areFieldsSet=true,areAllFieldsSet=true,lenient=true,
// zone=sun.util.calendar.ZoneInfo[id=&amp;quot;Asia/Calcutta&amp;quot;,offset=19800000,dstSavings=0,useDaylight=false,transitions=6,lastRule=null],
// firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2013,MONTH=6,WEEK_OF_YEAR=31,WEEK_OF_MONTH=5,DAY_OF_MONTH=28,
// DAY_OF_YEAR=209,DAY_OF_WEEK=1,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=56,SECOND=45,MILLISECOND=859,ZONE_OFFSET=19800000,DST_OFFSET=0]
System.out.println(cal.getTime());
// prints Sun Jul 28 20:56:45 IST 2013
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;manipulate-calendar&#34;&gt;Manipulate Calendar&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public void manipulateCalendar() {
Calendar cal = Calendar.getInstance();
System.out.println(cal.getTime());// Sun Jul 28 21:53:55 IST 2013
// add a day
cal.add(Calendar.DAY_OF_MONTH, 1);
System.out.println(cal.getTime());// Mon Jul 29 21:53:55 IST 2013
cal.add(Calendar.DAY_OF_WEEK, 1);
System.out.println(cal.getTime());// Tue Jul 30 21:53:55 IST 2013
cal.add(Calendar.HOUR, 1);
System.out.println(cal.getTime());// Tue Jul 30 22:53:55 IST 2013
cal.add(Calendar.HOUR_OF_DAY, 1);
System.out.println(cal.getTime());// Tue Jul 30 23:53:55 IST 2013
cal.add(Calendar.MINUTE, 100);
System.out.println(cal.getTime());// Wed Jul 31 01:33:55 IST 2013
// demonstrate leniency
cal.add(Calendar.DAY_OF_MONTH, 32);
System.out.println(cal.getTime());// Sun Sep 01 01:33:55 IST 2013
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/date/java-date-and-calendar-classes.jsp&#34; title=&#34;Date And Calendar&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java: org.json</title>
      <link>http://alimy.me/post/dev_201603132025/</link>
      <pubDate>Sun, 13 Mar 2016 20:25:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603132025/</guid>
      <description>&lt;h3 id=&#34;overview-of-the-api-classes&#34;&gt;Overview of The API Classes&lt;/h3&gt;

&lt;p&gt;org.json has classes to parse and write json string. It also converts between json and xml, HTTP header, Cookies, and CDF. The main classes are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;org.json.JSONObject - This class stores unordered key value pairs. The value can be Boolean, JSONArray, Number, String or JSONObject.NULL. It has constructors to take in a json string and store it as key value pairs. It also has constructors that take in a Map, a bean or a String&lt;/li&gt;
&lt;li&gt;org.json.JSONTokener - This class parses a JSON string and is also used internally by the JSONObject and JSONArray classes to parse JSON Strings&lt;/li&gt;
&lt;li&gt;org.json.JSONArray - This class stores an ordered sequence of values. Externally it represents a JSON Array&lt;/li&gt;
&lt;li&gt;org.json.JSONWriter - This class represents method to produce json text. It has an append(String) method to append a string to a json text, key(String) and value(String) method to add key and values to json string. It can also write an array.&lt;/li&gt;
&lt;li&gt;org.json.CDL- This class has methods to convert comma delimited text to JSONArray and a JSONArray to a comma delimited text. The array contains rows of comma separed strings, with rows separated by newline. The first row contains names.&lt;/li&gt;
&lt;li&gt;org.json.Cookie - This class has method to convert a web browser cookie to a JSONObject and back.&lt;/li&gt;
&lt;li&gt;org.json.CookieList - This class has method to convert a list of cookies to JSONObject and back.
Lets see some examples&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;parse-json&#34;&gt;Parse JSON&lt;/h3&gt;

&lt;p&gt;This examples shows how to parse a JSON string. The JSON string in this example is a list of genres (limited to 2) from freemusicarchive.org
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytriails.json.orgjson;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.commons.io.IOUtils;
import org.json.JSONObject;
import org.json.simple.JSONArray;

public class ParseJson1 {
	public static void main(String[] args) throws MalformedURLException, IOException {
		String url = &amp;quot;http://freemusicarchive.org/api/get/genres.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=2&amp;quot;;
		String genreJson = IOUtils.toString(new URL(url));
		JSONObject json = new JSONObject(genreJson);
		// get the title
		System.out.println(json.get(&amp;quot;title&amp;quot;));
		// get the data
		JSONArray genreArray = (JSONArray) json.get(&amp;quot;dataset&amp;quot;);
		// get the first genre
		JSONObject firstGenre = (JSONObject) genreArray.get(0);
		System.out.println(firstGenre.get(&amp;quot;genre_title&amp;quot;));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;build-json-using-a-bean&#34;&gt;Build JSON using a bean&lt;/h3&gt;

&lt;p&gt;Lets look at how to build the same JSON string as above but using a bean for the genre&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytriails.json.orgjson;

import org.json.JSONObject;

public class BuildJson1 {

	public static void main(String[] args) {
		JSONObject dataset = new JSONObject();
		dataset.put(&amp;quot;genre_id&amp;quot;, 1);
		dataset.put(&amp;quot;genre_parent_id&amp;quot;, JSONObject.NULL);
		dataset.put(&amp;quot;genre_title&amp;quot;, &amp;quot;International&amp;quot;);
		// use the accumulate function to add to an existing value. The value
		// will now be converted to a list
		dataset.accumulate(&amp;quot;genre_title&amp;quot;, &amp;quot;Pop&amp;quot;);
		// append to the key
		dataset.append(&amp;quot;genre_title&amp;quot;, &amp;quot;slow&amp;quot;);
		dataset.put(&amp;quot;genre_handle&amp;quot;, &amp;quot;International&amp;quot;);
		dataset.put(&amp;quot;genre_color&amp;quot;, &amp;quot;#CC3300&amp;quot;);

		// get the json array for a string
		System.out.println(dataset.getJSONArray(&amp;quot;genre_title&amp;quot;));
		// prints [&amp;quot;International&amp;quot;,&amp;quot;Pop&amp;quot;,&amp;quot;slow&amp;quot;]

		// increment a number by 1
		dataset.increment(&amp;quot;genre_id&amp;quot;);

		// quote a string allowing the json to be delivered within html
		System.out.println(JSONObject.quote(dataset.toString()));
		// prints
		// &amp;quot;{\&amp;quot;genre_color\&amp;quot;:\&amp;quot;#CC3300\&amp;quot;,\&amp;quot;genre_title\&amp;quot;:[\&amp;quot;International\&amp;quot;,\&amp;quot;Pop\&amp;quot;,\&amp;quot;slow\&amp;quot;],
		// \&amp;quot;genre_handle\&amp;quot;:\&amp;quot;International\&amp;quot;,\&amp;quot;genre_parent_id\&amp;quot;:null,\&amp;quot;genre_id\&amp;quot;:2}&amp;quot;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;creating-a-csv-from-jsonarray&#34;&gt;Creating a CSV from JsonArray&lt;/h3&gt;

&lt;p&gt;Lets look at an example of how to use the java.json.CDL class to convert a jsonarray to a csv&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytriails.json.orgjson;

import java.io.IOException;
import java.net.URL;

import org.apache.commons.io.IOUtils;
import org.json.CDL;
import org.json.JSONArray;
import org.json.JSONObject;

public class JsonToCsv {
	public static void main(String[] args) {
		String url = &amp;quot;http://freemusicarchive.org/api/get/genres.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=10&amp;quot;;
		try {
			String genreJson = IOUtils.toString(new URL(url));
			JSONObject json = new JSONObject(genreJson);
			System.out.println(CDL.toString(new JSONArray(json.get(&amp;quot;dataset&amp;quot;).toString())));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-org-json.jsp&#34; title=&#34;Java - org.json&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java: Json Simple</title>
      <link>http://alimy.me/post/dev_201603132015/</link>
      <pubDate>Sun, 13 Mar 2016 20:15:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603132015/</guid>
      <description>&lt;p&gt;Json Simple is, as the name suggest, a very simple API. The API itself is made up of around 13 classes. The main classes are :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSONParser - This parses Json text. It takes in a java.io.Reader or a String Object. It is also possible to pass a ContentHandler or ContainerHandler to the parser.&lt;/li&gt;
&lt;li&gt;JSONObject - This is a java representation of JSON string. It stores key value pairs. JsonObject extends HashMap. It has method to encode a map to a JSON text (writeJSONString(Map map, Writer out))&lt;/li&gt;
&lt;li&gt;JSONArray - Represents a collection. It extends an ArrayList. It implements the JSONAware and JSONStreamAware interface&lt;/li&gt;
&lt;li&gt;JSONValue - This class has methods to parse JSON string into Java objects. It uses the JSONParser to do so. It has methods to write JSON string from many java types (writeJSONString(Object value, Writer out)). It also has methods to escapte special characters using the escape(String s) method. This method escapes quotes, \, /, \r, \n, \b, \f, \t and other control characters (U+0000 through U+001F)&lt;/li&gt;
&lt;li&gt;JSONAware - Beans that support output to JSON form should implement this interface.
Lets see some examples&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;parse-json&#34;&gt;Parse JSON&lt;/h3&gt;

&lt;p&gt;This examples shows how to parse a JSON string. The JSON string in this example is a list of genres (limited to 2) from freemusicarchive.org
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.io.IOException;
import java.net.URL;

import org.apache.commons.io.IOUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;
import org.json.simple.parser.ParseException;

public class ParseJson1 {

    public static void main(String[] args) {
        String url = &amp;quot;http://freemusicarchive.org/api/get/genres.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=2&amp;quot;;
        /*
         * {&amp;quot;title&amp;quot;:&amp;quot;Free Music Archive - Genres&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;errors&amp;quot;:[],&amp;quot;total&amp;quot; : &amp;quot;161&amp;quot;,&amp;quot;total_pages&amp;quot;:81,&amp;quot;page&amp;quot;:1,&amp;quot;limit&amp;quot;:&amp;quot;2&amp;quot;,
         * &amp;quot;dataset&amp;quot;:
         * [{&amp;quot;genre_id&amp;quot;: &amp;quot;1&amp;quot;,&amp;quot;genre_parent_id&amp;quot;:&amp;quot;38&amp;quot;,&amp;quot;genre_title&amp;quot;:&amp;quot;Avant-Garde&amp;quot; ,&amp;quot;genre_handle&amp;quot;: &amp;quot;Avant-Garde&amp;quot;,&amp;quot;genre_color&amp;quot;:&amp;quot;#006666&amp;quot;},
         * {&amp;quot;genre_id&amp;quot;:&amp;quot;2&amp;quot;,&amp;quot;genre_parent_id&amp;quot; :null,&amp;quot;genre_title&amp;quot;:&amp;quot;International&amp;quot;,&amp;quot;genre_handle&amp;quot;:&amp;quot;International&amp;quot;,&amp;quot;genre_color&amp;quot;:&amp;quot;#CC3300&amp;quot;}]}
         */
        try {
            String genreJson = IOUtils.toString(new URL(url));
            JSONObject genreJsonObject = (JSONObject) JSONValue.parseWithException(genreJson);
            // get the title
            System.out.println(genreJsonObject.get(&amp;quot;title&amp;quot;));
            // get the data
            JSONArray genreArray = (JSONArray) genreJsonObject.get(&amp;quot;dataset&amp;quot;);
            // get the first genre
            JSONObject firstGenre = (JSONObject) genreArray.get(0);
            System.out.println(firstGenre.get(&amp;quot;genre_title&amp;quot;));
        } catch (IOException | ParseException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;build-json&#34;&gt;Build JSON&lt;/h3&gt;

&lt;p&gt;We now build a json string for a genre&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.util.HashMap;
import java.util.Map;

import org.json.simple.JSONAware;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;

public class BuildJson2 {

    public static void main(String[] args) {
        BuildJson2 json2 = new BuildJson2();
        GenreBean bean = json2.new GenreBean();
        bean.setGenre_title(&amp;quot;International&amp;quot;);
        bean.setGenre_color(&amp;quot;#CC3300&amp;quot;);
        bean.setGenre_handle(&amp;quot;International&amp;quot;);
        bean.setGenre_id(1);
        System.out.println(JSONValue.toJSONString(bean));
    }

    class GenreBean implements JSONAware {

        int genre_id;
        int genre_parent_id;
        String genre_handle;
        String genre_title;
        String genre_color;

        @Override
        public String toJSONString() {
            Map&amp;lt;Object , Object&amp;gt; genreBeanJsonMap = new HashMap&amp;lt;Object , Object&amp;gt;();
            genreBeanJsonMap.put(&amp;quot;genre_id&amp;quot;, getGenre_id());
            genreBeanJsonMap.put(&amp;quot;genre_parent_id&amp;quot;, getGenre_parent_id());
            genreBeanJsonMap.put(&amp;quot;genre_handle&amp;quot;, getGenre_handle());
            genreBeanJsonMap.put(&amp;quot;genre_title&amp;quot;, getGenre_handle());
            genreBeanJsonMap.put(&amp;quot;genre_color&amp;quot;, getGenre_color());
            return JSONObject.toJSONString(genreBeanJsonMap);
        }

        public int getGenre_id() {
            return genre_id;
        }

        public void setGenre_id(int genre_id) {
            this.genre_id = genre_id;
        }

        public int getGenre_parent_id() {
            return genre_parent_id;
        }

        public void setGenre_parent_id(int genre_parent_id) {
            this.genre_parent_id = genre_parent_id;
        }

        public String getGenre_handle() {
            return genre_handle;
        }

        public void setGenre_handle(String genre_handle) {
            this.genre_handle = genre_handle;
        }

        public String getGenre_title() {
            return genre_title;
        }

        public void setGenre_title(String genre_title) {
            this.genre_title = genre_title;
        }

        public String getGenre_color() {
            return genre_color;
        }

        public void setGenre_color(String genre_color) {
            this.genre_color = genre_color;
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-json-simple.jsp&#34; title=&#34;Java - Json Simple&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: User Guide</title>
      <link>http://alimy.me/post/dev_201603122045/</link>
      <pubDate>Sat, 12 Mar 2016 20:45:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122045/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Goals-for-Gson&#34;&gt;Goals for Gson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Gson-Performance-and-Scalability&#34;&gt;Gson Performance and Scalability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Gson-Users&#34;&gt;Gson Users&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Using-Gson&#34;&gt;Using Gson&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Gson-With-Maven&#34;&gt;Using Gson with Maven&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Primitives-Examples&#34;&gt;Primitives Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Object-Examples&#34;&gt;Object Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Finer-Points-with-Objects&#34;&gt;Finer Points with Objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Nested-Classes-including-Inner-Classes-&#34;&gt;Nested Classes (including Inner Classes)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Array-Examples&#34;&gt;Array Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Collections-Examples&#34;&gt;Collections Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Collections-Limitations&#34;&gt;Collections Limitations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Serializing-and-Deserializing-Generic-Types&#34;&gt;Serializing and Deserializing Generic Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types&#34;&gt;Serializing and Deserializing Collection with Objects of Arbitrary Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Built-in-Serializers-and-Deserializers&#34;&gt;Built-in Serializers and Deserializers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Custom-Serialization-and-Deserialization&#34;&gt;Custom Serialization and Deserialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Writing-a-Serializer&#34;&gt;Writing a Serializer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Writing-a-Deserializer&#34;&gt;Writing a Deserializer&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Writing-an-Instance-Creator&#34;&gt;Writing an Instance Creator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-InstanceCreator-for-a-Parameterized-Type&#34;&gt;InstanceCreator for a Parameterized Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format&#34;&gt;Compact Vs. Pretty Printing for JSON Output Format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Null-Object-Support&#34;&gt;Null Object Support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Versioning-Support&#34;&gt;Versioning Support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Excluding-Fields-From-Serialization-and-Deserialization&#34;&gt;Excluding Fields From Serialization and Deserialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Java-Modifier-Exclusion&#34;&gt;Java Modifier Exclusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Gson-s-Expose&#34;&gt;Gson&amp;rsquo;s &lt;code&gt;@Expose&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-User-Defined-Exclusion-Strategies&#34;&gt;User Defined Exclusion Strategies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-JSON-Field-Naming-Support&#34;&gt;JSON Field Naming Support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers&#34;&gt;Sharing State Across Custom Serializers and Deserializers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Streaming&#34;&gt;Streaming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Issues-in-Designing-Gson&#34;&gt;Issues in Designing Gson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#TOC-Future-Enhancements-to-Gson&#34;&gt;Future Enhancements to Gson&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;a-name-toc-overview-a-overview&#34;&gt;&lt;a name=&#34;TOC-Overview&#34;&gt;&lt;/a&gt;Overview&lt;/h2&gt;

&lt;p&gt;Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.&lt;/p&gt;

&lt;p&gt;Gson can work with arbitrary Java objects including pre-existing objects that you do not have source code of.&lt;/p&gt;

&lt;h2 id=&#34;a-name-toc-goals-for-gson-a-goals-for-gson&#34;&gt;&lt;a name=&#34;TOC-Goals-for-Gson&#34;&gt;&lt;/a&gt;Goals for Gson&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Provide easy to use mechanisms like &lt;code&gt;toString()&lt;/code&gt; and constructor (factory method) to convert Java to JSON and vice-versa&lt;/li&gt;
&lt;li&gt;Allow pre-existing unmodifiable objects to be converted to and from JSON&lt;/li&gt;
&lt;li&gt;Allow custom representations for objects&lt;/li&gt;
&lt;li&gt;Support arbitrarily complex objects&lt;/li&gt;
&lt;li&gt;Generate compact and readability JSON output&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-toc-gson-performance-and-scalability-a-gson-performance-and-scalability&#34;&gt;&lt;a name=&#34;TOC-Gson-Performance-and-Scalability&#34;&gt;&lt;/a&gt;Gson Performance and Scalability&lt;/h2&gt;

&lt;p&gt;Here are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class &lt;a href=&#34;gson/src/test/java/com/google/gson/metrics/PerformanceTest.java&#34;&gt;&lt;code&gt;PerformanceTest&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Strings: Deserialized strings of over 25MB without any problems (see &lt;code&gt;disabled_testStringDeserializationPerformance&lt;/code&gt; method in &lt;code&gt;PerformanceTest&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Large collections:

&lt;ul&gt;
&lt;li&gt;Serialized a collection of 1.4 million objects (see &lt;code&gt;disabled_testLargeCollectionSerialization&lt;/code&gt; method in &lt;code&gt;PerformanceTest&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Deserialized a collection of 87,000 objects (see &lt;code&gt;disabled_testLargeCollectionDeserialization&lt;/code&gt; in &lt;code&gt;PerformanceTest&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note: Delete the &lt;code&gt;disabled_&lt;/code&gt; prefix to run these tests. We use this prefix to prevent running these tests every time we run JUnit tests.&lt;/p&gt;

&lt;h2 id=&#34;a-name-toc-gson-users-a-gson-users&#34;&gt;&lt;a name=&#34;TOC-Gson-Users&#34;&gt;&lt;/a&gt;Gson Users&lt;/h2&gt;

&lt;p&gt;Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies. See details &lt;a href=&#34;https://sites.google.com/site/gson/gson-users&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-toc-using-gson-a-using-gson&#34;&gt;&lt;a name=&#34;TOC-Using-Gson&#34;&gt;&lt;/a&gt;Using Gson&lt;/h2&gt;

&lt;p&gt;The primary class to use is &lt;a href=&#34;gson/src/main/java/com/google/gson/Gson.java&#34;&gt;&lt;code&gt;Gson&lt;/code&gt;&lt;/a&gt; which you can just create by calling &lt;code&gt;new Gson()&lt;/code&gt;. There is also a class &lt;a href=&#34;gson/src/main/java/com/google/gson/GsonBuilder.java&#34;&gt;&lt;code&gt;GsonBuilder&lt;/code&gt;&lt;/a&gt; available that can be used to create a Gson instance with various settings like version control and so on.&lt;/p&gt;

&lt;p&gt;The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations.&lt;/p&gt;

&lt;h2 id=&#34;a-name-toc-gson-with-maven-a-using-gson-with-maven&#34;&gt;&lt;a name=&#34;TOC-Gson-With-Maven&#34;&gt;&lt;/a&gt;Using Gson with Maven&lt;/h2&gt;

&lt;p&gt;To use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;!--  Gson: Java to Json conversion --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.6.2&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is it, now your maven project is Gson enabled.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-primitives-examples-a-primitives-examples&#34;&gt;&lt;a name=&#34;TOC-Primitives-Examples&#34;&gt;&lt;/a&gt;Primitives Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Serialization
Gson gson = new Gson();
gson.toJson(1);            // ==&amp;gt; 1
gson.toJson(&amp;quot;abcd&amp;quot;);       // ==&amp;gt; &amp;quot;abcd&amp;quot;
gson.toJson(new Long(10)); // ==&amp;gt; 10
int[] values = { 1 };
gson.toJson(values);       // ==&amp;gt; [1]

// Deserialization
int one = gson.fromJson(&amp;quot;1&amp;quot;, int.class);
Integer one = gson.fromJson(&amp;quot;1&amp;quot;, Integer.class);
Long one = gson.fromJson(&amp;quot;1&amp;quot;, Long.class);
Boolean false = gson.fromJson(&amp;quot;false&amp;quot;, Boolean.class);
String str = gson.fromJson(&amp;quot;\&amp;quot;abc\&amp;quot;&amp;quot;, String.class);
String anotherStr = gson.fromJson(&amp;quot;[\&amp;quot;abc\&amp;quot;]&amp;quot;, String.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-toc-object-examples-a-object-examples&#34;&gt;&lt;a name=&#34;TOC-Object-Examples&#34;&gt;&lt;/a&gt;Object Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class BagOfPrimitives {
  private int value1 = 1;
  private String value2 = &amp;quot;abc&amp;quot;;
  private transient int value3 = 3;
  BagOfPrimitives() {
    // no-args constructor
  }
}

// Serialization
BagOfPrimitives obj = new BagOfPrimitives();
Gson gson = new Gson();
String json = gson.toJson(obj);  

// ==&amp;gt; json is {&amp;quot;value1&amp;quot;:1,&amp;quot;value2&amp;quot;:&amp;quot;abc&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you can not serialize objects with circular references since that will result in infinite recursion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Deserialization
BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);
// ==&amp;gt; obj2 is just like obj
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;a-name-toc-finer-points-with-objects-a-finer-points-with-objects&#34;&gt;&lt;a name=&#34;TOC-Finer-Points-with-Objects&#34;&gt;&lt;/a&gt;&lt;strong&gt;Finer Points with Objects&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;It is perfectly fine (and recommended) to use private fields&lt;/li&gt;
&lt;li&gt;There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.&lt;/li&gt;
&lt;li&gt;If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.&lt;/li&gt;
&lt;li&gt;This implementation handles nulls correctly&lt;/li&gt;
&lt;li&gt;While serialization, a null field is skipped from the output&lt;/li&gt;
&lt;li&gt;While deserialization, a missing entry in JSON results in setting the corresponding field in the object to null&lt;/li&gt;
&lt;li&gt;If a field is &lt;em&gt;synthetic&lt;/em&gt;, it is ignored and not included in JSON serialization or deserialization&lt;/li&gt;
&lt;li&gt;Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;a-name-toc-nested-classes-including-inner-classes-a-nested-classes-including-inner-classes&#34;&gt;&lt;a name=&#34;TOC-Nested-Classes-including-Inner-Classes-&#34;&gt;&lt;/a&gt;Nested Classes (including Inner Classes)&lt;/h3&gt;

&lt;p&gt;Gson can serialize static nested classes quite easily.&lt;/p&gt;

&lt;p&gt;Gson can also deserialize static nested classes. However, Gson can &lt;strong&gt;not&lt;/strong&gt; automatically deserialize the &lt;strong&gt;pure inner classes since their no-args constructor also need a reference to the containing Object&lt;/strong&gt; which is not available at the time of deserialization. You can address this problem by either making the inner class static or by providing a custom InstanceCreator for it. Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class A {
  public String a;

  class B {

    public String b;

    public B() {
      // No args constructor for B
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The above class B can not (by default) be serialized with Gson.&lt;/p&gt;

&lt;p&gt;Gson can not deserialize &lt;code&gt;{&amp;quot;b&amp;quot;:&amp;quot;abc&amp;quot;}&lt;/code&gt; into an instance of B since the class B is an inner class. if it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class InstanceCreatorForB implements InstanceCreator&amp;lt;A.B&amp;gt; {
  private final A a;
  public InstanceCreatorForB(A a)  {
    this.a = a;
  }
  public A.B createInstance(Type type) {
    return a.new B();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above is possible, but not recommended.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-array-examples-a-array-examples&#34;&gt;&lt;a name=&#34;TOC-Array-Examples&#34;&gt;&lt;/a&gt;Array Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Gson gson = new Gson();
int[] ints = {1, 2, 3, 4, 5};
String[] strings = {&amp;quot;abc&amp;quot;, &amp;quot;def&amp;quot;, &amp;quot;ghi&amp;quot;};

// Serialization
gson.toJson(ints);     // ==&amp;gt; [1,2,3,4,5]
gson.toJson(strings);  // ==&amp;gt; [&amp;quot;abc&amp;quot;, &amp;quot;def&amp;quot;, &amp;quot;ghi&amp;quot;]

// Deserialization
int[] ints2 = gson.fromJson(&amp;quot;[1,2,3,4,5]&amp;quot;, int[].class);
// ==&amp;gt; ints2 will be same as ints
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also support multi-dimensional arrays, with arbitrarily complex element types.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-collections-examples-a-collections-examples&#34;&gt;&lt;a name=&#34;TOC-Collections-Examples&#34;&gt;&lt;/a&gt;Collections Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Gson gson = new Gson();
Collection&amp;lt;Integer&amp;gt; ints = Lists.immutableList(1,2,3,4,5);

// Serialization
String json = gson.toJson(ints);  // ==&amp;gt; json is [1,2,3,4,5]

// Deserialization
Type collectionType = new TypeToken&amp;lt;Collection&amp;lt;Integer&amp;gt;&amp;gt;(){}.getType();
Collection&amp;lt;Integer&amp;gt; ints2 = gson.fromJson(json, collectionType);
// ==&amp;gt; ints2 is same as ints
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fairly hideous: note how we define the type of collection.
Unfortunately, there is no way to get around this in Java.&lt;/p&gt;

&lt;h4 id=&#34;a-name-toc-collections-limitations-a-collections-limitations&#34;&gt;&lt;a name=&#34;TOC-Collections-Limitations&#34;&gt;&lt;/a&gt;Collections Limitations&lt;/h4&gt;

&lt;p&gt;Gson can serialize collection of arbitrary objects but can not deserialize from it, because there is no way for the user to indicate the type of the resulting object. Instead, while deserializing, the Collection must be of a specific, generic type.
This makes sense, and is rarely a problem when following good Java coding practices.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-serializing-and-deserializing-generic-types-a-serializing-and-deserializing-generic-types&#34;&gt;&lt;a name=&#34;TOC-Serializing-and-Deserializing-Generic-Types&#34;&gt;&lt;/a&gt;Serializing and Deserializing Generic Types&lt;/h3&gt;

&lt;p&gt;When you call &lt;code&gt;toJson(obj)&lt;/code&gt;, Gson calls &lt;code&gt;obj.getClass()&lt;/code&gt; to get information on the fields to serialize. Similarly, you can typically pass &lt;code&gt;MyClass.class&lt;/code&gt; object in the &lt;code&gt;fromJson(json, MyClass.class)&lt;/code&gt; method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Foo&amp;lt;T&amp;gt; {
  T value;
}
Gson gson = new Gson();
Foo&amp;lt;Bar&amp;gt; foo = new Foo&amp;lt;Bar&amp;gt;();
gson.toJson(foo); // May not serialize foo.value correctly

gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code fails to interpret value as type Bar because Gson invokes &lt;code&gt;list.getClass()&lt;/code&gt; to get its class information, but this method returns a raw class, &lt;code&gt;Foo.class&lt;/code&gt;. This means that Gson has no way of knowing that this is an object of type &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt;, and not just plain &lt;code&gt;Foo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the &lt;a href=&#34;http://google.github.io/gson/apidocs/com/google/gson/reflect/TypeToken.html&#34;&gt;&lt;code&gt;TypeToken&lt;/code&gt;&lt;/a&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Type fooType = new TypeToken&amp;lt;Foo&amp;lt;Bar&amp;gt;&amp;gt;() {}.getType();
gson.toJson(foo, fooType);

gson.fromJson(json, fooType);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The idiom used to get &lt;code&gt;fooType&lt;/code&gt; actually defines an anonymous local inner class containing a method &lt;code&gt;getType()&lt;/code&gt; that returns the fully parameterized type.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-serializing-and-deserializing-collection-with-objects-of-arbitrary-types-a-serializing-and-deserializing-collection-with-objects-of-arbitrary-types&#34;&gt;&lt;a name=&#34;TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types&#34;&gt;&lt;/a&gt;Serializing and Deserializing Collection with Objects of Arbitrary Types&lt;/h3&gt;

&lt;p&gt;Sometimes you are dealing with JSON array that contains mixed types. For example:
&lt;code&gt;[&#39;hello&#39;,5,{name:&#39;GREETINGS&#39;,source:&#39;guest&#39;}]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The equivalent &lt;code&gt;Collection&lt;/code&gt; containing this is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Collection collection = new ArrayList();
collection.add(&amp;quot;hello&amp;quot;);
collection.add(5);
collection.add(new Event(&amp;quot;GREETINGS&amp;quot;, &amp;quot;guest&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where the &lt;code&gt;Event&lt;/code&gt; class is defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Event {
  private String name;
  private String source;
  private Event(String name, String source) {
    this.name = name;
    this.source = source;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can serialize the collection with Gson without doing anything specific: &lt;code&gt;toJson(collection)&lt;/code&gt; would write out the desired output.&lt;/p&gt;

&lt;p&gt;However, deserialization with &lt;code&gt;fromJson(json, Collection.class)&lt;/code&gt; will not work since Gson has no way of knowing how to map the input to the types. Gson requires that you provide a genericised version of collection type in &lt;code&gt;fromJson()&lt;/code&gt;. So, you have three options:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Use Gson&amp;rsquo;s parser API (low-level streaming parser or the DOM parser JsonParser) to parse the array elements and then use &lt;code&gt;Gson.fromJson()&lt;/code&gt; on each of the array elements.This is the preferred approach. &lt;a href=&#34;extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java&#34;&gt;Here is an example&lt;/a&gt; that demonstrates how to do this.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Register a type adapter for &lt;code&gt;Collection.class&lt;/code&gt; that looks at each of the array members and maps them to appropriate objects. The disadvantage of this approach is that it will screw up deserialization of other collection types in Gson.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Register a type adapter for &lt;code&gt;MyCollectionMemberType&lt;/code&gt; and use &lt;code&gt;fromJson()&lt;/code&gt; with &lt;code&gt;Collection&amp;lt;MyCollectionMemberType&amp;gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This approach is practical only if the array appears as a top-level element or if you can change the field type holding the collection to be of type &lt;code&gt;Collection&amp;lt;MyCollectionMemberType&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-built-in-serializers-and-deserializers-a-built-in-serializers-and-deserializers&#34;&gt;&lt;a name=&#34;TOC-Built-in-Serializers-and-Deserializers&#34;&gt;&lt;/a&gt;Built-in Serializers and Deserializers&lt;/h3&gt;

&lt;p&gt;Gson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate.
Here is a list of such classes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;java.net.URL&lt;/code&gt; to match it with strings like &lt;code&gt;&amp;quot;https://github.com/google/gson/&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.net.URI&lt;/code&gt; to match it with strings like &lt;code&gt;&amp;quot;/google/gson/&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can also find source code for some commonly used classes such as JodaTime at &lt;a href=&#34;https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1&#34;&gt;this page&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-custom-serialization-and-deserialization-a-custom-serialization-and-deserialization&#34;&gt;&lt;a name=&#34;TOC-Custom-Serialization-and-Deserialization&#34;&gt;&lt;/a&gt;Custom Serialization and Deserialization&lt;/h3&gt;

&lt;p&gt;Sometimes default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc).
Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Json Serialiers: Need to define custom serialization for an object&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Json Deserializers: Needed to define custom deserialization for a type&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instance Creators: Not needed if no-args constructor is available or a deserializer is registered&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;GsonBuilder gson = new GsonBuilder();
gson.registerTypeAdapter(MyType2.class, new MyTypeAdapter());
gson.registerTypeAdapter(MyType.class, new MySerializer());
gson.registerTypeAdapter(MyType.class, new MyDeserializer());
gson.registerTypeAdapter(MyType.class, new MyInstanceCreator());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;registerTypeAdapter&lt;/code&gt; call checks if the type adapter implements more than one of these interfaces and register it for all of them.&lt;/p&gt;

&lt;h4 id=&#34;a-name-toc-writing-a-serializer-a-writing-a-serializer&#34;&gt;&lt;a name=&#34;TOC-Writing-a-Serializer&#34;&gt;&lt;/a&gt;Writing a Serializer&lt;/h4&gt;

&lt;p&gt;Here is an example of how to write a custom serializer for JodaTime &lt;code&gt;DateTime&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private class DateTimeSerializer implements JsonSerializer&amp;lt;DateTime&amp;gt; {
  public JsonElement serialize(DateTime src, Type typeOfSrc, JsonSerializationContext context) {
    return new JsonPrimitive(src.toString());
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gson calls &lt;code&gt;serialize()&lt;/code&gt; when it runs into a &lt;code&gt;DateTime&lt;/code&gt; object during serialization.&lt;/p&gt;

&lt;h4 id=&#34;a-name-toc-writing-a-deserializer-a-writing-a-deserializer&#34;&gt;&lt;a name=&#34;TOC-Writing-a-Deserializer&#34;&gt;&lt;/a&gt;Writing a Deserializer&lt;/h4&gt;

&lt;p&gt;Here is an example of how to write a custom deserializer for JodaTime DateTime class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private class DateTimeDeserializer implements JsonDeserializer&amp;lt;DateTime&amp;gt; {
  public DateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
      throws JsonParseException {
    return new DateTime(json.getAsJsonPrimitive().getAsString());
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gson calls &lt;code&gt;deserialize&lt;/code&gt; when it needs to deserialize a JSON string fragment into a DateTime object&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Finer points with Serializers and Deserializers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Often you want to register a single handler for all generic types corresponding to a raw type&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For example, suppose you have an &lt;code&gt;Id&lt;/code&gt; class for id representation/translation (i.e. an internal vs. external representation).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Id&amp;lt;T&amp;gt;&lt;/code&gt; type that has same serialization for all generic types

&lt;ul&gt;
&lt;li&gt;Essentially write out the id value&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Deserialization is very similar but not exactly the same

&lt;ul&gt;
&lt;li&gt;Need to call &lt;code&gt;new Id(Class&amp;lt;T&amp;gt;, String)&lt;/code&gt; which returns an instance of &lt;code&gt;Id&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Gson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say &lt;code&gt;Id&amp;lt;RequiresSpecialHandling&amp;gt;&lt;/code&gt; needed special handling).
The &lt;code&gt;Type&lt;/code&gt; parameter for the &lt;code&gt;toJson()&lt;/code&gt; and &lt;code&gt;fromJson()&lt;/code&gt; contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-writing-an-instance-creator-a-writing-an-instance-creator&#34;&gt;&lt;a name=&#34;TOC-Writing-an-Instance-Creator&#34;&gt;&lt;/a&gt;Writing an Instance Creator&lt;/h3&gt;

&lt;p&gt;While deserializing an Object, Gson needs to create a default instance of the class.
Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Doesn&amp;rsquo;t matter whether public or private&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Typically, Instance Creators are needed when you are dealing with a library class that does NOT define a no-argument constructor&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Instance Creator Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private class MoneyInstanceCreator implements InstanceCreator&amp;lt;Money&amp;gt; {
  public Money createInstance(Type type) {
    return new Money(&amp;quot;1000000&amp;quot;, CurrencyCode.USD);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type could be of a corresponding generic type&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Very useful to invoke constructors which need specific generic type information&lt;/li&gt;
&lt;li&gt;For example, if the &lt;code&gt;Id&lt;/code&gt; class stores the class for which the Id is being created&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;a-name-toc-instancecreator-for-a-parameterized-type-a-instancecreator-for-a-parameterized-type&#34;&gt;&lt;a name=&#34;TOC-InstanceCreator-for-a-Parameterized-Type&#34;&gt;&lt;/a&gt;InstanceCreator for a Parameterized Type&lt;/h4&gt;

&lt;p&gt;Sometimes that the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyList&amp;lt;T&amp;gt; extends ArrayList&amp;lt;T&amp;gt; {
}

class MyListInstanceCreator implements InstanceCreator&amp;lt;MyList&amp;lt;?&amp;gt;&amp;gt; {
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
  public MyList&amp;lt;?&amp;gt; createInstance(Type type) {
    // No need to use a parameterized list since the actual instance will have the raw type anyway.
    return new MyList();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the &lt;code&gt;createInstance&lt;/code&gt; method. Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Id&amp;lt;T&amp;gt; {
  private final Class&amp;lt;T&amp;gt; classOfId;
  private final long value;
  public Id(Class&amp;lt;T&amp;gt; classOfId, long value) {
    this.classOfId = classOfId;
    this.value = value;
  }
}

class IdInstanceCreator implements InstanceCreator&amp;lt;Id&amp;lt;?&amp;gt;&amp;gt; {
  public Id&amp;lt;?&amp;gt; createInstance(Type type) {
    Type[] typeParameters = ((ParameterizedType)type).getActualTypeArguments();
    Type idType = typeParameters[0]; // Id has only one parameterized type T
    return Id.get((Class)idType, 0L);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, an instance of the Id class can not be created without actually passing in the actual type for the parameterized type. We solve this problem by using the passed method parameter, &lt;code&gt;type&lt;/code&gt;. The &lt;code&gt;type&lt;/code&gt; object in this case is the Java parameterized type representation of &lt;code&gt;Id&amp;lt;Foo&amp;gt;&lt;/code&gt; where the actual instance should be bound to &lt;code&gt;Id&amp;lt;Foo&amp;gt;&lt;/code&gt;. Since &lt;code&gt;Id&lt;/code&gt; class has just one parameterized type parameter, &lt;code&gt;T&lt;/code&gt;, we use the zeroth element of the type array returned by &lt;code&gt;getActualTypeArgument()&lt;/code&gt; which will hold &lt;code&gt;Foo.class&lt;/code&gt; in this case.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-compact-vs-pretty-printing-for-json-output-format-a-compact-vs-pretty-printing-for-json-output-format&#34;&gt;&lt;a name=&#34;TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format&#34;&gt;&lt;/a&gt;Compact Vs. Pretty Printing for JSON Output Format&lt;/h3&gt;

&lt;p&gt;The default JSON output that is provide by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, &amp;ldquo;null&amp;rdquo; fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the &lt;a href=&#34;#TOC-Null-Object-Support&#34;&gt;Null Object Support&lt;/a&gt; section for information on configure Gson to output all null values.&lt;/p&gt;

&lt;p&gt;If you like to use the Pretty Print feature, you must configure your &lt;code&gt;Gson&lt;/code&gt; instance using the &lt;code&gt;GsonBuilder&lt;/code&gt;. The &lt;code&gt;JsonFormatter&lt;/code&gt; is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default &lt;code&gt;JsonPrintFormatter&lt;/code&gt; that has default line length of 80 character, 2 character indentation, and 4 character right margin.&lt;/p&gt;

&lt;p&gt;The following is an example shows how to configure a &lt;code&gt;Gson&lt;/code&gt; instance to use the default &lt;code&gt;JsonPrintFormatter&lt;/code&gt; instead of the &lt;code&gt;JsonCompactFormatter&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Gson gson = new GsonBuilder().setPrettyPrinting().create();
String jsonOutput = gson.toJson(someObject);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-toc-null-object-support-a-null-object-support&#34;&gt;&lt;a name=&#34;TOC-Null-Object-Support&#34;&gt;&lt;/a&gt;Null Object Support&lt;/h3&gt;

&lt;p&gt;The default behaviour that is implemented in Gson is that &lt;code&gt;null&lt;/code&gt; object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how you would configure a &lt;code&gt;Gson&lt;/code&gt; instance to output null:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Gson gson = new GsonBuilder().serializeNulls().create();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NOTE: when serializing &lt;code&gt;null&lt;/code&gt;s with Gson, it will add a &lt;code&gt;JsonNull&lt;/code&gt; element to the &lt;code&gt;JsonElement&lt;/code&gt; structure. Therefore, this object can be used in custom serialization/deserialization.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Foo {
  private final String s;
  private final int i;

  public Foo() {
    this(null, 5);
  }

  public Foo(String s, int i) {
    this.s = s;
    this.i = i;
  }
}

Gson gson = new GsonBuilder().serializeNulls().create();
Foo foo = new Foo();
String json = gson.toJson(foo);
System.out.println(json);

json = gson.toJson(null);
System.out.println(json);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;s&amp;quot;:null,&amp;quot;i&amp;quot;:5}
null
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-toc-versioning-support-a-versioning-support&#34;&gt;&lt;a name=&#34;TOC-Versioning-Support&#34;&gt;&lt;/a&gt;Versioning Support&lt;/h3&gt;

&lt;p&gt;Multiple versions of the same object can be maintained by using &lt;a href=&#34;gson/src/main/java/com/google/gson/annotations/Since.java&#34;&gt;@Since&lt;/a&gt; annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your &lt;code&gt;Gson&lt;/code&gt; instance to ignore any field/object that is greater than some version number. If no version is set on the &lt;code&gt;Gson&lt;/code&gt; instance then it will serialize and deserialize all fields and classes regardless of the version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class VersionedClass {
  @Since(1.1) private final String newerField;
  @Since(1.0) private final String newField;
  private final String field;

  public VersionedClass() {
    this.newerField = &amp;quot;newer&amp;quot;;
    this.newField = &amp;quot;new&amp;quot;;
    this.field = &amp;quot;old&amp;quot;;
  }
}

VersionedClass versionedObject = new VersionedClass();
Gson gson = new GsonBuilder().setVersion(1.0).create();
String jsonOutput = gson.toJson(someObject);
System.out.println(jsonOutput);
System.out.println();

gson = new Gson();
jsonOutput = gson.toJson(someObject);
System.out.println(jsonOutput);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;newField&amp;quot;:&amp;quot;new&amp;quot;,&amp;quot;field&amp;quot;:&amp;quot;old&amp;quot;}

{&amp;quot;newerField&amp;quot;:&amp;quot;newer&amp;quot;,&amp;quot;newField&amp;quot;:&amp;quot;new&amp;quot;,&amp;quot;field&amp;quot;:&amp;quot;old&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-toc-excluding-fields-from-serialization-and-deserialization-a-excluding-fields-from-serialization-and-deserialization&#34;&gt;&lt;a name=&#34;TOC-Excluding-Fields-From-Serialization-and-Deserialization&#34;&gt;&lt;/a&gt;Excluding Fields From Serialization and Deserialization&lt;/h3&gt;

&lt;p&gt;Gson supports numerous mechanisms for excluding top-level classes, fields and field types. Below are pluggable mechanism that allow field and class exclusion. If none of the below mechanism satisfy your needs then you can always use &lt;a href=&#34;#TOC-Custom-Serialization-and-Deserializ&#34;&gt;custom serializers and deserializers&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;a-name-toc-java-modifier-exclusion-a-java-modifier-exclusion&#34;&gt;&lt;a name=&#34;TOC-Java-Modifier-Exclusion&#34;&gt;&lt;/a&gt;Java Modifier Exclusion&lt;/h4&gt;

&lt;p&gt;By default, if you mark a field as &lt;code&gt;transient&lt;/code&gt;, it will be excluded. As well, if a field is marked as &lt;code&gt;static&lt;/code&gt; then by default it will be excluded. If you want to include some transient fields then you can do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.reflect.Modifier;
Gson gson = new GsonBuilder()
    .excludeFieldsWithModifiers(Modifier.STATIC)
    .create();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NOTE: you can use any number of the &lt;code&gt;Modifier&lt;/code&gt; constants to &lt;code&gt;excludeFieldsWithModifiers&lt;/code&gt; method. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Gson gson = new GsonBuilder()
    .excludeFieldsWithModifiers(Modifier.STATIC, Modifier.TRANSIENT, Modifier.VOLATILE)
    .create();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;a-name-toc-gson-s-expose-a-gson-s-expose&#34;&gt;&lt;a name=&#34;TOC-Gson-s-Expose&#34;&gt;&lt;/a&gt;Gson&amp;rsquo;s &lt;code&gt;@Expose&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using &lt;code&gt;new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()&lt;/code&gt;. The Gson instance created will exclude all fields in a class that are not marked with &lt;code&gt;@Expose&lt;/code&gt; annotation.&lt;/p&gt;

&lt;h4 id=&#34;a-name-toc-user-defined-exclusion-strategies-a-user-defined-exclusion-strategies&#34;&gt;&lt;a name=&#34;TOC-User-Defined-Exclusion-Strategies&#34;&gt;&lt;/a&gt;User Defined Exclusion Strategies&lt;/h4&gt;

&lt;p&gt;If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the &lt;a href=&#34;http://google.github.io/gson/apidocs/com/google/gson/ExclusionStrategy.html&#34;&gt;&lt;code&gt;ExclusionStrategy&lt;/code&gt;&lt;/a&gt; JavaDoc for more information.&lt;/p&gt;

&lt;p&gt;The following example shows how to exclude fields marked with a specific &lt;code&gt;@Foo&lt;/code&gt; annotation and excludes top-level types (or declared field type) of class &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD})
public @interface Foo {
  // Field tag only annotation
}

public class SampleObjectForTest {
  @Foo private final int annotatedField;
  private final String stringField;
  private final long longField;
  private final Class&amp;lt;?&amp;gt; clazzField;

  public SampleObjectForTest() {
    annotatedField = 5;
    stringField = &amp;quot;someDefaultValue&amp;quot;;
    longField = 1234;
  }
}

public class MyExclusionStrategy implements ExclusionStrategy {
  private final Class&amp;lt;?&amp;gt; typeToSkip;

  private MyExclusionStrategy(Class&amp;lt;?&amp;gt; typeToSkip) {
    this.typeToSkip = typeToSkip;
  }

  public boolean shouldSkipClass(Class&amp;lt;?&amp;gt; clazz) {
    return (clazz == typeToSkip);
  }

  public boolean shouldSkipField(FieldAttributes f) {
    return f.getAnnotation(Foo.class) != null;
  }
}

public static void main(String[] args) {
  Gson gson = new GsonBuilder()
      .setExclusionStrategies(new MyExclusionStrategy(String.class))
      .serializeNulls()
      .create();
  SampleObjectForTest src = new SampleObjectForTest();
  String json = gson.toJson(src);
  System.out.println(json);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;longField&amp;quot;:1234}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-toc-json-field-naming-support-a-json-field-naming-support&#34;&gt;&lt;a name=&#34;TOC-JSON-Field-Naming-Support&#34;&gt;&lt;/a&gt;JSON Field Naming Support&lt;/h3&gt;

&lt;p&gt;Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case &amp;mdash; &lt;code&gt;sampleFieldNameInJava&lt;/code&gt;) to a Json field name (i.e., &lt;code&gt;sample_field_name_in_java&lt;/code&gt; or &lt;code&gt;SampleFieldNameInJava&lt;/code&gt;). See the &lt;a href=&#34;http://google.github.io/gson/apidocs/com/google/gson/FieldNamingPolicy.html&#34;&gt;FieldNamingPolicy&lt;/a&gt; class for information on the pre-defined naming policies.&lt;/p&gt;

&lt;p&gt;It also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise &amp;ldquo;Runtime&amp;rdquo; exceptions if an invalid field name is provided as the annotation value.&lt;/p&gt;

&lt;p&gt;The following is an example of how to use both Gson naming policy features:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private class SomeObject {
  @SerializedName(&amp;quot;custom_naming&amp;quot;) private final String someField;
  private final String someOtherField;

  public SomeObject(String a, String b) {
    this.someField = a;
    this.someOtherField = b;
  }
}

SomeObject someObject = new SomeObject(&amp;quot;first&amp;quot;, &amp;quot;second&amp;quot;);
Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();
String jsonRepresentation = gson.toJson(someObject);
System.out.println(jsonRepresentation);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;custom_naming&amp;quot;:&amp;quot;first&amp;quot;,&amp;quot;SomeOtherField&amp;quot;:&amp;quot;second&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have a need for custom naming policy (&lt;a href=&#34;http://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892&#34;&gt;see this discussion&lt;/a&gt;), you can use the &lt;a href=&#34;http://google.github.io/gson/apidocs/com/google/gson/annotations/SerializedName.html&#34;&gt;@SerializedName&lt;/a&gt; annotation.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-sharing-state-across-custom-serializers-and-deserializers-a-sharing-state-across-custom-serializers-and-deserializers&#34;&gt;&lt;a name=&#34;TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers&#34;&gt;&lt;/a&gt;Sharing State Across Custom Serializers and Deserializers&lt;/h3&gt;

&lt;p&gt;Sometimes you need to share state across custom serializers/deserializers (&lt;a href=&#34;http://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb&#34;&gt;see this discussion&lt;/a&gt;). You can use the following three strategies to accomplish this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Store shared state in static fields&lt;/li&gt;
&lt;li&gt;Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state&lt;/li&gt;
&lt;li&gt;Use Java &lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1 and 2 are not thread-safe options, but 3 is.&lt;/p&gt;

&lt;h3 id=&#34;a-name-toc-streaming-a-streaming&#34;&gt;&lt;a name=&#34;TOC-Streaming&#34;&gt;&lt;/a&gt;Streaming&lt;/h3&gt;

&lt;p&gt;In addition Gson&amp;rsquo;s object model and data binding, you can use Gson to read from and write to a &lt;a href=&#34;https://sites.google.com/site/gson/streaming&#34;&gt;stream&lt;/a&gt;. You can also combine streaming and object model access to get the best of both approaches.&lt;/p&gt;

&lt;h2 id=&#34;a-name-toc-issues-in-designing-gson-a-issues-in-designing-gson&#34;&gt;&lt;a name=&#34;TOC-Issues-in-Designing-Gson&#34;&gt;&lt;/a&gt;Issues in Designing Gson&lt;/h2&gt;

&lt;p&gt;See the &lt;a href=&#34;https://sites.google.com/site/gson/gson-design-document&#34; title=&#34;Gson design document&#34;&gt;Gson design document&lt;/a&gt; for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion.&lt;/p&gt;

&lt;h2 id=&#34;a-name-toc-future-enhancements-to-gson-a-future-enhancements-to-gson&#34;&gt;&lt;a name=&#34;TOC-Future-Enhancements-to-Gson&#34;&gt;&lt;/a&gt;Future Enhancements to Gson&lt;/h2&gt;

&lt;p&gt;For the latest list of proposed enhancements or if you&amp;rsquo;d like to suggest new ones, see the &lt;a href=&#34;https://github.com/google/gson/issues&#34;&gt;Issues section&lt;/a&gt; under the project website.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;https://github.com/google/gson/blob/master/UserGuide.md&#34; title=&#34;User Guide&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: Exclusion Strategy</title>
      <link>http://alimy.me/post/dev_201603122040/</link>
      <pubDate>Sat, 12 Mar 2016 20:40:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122040/</guid>
      <description>&lt;p&gt;In this tutorial we look at how to selectively include fields from a java object to a json string. By default, Gson tries to map all fields in the java object to the corresponding property in json. However, in certain cases we may want to control that. There are a few ways to do this. It is also possible to excluse fields from third party packages where we have no access to the source code. The different ways to exclude fields are :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;By defining a custom annotation and ignoring fields that are annotated with that.&lt;/li&gt;
&lt;li&gt;By Defining a custom exclusion class by extending the ExclusionStrategy interface and implementing the public boolean shouldSkipField(FieldAttributes f); and public boolean shouldSkipClass(Class clazz); methods&lt;/li&gt;

&lt;li&gt;&lt;p&gt;By using the @Expose annotations and then using the excludeFieldsWithoutExposeAnnotation() method on the GsonBuilder. This will ignore all fields except the ones that have been exposed using the @Expose annotation.
&lt;/p&gt;

&lt;h4 id=&#34;the-example-below-demonstrates-all-three&#34;&gt;The example below demonstrates all three&lt;/h4&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.awt.Color;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class ExclusionExample {
	public static void main(String[] args) {
		// We create an instance of type CAT.
		Cat cat = new Cat();
		cat.setName(&amp;quot;Cat&amp;quot;);
		cat.setAge(1);
		cat.setColor(Color.BLACK);
		cat.setCountry(&amp;quot;US&amp;quot;);
		// we allow serializing null. therefore although the fields lazy is
		// null, it will be serialized. We add a CustomExclusionStrategy that
		// will exclude the Color class. We also allow only those fields that
		// have been exposed using the @Expore annotation
		Gson gson = new GsonBuilder().serializeNulls().setExclusionStrategies(new CustomExclusionStrategy(Color.class))
				.excludeFieldsWithoutExposeAnnotation().create();
		System.out.println(gson.toJson(cat));
		// prints {&amp;quot;name&amp;quot;:&amp;quot;Cat&amp;quot;,&amp;quot;lazy&amp;quot;:null}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-cat-class&#34;&gt;The Cat class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.awt.Color;

import com.google.gson.annotations.Expose;

public class Cat {
	@Expose
	private String name;
	private int age;
	private Color color;
	@Expose
	@Country
	private String country;
	@Expose
	private Boolean lazy = null;

	public void setAge(int age) {
		this.age = age;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void setColor(Color color) {
		this.color = color;
	}

	public int getAge() {
		return age;
	}

	public String getName() {
		return name;
	}

	public Color getColor() {
		return color;
	}

	public void setCountry(String country) {
		this.country = country;
	}

	public String getCountry() {
		return country;
	}

	public void setLazy(Boolean lazy) {
		this.lazy = lazy;
	}

	public Boolean getLazy() {
		return lazy;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-exclusion-strategy&#34;&gt;The Exclusion Strategy&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import com.google.gson.ExclusionStrategy;
import com.google.gson.FieldAttributes;

/**
 * This class defines custom exclusion policy. We want to ignore all fields that
 * have been annotated with the Country annotation. Note that we can also ignore
 * fields based on name or type. This same policy can be applied to any class.
 * In this example we apply to the CAT class, but it is not limited to the cat
 * class.
 *
 */
public class CustomExclusionStrategy implements ExclusionStrategy {

	private Class classToExclude;

	public CustomExclusionStrategy(Class classToExclude) {
		this.classToExclude = classToExclude;
	}

	// This method is called for all fields. if the method returns false the
	// field is excluded from serialization
	@Override
	public boolean shouldSkipField(FieldAttributes f) {
		if (f.getAnnotation(Country.class) == null)
			return false;

		return true;
	}

	// This method is called for all classes. If the method returns false the
	// class is excluded.
	@Override
	public boolean shouldSkipClass(Class&amp;lt;?&amp;gt; clazz) {
		if (clazz.equals(classToExclude))
			return true;
		return false;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-exclusion-strategy.jsp&#34; title=&#34;Excluding certain fields from Java classes&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: Custom Serializer</title>
      <link>http://alimy.me/post/dev_201603122035/</link>
      <pubDate>Sat, 12 Mar 2016 20:35:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122035/</guid>
      <description>&lt;p&gt;Just as we saw in the &lt;a href=&#34;http://alimy.me/post/dev_201603122030&#34;&gt;previous&lt;/a&gt; tutorial, Gson provides way to specify custom serializers and deserializers. Register a custom serializer with the GsonBuilder if you need you own way to convert a java object to json and you a custom deserializer if you dont like Gson&amp;rsquo;s way of converting json to the java object. The first example below shows a custom serializer and the second example shows a custom deserializer.&lt;/p&gt;

&lt;h3 id=&#34;custom-serializer&#34;&gt;Custom Serializer&lt;/h3&gt;

&lt;p&gt;Create a custom serializer by implementing a com.studytrails.json.gson.JsonSerializer and implementing the public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context); method. src is the source object and Type is the type of the source object. The example below demonstrates a custom Serializer.
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.reflect.TypeToken;

public class DogSerializer implements JsonSerializer {
	@Override
	public JsonElement serialize(Dog src, Type typeOfSrc, JsonSerializationContext context) {
		// This method gets involved whenever the parser encounters the Dog
		// object (for which this serializer is registered)
		JsonObject object = new JsonObject();
		String name = src.getName().replaceAll(&amp;quot; &amp;quot;, &amp;quot;_&amp;quot;);
		object.addProperty(&amp;quot;name&amp;quot;, name);
		// we create the json object for the dog and send it back to the
		// Gson serializer
		return object;
	}

	public static void main(String[] args) {
		Animall&amp;lt;Dog&amp;gt; animal = new Animall&amp;lt;Dog&amp;gt;();
		Dog dog = new Dog(&amp;quot;I am a dog&amp;quot;);
		animal.setAnimal(dog);
		// Create the GsonBuilder and register a serializer for the Dog class.
		// Whenever the Dog class is encountered Gson calls the DogSerializer
		// we set pretty printing own to format the json
		Gson gson = new GsonBuilder().registerTypeAdapter(Dog.class, new DogSerializer()).setPrettyPrinting().create();
		// Since Animal contains generic type create the type using TypeToken
		// class.
		Type animalType = new TypeToken&amp;lt;Animal&amp;lt;Dog&amp;gt;&amp;gt;() {
		}.getType();
		System.out.println(gson.toJson(animal, animalType));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Animal class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

public class Animal {

	public T animal;

	public void setAnimal(T animal) {
		this.animal = animal;
	}

	public T get() {
		return animal;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Dog class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

public class Dog {
	private String name;

	public Dog(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;custom-deserializer&#34;&gt;Custom DeSerializer&lt;/h4&gt;

&lt;p&gt;Use a custome De serializer to create a Dog Object from the json. To create a deserializer implement the public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;

public class DogDeserialiser implements JsonDeserializer&amp;lt;Dog&amp;gt; {
	@Override
	public Dog deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
		String name = json.getAsJsonObject().get(&amp;quot;name&amp;quot;).getAsString();
		name = name.replace(&amp;quot; &amp;quot;, &amp;quot;_&amp;quot;);
		Dog dog = new Dog(name);

		return dog;
	}

	public static void main(String[] args) {
		String json = &amp;quot;{\&amp;quot;animal\&amp;quot;:{\&amp;quot;name\&amp;quot;:\&amp;quot;I am a dog\&amp;quot;}}&amp;quot;;
		Gson gson = new GsonBuilder().registerTypeAdapter(Dog.class, new DogDeserialiser()).create();
		Type animalType = new TypeToken&amp;lt;Animal&amp;lt;Dog&amp;gt;&amp;gt;() {
		}.getType();
		Animal&amp;lt;Dog&amp;gt; animal = gson.fromJson(json, animalType);
		System.out.println(animal.get().getName());
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-introduction.jsp&#34; title=&#34;Using Custom Serialization and Deserialization classes&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: Custom Type Adapter</title>
      <link>http://alimy.me/post/dev_201603122030/</link>
      <pubDate>Sat, 12 Mar 2016 20:30:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122030/</guid>
      <description>&lt;p&gt;In the earlier tutorials we have seen how gson can serialize and deserialize java classes with or without hierarchies. By default, it introspects the classes and comes with with a strategy for serializing and deserializing it. However, in some cases, you want to specify your own conversion strategy. That is, you want to control how the java object is converted to json string and the other way round. Gson provides a capability to specify a custom type adapter. You tell Gson that for a particular class, use the conversion strategy specified by your custom adapter. Lets look at how to write the type adapter :
To write a custom adapter extend the com.google.gson.TypeAdapter abstract class. Implement the public abstract T read(JsonReader in) throws IOException; and public abstract void write(JsonWriter out, T value) throws IOException; methods. The adapter should also handle nulls. Create the Type adapter instance and then register it with the GsonBuilder. Create the Gson object from the GsonBuilder and then use that to serialize and deserialize. Lets look at an example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.commons.io.IOUtils;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class DatasetTypeAdapterExample8 {

	public static void main(String[] args) throws MalformedURLException, IOException {
		String url = &amp;quot;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=5&amp;quot;;
		String json = IOUtils.toString(new URL(url));
		// Create the custom type adapter and register it with the GsonBuilder
		// class.
		Gson gson = new GsonBuilder().registerTypeAdapter(Dataset.class, new DatasetTypeAdapter()).create();
		// deserialize the json to Albums class. The Dataset objects are part of
		// the Albums class. Whenever Gson encounters an object of type DataSet
		// it calls the DatasetTypeAdapter to read and write json.
		Albums albums = gson.fromJson(json, Albums.class);
		System.out.println(albums.getDataset()[1].getAlbum_title());
		// prints
		// http://freemusicarchive.org/music/The_Yes_Sirs/Through_The_Cracks_Mix_Vol_1/
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
The Adapter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.io.IOException;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;

/**
 * The Dataset class contains the information about a particular Album.
 * album_title and album_url are two distinct fields in the json. The Dataset
 * object contains the field album_title. Normally Gson would map the
 * album_title property in the json the the album_title field in the Dataset
 * object. However, we dont want that. We want to use the album_url property
 * from the json object to populate the album_title field in the Dataset object.
 * we build a custom TypeAdapter to do that. This is just a trivial case, you
 * could also combine album_url and album_title properties and set it to the
 * album_title field of the Dataset Object.
 *
 */
public class DatasetTypeAdapter extends TypeAdapter&amp;lt;Dataset&amp;gt; {
	@Override
	public Dataset read(JsonReader reader) throws IOException {
		// the first token is the start object
		JsonToken token = reader.peek();
		Dataset dataset = new Dataset();
		if (token.equals(JsonToken.BEGIN_OBJECT)) {
			reader.beginObject();
			while (!reader.peek().equals(JsonToken.END_OBJECT)) {
				if (reader.peek().equals(JsonToken.NAME)) {
					if (reader.nextName().equals(&amp;quot;album_url&amp;quot;))
						dataset.setAlbum_title(reader.nextString());
					else
						reader.skipValue();

				}
			}
			reader.endObject();

		}
		return dataset;
	}

	@Override
	public void write(JsonWriter out, Dataset value) throws IOException {

	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Albums class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;


public class Albums {

	private String title;
	private Dataset[] dataset;

	public void setTitle(String title) {
		this.title = title;
	}

	public void setDataset(Dataset[] dataset) {
		this.dataset = dataset;
	}

	public String getTitle() {
		return title;
	}

	public Dataset[] getDataset() {
		return dataset;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Dataset class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.util.HashMap;
import java.util.Map;

public class Dataset {
	private String album_id;
	private String album_title;
	private Map&amp;lt;String , Object&amp;gt; otherProperties = new HashMap&amp;lt;String , Object&amp;gt;();

	public String getAlbum_id() {
		return album_id;
	}

	public void setAlbum_id(String album_id) {
		this.album_id = album_id;
	}

	public String getAlbum_title() {
		return album_title;
	}

	public void setAlbum_title(String album_title) {
		this.album_title = album_title;
	}

	public Object get(String name) {
		return otherProperties.get(name);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-type-adapter.jsp&#34; title=&#34;Using Custom type adapters&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: Serializing Inner Classes</title>
      <link>http://alimy.me/post/dev_201603122028/</link>
      <pubDate>Sat, 12 Mar 2016 20:28:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122028/</guid>
      <description>&lt;h3 id=&#34;serializing-inner-classes&#34;&gt;Serializing inner classes&lt;/h3&gt;

&lt;p&gt;Gson can serialize inner classes and static nested classes. The detailed example below demonstrates the following things.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Serializing class containing static nested class&lt;/li&gt;
&lt;li&gt;Serializing class containing non static nested class (Inner class)&lt;/li&gt;
&lt;li&gt;De-serializing json to a class containing static and non static inner class&lt;/li&gt;
&lt;li&gt;Serializing static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;Serializing non static nested class (without the enclosing type)&lt;/li&gt;
&lt;li&gt;De-serializing json to a static nested class (without the enclosing type)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;De-serializing json to a non static nested class (without the enclosing type)
&lt;/p&gt;

&lt;h4 id=&#34;the-example&#34;&gt;The Example&lt;/h4&gt;

&lt;p&gt;```
package com.studytrails.json.gson;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;import java.lang.reflect.Modifier;&lt;/p&gt;

&lt;p&gt;import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.studytrails.json.gson.AlbumsWithInnerClass.Dataset;
import com.studytrails.json.gson.AlbumsWithInnerClass.Dataset2;&lt;/p&gt;

&lt;p&gt;public class SerializeInnerClassExample4 {
    public static void main(String[] args) {
        // create an Albums class with a static nested class and a non static
        // nested class
        AlbumsWithInnerClass albums = new AlbumsWithInnerClass();
        albums.setName(&amp;ldquo;SerializeInnerClass&amp;rdquo;);
        // create a dataset. we need the enclosing type since this is a non
        // static nested class (inner class)
        Dataset dataset = albums.new Dataset();
        dataset.setAlbum_id(&amp;ldquo;1&amp;rdquo;);
        dataset.setAlbum_name(&amp;ldquo;albums1&amp;rdquo;);
        // assign the datasets to albums
        albums.setDatasetsInner(new Dataset[] { dataset });&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // static inner class can be created without the enclosing type
    Dataset2 dataset2 = new Dataset2();
    dataset2.setAlbum_id(&amp;quot;2&amp;quot;);
    dataset2.setAlbum_name(&amp;quot;albums2&amp;quot;);
    albums.setDatasetsStatic(new Dataset2[] { dataset2 });

    // create the GsonBuilder
    GsonBuilder builder = new GsonBuilder();
    // we ignore Private fields
    builder.excludeFieldsWithModifiers(Modifier.PRIVATE);
    Gson gson = builder.create();

    // serialize the albums object
    String json = gson.toJson(albums);
    System.out.println(json);
    // prints
    // {&amp;quot;name&amp;quot;:&amp;quot;SerializeInnerClass&amp;quot;,&amp;quot;datasetsInner&amp;quot;:[{&amp;quot;album_name&amp;quot;:&amp;quot;SerializeInnerClass_albums1&amp;quot;,&amp;quot;album_id&amp;quot;:&amp;quot;1&amp;quot;}],
    // &amp;quot;datasetsStatic&amp;quot;:[{&amp;quot;album_name&amp;quot;:&amp;quot;albums2&amp;quot;,&amp;quot;album_id&amp;quot;:&amp;quot;2&amp;quot;}]}

    // We read the json string now and recreate the AlbumsWithInnerClass class
    Gson gson3 = new Gson();
    AlbumsWithInnerClass parsedAlbums = gson3.fromJson(json, AlbumsWithInnerClass.class);
    System.out.println(parsedAlbums.datasetsInner[0].album_name);
    // prints SerializeInnerClass_albums1
    System.out.println(parsedAlbums.datasetsStatic[0].album_name);
    // prints albums2

    // now lets try and serialize only the object of inner class
    Gson gson2 = new Gson();
    String json2 = gson2.toJson(dataset);
    System.out.println(json2);
    // prints {&amp;quot;album_name&amp;quot;:&amp;quot;SerializeInnerClass_albums1&amp;quot;,&amp;quot;album_id&amp;quot;:&amp;quot;1&amp;quot;}

    // serialize nested static class
    String json3 = gson2.toJson(dataset2);
    System.out.println(json3);
    // prints {&amp;quot;album_name&amp;quot;:&amp;quot;albums2&amp;quot;,&amp;quot;album_id&amp;quot;:&amp;quot;2&amp;quot;}

    // let us now create the inner class from the json string
    Gson gson4 = new Gson();
    Dataset parsedDataset = gson4.fromJson(json2, Dataset.class);
    System.out.println(parsedDataset.getClass());
    // prints class com.studytrails.json.gson.AlbumsWithInnerClass$Dataset
    System.out.println(parsedDataset.album_name);
    // prints SerializeInnerClass_albums1

    // create nested static class from the json string
    Dataset2 parsedStaticNestedClass = gson4.fromJson(json3, Dataset2.class);
    System.out.println(parsedStaticNestedClass.getClass());
    // prints class com.studytrails.json.gson.AlbumsWithInnerClass$Dataset2
    System.out.println(parsedStaticNestedClass.album_name);
    // prints albums2

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#### The AlbumsWithInnerClass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;package com.studytrails.json.gson;&lt;/p&gt;

&lt;p&gt;public class AlbumsWithInnerClass {
    public String name;
    private String year;
    public Dataset[] datasetsInner;
    public Dataset2[] datasetsStatic;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void setDatasetsInner(Dataset[] datasetsInner) {
    this.datasetsInner = datasetsInner;
}

public void setDatasetsStatic(Dataset2[] datasetsStatic) {
    this.datasetsStatic = datasetsStatic;
}

public void setName(String name) {
    this.name = name;
}

public void setYear(String year) {
    this.year = year;
}

class Dataset {
    public String album_name;
    public String album_id;

    public void setAlbum_id(String album_id) {
        this.album_id = album_id;
    }

    public void setAlbum_name(String album_name) {
        this.album_name = name + &amp;quot;_&amp;quot; + album_name;
    }
}

static class Dataset2 {
    public String album_name;
    public String album_id;

    public void setAlbum_id(String album_id) {
        this.album_id = album_id;
    }

    public void setAlbum_name(String album_name) {
        this.album_name = album_name;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-serialize-inner-classes.jsp&#34; title=&#34;Serializing Inner Classes&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: Serializing and deserializing Java Generic Classes</title>
      <link>http://alimy.me/post/dev_201603122025/</link>
      <pubDate>Sat, 12 Mar 2016 20:25:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122025/</guid>
      <description>&lt;h3 id=&#34;serializing-list&#34;&gt;Serializing list&lt;/h3&gt;

&lt;p&gt;As we saw in the previous tutorial serializing and deserializing classes with generic types is non trivial since generic type information is lost while serializing. Gson provides a class called com.google.gson.reflect.TypeToken to store generic types. The example below shows how to use the TypeToken class to serialize and deserialize Classes with generic types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Type;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class GenericTypesExample8 {
	public static void main(String[] args) {
		// create an animal class that is of type dog.
		Animal animal = new Animal&amp;lt;Dog&amp;gt;();
		// Create a Dog instance
		Dog dog = new Dog(&amp;quot;I am a dog&amp;quot;);

		animal.setAnimal(dog);
		Gson gson = new Gson();
		// Define a Type that is an Animal of type dog.
		Type animalType = new TypeToken&amp;lt;Animal&amp;lt;Dog&amp;gt;&amp;gt;() {
		}.getType();

		// we first convert the animal object to a json and then read the json
		// back. However we define the json to be of Animal type
		Animal animal1 = gson.fromJson(gson.toJson(animal, animalType), Animal.class);
		System.out.println(animal1.get().getClass()); // prints class

    // com.google.gson.internal.LinkedTreeMap
		// In contrast to above where we read the json back using the Animal
		// type, here we read the json back as the custom animalType Type. This
		// gives Gson an idea of what
		// the generic type should be.
		Animal animal2 = gson.fromJson(gson.toJson(animal), animalType);
		System.out.println(animal2.get().getClass());
		// prints class com.studytrails.json.gson.Dog

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;animal-class&#34;&gt;Animal class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

public class Animal {

	public T animal;

	public void setAnimal(T animal) {
		this.animal = animal;
	}

	public T get() {
		return animal;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dog-class&#34;&gt;Dog Class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

public class Dog {
	private String name;

	public Dog(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-introduction.jsp&#34; title=&#34;Serializing and deserializing Java Generic Classes&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gson: Serializing Collections</title>
      <link>http://alimy.me/post/dev_201603122022/</link>
      <pubDate>Sat, 12 Mar 2016 20:22:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603122022/</guid>
      <description>&lt;h3 id=&#34;serializing-list&#34;&gt;Serializing list&lt;/h3&gt;

&lt;p&gt;Serializing Collections should have been similar to serializing other objects. However, the problem is that Collections are generic and the generic type information is not maintained in the json. We therefore pass the type while deserializing list. Note that if the Collection has different types of objects then there is no way to serialize it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.lang.reflect.Type;
import java.util.Collection;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class DeSerializeListExample5 {
	public static void main(String[] args) {
		String json = &amp;quot;[{album_id:1,album_title:&#39;album1&#39;},{album_id:2,album_title:&#39;album2&#39;}]&amp;quot;;

		Gson gson = new Gson();
		// create the type for the collection. In this case define that the collection is of type Dataset
		Type datasetListType = new TypeToken&amp;lt;Collection&amp;lt;Dataset&amp;gt;&amp;gt;() {}.getType();
		List&amp;lt;Dataset&amp;gt; datasets = gson.fromJson(json, datasetListType);
		for (Dataset dataset : datasets) {
			System.out.println(dataset.getAlbum_title());
			System.out.println(dataset.getAlbum_id());
		}
		// Prints
		//album1
		//1
		//album2
		//2

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;the-dataset-class&#34;&gt;The Dataset Class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.gson;

import java.util.HashMap;
import java.util.Map;

public class Dataset {
	private String album_id;
	private String album_title;
	private Map&amp;lt;String , Object&amp;gt; otherProperties = new HashMap&amp;lt;String , Object&amp;gt;();

	public String getAlbum_id() {
		return album_id;
	}

	public void setAlbum_id(String album_id) {
		this.album_id = album_id;
	}

	public String getAlbum_title() {
		return album_title;
	}

	public void setAlbum_title(String album_title) {
		this.album_title = album_title;
	}

	public Object get(String name) {
		return otherProperties.get(name);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-google-json-serializing-collections.jsp&#34; title=&#34;Serializing Collections&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
