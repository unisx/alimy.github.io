<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Development on Alimy </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://alimy.me/categories/development/</link>
    
    
    <copyright>&amp;copy;2016, Alimy; all rights reserved.</copyright>
    <updated>Tue, 08 Mar 2016 14:41:00 CST</updated>
    
    <item>
      <title>XStream: Java to XML Using Annotation</title>
      <link>http://alimy.me/post/dev_201603081441/</link>
      <pubDate>Tue, 08 Mar 2016 14:41:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081441/</guid>
      <description>&lt;p&gt;In the previous tutorials we saw an example of how to &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34;&gt;create a java object from XML&lt;/a&gt;. That tutorial also explained the concept of aliases and implicit collection. In this tutorial we continue with that but use annotation on the java class. The advantage with annotation is that it is faster to code and develop. the disadvantage is that you bind the java class to XStream.&lt;/p&gt;

&lt;p&gt;In the example below we convert an object of type JazzArtist to XML. JazzArtist contains fields name, isAlive, a url and a list of albums. This example uses the following annotations&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@XStreamAlias - Used on the type, field or attribute. To understand &amp;lsquo;aliases&amp;rsquo; look at this tutorial&lt;/li&gt;
&lt;li&gt;@XStreamImplicit - Used on Collections or array. To understand &amp;lsquo;Implicit Collections/Arrays&amp;rsquo; look at the this tutorial.&lt;/li&gt;
&lt;li&gt;@XStreamAsAttribute - Used to mark a field as an attribute.&lt;/li&gt;
&lt;li&gt;@XStreamConverter - Use a specific converter for this field. We will look at Converters in detail in a later tutorial. In this example we use a Boolean converter for &amp;lsquo;isAlive&amp;rsquo; field, we want the XML to have values yes or no instead of true or false.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is the complete example. In this example we want to create an XML from an object of type JazzArtist2.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We use annotation to first use an alias of &amp;lsquo;artist&amp;rsquo; for JazzArtist2. Each Jazz Artist has a list of albums.&lt;/li&gt;
&lt;li&gt;In the resulting XML we dont want the albums to appear under the element &amp;lsquo;albums&amp;rsquo;, rather we want each album to be the child of the artist element. We therefore mark &amp;lsquo;albums&amp;rsquo; as an implicit collection using the @XStreamImplicit annotation.&lt;/li&gt;
&lt;li&gt;We don&amp;rsquo;t want to include the &amp;lsquo;noOfRecords&amp;rsquo; in the resulting XML, we therefore use the @XStreamOmitField to omit that field.&lt;/li&gt;
&lt;li&gt;We want genre to be an attribute of the album instead of a child. we use @XStreamAsAttribute to mark genre as an attribute.&lt;/li&gt;
&lt;li&gt;In this example we also use an annotation for a Converter. There is a boolean field in the JazzArtist2 class called isAlive. We dont want the   XML to have values &amp;lsquo;true&amp;rsquo; or &amp;lsquo;false&amp;rsquo; but values &amp;lsquo;yes&amp;rsquo; or &amp;lsquo;no&amp;rsquo; since they are more human friendly. The @XStreamConverter can be used to specify a Converter and pass values to its constructor.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import com.thoughtworks.xstream.annotations.XStreamConverter;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.annotations.XStreamOmitField;
import com.thoughtworks.xstream.converters.basic.BooleanConverter;

public class CreateXMLFromMusicArtistObjectAnnotated {

    public static void main(String[] args) throws MalformedURLException {
        CreateXMLFromMusicArtistObjectAnnotated marshaller =
                new CreateXMLFromMusicArtistObjectAnnotated();
        marshaller.createXMlFromObject();
    }

    private void createXMlFromObject() throws MalformedURLException {
        JazzArtist2 artist2 = new JazzArtist2(&amp;quot;Benny Goodman&amp;quot;,
                false, new URL(&amp;quot;http://www.bennygoodman.com/&amp;quot;));
        Album2 album3 = new Album2(&amp;quot;In Stockholm&amp;quot;, 5, 1959,&amp;quot;swing&amp;quot;);
        Album2 album4 = new Album2(&amp;quot;A Jazz Holiday&amp;quot;, 3, 1928,&amp;quot;swing&amp;quot;);
        artist2.addAlbum(album3);
        artist2.addAlbum(album4);
        XStream xStream2 = new XStream();
        xStream2.processAnnotations(JazzArtist2.class);
        System.out.println(xStream2.toXML(artist2));
    }
}

@XStreamAlias(&amp;quot;artist&amp;quot;)
class JazzArtist2 {
    public String name;
    @XStreamConverter(value = BooleanConverter.class,
            booleans = { true }/*is case sensitive*/,
            strings = { &amp;quot;Yes&amp;quot;, &amp;quot;No&amp;quot; })
    public boolean isAlive;
    public URL url;
    @XStreamImplicit
    public List&amp;lt;Album2&amp;gt; albums = new ArrayList&amp;lt;Album2&amp;gt;();

    public JazzArtist2(String name, boolean isAlive, URL url) {
        this.name = name;
        this.isAlive = isAlive;
        this.url = url;
    }

    public void addAlbum(Album2 album) {
        albums.add(album);
    }

}

@XStreamAlias(&amp;quot;album&amp;quot;)
class Album2 {
    public String title;
    @XStreamOmitField
    public int noOfRecords;
    public int year;
    @XStreamAsAttribute
    public String genre;

    public Album2(String title, int noOfRecords, int year,String genre) {
        this.title = title;
        this.noOfRecords = noOfRecords;
        this.year = year;
        this.genre = genre;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;name&amp;gt;Benny Goodman&amp;lt;/name&amp;gt;
  &amp;lt;isalive&amp;gt;No&amp;lt;/isalive&amp;gt;
  &amp;lt;url&amp;gt;http://www.bennygoodman.com/&amp;lt;/url&amp;gt;
  &amp;lt;album genre=&amp;quot;swing&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;In Stockholm&amp;lt;/title&amp;gt;
    &amp;lt;year&amp;gt;1959&amp;lt;/year&amp;gt;
  &amp;lt;/album&amp;gt;
  &amp;lt;album genre=&amp;quot;swing&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;A Jazz Holiday&amp;lt;/title&amp;gt;
    &amp;lt;year&amp;gt;1928&amp;lt;/year&amp;gt;
  &amp;lt;/album&amp;gt;
&amp;lt;/artist&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-java-to-xml-annotated.jsp&#34; title=&#34;Java to XML Using Annotation&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XStream: Java to XML</title>
      <link>http://alimy.me/post/dev_201603081433/</link>
      <pubDate>Tue, 08 Mar 2016 14:33:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081433/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34;&gt;previous&lt;/a&gt; example we saw how to convert a Java Object to XML and back. In this example we look at another example of Java Object to XML Conversion. The example uses an object called a &amp;lsquo;JazzArtist&amp;rsquo;. This object has a list of &amp;lsquo;Album&amp;rsquo; objects besides some other properties. We see here another example of Alias and implicit collection. (To understand alias and implicit collections look at this tutorial) We divide the example in three parts. In the first part we do not use aliases or implicit collections. In the second part we use aliases and in the third part we use an implicit Collection. Note the output from the three parts and observe how aliases and implicit collection change the way the output xml looks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.ArrayList;
import java.util.List;

import com.thoughtworks.xstream.XStream;

public class CreateXMLFromMusicArtistObject {

    public static void main(String[] args) {
        CreateXMLFromMusicArtistObject marshaller = new CreateXMLFromMusicArtistObject();
        marshaller.createXMlFromObject();
        marshaller.createXMLFromObjectUsingAlias();
        marshaller.createXMLFromObjectUsingAliasAndImplicitCollection();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The JazzArtist and Album classes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class JazzArtist {
    public String name;
    public boolean isAlive;
    public String url;
    public List&amp;lt;Album&amp;gt; albums = new ArrayList&amp;lt;Album&amp;gt;();

    public JazzArtist(String name, boolean isAlive, String url) {
        this.name = name;
        this.isAlive = isAlive;
        this.url = url;
    }

    public void addAlbum(Album album) {
        albums.add(album);
    }

}

class Album {
    public String title;
    public int noOfrecords;
    public int year;

    public Album(String title, int noOfrecords, int year) {
        this.title = title;
        this.noOfrecords = noOfrecords;
        this.year = year;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first method - without alias and Implicit Collection&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void createXMlFromObject() {
 JazzArtist artist = new JazzArtist(&amp;quot;Bix Beiderbecke&amp;quot;, false, null);
 Album album1 = new Album(&amp;quot;Bix Beiderbecke with the Paul Whiteman Orchestra&amp;quot;, 5, 1928);
 Album album2 = new Album(&amp;quot;Bix Beiderbecke and His Gang&amp;quot;, 6, 1927);
 artist.addAlbum(album1);
 artist.addAlbum(album2);
 XStream xStream = new XStream();
 System.out.println(xStream.toXML(artist));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output from the first method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;com.studytrails.xml.xstream.jazzartist&amp;gt;
  &amp;lt;name&amp;gt;Bix Beiderbecke&amp;lt;/name&amp;gt;
  &amp;lt;isalive&amp;gt;false&amp;lt;/isalive&amp;gt;
  &amp;lt;albums&amp;gt;
    &amp;lt;com.studytrails.xml.xstream.album&amp;gt;
      &amp;lt;title&amp;gt;Bix Beiderbecke with the Paul Whiteman Orchestra&amp;lt;/title&amp;gt;
      &amp;lt;noofrecords&amp;gt;5&amp;lt;/noofrecords&amp;gt;
      &amp;lt;year&amp;gt;1928&amp;lt;/year&amp;gt;
    &amp;lt;/com.studytrails.xml.xstream.album&amp;gt;
    &amp;lt;com.studytrails.xml.xstream.album&amp;gt;
      &amp;lt;title&amp;gt;Bix Beiderbecke and His Gang&amp;lt;/title&amp;gt;
      &amp;lt;noofrecords&amp;gt;6&amp;lt;/noofrecords&amp;gt;
      &amp;lt;year&amp;gt;1927&amp;lt;/year&amp;gt;
    &amp;lt;/com.studytrails.xml.xstream.album&amp;gt;
  &amp;lt;/albums&amp;gt;
&amp;lt;/com.studytrails.xml.xstream.jazzartist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second method - with aliases&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void createXMLFromObjectUsingAliasAndImplicitCollection() {
 JazzArtist artist2 = new JazzArtist(&amp;quot;Benny Goodman&amp;quot;, false, null);
 Album album3 = new Album(&amp;quot;In Stockholm&amp;quot;, 5, 1959);
 Album album4 = new Album(&amp;quot;A Jazz Holiday&amp;quot;, 3, 1928);
 artist2.addAlbum(album3);
 artist2.addAlbum(album4);
 XStream xStream2 = new XStream();
 xStream2.alias(&amp;quot;artist&amp;quot;, JazzArtist.class);
 xStream2.alias(&amp;quot;album&amp;quot;, Album.class);
 xStream2.addImplicitCollection(JazzArtist.class, &amp;quot;albums&amp;quot;);
 System.out.println(xStream2.toXML(artist2));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output from the second method, the long class names are replaced by the alias.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;name&amp;gt;Benny Goodman&amp;lt;/name&amp;gt;
  &amp;lt;isalive&amp;gt;false&amp;lt;/isalive&amp;gt;
  &amp;lt;albums&amp;gt;
    &amp;lt;album&amp;gt;
      &amp;lt;title&amp;gt;In Stockholm&amp;lt;/title&amp;gt;
      &amp;lt;noofrecords&amp;gt;5&amp;lt;/noofrecords&amp;gt;
      &amp;lt;year&amp;gt;1959&amp;lt;/year&amp;gt;
    &amp;lt;/album&amp;gt;
    &amp;lt;album&amp;gt;
      &amp;lt;title&amp;gt;A Jazz Holiday&amp;lt;/title&amp;gt;
      &amp;lt;noofrecords&amp;gt;3&amp;lt;/noofrecords&amp;gt;
      &amp;lt;year&amp;gt;1928&amp;lt;/year&amp;gt;
    &amp;lt;/album&amp;gt;
  &amp;lt;/albums&amp;gt;
&amp;lt;/artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third method - with alias and implicit collection&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void createXMLFromObjectUsingAlias() {
 JazzArtist artist2 = new JazzArtist(&amp;quot;Benny Goodman&amp;quot;, false, null);
 Album album3 = new Album(&amp;quot;In Stockholm&amp;quot;, 5, 1959);
 Album album4 = new Album(&amp;quot;A Jazz Holiday&amp;quot;, 3, 1928);
 artist2.addAlbum(album3);
 artist2.addAlbum(album4);
 XStream xStream2 = new XStream();
 xStream2.alias(&amp;quot;artist&amp;quot;, JazzArtist.class);
 xStream2.alias(&amp;quot;album&amp;quot;, Album.class);
 System.out.println(xStream2.toXML(artist2));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output from the third method, the &amp;lsquo;albums&amp;rsquo; element is not required and all the &amp;lsquo;album&amp;rsquo; elements are now directly children of the artist.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;artist&amp;gt;
  &amp;lt;name&amp;gt;Benny Goodman&amp;lt;/name&amp;gt;
  &amp;lt;isalive&amp;gt;false&amp;lt;/isalive&amp;gt;
  &amp;lt;album&amp;gt;
    &amp;lt;title&amp;gt;In Stockholm&amp;lt;/title&amp;gt;
    &amp;lt;noofrecords&amp;gt;5&amp;lt;/noofrecords&amp;gt;
    &amp;lt;year&amp;gt;1959&amp;lt;/year&amp;gt;
  &amp;lt;/album&amp;gt;
  &amp;lt;album&amp;gt;
    &amp;lt;title&amp;gt;A Jazz Holiday&amp;lt;/title&amp;gt;
    &amp;lt;noofrecords&amp;gt;3&amp;lt;/noofrecords&amp;gt;
    &amp;lt;year&amp;gt;1928&amp;lt;/year&amp;gt;
  &amp;lt;/album&amp;gt;
&amp;lt;/artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-xml-to-java.jsp&#34; title=&#34;XStream XML to Java&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XStream: XML To Java</title>
      <link>http://alimy.me/post/dev_201603081427/</link>
      <pubDate>Tue, 08 Mar 2016 14:27:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081427/</guid>
      <description>&lt;p&gt;In the earlier tutorial we looked at a way to &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;Parsing an XML&#34;&gt;convert Java to XML and back&lt;/a&gt;. In this tutorial we look at some more examples of XML To Java Conversion. XStream can convert XML elements to multiple types depending on the type specified in the Java class. For example a series for similarly named elements can be converted to an array of String, a List of String or an enum. XStream uses an appropriate Converter based on type specified in the java class. Lets look at some examples.&lt;/p&gt;

&lt;p&gt;In this first example we have an XML that has a parent element called &amp;lsquo;Music&amp;rsquo;. It has a child element called type. We populate a Music object that has a &amp;lsquo;type&amp;rsquo; field which is an enum.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;

public class ConverterExample3 {
    static String xml1 = &amp;quot;&amp;lt;Music&amp;gt;&amp;lt;type&amp;gt;rock&amp;lt;/type&amp;gt;&amp;lt;/Music&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        XStream xStream = new XStream();
        xStream.processAnnotations(Music.class);
        Music musicObject = (Music) xStream.fromXML(xml1);
        System.out.println(musicObject);
        // prints Music [type=ROCK]
    }

}

@XStreamAlias(&amp;quot;Music&amp;quot;)
class Music {
    public enum genre {
        ROCK, JAZZ
    };

    genre type;

    @Override
    public String toString() {
        return &amp;quot;Music [type=&amp;quot; + type + &amp;quot;]&amp;quot;;
    }

}     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the next examples we convert the genre into a List of Strings&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.List;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamImplicit;

public class ConverterExample4 {

    static String xml = &amp;quot;&amp;lt;Music&amp;gt;&amp;lt;type&amp;gt;rock&amp;lt;/type&amp;gt;&amp;lt;type&amp;gt;jazz&amp;lt;/type&amp;gt;&amp;lt;/Music&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        XStream xStream = new XStream();
        xStream.processAnnotations(Music2.class);
        Music2 musicObject = (Music2) xStream.fromXML(xml);

        System.out.println(musicObject);
    }

}

@XStreamAlias(&amp;quot;Music&amp;quot;)
class Music2 {

    @XStreamImplicit
    List&amp;lt;String&amp;gt; type;

    @Override
    public String toString() {
        return &amp;quot;Music2 [type=&amp;quot; + type + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example The Music elements has a sequence of Artist elements each with an album name and a author name. We convert that to Music Object containing a map of Albums.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamImplicit;

public class ConverterExample6 {

    static String xml = &amp;quot;&amp;lt;Music&amp;gt;&amp;lt;album&amp;gt;&amp;lt;name&amp;gt;name1&amp;lt;/name&amp;gt;&amp;lt;author&amp;gt;author1&amp;lt;/author&amp;gt;&amp;lt;/album&amp;gt;&amp;lt;/Music&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        XStream xStream = new XStream();
        xStream.processAnnotations(Music4.class);
        xStream.alias(&amp;quot;name&amp;quot;, String.class);
        xStream.alias(&amp;quot;author&amp;quot;, String.class);
        xStream.alias(&amp;quot;album&amp;quot;, Entry.class);
        Music4 musicObject = (Music4) xStream.fromXML(xml);

        System.out.println(musicObject);
    }

}

@XStreamAlias(&amp;quot;Music&amp;quot;)
class Music4 {

    @XStreamImplicit
    Map&amp;lt;String, String&amp;gt; albums = new HashMap&amp;lt;String, String&amp;gt;();

    @Override
    public String toString() {
        return &amp;quot;Music4 [testMap=&amp;quot; + albums + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the last example lets look at how to deserialize a Date Object. We use a DateConverter where we can specify a format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.converters.basic.DateConverter;

public class ConverterExample7 {
    static String xml = &amp;quot;&amp;lt;Musician&amp;gt;&amp;lt;birthdate&amp;gt;04-20-1976 23:00:00&amp;lt;/birthdate&amp;gt;&amp;lt;/Musician&amp;gt;&amp;quot;;

    public static void main(String[] args) {
        XStream xStream = new XStream();
        xStream.processAnnotations(Musician.class);
        xStream.registerConverter(new DateConverter(&amp;quot;MM-dd-yyyy HH:mm:ss&amp;quot;,
                new String[] {}, TimeZone.getTimeZone(&amp;quot;UTC&amp;quot;)));
        Musician musician = (Musician) xStream.fromXML(xml);
        System.out.println(musician);
    }

}

@XStreamAlias(&amp;quot;Musician&amp;quot;)
class Musician {
    private Date birthdate;

    @Override
    public String toString() {
        SimpleDateFormat format = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);
        format.setTimeZone(TimeZone.getTimeZone(&amp;quot;UTC&amp;quot;));
        return &amp;quot;Musician [birthdate=&amp;quot; + format.format(birthdate) + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-xml-to-java.jsp&#34; title=&#34;XStream XML to Java&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XStream: Java to XML and Back</title>
      <link>http://alimy.me/post/dev_201603081411/</link>
      <pubDate>Tue, 08 Mar 2016 14:11:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081411/</guid>
      <description>

&lt;h3 id=&#34;the-problem-statement:bc08890a77c807eef23ae3fbd92d9134&#34;&gt;The Problem Statement&lt;/h3&gt;

&lt;p&gt;XStream can be used to convert a Java Object to XML and back. This tutorial aims to create a java representation of the BBC RSS. We will start with a Simple java class and gradually start adding complexity to it so that it can be converted to the BBC RSS. Note that if you are looking at a way to parse an XML, it would be a good idea to first build a java class that XStream can convert to the required XML. XStream can then use the same class to deserialize the XML. First, have a look at the &lt;a href=&#34;http://feeds.bbci.co.uk/news/technology/rss.xml?edition=int&#34; title=&#34;BBC RSS&#34;&gt;BBC RSS&lt;/a&gt;. Your browser would have formatted it to html so look at the source to see the XML. The parent element is &amp;lsquo;rss&amp;rsquo;. It has a child element called &amp;lsquo;channel&amp;rsquo;. The &amp;lsquo;channel&amp;rsquo; has some properties (title, link, image etc) and a list of news &amp;lsquo;item&amp;rsquo;(s). Each &amp;lsquo;item&amp;rsquo; has properties set on it (title, description etc). The aim is to create a Java class that XStream can convert to the BBC RSS.&lt;/p&gt;

&lt;h3 id=&#34;creating-an-xstream-instance:bc08890a77c807eef23ae3fbd92d9134&#34;&gt;Creating an XStream Instance&lt;/h3&gt;

&lt;p&gt;The first step is to create an instance of com.thoughtworks.xstream.XStream. This class is a facade to the XStream API and provides all major functionalities. If this class does not solve your problem then you could directly call the API methods. After obtaining the instance of XStream use the fromXML method to convert the XML to a java object. Note that creating an XStream instance is an expensive operation. It is therefore advisable to create a proper instance once and then reuse it for multiple calls (even in parallel). The setup is not threadsafe but any subsequent marshalling/unmarshalling is threadsafe.&lt;/p&gt;

&lt;h3 id=&#34;aliases:bc08890a77c807eef23ae3fbd92d9134&#34;&gt;Aliases&lt;/h3&gt;

&lt;p&gt;XStream provides a very useful functionality called aliases. In our example we want to convert an instance of com.studytrails.xml.xstream.Rss to an rss element. We tell XStream that the element &amp;lsquo;rss&amp;rsquo; is an &amp;lsquo;alias&amp;rsquo; to &amp;lsquo;com.studytrails.xml.xstream.Rss&amp;rsquo; so that XStream knows how to convert them. If we dont provide the alias while converting the object to XML then XStream would give the element the fully qualified name of the class. Aliases work for Classes as well as fields. The example below demonstrates the use of aliases.&lt;/p&gt;

&lt;h3 id=&#34;implicit-collection:bc08890a77c807eef23ae3fbd92d9134&#34;&gt;Implicit Collection&lt;/h3&gt;

&lt;p&gt;The Channel element in BBC has a list of items. However, note that the XML stream does not have an &lt;items&gt; element containing a list of &lt;item&gt; elements. The XML stream just has a list of &lt;item&gt; elements directly under the &lt;Channel&gt; element. We want to map them to the &amp;lsquo;items&amp;rsquo; java.util.List of the Channel Object. To accomplish this we use a concept in XStream called Implicit Collection. we say that &amp;lsquo;items&amp;rsquo; is an implicit collection. What that means is that there is actually no &amp;lsquo;items&amp;rsquo; element in the XML, but put all XML elements with name &amp;lsquo;item&amp;rsquo; (since the java property items is of type List&lt;Item&gt;) into the &amp;lsquo;items&amp;rsquo; property of the java object. Look at the example to see how it works.&lt;/p&gt;

&lt;h3 id=&#34;attributes:bc08890a77c807eef23ae3fbd92d9134&#34;&gt;Attributes&lt;/h3&gt;

&lt;p&gt;Handling attributes is a little tricky. In this example we provide one way to handle attributes, however, we have a dedicated tutorial to explain how attributes can be handled using XStream.&lt;/p&gt;

&lt;h3 id=&#34;namespaces:bc08890a77c807eef23ae3fbd92d9134&#34;&gt;Namespaces&lt;/h3&gt;

&lt;p&gt;Elements within a namespace can be handled by XStream by using aliases. In this example there is a link within the namespace atom. we just use an alias to read that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xstream.aliasField(&amp;quot;atom:link&amp;quot;, Channel.class, &amp;quot;a_link&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example:bc08890a77c807eef23ae3fbd92d9134&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Lets start building the java example. As a first step create a Java class for the root element i.e. RSS&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import com.thoughtworks.xstream.XStream;

public class BBCRSSExample {
    public static void main(String[] args) {
        XStream xStream = new XStream();
        Rss bbcRss = new Rss();
        System.out.println(xStream.toXML(bbcRss));
    }
}

class Rss {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;com.studytrails.xml.xstream.Rss/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We dont want the fully qualified name of the class for Rss. Lets use alias to simplify the name. Add this line after creating the Rss instance&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.alias(&amp;quot;rss&amp;quot;, Rss.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output now becomes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;rss/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rss elmenent contains a Channel element. Lets create a Channel class. The channel element is a child of rss element. Create a field in the Rss class to hold an object of type Channel. Add these lines to the main method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Channel channel = new Channel();
bbcRss.channel = channel;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how the Rss and Channel class looks now&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Rss {
    public Channel channel;
}
class Channel {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how the XML looks now&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;rss&amp;gt;
  &amp;lt;channel/&amp;gt;
&amp;lt;/rss&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we start adding fields to the classes lets look at an important field. The channel element contains this :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;atom:link href=&amp;quot;http://feeds.bbci.co.uk/news/technology/rss.xml&amp;quot; rel=&amp;quot;self&amp;quot; type=&amp;quot;application/rss+xml&amp;quot;&amp;gt;
&amp;lt;/atom:link&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the link element belongs to a different namespace. There is a neat little trick to handle this.
Create a class called AtomLink.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AtomLink {
    public String href;
    public String rel;
    public String type;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create an instance of AtomLink in the main class and assign it to a field in the Channel class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AtomLink atomLink = new AtomLink();
atomLink.href = &amp;quot;http://feeds.bbci.co.uk/news/technology/rss.xml&amp;quot;;
atomLink.rel = &amp;quot;self&amp;quot;;
atomLink.type = &amp;quot;application/rss+xml&amp;quot;;
channel.a_link = atomLink;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use alias to give the element a namespace prefix&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.aliasField(&amp;quot;atom:link&amp;quot;, Channel.class, &amp;quot;a_link&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now we want href, rel and type to be attributes instead of child elements, this is how we do that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xstream.aliasAttribute(AtomLink.class, &amp;quot;type&amp;quot;, &amp;quot;type&amp;quot;);
xstream.aliasAttribute(AtomLink.class, &amp;quot;href&amp;quot;, &amp;quot;href&amp;quot;);
xstream.aliasAttribute(AtomLink.class, &amp;quot;rel&amp;quot;, &amp;quot;rel&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see how our XML looks now&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;rss&amp;gt;
  &amp;lt;channel&amp;gt;
    &amp;lt;atom:link href=&amp;quot;http://feeds.bbci.co.uk/news/technology/rss.xml&amp;quot; rel=&amp;quot;self&amp;quot; type=&amp;quot;application/rss+xml&amp;quot;&amp;gt;
  &amp;lt;/atom:link&amp;gt;&amp;lt;/channel&amp;gt;
&amp;lt;/rss&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hope you are enjoying the example. It is important that you understand what&amp;rsquo;s happened so far. Go back to the example if you have any doubt since we will start picking up pace now.
The next important part is the item. The channel contains a list of items but the items are not included in a parent &amp;lsquo;items&amp;rsquo; element. XStream handles this using a concept called Implicit Collection. Lets see how it works, first lets create the Item class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Item {
    public String title;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;create a field in channel class to hold the list of items&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Channel {
    public AtomLink a_link;
    public List&amp;lt;Item&amp;gt; items;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the main class we create an alias for Item and then add an implicit Collection for items. We add two items to the list and see how the XML looks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.alias(&amp;quot;item&amp;quot;, Item.class);
xStream.addImplicitCollection(Channel.class, &amp;quot;items&amp;quot;);
channel.items = new ArrayList&amp;lt;Item&amp;gt;();
Item item = new Item();
item.title=&amp;quot;Item1&amp;quot;;
Item item2 = new Item();
item2.title=&amp;quot;Item2&amp;quot;;
channel.items.add(item);
channel.items.add(item2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;rss&amp;gt;
  &amp;lt;channel&amp;gt;
    &amp;lt;atom:link href=&amp;quot;http://feeds.bbci.co.uk/news/technology/rss.xml&amp;quot; rel=&amp;quot;self&amp;quot; type=&amp;quot;application/rss+xml&amp;quot;&amp;gt;
    &amp;lt;item&amp;gt;
      &amp;lt;title&amp;gt;Item1&amp;lt;/title&amp;gt;
    &amp;lt;/item&amp;gt;
    &amp;lt;item&amp;gt;
      &amp;lt;title&amp;gt;Item2&amp;lt;/title&amp;gt;
    &amp;lt;/item&amp;gt;
  &amp;lt;/atom:link&amp;gt;&amp;lt;/channel&amp;gt;
&amp;lt;/rss&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we add class for the Thumbnail which is part of the item element. An item can have multiple thumbnails. Lets use an array now instead of a Collection just to demonstrate how an ImplicitArray works.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Item {
    public String title;
    public MediaThumbnail[] media_thumbnails;
}

class MediaThumbnail {
    public int width;
    public int height;
    public String url;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main method creates the array and adds thumbnails to it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xStream.addImplicitArray(Item.class, &amp;quot;media_thumbnails&amp;quot;, &amp;quot;media:thumbnail&amp;quot;);
xStream.aliasAttribute(MediaThumbnail.class, &amp;quot;width&amp;quot;,&amp;quot;width&amp;quot;);
xStream.aliasAttribute(MediaThumbnail.class, &amp;quot;height&amp;quot;,&amp;quot;height&amp;quot;);
xStream.aliasAttribute(MediaThumbnail.class, &amp;quot;url&amp;quot;,&amp;quot;url&amp;quot;);

MediaThumbnail thumbnail = new MediaThumbnail();
thumbnail.height=100;
thumbnail.width=50;
thumbnail.url=&amp;quot;thumbnail_link&amp;quot;;
MediaThumbnail thumbnail2 = new MediaThumbnail();
thumbnail2.height=100;
thumbnail2.width=50;
thumbnail2.url=&amp;quot;thumbnail_link2&amp;quot;;

item.media_thumbnails = new MediaThumbnail[2];
item.media_thumbnails[0] = thumbnail;
item.media_thumbnails[1] = thumbnail2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have almost built up the whole class. We can further add the Image class that stores the image in a channel. After creating all classes we start adding the other fields to them. Once the Rss class is ready you can then use it to read the BBC RRS! Heres the complete class and the main method that does the reading.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.net.MalformedURLException;
import java.net.URL;

import com.thoughtworks.xstream.XStream;

public class XStreamDeserializerExample1 {

    private String bbcUrl = &amp;quot;http://feeds.bbci.co.uk/news/technology/rss.xml?edition=int&amp;quot;;

    public static void main(String[] args) throws MalformedURLException {
        XStreamDeserializerExample1 serializer = new XStreamDeserializerExample1();
        serializer.basicSerialization();
    }

    private void basicSerialization() throws MalformedURLException {

        XStream xstream = new XStream();
        xstream.alias(&amp;quot;rss&amp;quot;, Rss.class);
        xstream.aliasField(&amp;quot;atom:link&amp;quot;, Channel.class, &amp;quot;a_link&amp;quot;);
        xstream.alias(&amp;quot;item&amp;quot;, Item.class);

        xstream.aliasAttribute(AtomLink.class, &amp;quot;type&amp;quot;, &amp;quot;type&amp;quot;);
        xstream.aliasAttribute(AtomLink.class, &amp;quot;href&amp;quot;, &amp;quot;href&amp;quot;);
        xstream.aliasAttribute(AtomLink.class, &amp;quot;rel&amp;quot;, &amp;quot;rel&amp;quot;);

        xstream.aliasAttribute(MediaThumbnail.class, &amp;quot;width&amp;quot;,&amp;quot;width&amp;quot;);
        xstream.aliasAttribute(MediaThumbnail.class, &amp;quot;height&amp;quot;,&amp;quot;height&amp;quot;);
        xstream.aliasAttribute(MediaThumbnail.class, &amp;quot;url&amp;quot;,&amp;quot;url&amp;quot;);

        xstream.addImplicitCollection(Channel.class, &amp;quot;items&amp;quot;);
        xstream.addImplicitArray(Item.class, &amp;quot;media_thumbnails&amp;quot;, &amp;quot;media:thumbnail&amp;quot;);
        Rss bbcFeed = (Rss) xstream.fromXML(new URL(bbcUrl));
        // bbcFeed now contains the Java representation of the BBC RSS
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The classes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.List;

public class Rss {
    public Channel channel;
}

class Channel {
    public String title;
    public String link;
    public String description;
    public String language;
    public String lastBuildDate;
    public String copyright;
    public Image4 image;
    public String ttl;
    public AtomLink a_link;
    public List&amp;lt;item&amp;gt; items;
}

class AtomLink {
    public String href;
    public String rel;
    public String type;
}

class Item {
    public String title;
    public String description;
    public String link;
    public String guid;
    public String pubDate;
    public MediaThumbnail[] media_thumbnails;
}

class MediaThumbnail {
    public int width;
    public int height;
    public String url;
}

class Image {
    public String url;
    public String title;
    public String link;
    public String width;
    public String height;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-java-to-xml-and-back.jsp&#34; title=&#34;XStream Parsing an XML&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Xstream: Introduction</title>
      <link>http://alimy.me/post/dev_201603081355/</link>
      <pubDate>Tue, 08 Mar 2016 13:58:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081355/</guid>
      <description>&lt;p&gt;What is XStream&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.codehaus.org/&#34; title=&#34;codehaus&#34;&gt;XStream&lt;/a&gt; is a java library to convert Java Object into XML and back. You can take nearly every arbitrary deeply nested object turn it to XML and read it back without further configuration. You&amp;rsquo;re done if all you want to have is a persisted object in XML. XStream&amp;rsquo;s power lies in its extensive list of &amp;lsquo;Converters&amp;rsquo; that help convert a wide variety of Java Objects to XML and vice versa. A Converter is a class that specifies how a Java Object should be serialized to XML. XStream comes bundled with a lot of Converters and you can also customize your own.&lt;/p&gt;

&lt;p&gt;XStream allows converting a class to XML without modifying the class. It can serialize private and final fields and also inner classes. It can serialize references to objects. XStream has also added security measures that allows you to selectively de-serialize and serialize based on type.&lt;/p&gt;

&lt;p&gt;These tutorials provide an indepth look at all major XStream functionalities and presents examples as well as explanations that significantly reduce the learning curve that is generally experienced with any open source library.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;Parsing an XML&#34;&gt;Converting a Java Object to XML and back - Parsing an XML&lt;/a&gt;- In this tutorial we explain how to build a java object to read an XML. The objective is to create a java object and convert it to an XML which looks similar to the XML that we want to read. We then simply use this java object and XStream to parse our XML. This example introduces the basic XStream usage and also explains field and attribute &amp;lsquo;alias&amp;rsquo; and &amp;lsquo;ImplicitCollection&amp;rsquo;/&amp;lsquo;ImplicitArray&amp;rsquo;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603081427&#34; title=&#34;XML to Java&#34;&gt;XML to Java&lt;/a&gt; - We look at some more examples of XML to Java conversion. For example, we see how a piece of XML can be converted to either a List of String or a String array.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603081433&#34; title=&#34;Java to XML&#34;&gt;Java to XML&lt;/a&gt; - In this tutorial we learn how to serialize java to XML. The example demonstrates the use of aliases and implicit collection and also shows how the conversion looks if we dont use alias or implicit collectsion&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603081441&#34; title=&#34;Java to XML Usging Annotation&#34;&gt;Java to XML Using Annotation&lt;/a&gt; - This tutorial shows how to serialize Java to XML using annotations.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/&#34; title=&#34;Handling Attributes in XML&#34;&gt;Handling Attributes in XML&lt;/a&gt; - Handling attributes requires special methods since an element may contain an attribute with or without a value. In this tutorial we look at three ways of handling attributes - Element with attributes but no value, element with attributes but no value (using aliases), element with attribute and value (ToAttributedValueConverter)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/&#34; title=&#34;Referencing Objects&#34;&gt;Referencing Objects&lt;/a&gt; - A java class may have fields that store reference to other objects. There may be cases where a circular reference is encountered. XStream has multiple ways to store references to other objects. In this tutorial we look at all modes of storing references using XStream.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/&#34; title=&#34;Custom Converter for BufferedImage&#34;&gt;Custom Converter for BufferedImage&lt;/a&gt; - The power of XStream lies in its ability to convert a java class to XML and vice versa. Its does so using classes called &amp;lsquo;converters&amp;rsquo;. These converters have methods for marshalling and unmarshalling java and XML. XStream provides a lot of basic converters (basic java classes), Collection Converters and extended converters (converts third party java classes). However, if there is a class for which no converters are available then XStream provides a way to implement a custom converter. In this example we learn how to develop a custom converter for a BufferedImage.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/&#34; title=&#34;Basic Built-in Converters&#34;&gt;Basic Built-in Converters&lt;/a&gt; - This example shows some of the basic converters in XStream.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/&#34; title=&#34;Collection Converters&#34;&gt;Collection Converters&lt;/a&gt; - This example shows the collection converters in XStream.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/&#34; title=&#34;Json to Java&#34;&gt;Json to Java&lt;/a&gt; - XStream also provides a way to convert a Json to java object. It has two drivers to do so. In this tutorial we learn how to convert json to java using XStream.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://alimy.me/&#34; title=&#34;XML Transformation&#34;&gt;XML Transformation&lt;/a&gt; - XStream provides a TraxSource that can be used as a source for XSLT transformation. The TraxSource uses the Java Object that is to be transformed and an XStream object.&lt;/p&gt;

&lt;p&gt;We thank Jörg Schaible and Joe Walnes for their valuable feedback in making this tutorial better.&lt;/p&gt;

&lt;p&gt;We hope this tutorials help you in your work and we would appreciate if you could leave us your feedback and help us reach other developers by sharing our site on facebook and google.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-introduction.jsp&#34; title=&#34;XStream Introduction&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SimpleXML: Example</title>
      <link>http://alimy.me/post/dev_201603081313/</link>
      <pubDate>Tue, 08 Mar 2016 13:13:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603081313/</guid>
      <description>

&lt;p&gt;This page provides a series of examples illustrating how a class can be annotated. It acts as a quick and dirty overview of how the framework can be used and also acts as a reference page. All examples can be downloaded for convenience. For further information take a look at the &lt;a href=&#34;http://alimy.me/post/dev_201603032011&#34; title=&#34;SimpleXML Tutorial&#34;&gt;Tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-creating-nested-path-elements:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Creating nested path elements&lt;/h3&gt;

&lt;p&gt;Here an example of how to use the &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/javadoc/org/simpleframework/xml/Path.html&#34;&gt;Path&lt;/a&gt; annotation to create nested elements and attributes using a single annotated class. Below is an example showing two elements nested within a XPath expression.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @Path(&amp;quot;a/b[1]&amp;quot;)
   @Element
   private String x;

   @Path(&amp;quot;a/b[2]&amp;quot;)
   @Element
   private String y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML that can be generated by this class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;a&amp;gt;
    &amp;lt;b&amp;gt;
      &amp;lt;x&amp;gt;foo&amp;lt;/x&amp;gt;
    &amp;lt;/b&amp;gt;
    &amp;lt;b&amp;gt;
      &amp;lt;y&amp;gt;bar&amp;lt;/y&amp;gt;
    &amp;lt;/b&amp;gt;
  &amp;lt;/a&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example1/example1.zip&#34; title=&#34;example1&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-dynamically-selecting-an-element-name:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Dynamically selecting an element name&lt;/h3&gt;

&lt;p&gt;Here an example of how to use the ElementUnion annotation to specify a list of options to use for serialization. The union annotation pairs an element name with a type, this allows the element name to dictate selection of the type deserialized and also allows a known type to be serialized with a specific element name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @ElementUnion({
      @Element(name=&amp;quot;text&amp;quot;, type=String.class),
      @Element(name=&amp;quot;int&amp;quot;, type=Integer.class),
      @Element(name=&amp;quot;double&amp;quot;, type=Double.class)
   })
   private Object value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, here because the object value was an integer the resulting XML element is called int.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;int&amp;gt;12&amp;lt;/int&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example2/example2.zip&#34; title=&#34;example2&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-constructor-injection:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Constructor injection&lt;/h3&gt;

&lt;p&gt;Constructor injection can be performed with any number of arguments using any of the XML annotations. In this example the Element annotation is used to identify two values to be injected in to a specific constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Point {

   @Element
   private final int x;

   @Element
   private final int y;

   public Point(@Element(name=&amp;quot;x&amp;quot;) int x, @Element(name=&amp;quot;y&amp;quot;) int y) {
      this.x = x;
      this.y = y;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, both the x and y values will be injected in to the annotated constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;point&amp;gt;
  &amp;lt;x&amp;gt;10&amp;lt;/x&amp;gt;
  &amp;lt;y&amp;gt;4&amp;lt;/y&amp;gt;
&amp;lt;/point&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example3/example3.zip&#34; title=&#34;example3&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-constructor-injection-with-nested-path-elements:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Constructor injection with nested path elements&lt;/h3&gt;

&lt;p&gt;In this example constructor injection is performed on two elements which also have Path annotations. As can be seen if there is no ambiguity there is no need to specify the path annotations on the constructor. This reduces the clutter that can occur with excessive annotations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Point {

   @Path(&amp;quot;a/b[1]&amp;quot;)
   @Element
   private final int x;

   @Path(&amp;quot;a/b[1]&amp;quot;)
   @Element
   private final int y;

   public Point(@Element(name=&amp;quot;x&amp;quot;) int x, @Element(name=&amp;quot;y&amp;quot;) int y) {
      this.x = x;
      this.y = y;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, both the x and y values will be injected in to the annotated constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;point&amp;gt;
  &amp;lt;a&amp;gt;
    &amp;lt;b&amp;gt;
      &amp;lt;x&amp;gt;2&amp;lt;/x&amp;gt;
      &amp;lt;y&amp;gt;7&amp;lt;/y&amp;gt;
    &amp;lt;/b&amp;gt;
  &amp;lt;/a&amp;gt;
&amp;lt;/point&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example4/example4.zip&#34; title=&#34;example4&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-using-namespaces:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Using namespaces&lt;/h3&gt;

&lt;p&gt;Below is an example of how to use namespaces with the Namespace annotation. Here two namespaces are declared without a prefix, this means they belong to the default namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @Namespace(reference=&amp;quot;http://www.blah.com/ns/a&amp;quot;)
   @Element
   private String a;

   @Namespace(reference=&amp;quot;http://www.blah.com/ns/b&amp;quot;)
   @Element
   private String b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, as can be seen the namespaces are used to qualify the resulting elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;a xmlns=&amp;quot;http://www.blah.com/ns/a&amp;quot;&amp;gt;foo&amp;lt;/a&amp;gt;
  &amp;lt;b xmlns=&amp;quot;http://www.blah.com/ns/b&amp;quot;&amp;gt;bar&amp;lt;/b&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example5/example5.zip&#34; title=&#34;example5&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-declaring-a-namespace-prefix:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Declaring a namespace prefix&lt;/h3&gt;

&lt;p&gt;When using the Namespace annotation a prefix can be specified. This prefix is added to the qualified XML elements to ensure they are within a specific namespace, rather than the default namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @Namespace(prefix=&amp;quot;ns1&amp;quot;, reference=&amp;quot;http://www.blah.com/ns/a&amp;quot;)
   @Element
   private String a;

   @Namespace(prefix=&amp;quot;ns2&amp;quot;, reference=&amp;quot;http://www.blah.com/ns/b&amp;quot;)
   @Element
   private String b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting XML shows that both elements contain the namespace prefix declared in the annotation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;ns1:a xmlns:ns1=&amp;quot;http://www.blah.com/ns/a&amp;quot;&amp;gt;foo&amp;lt;/ns1:a&amp;gt;
  &amp;lt;ns2:b xmlns:ns2=&amp;quot;http://www.blah.com/ns/b&amp;quot;&amp;gt;bar&amp;lt;/ns2:b&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example6/example6.zip&#34; title=&#34;example6&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-namespace-prefix-inheritance:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Namespace prefix inheritance&lt;/h3&gt;

&lt;p&gt;Here a class level namespace is declared using the Namespace annotation. The element declared with the same namespace reference does not need to declare a prefix as it will be inherited from the class level annotation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Namespace(prefix=&amp;quot;ns1&amp;quot;, reference=&amp;quot;http://www.blah.com/ns/a&amp;quot;)
public class Example {

   @Namespace(reference=&amp;quot;http://www.blah.com/ns/a&amp;quot;)
   @Path(&amp;quot;a/b&amp;quot;)
   @Element
   private String x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen in the resulting XML the namespace is declared only once, the child element inherits the original prefix reducing the verbosity of the XML.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example xmlns:ns1=&amp;quot;http://www.blah.com/ns/a&amp;quot;&amp;gt;
  &amp;lt;a&amp;gt;
    &amp;lt;b&amp;gt;
      &amp;lt;ns1:x&amp;gt;blah&amp;lt;/ns1:x&amp;gt;
    &amp;lt;/b&amp;gt;
  &amp;lt;/a&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example7/example7.zip&#34; title=&#34;example7&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-default-serialization:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Default serialization&lt;/h3&gt;

&lt;p&gt;This example shows how the Default annotation can be used. When this annotation is used fields will be serialized without the need for annotations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Default
public class Example {

   private List&amp;lt;Double&amp;gt; a;
   private String b;
   private String c;
   private Date d;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen in the resulting XML is generated for all fields within the class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;a&amp;gt;
    &amp;lt;double&amp;gt;1.2&amp;lt;/double&amp;gt;
    &amp;lt;double&amp;gt;31.6&amp;lt;/double&amp;gt;
    &amp;lt;double&amp;gt;52.99&amp;lt;/double&amp;gt;
  &amp;lt;/a&amp;gt;
  &amp;lt;b&amp;gt;foo&amp;lt;/b&amp;gt;
  &amp;lt;c&amp;gt;bar&amp;lt;/c&amp;gt;
  &amp;lt;d&amp;gt;2012-05-22&amp;lt;/d&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example8/example8.zip&#34; title=&#34;example8&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-default-serialization-of-properties:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Default serialization of properties&lt;/h3&gt;

&lt;p&gt;This example shows how the Default annotation can be configured to use bean methods instead of fields for serialization. When used in this manner all methods that follow the Java Bean naming conventions will be considered for serialization.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Default(DefaultType.PROPERTY)
public class Example {

   private String name;

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen in the resulting XML is generated for the Java Bean method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example9/example9.zip&#34; title=&#34;example9&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-collecting-various-types-in-a-single-list:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Collecting various types in a single list&lt;/h3&gt;

&lt;p&gt;Here an example of how to use the ElementListUnion can be seen. This annotation allows a number of types to be declared to match a single list, all elements that match the declared names will be gathered in to the list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @ElementListUnion({
      @ElementList(entry=&amp;quot;int&amp;quot;, type=Integer.class, inline=true),
      @ElementList(entry=&amp;quot;date&amp;quot;, type=Date.class, inline=true),
      @ElementList(entry=&amp;quot;text&amp;quot;, type=String.class, inline=true)
   })
   private List&amp;lt;Object&amp;gt; list;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, each type is given a name according to its type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;int&amp;gt;12&amp;lt;/int&amp;gt;
  &amp;lt;date&amp;gt;2012-22-05&amp;lt;/date&amp;gt;
  &amp;lt;date&amp;gt;1977-18-11&amp;lt;/date&amp;gt;
  &amp;lt;text&amp;gt;blah&amp;lt;/text&amp;gt;
  &amp;lt;int&amp;gt;1&amp;lt;/int&amp;gt;
  &amp;lt;int&amp;gt;34525&amp;lt;/int&amp;gt;
  &amp;lt;date&amp;gt;2001-01-05&amp;lt;/date&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example10/example10.zip&#34; title=&#34;example10&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sect-dynamically-matching-a-constructor:6ed76957f65e40caff73dba00e2f11f2&#34;&gt;&amp;sect;Dynamically matching a constructor&lt;/h3&gt;

&lt;p&gt;Here an example of how to use the ElementUnion to dynamically select a constructor based on the value deserialized. Constructor matching will be done by examining the declared name and the instance type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @ElementUnion({
      @Element(name=&amp;quot;int&amp;quot;, type=Integer.class),
      @Element(name=&amp;quot;date&amp;quot;, type=Date.class),
      @Element(name=&amp;quot;text&amp;quot;, type=String.class)
   })
   private Object value;

   public Example(@Element(name=&amp;quot;int&amp;quot;) int value) {
      this.value = value;
   }

   public Example(@Element(name=&amp;quot;date&amp;quot;) Date value) {
      this.value = value;
   }

   public Example(@Element(name=&amp;quot;text&amp;quot;) String value) {
      this.value = value;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The below snippet shows an example of the resulting XML, here the constructor accepting a date will be invoked as that is what is deserialized from the file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
  &amp;lt;date&amp;gt;2001-01-05&amp;lt;/date&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example can be downloaded from &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/example11/example11.zip&#34; title=&#34;example11&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/examples/examples.php&#34; title=&#34;SimpleXML Examples&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SimpleXML: Tutorial</title>
      <link>http://alimy.me/post/dev_201603032011/</link>
      <pubDate>Thu, 03 Mar 2016 20:11:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603032011/</guid>
      <description>

&lt;p&gt;This page provides a tutorial that will prepare users for using XML serialization. Before this tutorial is attempted it is advisable to have a look at the &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/javadoc/&#34;&gt;Javadoc&lt;/a&gt; documentation for the framework. Although there are only several annotations and objects involved in the serialization process the framework itself has many powerful features which this tutorial attempts to describe.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Serializing a simple object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Deserializing a simple object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;Nested object serialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;Optional elements and attributes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;Reading a list of elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;Overriding an annotated type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;Dealing with an inline list of elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;Constructor injection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9&#34;&gt;Reading an array of elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10&#34;&gt;Adding text and attributes to elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;Dealing with map objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12&#34;&gt;Scattering inline element entries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13&#34;&gt;Loose object mapping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14&#34;&gt;Java Bean serialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15&#34;&gt;Default object serialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#16&#34;&gt;Example using template filters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#17&#34;&gt;Receiving persister callbacks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#18&#34;&gt;Maintaining state between persister callbacks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#19&#34;&gt;Serializing with CDATA blocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#20&#34;&gt;Using XML namespaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#21&#34;&gt;Resolving object reference cycles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22&#34;&gt;Reusing XML elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23&#34;&gt;Using utility collections&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24&#34;&gt;Object substitution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25&#34;&gt;Serializing Java language types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26&#34;&gt;Styling serialized XML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27&#34;&gt;Version tolerant serialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#28&#34;&gt;Serializing static final fields&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#29&#34;&gt;Overriding serialization with converters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#30&#34;&gt;Intercepting the serialization process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#31&#34;&gt;Mapping with XPath expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32&#34;&gt;Dynamic serialization with unions&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;a-name-1-sect-serializing-a-simple-object:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;1&#34;/&gt; &amp;sect;Serializing a simple object&lt;/h3&gt;

&lt;p&gt;In order to serialize an object to XML a series of annotations must be placed within that object. These annotations tell the persister how the object should be serialized. For example take the class shown below. Here there are three different annotations, one used to describe the name of the root element, one that describes an XML message element, and a final annotation for an id attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @Element
   private String text;

   @Attribute
   private int index;

   public Example() {
      super();
   }  

   public Example(String text, int index) {
      this.text = text;
      this.index = index;
   }

   public String getMessage() {
      return text;
   }

   public int getId() {
      return index;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To serialize an instance of the above object a &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/javadoc/org/simpleframework/xml/core/Persister.html&#34;&gt;Persister&lt;/a&gt; is required. The persister object is then given an instance of the annotated object and an output result, which is a file in this example. Other output formats are possible with the persister object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Serializer serializer = new Persister();
Example example = new Example(&amp;quot;Example message&amp;quot;, 123);
File result = new File(&amp;quot;example.xml&amp;quot;);

serializer.write(example, result);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the above code is executed the object instance will have been transferred as an XML document to the specified file. The resulting XML file will contain the contents shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example index=&amp;quot;123&amp;quot;&amp;gt;
   &amp;lt;text&amp;gt;Example message&amp;lt;/text&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As well as the capability of using the field an object name to acquire the XML element and attribute names explicit naming is possible. Each annotation contains a name attribute, which can be given a string providing the name of the XML attribute or element. This ensures that should the object have unusable field or method names they can be overridden, also if your code is obfuscated explicit naming is the only reliable way to serialize and deserialize objects consistently. An example of the previous object with explicit naming is shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root(name=&amp;quot;root&amp;quot;)
public class Example {

   @Element(name=&amp;quot;message&amp;quot;)
   private String text;

   @Attribute(name=&amp;quot;id&amp;quot;)
   private int index;

   public Example() {
      super();
   }  

   public Example(String text, int index) {
      this.text = text;
      this.index = index;
   }

   public String getMessage() {
      return text;
   }

   public int getId() {
      return index;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above object the XML document constructed from an instance of the object results in a different format. Here the XML element and attribute names have been overridden with the annotation names. The resulting output is shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;root id=&amp;quot;123&amp;quot;&amp;gt;
   &amp;lt;message&amp;gt;Example message&amp;lt;/message&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-2-sect-deserializing-a-simple-object:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;2&#34; /&gt; &amp;sect;Deserializing a simple object&lt;/h3&gt;

&lt;p&gt;Taking the above example object the XML deserialization process is described in the code snippet shown below. As can be seen the deserialization process is just as simple. The persister is given the class representing the serialized object and the source of the XML document. To deserialize the object the read method is used, which produces an instance of the annotated object. Also, note that there is no need to cast the return value from the read method as the method is generic.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Serializer serializer = new Persister();
File source = new File(&amp;quot;example.xml&amp;quot;);

Example example = serializer.read(Example.class, source);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-sect-nested-object-serialization:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;3&#34; /&gt; &amp;sect;Nested object serialization&lt;/h3&gt;

&lt;p&gt;As well as simple object serialization, nested object serialization is possible. This is where a serializable object can contain any number of serializable objects, to any depth. Take the example shown in the code snippet below. This shows several objects that are linked together to form a single serializable entity. Here the root configuration object contains a server object, which in turn contains a security information object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Configuration {

   @Element
   private Server server;

   @Attribute
   private int id;

   public int getIdentity() {
      return id;
   }

   public Server getServer() {
      return server;           
   }
}

public class Server {

   @Attribute
   private int port;

   @Element
   private String host;

   @Element
   private Security security;

   public int getPort() {
      return port;           
   }

   public String getHost() {
      return host;           
   }

   public Security getSecurity() {
      return security;           
   }
}

public class Security {

   @Attribute
   private boolean ssl;

   @Element
   private String keyStore;

   public boolean isSSL() {
      return ssl;           
   }

   public String getKeyStore() {
      return keyStore;           
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to create an initialized configuration object an XML document can be used. This XML document needs to match the XML annotations for the object graph. So taking the above class schema the XML document would look like the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;configuration id=&amp;quot;1234&amp;quot;&amp;gt;
   &amp;lt;server port=&amp;quot;80&amp;quot;&amp;gt;
      &amp;lt;host&amp;gt;www.domain.com&amp;lt;/host&amp;gt;
      &amp;lt;security ssl=&amp;quot;true&amp;quot;&amp;gt;
         &amp;lt;keyStore&amp;gt;example keystore&amp;lt;/keyStore&amp;gt;
      &amp;lt;/security&amp;gt;
   &amp;lt;/server&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How the mapping is done can be seen by examining the XML document elements and attributes and comparing these to the annotations within the schema classes. The mapping is quite simple and can be picked up and understood in several minutes.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-sect-optional-elements-and-attributes:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;4&#34; /&gt;&amp;sect;Optional elements and attributes&lt;/h3&gt;

&lt;p&gt;At times it may be required to have an optional XML element or attribute as the source XML may not contain the attribute or element. Also, it may be that an object field is null and so cannot be serialized. In such scenarios the element or attribute can be set as not required. The following code example demonstrates an optional element and attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class OptionalExample {

   @Attribute(required=false)
   private int version;

   @Attribute
   private String id;

   @Element(required=false)
   private String name;   

   @Element
   private String address;

   public int getId() {
      return id;
   }

   public int getVersion() {
      return version;
   }

   public String getName() {
      return name;
   }

   public String getAddress() {
      return address;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above object the version and name are not required. So, and XML source document may not contain either of these details and the object can still be serialized safely. For example take the following XML document, which is a valid representation of the above object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;optionalExample id=&amp;quot;10&amp;quot;&amp;gt;
   &amp;lt;address&amp;gt;Some example address&amp;lt;/address&amp;gt;
&amp;lt;/optionalExample&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even without the name and version XML nodes this document can be deserialized in to an object. This feature is useful when your XML contains optional details and allows more flexible parsing. To further clarify the implementation of optional fields take the example shown below. This shows how the entry object is deserialized from the above document, which is contained within a file. Once deserialized the object values can be examined.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Serializer serializer = new Persister();
File source = new File(&amp;quot;example.xml&amp;quot;);
OptionalExample example = serializer.read(OptionalExample.class, source);

assert example.getVersion() == 0;
assert example.getName() == null;
assert example.getId() == 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-5-sect-reading-a-list-of-elements:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;5&#34; /&gt;&amp;sect;Reading a list of elements&lt;/h3&gt;

&lt;p&gt;In XML configuration and in Java objects there is often a one to many relationship from a parent to a child object. In order to support this common relationship an ElementList annotation has been provided. This allows an annotated schema class to be used as an entry to a Java collection object. Take the example shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class PropertyList {

   @ElementList
   private List&amp;lt;Entry&amp;gt; list;

   @Attribute
   private String name;

   public String getName() {
      return name;
   }

   public List getProperties() {
      return list;
   }
}

@Root
public class Entry {

   @Attribute
   private String key;

   @Element
   private String value;

   public String getName() {
      return name;
   }

   public String getValue() {
      return value;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above code snippet the element list annotation can be seen. The field type is reflectively instantiated as a matching concrete object from the Java collections framework, typically it is an array list, but can be any collection object if the field type declaration provides a concrete implementation type rather than the abstract list type shown in the above example.&lt;/p&gt;

&lt;p&gt;Below an XML document is shown that matches the schema class. Here each entry element will be deserialized using the declared entry class and inserted into the collection instance created. Once all entry objects have been deserialized the object instance contains a collection containing individual property objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;propertyList name=&amp;quot;example&amp;quot;&amp;gt;
   &amp;lt;list&amp;gt;
      &amp;lt;entry key=&amp;quot;one&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
      &amp;lt;entry key=&amp;quot;two&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
      &amp;lt;entry key=&amp;quot;three&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
      &amp;lt;entry key=&amp;quot;four&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
   &amp;lt;/list&amp;gt;
&amp;lt;/propertyList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above example it can be seen that the entry details are taken from the generic type of the collection. It declares a list with the entry class as its generic parameter. This type of declaration is often not possible, for example if a specialized list contains more than one generic type which one is the correct type to use for deserialization or serialization. In such scenarios the type must be provided explicitly. Take the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class ExampleList {

   @ElementList(type=C.class)
   private SpecialList&amp;lt;A, B, C&amp;gt; list;

   public SpecialList&amp;lt;A, B, C&amp;gt; getSpecialList() {
      return list;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example the special list takes three generic parameters, however only one is used as the generic parameter for the collection. As can be seen an explicit declaration of which type to use is required. This can be done with the type attribute of the ElementList annotation.&lt;/p&gt;

&lt;h3 id=&#34;a-name-6-sect-overriding-an-annotated-type:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;6&#34; /&gt;&amp;sect;Overriding an annotated type&lt;/h3&gt;

&lt;p&gt;In order to accommodate dynamic types within the deserialization process a class attribute can be added to an XML element, which will ensure that that element can be instantiated as the declared type. This ensures that field and method types can reference abstract classes and interfaces, it also allows multiple types to be added into an annotated collection.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package example.demo;

public interface Task {

   public double execute();
}

@Root
public class Example implements Task {

   @Element
   private Task task;

   public double execute() {
      return task.execute();
   }  
}

public class DivideTask implements Task {

   @Element(name=&amp;quot;left&amp;quot;)
   private float text;

   @Element(name=&amp;quot;right&amp;quot;)
   private float right;

   public double execute() {
      return left / right;
   }
}

public class MultiplyTask implements Task {

   @Element(name=&amp;quot;first&amp;quot;)
   private int first;

   @Element(name=&amp;quot;second&amp;quot;)
   private int second;

   public double execute() {
      return first * second;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class attribute must be a fully qualified class name so that the context class loader can load it. Also, the type can contain its own unique annotations and types which makes the deserialization and serialization process truly dynamic. Below is an example XML document declaring the class type for the task object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
   &amp;lt;task class=&amp;quot;example.demo.DivideTask&amp;quot;&amp;gt;
      &amp;lt;left&amp;gt;16.5&amp;lt;/left&amp;gt;
      &amp;lt;right&amp;gt;4.1&amp;lt;/right&amp;gt;
   &amp;lt;/task&amp;gt;
&amp;lt;/example&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to execute the task described in the XML document the following code can be used. Here it is assumed the XML source is contained within a file. Once the example object has been deserialized the task can be executed and the result acquired.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Serializer serializer = new Persister();
File example = new File(&amp;quot;example.xml&amp;quot;);
Example example = serializer.read(Example.class, example)

double value = example.execute();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-7-sect-dealing-with-an-inline-list-of-elements:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;7&#34; /&gt;&amp;sect;Dealing with an inline list of elements&lt;/h3&gt;

&lt;p&gt;When dealing with third party XML or with XML that contains a grouping of related elements a common format involves the elements to exist in a sequence with no wrapping parent element. In order to accomodate such structures the element list annotation can be configured to ignore the parent element for the list. For example take the following XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;propertyList&amp;gt;
   &amp;lt;name&amp;gt;example&amp;lt;/name&amp;gt;
   &amp;lt;entry key=&amp;quot;one&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
   &amp;lt;entry key=&amp;quot;two&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;second value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
   &amp;lt;entry key=&amp;quot;three&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;third value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
&amp;lt;/propertyList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above XML document there is a sequence of entry elements, however unlike the previous example these are not enclosed within a parent element. In order to achieve this the inline attribute of the ElementList annotation can be set to true. The following code snippet demonstrates how to use the inline attribute to process the above XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class PropertyList {

   @ElementList(inline=true)
   private List&amp;lt;Entry&amp;gt; list;

   @Element
   private String name;

   public String getName() {
      return name;
   }

   public List getProperties() {
      return list;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a number of conditions for the use of the inline element list. Firstly, each element within the inline list must be placed one after another. They cannot be dispersed in between other elements. Also, each entry type within the list must have the same root name, to clarify take the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package example.demo;

@Root
public class Entry {

    @Attribute
    protected String key;

    @Element
    protected String value;

    public String getKey() {
       return key;
    }
}

public class ValidEntry extends Entry {

   public String getValue() {
      return value;
   }
}

@Root
public class InvalidEntry extends Entry {

   public String getValue() {
      return value;
   }
}

@Root(name=&amp;quot;entry&amp;quot;)
public class FixedEntry extends InvalidEntry {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of the above types extend the same base type, and so all are candidates for use with the PropertyList described earlier. However, although all types could be successfully deserialized and serialized using a list which is not inline, only some can be serialized with an inline list. For instance the type InvalidEntry could not be serialized as it will be serialized with a different name from all the other entrie implementations. The InvalidEntry object has a Root annotation which means that its XML element name will be &amp;ldquo;invalidEntry&amp;rdquo;. In order to be used with the inline list all objects must have the same XML element name of &amp;ldquo;entry&amp;rdquo;. By extending the InvalidEntry type and explicitly specifying the name to be &amp;ldquo;entry&amp;rdquo; the FixedEntry subclass can be used without any issues. For example take the following XML document, which could represent a mixture of entry types.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;propertyList&amp;gt;
   &amp;lt;name&amp;gt;example&amp;lt;/name&amp;gt;
   &amp;lt;entry key=&amp;quot;one&amp;quot; class=&amp;quot;example.demo.ValidEntry&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
   &amp;lt;entry key=&amp;quot;two&amp;quot; class=&amp;quot;example.demo.FixedEntry&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;second value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
   &amp;lt;entry key=&amp;quot;three&amp;quot; class=&amp;quot;example.demo.Entry&amp;quot;&amp;gt;
      &amp;lt;value&amp;gt;third value&amp;lt;/value&amp;gt;
   &amp;lt;/entry&amp;gt;
&amp;lt;/propertyList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of the above entry elements within the inline list contain the same XML element name. Also each type is specified as a subclass implementation of the root Entry object.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-sect-constructor-injection:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;8&#34; /&gt;&amp;sect;Constructor injection&lt;/h3&gt;

&lt;p&gt;All but the simplest of programs will have some form of immutable objects. These are objects that do not have setters and so will acquire data by using constructor injection. In this manner the object sets its internal state from the data provided to the constructor. This can also be achieved with serialization, if you would like to serialize and deserialize objects but do not want to provide setter methods this can be done, as illustrated in the example below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class OrderManager {

    private final List&amp;lt;Order&amp;gt; orders;

    public OrderManager(@ElementList(name=&amp;quot;orders&amp;quot;) List&amp;lt;Order&amp;gt; orders) {
        this.orders = orders;
    }

    @ElementList(name=&amp;quot;orders&amp;quot;)
    public List&amp;lt;Order&amp;gt; getOrders() {
        return orders;
    }
}

@Root
public class Order {

    @Attribute(name=&amp;quot;name&amp;quot;)
    private final String name;

    @Element(name=&amp;quot;product&amp;quot;)
    private final String product;

    public Order(@Attribute(name=&amp;quot;name&amp;quot;) String name,
                 @Element(name=&amp;quot;product&amp;quot;) String product)
    {
        this.product = product;
        this.name = name;
    }

    public String getProduct() {
        return product;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code illustrates an order manager that contains a list of immutable order objects. On deserialization the values are taken from the XML document and injected in to the constructor to instantiate the object. This is a very useful feature that is not often found in serialization frameworks. One restriction on the constructor injection is that it must be used with an annotated get method or field. This is required so that on serialization the persister knows where to get the data to write. Taking the above example if the getOrders method was not annotated then there would be no way to determine how to write the order manager object. Below is some example XML resulting from serialization of the order manager.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;orderManager&amp;gt;
    &amp;lt;order name=&amp;quot;AX101&amp;quot;&amp;gt;
        &amp;lt;product&amp;gt;Product A&amp;lt;/product&amp;gt;
    &amp;lt;/order&amp;gt;
    &amp;lt;order name=&amp;quot;AX102&amp;quot;&amp;gt;
        &amp;lt;product&amp;gt;Product B&amp;lt;/product&amp;gt;
    &amp;lt;/order&amp;gt;
    &amp;lt;order name=&amp;quot;AX103&amp;quot;&amp;gt;
        &amp;lt;product&amp;gt;Product C&amp;lt;/product&amp;gt;
    &amp;lt;/order&amp;gt;
&amp;lt;/orderManager&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-9-sect-reading-an-array-of-elements:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;9&#34; /&gt;&amp;sect;Reading an array of elements&lt;/h3&gt;

&lt;p&gt;As well as being able to deserialize elements in to a collection arrays can also be serialized and deserialized. However, unlike the @ElementList annotation the ElementArray annotation can also deserialize primitive values such as int arrays, char arrays, and so on. Below is an example object with an array of integer values and a parallel array of string values.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class AddressBook {

   @ElementArray
   private Address[] addresses;   

   @ElementArray
   private String[] names;        

   @ElementArray
   private int[] ages;   

   public Address[] getAddresses() {
      return addresses;           
   }

   public String[] getNames() {
      return names;           
   }

   public int[] getAges() {
      return ages;           
   }
}

@Root
public class Address {

   @Element(required=false)
   private String house;        

   @Element
   private String street;  

   @Element
   private String city;

   public String getHouse() {
      return house;           
   }

   public String getStreet() {
      return street;           
   }

   public String getCity() {
      return city;           
   }     
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above object both primitive arrays require an entry attribute, this is because primitives can not be annotated with the Root annotation. The entry attribute tells the persister than an extra XML element is required to wrap the entry. This entry element can also be applied to serializable objects that have the Root annotation, however it is typically only used for primitive arrays. The following XML is an example of what is produced by the above objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;addressBook&amp;gt;
   &amp;lt;addresses length=&amp;quot;3&amp;quot;&amp;gt;
      &amp;lt;address&amp;gt;
         &amp;lt;house&amp;gt;House 33&amp;lt;/house&amp;gt;
         &amp;lt;street&amp;gt;Sesame Street&amp;lt;/street&amp;gt;
         &amp;lt;city&amp;gt;City&amp;lt;/city&amp;gt;
      &amp;lt;/address&amp;gt;
      &amp;lt;address&amp;gt;
         &amp;lt;street&amp;gt;Some Street&amp;lt;/street&amp;gt;
         &amp;lt;city&amp;gt;The City&amp;lt;/city&amp;gt;
      &amp;lt;/address&amp;gt;
      &amp;lt;address&amp;gt;
         &amp;lt;house&amp;gt;Another House&amp;lt;/house&amp;gt;
         &amp;lt;street&amp;gt;My Street&amp;lt;/street&amp;gt;
         &amp;lt;city&amp;gt;Same City&amp;lt;/city&amp;gt;
      &amp;lt;/address&amp;gt;
   &amp;lt;/addresses&amp;gt;
   &amp;lt;names length=&amp;quot;3&amp;quot;&amp;gt;
      &amp;lt;string&amp;gt;Jonny Walker&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Jack Daniels&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Jim Beam&amp;lt;/string&amp;gt;
   &amp;lt;/names&amp;gt;
   &amp;lt;ages length=&amp;quot;3&amp;quot;&amp;gt;
      &amp;lt;int&amp;gt;30&amp;lt;/int&amp;gt;
      &amp;lt;int&amp;gt;42&amp;lt;/int&amp;gt;
      &amp;lt;int&amp;gt;31&amp;lt;/int&amp;gt;
   &amp;lt;/ages&amp;gt;
&amp;lt;/addressBook&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the above XML it can be seen that each entity within an array index is named the same as its type. So a string is wrapped in a &amp;lsquo;string&amp;rsquo; element and an int is wrapped in an &amp;lsquo;int&amp;rsquo; element. This is done because the default name for the ElementArray annotation is its type name, unless the Root annotation is used with a name. This can be overridden by providing an explicit entry name for the array. For example take the simple object below which contains an array of names as string objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class NameList {

   @ElementArray(entry=&amp;quot;name&amp;quot;)
   private String[] names;        

   public String[] getNames() {
      return names;           
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above XML the following document is a valid representation. Notice how each of the names within the XML document is wrapped in a &amp;lsquo;name&amp;rsquo; element. This element name is taken from the annotation provided.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;nameList&amp;gt;
   &amp;lt;names length=&amp;quot;3&amp;quot;&amp;gt;
      &amp;lt;name&amp;gt;Jonny Walker&amp;lt;/name&amp;gt;
      &amp;lt;name&amp;gt;Jack Daniels&amp;lt;/name&amp;gt;
      &amp;lt;name&amp;gt;Jim Beam&amp;lt;/name&amp;gt;
   &amp;lt;/names&amp;gt;
&amp;lt;/nameList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-10-sect-adding-text-and-attributes-to-elements:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;10&#34; /&gt;&amp;sect;Adding text and attributes to elements&lt;/h3&gt;

&lt;p&gt;As can be seen from the previous example annotating a primitive such as a String with the Element annotation will result in text been added to a names XML element. However it is also possible to add text to an element that contains attributes. An example of such a class schema is shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Entry {

   @Attribute
   private String name;

   @Attribute
   private int version;     

   @Text
   private String value;

   public int getVersion() {
      return version;           
   }

   public String getName() {
      return name;
   }

   public String getValue() {
      return value;              
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the class is annotated in such a way that an element contains two attributes named version and name. It also contains a text annotation which specifies text to add to the generated element. Below is an example XML document that can be generated using the specified class schema.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;entry version=&#39;1&#39; name=&#39;name&#39;&amp;gt;
   Some example text within an element
&amp;lt;/entry&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rules that govern the use of the Text annotation are that there can only be one per schema class. Also, this annotation cannot be used with the Element annotation. Only the Attribute annotation can be used with it as this annotation does not add any content within the owning element.&lt;/p&gt;

&lt;h3 id=&#34;a-name-11-sect-dealing-with-map-objects:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;11&#34; /&gt;&amp;sect;Dealing with map objects&lt;/h3&gt;

&lt;p&gt;Although it is possible to deal with most repetitive XML elements within documents using element lists it is often more convenient to use a Map object. In order to deal with maps the ElementMap annotation can be used. The element map annotation can be used with both primitive and composite objects. For example take the following XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
   &amp;lt;property key=&amp;quot;one&amp;quot;&amp;gt;first value&amp;lt;/property&amp;gt;
   &amp;lt;property key=&amp;quot;two&amp;quot;&amp;gt;second value&amp;lt;/property&amp;gt;
   &amp;lt;property key=&amp;quot;three&amp;quot;&amp;gt;third value&amp;lt;/property&amp;gt;
   &amp;lt;name&amp;gt;example name&amp;lt;/name&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above XML document the sequence of properties elements can be used to describe a map of strings, where the key attribute acts as the key for the value within the property element. The following code snipped demonstrates how to use the ElementMap annotation to process the above XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root(name=&amp;quot;properties&amp;quot;)
public class PropertyMap {

   @ElementMap(entry=&amp;quot;property&amp;quot;, key=&amp;quot;key&amp;quot;, attribute=true, inline=true)
   private Map&amp;lt;String, String&amp;gt; map;

   @Element
   private String name;  

   public String getName() {
      return name;
   }

   public Map&amp;lt;String, Entry&amp;gt; getMap() {
      return map;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-12-sect-scattering-inline-element-entries:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;12&#34; /&gt;&amp;sect;Scattering inline element entries&lt;/h3&gt;

&lt;p&gt;Elements that are scattered throughout an XML document can be collected by inline lists and inline maps. Simply provide an entry name for the XML element name the list or map is to collect and they will be extracted and placed in to the collection object. For example take the following XML element. It contains include and exclude XML elements which are in no specific order. Even though they are not in any order the deserialization process is able to gather the XML elements as thet are encountered.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;fileSet path=&amp;quot;/user/niall&amp;quot;&amp;gt;
   &amp;lt;include pattern=&amp;quot;.*.jar&amp;quot;/&amp;gt;
   &amp;lt;exclude pattern=&amp;quot;.*.bak&amp;quot;/&amp;gt;
   &amp;lt;exclude pattern=&amp;quot;~.*&amp;quot;/&amp;gt;
   &amp;lt;include pattern=&amp;quot;.*.class&amp;quot;/&amp;gt;
   &amp;lt;exclude pattern=&amp;quot;images/.*&amp;quot;/&amp;gt;
&amp;lt;/fileSet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to achieve this the following object can be used. This declares two inline collections which specify the name of the entry objects that they are collecting. If the entry attribute is not specified then the name of the object will be used instead.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class FileSet {

   @ElementList(entry=&amp;quot;include&amp;quot;, inline=true)
   private List&amp;lt;Match&amp;gt; include;

   @ElementList(entry=&amp;quot;exclude&amp;quot;, inline=true)
   private List&amp;lt;Match&amp;gt; exclude;

   @Attribute
   private File path;

   private List&amp;lt;File&amp;gt; files;

   public FileSet() {
      this.files = new ArrayList&amp;lt;File&amp;gt;();
   }

   @Commit
   public void commit() {
      scan(path);
   }

   private void scan(File path) {
      File[] list = path.listFiles();

      for(File file : list) {
         if(file.isDirectory()) {
            scan(path);
         } else {            
            if(matches(file)) {
               files.add(file);
            }
         }
      }
   }

   private boolean matches(File file) {
      for(Match match : exclude) {
         if(match.matches(file)) {
            return false;
         }
      }
      for(Match match : include) {
         if(match.matches(file)) {
            return true;
         }
      }
      return false;
   }

   public List&amp;lt;File&amp;gt; getFiles() {
      return files;
   }

   @Root
   private static class Match {

      @Attribute            
      private String pattern;            

      public boolean matches(File file) {
         Stirng path = file.getPath();

         if(!file.isFile()) {
            return false;
         }
         return path.matches(pattern);         
      }         
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-13-sect-loose-object-mapping:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;13&#34; /&gt;&amp;sect;Loose object mapping&lt;/h3&gt;

&lt;p&gt;An important feature for any XML tool is the ability to sift through the source XML to find particular XML attributes an elements of interest. It would not be very convinient if you had to write an object that accurately mapped every attribute an element in an XML document if all you are interested in is perhaps an element and several attributes. Take the following XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;contact id=&amp;quot;71&amp;quot; version=&amp;quot;1.0&amp;quot;&amp;gt;
   &amp;lt;name&amp;gt;
      &amp;lt;first&amp;gt;Niall&amp;lt;/first&amp;gt;
      &amp;lt;surname&amp;gt;Gallagher&amp;lt;/surname&amp;gt;
   &amp;lt;/name&amp;gt;
   &amp;lt;address&amp;gt;
      &amp;lt;house&amp;gt;House 33&amp;lt;/house&amp;gt;
      &amp;lt;street&amp;gt;Sesame Street&amp;lt;/street&amp;gt;
      &amp;lt;city&amp;gt;City&amp;lt;/city&amp;gt;
   &amp;lt;/address&amp;gt;
   &amp;lt;phone&amp;gt;
      &amp;lt;mobile&amp;gt;123456789&amp;lt;/mobile&amp;gt;
      &amp;lt;home&amp;gt;987654321&amp;lt;/home&amp;gt;
   &amp;lt;/phone&amp;gt;
&amp;lt;/contact&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If my object only required the some of the details of the specified contact, for example the phone contacts and the name then it needs to be able to ignore the address details safely. The following code shows how this can be done by setting strict to false within the Root annotation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root(strict=false)
public class Contact {

   @Element
   private Name name;

   @Element
   private Phone phone;

   public String getName() {
      return name.first;
   }

   public String getSurname() {
      return name.surname;
   }

   public String getMobilePhone() {
      return phone.mobile;
   }

   public String getHomePhone() {
      return phone.home;
   }

   @Root
   private static class Name {

      @Element
      private String first;

      @Element
      private String surname;
   }

   @Root
   private static class Phone {

      @Element(required=false)
      private String mobile;

      @Element
      private String home;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above object can be used to parse the contact XML source. This simple ignores any XML elements or attributes that do not appear in the class schema. To further clarify the implementation of loose mappings take the example shown below. This shows how the entry object is deserialized from the above document, which is contained within a file. Once deserialized the object values can be examined.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Serializer serializer = new Persister();
File source = new File(&amp;quot;contact.xml&amp;quot;);
Contact contact = serializer.read(Contact.class, source);

assert contact.getName().equals(&amp;quot;Niall&amp;quot;);
assert contact.getSurname().equals(&amp;quot;Gallagher&amp;quot;);
assert contact.getMobilePhone().equals(&amp;quot;123456789&amp;quot;);
assert contact.getHomePhone().equals(&amp;quot;987654321&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Should there be more than a single object that requires loose mapping then using the Root annotation might not be the ideal solution. In such a scenario the persister itself can be asked to perform loose mapping. Simply pass a boolean to the read method indicating the type of mapping required. By default the persister uses strict mapping, which can be overridden on an object by object basis using the Root annotation, as shown in the above example. However, this default can be overridden as can be seen in the code snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Contact contact = serializer.read(Contact.class, source, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the boolean passed to the overridden read method tells the serializer to perform a loose mapping. There is no need to specify anything in the annotations, the serializer will simply map every object loosely. This can be a much more convenient way to perform loose mapping, as you only need to annotate your objects with the elements or attributes you are interested in, all other elements and attributes will be ignored during deserialization. Such a solution is best suited to external XML documents where your annotated objects do not define the schema.&lt;/p&gt;

&lt;h3 id=&#34;a-name-14-sect-java-bean-serialization:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;14&#34; /&gt;&amp;sect;Java Bean serialization&lt;/h3&gt;

&lt;p&gt;Although field based serialization offers a simple and efficient means for serializing and deserializing an object it can often be benificial to use Java Bean getters and setters to read and write values. In particular annotating Java Bean setter and getter methods will allow for a cleaner means to override the serialization behaviour than using fields. It also allows for processing and validation to be performed as the object is being deserialized. Below is an example of how to annotate an objects methods for use in the serialization process, this example mixes annotated fields with annotated methods.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Message {

   private Collection&amp;lt;Entry&amp;gt; list;

   @Attribute
   private float version;        

   @ElementList
   public void setList(Collection&amp;lt;Entry&amp;gt; entry) {
      if(entry.isEmpty()) {
         throw new IllegalArgumentException(&amp;quot;Empty collection&amp;quot;);              
      }
      this.entry = entry;           
   }        

   @ElementList
   public Collection&amp;lt;Entry&amp;gt; getList() {
      return entry;           
   }
}

@Root
public class Entry {

   @Attribute
   public String name;    

   public String text;   

   @Text
   public String getText() {
      return text;           
   }

   @Text
   public void setText(String text){
      this.text = text;           
   }

   public String getName() {
      return name;           
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above code the message class will have its methods invoked when a list of entry objects is encountered. Here the method can perform some form of validation when the list of entry objects is deserialized. Such validation can also be peformed using the persister callback methods, which is described in a later section. The requirements for Java Bean method serialization are that both the setter and getter must be annotated with the same annotation, and both annotations must contain identical attributes. The object class schema could produce the following XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;message version=&amp;quot;1.2&amp;quot;&amp;gt;
   &amp;lt;list&amp;gt;
      &amp;lt;entry name=&amp;quot;a&amp;quot;&amp;gt;Example text one&amp;lt;/entry&amp;gt;
      &amp;lt;entry name=&amp;quot;b&amp;quot;&amp;gt;Example text two&amp;lt;/entry&amp;gt;
   &amp;lt;/list&amp;gt;
&amp;lt;/message&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-15-sect-default-object-serialization:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;15&#34; /&gt;&amp;sect;Default object serialization&lt;/h3&gt;

&lt;p&gt;If an object grows large it often becomes tedious to annotate each field or method that needs to be serialized. In such scenarios the Default annotation can be used. This will apply default annotations to either the fields or methods of an object that is to be serialized. To specify whether it is the fields or methods that will have default annotations, the DefaultType enumeration can be used. Take the code snippet below, this shows two objects with default annotations, one that will apply defaults to the object fields, and one that will apply defaults to the Java Bean methods of the object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Default(DefaultType.FIELD)
public class OrderItem {

   private Customer customer;

   private String name;

   @Attribute
   private double price;

   @Transient
   private String category;

   public String getName() {
      return name;
   }   

   public Customer getCustomer() {
      return customer;
   }
}

@Root
@Default(DefaultType.PROPERTY)
private class Customer {

   private String name;

   private String address;

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above object the Transient annotation is used to specify that even though default annotations should be applied to the objects fields, the field annotated as transient should not be serialized. Below is the XML that could be produced using the above classes, notice that if defaults apply to Java Bean methods, the fields will not be defaulted, instead they will be ignored.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;orderItem price=&amp;quot;10.99&amp;quot;&amp;gt;
    &amp;lt;customer&amp;gt;
        &amp;lt;name&amp;gt;Elvis Presley&amp;lt;/name&amp;gt;
    &amp;lt;/customer&amp;gt;
    &amp;lt;name&amp;gt;IRT452&amp;lt;/name&amp;gt;
&amp;lt;/orderItem&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the above XML it is obvious, that defaults apply to only those fields or methods requested. If a field or method already has an annotation, that is the annotation that is used. If a field or method is to be omitted from serialization then it can be marked as transient. Applying defaults to an object, can often lead to a cleaner object structure, and makes it much easier to make objects serializable.&lt;/p&gt;

&lt;h3 id=&#34;a-name-16-sect-example-using-template-filters:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;16&#34; /&gt;&amp;sect;Example using template filters&lt;/h3&gt;

&lt;p&gt;Another very powerful feature with this XML serialization framework is the ability to use templating when deserializing an XML document. This allows values within elements and attributes to use template variables that can be replaced using a Filter object. The simplest filter object is the map filter, which allows the user to place a Java map within the filter object exposing the key value pairs to the templating system. The template system can now use the filter to find replacement values for template variables within the XML document. To clarify take the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Layout {

   @Element
   private String path;

   @Element
   private String user;

   @Attribute
   private int id;

   public String getPath() {
      return path;
   }

   public String getUser() {
      return user;
   }

   public int getId() {
      return id;
   }
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above object has declared two elements and an attribute to be deserialized from an XML document. These values are typically static values within the XML source. However using a template variable syntax the deserialization process will attempt to substitute the keys with values from the filter. Take the XML document below with two template variables declared ${home.path} and ${user.name}.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;layout id=&amp;quot;123&amp;quot;&amp;gt;
   &amp;lt;path&amp;gt;${home.path}&amp;lt;/path&amp;gt;
   &amp;lt;user&amp;gt;${user.name}&amp;lt;/user&amp;gt;
&amp;lt;/layout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To ensure that these values can be replaced with user specified mappings a map filter can be used. Below is an example of how to create a persister that can be given user specified key value pairs. Here the above XML source is deserialized from a file and the annotated fields are given filter mappings if there is a mapping specified.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Map map = new HashMap();

map.put(&amp;quot;home.path&amp;quot;, &amp;quot;/home/john.doe&amp;quot;);
map.put(&amp;quot;user.name&amp;quot;, &amp;quot;john.doe&amp;quot;);

Filter filter = new MapFilter(map);
Serializer serializer = new Persister(filter);
File source = new File(&amp;quot;layout.xml&amp;quot;);
Layout layout = serializer.read(Layout.class, source);

assert layout.getPath().equals(&amp;quot;/home/john.doe&amp;quot;);
assert layout.getUser().equals(&amp;quot;john.doe&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As well as the map filter there are several stock filters which can be used to substitute template variables with OS environment variables and JVM system properties. Also several template variables can exist within the values. For example take the following XML document, which could be used in the above example given that the mappings for ${first.name} and ${second.name} were added to the map filter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;layout id=&amp;quot;123&amp;quot;&amp;gt;
   &amp;lt;path&amp;gt;/home/${first.name}.${second.name}&amp;lt;/path&amp;gt;
   &amp;lt;user&amp;gt;${first.name}.${second.name}&amp;lt;/user&amp;gt;
&amp;lt;/layout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-17-sect-receiving-persister-callbacks:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;17&#34; /&gt;&amp;sect;Receiving persister callbacks&lt;/h3&gt;

&lt;p&gt;Of critical importance to the serialization and deserialization process is that the objects have some control or participation in the process. It is no good to have the persister deserialize the object tree from an XML document only to see that the data is not valid or that further data structures need to be created in many of the deserialized objects. To allow objects to participate in the deserialization process two annotations can be used, these are the Validate and Commit annotations.&lt;/p&gt;

&lt;p&gt;Both are involved in the deserialization process (not the serialization process) and are called immediately after an object has been deserialized. Validation is performed first, and if the deserialized object contains a method annotated with the validate annotation it is invoked. This allows the object to perform validation of its fields, if the object requirements are met the method returns quietly, if they are not met the object can throw an exception to terminate the deserialization process. The commit method is invoked in much the same way, the persister looks for a method marked with the commit annotation, if one exists it is invoked. However, unlike the validate method the commit method is typically used to build further data structures, for example hash tables or trees. Below is an example of an object making use of these annotations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class PropertyMap {

   private Map&amp;lt;String, Property&amp;gt; map;

   @ElementList
   private List&amp;lt;Property&amp;gt; list;

   public PropertyMap() {
      this.map = new HashMap&amp;lt;String, Entry&amp;gt;();
   }

   @Validate
   public void validate() {
      List&amp;lt;String&amp;gt; keys = new ArrayList&amp;lt;String&amp;gt;();

      for(Property entry : list) {
         String key = entry.getKey();

         if(keys.contains(key)) {
            throw new PersistenceException(&amp;quot;Duplicate key %s&amp;quot;, key);
         }
         keys.put(key);         
      }      
   }

   @Commit
   public void build() {
      for(Property entry : list) {
         insert(entry);
      }     
   }

   public void insert(Property entry) {
      map.put(entry.getName(), entry);      
   }  

   public String getProperty(String name) {
      return map.get(name).getValue();
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above object deserializes a list of property objects into a list. Once the property objects have been deserialized they are validated by checking that an entry with a specific key exists only once. After the validation process has completed the commit method is invoked by the persister, here the object uses the deserialized property object to build a hash table containing the property values keyed via the property key. Below is how the above object would be represented as an XML document.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
   &amp;lt;list&amp;gt;
      &amp;lt;entry key=&amp;quot;one&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
      &amp;lt;entry key=&amp;quot;two&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
      &amp;lt;entry key=&amp;quot;three&amp;quot;&amp;gt;
         &amp;lt;value&amp;gt;first value&amp;lt;/value&amp;gt;
      &amp;lt;/entry&amp;gt;
   &amp;lt;/list&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As well as annotations involved in the deserialization process there are annotations that can be used to receive persister callbacks for the serialization process. Two annotations can be used, they are the Persist and Complete methods. To receive persister callbacks the methods must be no argument methods marked with the appropriate annotations.
The persist method is invoked before the serialization of the object. This allows the object to prepare in some implementation specific way for the serialization process. This method may throw an exception to terminate the serialization process. Once serialization has completed the complete method is invoked. This allows the object to revert to its previous state, that is, to undo what the persist method has done. Below is an example of how these annotations can be used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class MailMessage {

   @Attribute
   private Stirng format;

   @Element
   private String encoded;

   private byte[] content;

   private Encoder encoder;

   public MailMessage() {
      this.encoder = new Encoder();
   }

   public void setEncoding(String format) {
      this.format = format;
   }

   public String getEncoding() {
      return format;
   }

   public void setMessage(byte[] content) {
      this.content = content;
   }

   public byte[] getMessage() {
      return content;
   }

   @Commit
   public void commit() {
      decoded = encoder.decode(encoded, format);
      encoded = null;
   }

   @Persist
   public void prepare() {
      encoded = encoder.encode(decoded, format);      
   }

   @Complete
   public void release() {
      encoded = null;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example illustrates how the persist and complete methods can be used in a scenario where the serialization process needs to encode a byte array into a specific encoding format. Before the object is persisted the persistable field is set to an encoded string. When serialization has completed the encoded value is nulled to free the memory it holds. This example is somewhat contrived however it effectively demonstrates how the annotations can be used. Below is an example of what the XML document should look like.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;mailMessage format=&amp;quot;base64&amp;quot;&amp;gt;
    U2ltcGxlIGlzIGFuIFhNTCBzZXJpYWxpemF0aW9uIGZyYW1ld29yayBmb3IgSmF2YS4gSXRzIGdv
    YWwgaXMgdG8gcHJvdmlkZSBhbiBYTUwgZnJhbWV3b3JrIHRoYXQgZW5hYmxlcyByYXBpZCBkZXZl
    bG9wbWVudCBvZiBYTUwgY29uZmlndXJhdGlvbiBhbmQgY29tbXVuaWNhdGlvbiBzeXN0ZW1zLiBU
    aGlzIGZyYW1ld29yayBhaWRzIHRoZSBkZXZlbG9wbWVudCBvZiBYTUwgc3lzdGVtcyB3aXRoIG1p
    bmltYWwgZWZmb3J0IGFuZCByZWR1Y2VkIGVycm9ycy4gVGhlIGZyYW1ld29yayBib3Jyb3dzIGlk
    ZWFzIGFuZCBjb25jZXB0cyBmcm9tIGV4aXN0aW5nIFhNTCB0b29scyBzdWNoIGFzIEMjIFhNTCBz
    ZXJpYWxpemF0aW9uIGFuZCBvdGhlciBwcm9wcmlldGFyeSBmcmFtZXdvcmtzIGFuZCBjb21iaW5l
    cyB0aG9zZSBpZGVhcyByZXN1bHRpbmcgaW4gYSBzaW1wbGUgeWV0IGV4dHJlbWVseSBwb3dlcmZ1
    bCB0b29sIGZvciB1c2luZyBhbmQgbWFuaXB1bGF0aW5nIFhNTC4gQmVsb3cgaXMgYSBsaXN0IG9m
    IHNvbWUgb2YgdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgZnJhbWV3b3JrLiA=    
&amp;lt;/mailMessage&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above XML message the contents can be serialized and deserialized safely using persister callbacks. The object can prepare itself before serialization by encoding the contents of the message to the encoding format specified. Once it has been encoded and serialized any resources created for serialization can be released.&lt;/p&gt;

&lt;h3 id=&#34;a-name-18-sect-maintaining-state-between-persister-callbacks:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;18&#34; /&gt;&amp;sect;Maintaining state between persister callbacks&lt;/h3&gt;

&lt;p&gt;When serializing and deserializing objects there is often a need to share information between callbacks without affecting the object implementation. In order to achieve this the persister can provide a session map to the methods annotated for persister callbacks. Below is an example of a serializable object that can receive a persister session object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Person {

   @ElementList
   private List&amp;lt;Variable&amp;gt; details;

   @Element
   private Address address;

   private List names;

   @Validate
   public void validate(Map session) throws PersistenceException {
      if(session.isEmpty()) {
         throw new PersistenceException(&amp;quot;Map must not be empty&amp;quot;)
      }
   }

   @Commit
   public void commit(Map session) {
      Set keys = session.keySet();

      for(Object item : keys) {
         names.add(item);
      }
   }
}

@Address
public class Address {

   @Element
   private String street;

   @Element
   private String city;

   @Element
   private String state;

   public String getStreet() {
      return street;
   }

   public String getCity() {
      return city;
   }

   public String getState() {
      return state;
   }
}

@Root
public class Variable {

   @Attribute
   private String name;

   @Attribute
   private String value;

   @Commit
   public void commit(Map session) {
      session.put(name, value);
   }

   public String getName() {
      return name;
   }

   public String getValue() {
      return value;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example shows how entry objects can pass there names to its parent during the deserialization process. To clarify, deserialization is performed in a depth first manner so for this example the entry objects will be initialized and have their callback methods invoked before the root example class.
Although this may not seem like a very powerful feature, it offers great capabilities when paired with the templating system described earlier. The templating engine has access to all details placed into the session map object. So other values within the XML document can reference each other. For example take the XML document below for the above objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;person&amp;gt;
   &amp;lt;details&amp;gt;
      &amp;lt;var name=&amp;quot;name&amp;quot; value=&amp;quot;John Doe&amp;quot;/&amp;gt;
      &amp;lt;var name=&amp;quot;street&amp;quot; value=&amp;quot;Sesame Street&amp;quot;/&amp;gt;
      &amp;lt;var name=&amp;quot;city&amp;quot; value=&amp;quot;Metropolis&amp;quot;/&amp;gt;
      &amp;lt;var name=&amp;quot;state&amp;quot; value=&amp;quot;Some State&amp;quot;/&amp;gt;
   &amp;lt;/details&amp;gt;
   &amp;lt;address&amp;gt;
      &amp;lt;street&amp;gt;${street}&amp;lt;/street&amp;gt;
      &amp;lt;city&amp;gt;${city}&amp;lt;/city&amp;gt;
      &amp;lt;state&amp;gt;${state}&amp;lt;/state&amp;gt;
   &amp;lt;/address&amp;gt;   
&amp;lt;/person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above XML document illustrates how the variable objects values are accessible to the elements declared in the address element. The street, city, and state needed to be defined only once to be shared throughout the document&lt;/p&gt;

&lt;h3 id=&#34;a-name-19-sect-serializing-with-cdata-blocks:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;19&#34; /&gt;&amp;sect;Serializing with CDATA blocks&lt;/h3&gt;

&lt;p&gt;At times it is nessecary to serialize large text and element data values. Such values may also contain formatting that you wish to preserve. In such situations it is often best to wrap the values within XML CDATA blocks. The CDATA block can contain XML characters and formatting information which will not be modified by other XML parsers. For example take the following XML source.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;query type=&amp;quot;scrape&amp;quot; name=&amp;quot;title&amp;quot;&amp;gt;
   &amp;lt;data&amp;gt;&amp;lt;![CDATA[

         &amp;lt;news&amp;gt;
         {
            for $text in .//B
            return $text
         }
         &amp;lt;/news&amp;gt;

    ]]&amp;gt;&amp;lt;/data&amp;gt;
&amp;lt;/query&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above XML there is an embedded XQuery expression which is encapsulated within a CDATA block. Such a configuration allows the XQuery expression to exist within the XML document without any need to escape the XML characters. Also, if the XQuery expression was very large then this form of encoding would provide better performance. In order to ensure that the data is maintained within the CDATA block the following could be used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Query {

   @Attribute
   private String scrape;

   @Attribute
   private String title;

   @Element(data=true)
   private String data;  

   public String getData() {
      return data;
   }

   public String getTitle() {
      return title;
   }

   public String getScrape() {
      return scrape;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the Element annotation has the data attribute set to true. This tells the serialization process that any value stored within the data field must be written to the resulting XML document within a CDATA block. The data attribute can be used with the Text, ElementArray, and ElementList annotations also.&lt;/p&gt;

&lt;h3 id=&#34;a-name-20-sect-using-xml-namespaces:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;20&#34; /&gt;&amp;sect;Using XML namespaces&lt;/h3&gt;

&lt;p&gt;Namespaces are used to qualify an element or an attribute in an XML document. In order to use namespaces the Namespace annotation can be used. This allows the declaration of the namespace prefix and reference, often called the namespace URI. Namespace annotations can be used on fields, methods, and even classes. For example take the XML snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;parent xmlns=&amp;quot;http://domain/parent&amp;quot;&amp;gt;
   &amp;lt;pre:child xmlns:pre=&amp;quot;http://domain/child&amp;quot;&amp;gt;
      &amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;
      &amp;lt;address xmlns=&amp;quot;&amp;quot;&amp;gt;
          &amp;lt;street&amp;gt;Sin City&amp;lt;/street&amp;gt;
      &amp;lt;/address&amp;gt;
   &amp;lt;/pre:child&amp;gt;
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above XML document, the root element is qualified with a default namespace. A default namespace is a namespace that is inherited by all child elements, for further details see Section 6.2 of the namespaces in XML 1.0 specification. In order to annotate a field, method, or class with a default namespace the Namespace annotation can be declared using only the reference attribute. For example, see the annotated class below that produces the above XML.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Namespace(reference=&amp;quot;http://domain/parent&amp;quot;)
public class Parent {

   @Element
   @Namespace(reference=&amp;quot;http://domain/child&amp;quot;, prefix=&amp;quot;pre&amp;quot;)
   private Child child;

   public Child getChild() {
      return child;
   }
}

@Root
public class Child {

   @Element
   private String name;

   @Element
   @Namespace
   private Address address;

   public Address getAddress() {
      return address;
   }
}

@Root
public class Address {

   @Element
   private String street;

   public String getStreet() {
      return street;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code snippet also shows an annotation with both the namespace reference and prefix attributes declared. Such an annotation declaration will result in a namespace qualified with a prefix. As can be seen in the XML example a prefixed namespace qualifies the XML element with a string prefix followed by a colon.&lt;/p&gt;

&lt;p&gt;Should your document require more than one namespace declared in a single element the NamespaceList annotation can be used. This allows multiple namespaces to be declared in a single element. Declaring multiple namespaces in a single element can produce a cleaner more readable XML document. Take the XML snippet below from the namespaces in XML 1.0 specification, which shows an element with multiple namespaces.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;book xmlns=&amp;quot;urn:loc.gov:books&amp;quot; xmlns:isbn=&amp;quot;urn:ISBN:0-395-36341-6&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Cheaper by the Dozen&amp;lt;/title&amp;gt;
    &amp;lt;isbn:number&amp;gt;1568491379&amp;lt;/isbn:number&amp;gt;
&amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This XML snippet shows two namespaces declared in the root element. Here the root element will be qualified with the default namespace, and child elements can if desired be qualified by the prefixed namespace. To illustrate how such namespace declarations can be done, see the annotated class below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@NamespaceList({
@Namespace(reference=&amp;quot;urn:loc.gov:books&amp;quot;)
@Namespace(reference=&amp;quot;urn:ISBN:0-395-36341-6&amp;quot;, prefix=&amp;quot;isbn&amp;quot;)
})
public class Book {

   @Element
   @Namespace(reference=&amp;quot;urn:ISBN:0-395-36341-6&amp;quot;)
   private String number;

   @Element
   private String title;

   public String getTitle() {
      return title;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen above, there is no need to redeclare the prefix attribute once it has already been declared. This allows the annotation declarations to be less verbose and ensures a consistent use of a prefix for a given namespace reference. Also, once a namespace has been declared and is in scope then it will not be declared a second time in the resulting XML, this ensures the resulting XML document does not contain redundant namespace declarations.&lt;/p&gt;

&lt;h3 id=&#34;a-name-21-sect-resolving-object-reference-cycles:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;21&#34; /&gt;&amp;sect;Resolving object reference cycles&lt;/h3&gt;

&lt;p&gt;When there are cycles in your object graph this can lead to recursive serialization. However it is possible to resolve these references using a stock strategy. The CycleStrategy maintains the object graph during serialization and deserialization such that cyclical references can be traced and resolved. For example take the following object relationships.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Parent {

   private Collection&amp;lt;Child&amp;gt; children;

   private String name;

   @Attribute
   public String getName() {
      return name;                   
   }

   @Attribute
   public void setName(String name) {
      this.name = name;           
   }

   @Element
   public void setChildren(Collection&amp;lt;Child&amp;gt; children) {
      this.children = children;           
   }

   @Element   
   public Collection&amp;lt;Child&amp;gt; getChildren() {
      return children;           
   }        

   public void addChild(Child child) {
      children.add(child);           
   }
}

@Root
public class Child {

   private Parent parent;

   private String name;

   public Child() {
      super();           
   }

   public Child(Parent parent) {
      this.parent = parent;           
   }

   @Attribute
   public String getName() {
      return name;           
   }

   @Attribute
   public void setName(String name) {
      this.name = name;           
   }

   @Element
   public Parent getParent() {
      return parent;
   }

   @Element
   public void setParent(Parent parent) {
      this.parent = parent;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above code snippet the cyclic relation ship between the parent and child can be seen. A parent can have multiple children and a child can have a reference to its parent. This can cause problems for some XML binding and serialization frameworks. However this form of object relationship can be handled seamlessly using the CycleStrategy object. Below is an example of what a resulting XML document might look like.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;parent name=&amp;quot;john&amp;quot; id=&amp;quot;1&amp;quot;&amp;gt;
   &amp;lt;children&amp;gt;
      &amp;lt;child id=&amp;quot;2&amp;quot; name=&amp;quot;tom&amp;quot;&amp;gt;
         &amp;lt;parent ref=&amp;quot;1&amp;quot;/&amp;gt;
      &amp;lt;/child&amp;gt;
      &amp;lt;child id=&amp;quot;3&amp;quot; name=&amp;quot;dick&amp;quot;&amp;gt;
         &amp;lt;parent ref=&amp;quot;1&amp;quot;/&amp;gt;
      &amp;lt;/child&amp;gt;
      &amp;lt;child id=&amp;quot;4&amp;quot; name=&amp;quot;harry&amp;quot;&amp;gt;
         &amp;lt;parent ref=&amp;quot;1&amp;quot;/&amp;gt;
      &amp;lt;/child&amp;gt;
   &amp;lt;/children&amp;gt;
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen there are two extra attributes present, the id attribute and the ref attribute. These references are inserted into the serialized XML document when the object is persisted. They allow object relationships and references to be recreated during deserialization. To further clarify take the following code snippet which shows how to create a persister that can handle such references.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Strategy strategy = new CycleStrategy(&amp;quot;id&amp;quot;, &amp;quot;ref&amp;quot;);
Serializer serializer = new Persister(strategy);
File source = new File(&amp;quot;example.xml&amp;quot;);
Parent parent = serializer.read(Parent.class, source);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The strategy is created by specifying the identity attribute as id and the refering attribute as ref. For convinience these attributes have reasonable defaults and the no argument constructor can be used to create the strategy. Although the example shown here is very simple the cycle strategy is capable of serializing and deserializing large and complex relationships.&lt;/p&gt;

&lt;h3 id=&#34;a-name-22-sect-reusing-xml-elements:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;22&#34; /&gt;&amp;sect;Reusing XML elements&lt;/h3&gt;

&lt;p&gt;As can be seen from using the CycleStrategy in the previous section object references can easily be maintained regardless of complexity. Another benifit of using the cycle strategy is that you can conviniently reuse elements when creating configuration. For example take the following example of a task framework.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Workspace {

   @Attribute
   private File path;

   @Attribute
   private String name

   private File getPath() {
      return path;           
   }

   private String getName() {
      return name;           
   }
}

@Root
public abstract Task {

   @Element        
   private Workspace workspace;         

   public abstract void execute() throws Exception;
}

public class DeleteTask extends Task {

   @ElementList(inline=true, entry=&amp;quot;resource&amp;quot;)        
   private Collection&amp;lt;String&amp;gt; list;        

   public void execute() {
      File root = getPath();

      for(String path : list) {
         new File(root, path).delete();              
      }
   }  
}

public class MoveTask extends Task {

   @ElementList(inline=true, entry=&amp;quot;resource&amp;quot;)
   private Collection&amp;lt;String&amp;gt; list;

   @Attribute
   private File from;

   public void execute() {
      File root = getPath();

      for(String path : list) {
         File create = new File(root, path);
         File copy = new File(from, path);

         copy.renameTo(create);
      }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code snippet shows a very simple task framework that is used to perform actions on a workspace. Each task must contain details for the workspace it will perform its specific task on. So, making use of the cycle strategy it is possible to declare a specific object once, using a know identifier and referencing that object throughout a single XML document. This eases the configuration burden and ensures that less errors can creap in to large complex documents where may objects are declared.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;job&amp;gt;
   &amp;lt;workspace id=&amp;quot;default&amp;quot;&amp;gt;
      &amp;lt;path&amp;gt;c:\workspace\task&amp;lt;/path&amp;gt;
   &amp;lt;/workspace&amp;gt;
   &amp;lt;task class=&amp;quot;example.DeleteTask&amp;quot;&amp;gt;
      &amp;lt;workspace ref=&amp;quot;default&amp;quot;/&amp;gt;
      &amp;lt;resource&amp;gt;output.dat&amp;lt;/resource&amp;gt;
      &amp;lt;resource&amp;gt;result.log&amp;lt;/resource&amp;gt;
   &amp;lt;/task&amp;gt;
   &amp;lt;task class=&amp;quot;example.MoveTask&amp;quot;&amp;gt;
      &amp;lt;workspace ref=&amp;quot;default&amp;quot;/&amp;gt;
      &amp;lt;from&amp;gt;c:\workspace\data&amp;lt;/from&amp;gt;
      &amp;lt;resource&amp;gt;input.xml&amp;lt;/resource&amp;gt;
   &amp;lt;/task&amp;gt;
&amp;lt;/job&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-23-sect-using-utility-collections:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;23&#34; /&gt;&amp;sect;Using utility collections&lt;/h3&gt;

&lt;p&gt;For convinience there are several convinience collections which can be used. These collections only need to be annotated with the ElementList annotation to be used. The first stock collection resembles a map in that it will accept values that have a known key or name object, it is the Dictionary collection. This collection requires objects of type Entry to be inserted on deserialization as this object contains a known key value. To illustrate how to use this collection take the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class TextMap {

   @ElementList(inline=true)
   private Dictionary&amp;lt;Text&amp;gt; list;   

   public Text get(String name) {
      return list.get(name);           
   }
}

@Root
public class Text extends Entry {

   @Text          
   public String text;

   public String getText() {
      return text;           
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above objects show how the dictionary collection is annotated with the element list annotation. The containing object can not serialize and deserialize entry objects which can be retrieve by name. For example take the following XML which shows the serialized representation of the text map object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;textMap&amp;gt;
   &amp;lt;text name=&amp;quot;name&amp;quot;&amp;gt;Niall Gallagher&amp;lt;/text&amp;gt;
   &amp;lt;text name=&amp;quot;street&amp;quot;&amp;gt;Seasme Street&amp;lt;/text&amp;gt;
   &amp;lt;text name=&amp;quot;city&amp;quot;&amp;gt;Atlantis&amp;lt;/text&amp;gt;
&amp;lt;/textMap&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each text entry deserialized in to the dictionary can now be acquired by name. Although this offers a convinient map like structure of acquring objects based on a name there is often a need to match objects. For such a requirement the Resolver collection can be used. This offers a fast pattern matching collection that matches names or keys to patterns. Patterns are deserialized within Match objects, which are inserted in to the resolver on deserialization. An example of the resolver is shown below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
private static class ContentType extends Match {

   @Attribute
   private String value;        

   public ContentType() {
      super();                  
   }

   public ContentType(String pattern, String value) {
      this.pattern = pattern;
      this.value = value;        
   }
}

@Root
private static class ContentResolver implements Iterable {

   @ElementList
   private Resolver&amp;lt;ContentType&amp;gt; list;           

   @Attribute
   private String name;

   public Iterator&amp;lt;ContentType&amp;gt; iterator() {
      return list.iterator();
   }

   public ContentType resolve(String name) {
      return list.resolve(name);              
   }
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above content resolver will match a string with a content type. Such an arrangement could be used to resolve paths to content types. For example the following XML document illustrates how the resolver could be used to match URL paths to content types for a web application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;contentResolver name=&amp;quot;example&amp;quot;&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;*.html&amp;quot; value=&amp;quot;text/html&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;*.jpg&amp;quot; value=&amp;quot;image/jpeg&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;/images/*&amp;quot; value=&amp;quot;image/jpeg&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;/log/**&amp;quot; value=&amp;quot;text/plain&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;*.exe&amp;quot; value=&amp;quot;application/octetstream&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;**.txt&amp;quot; value=&amp;quot;text/plain&amp;quot;/&amp;gt;
   &amp;lt;contentType pattern=&amp;quot;/html/*&amp;quot; value=&amp;quot;text/html&amp;quot;/&amp;gt;
&amp;lt;/contentResolver&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the resolver collection can only deal with wild card characters such as * and ? it is much faster than resolutions performed using Java regular expressions. Typically it is several orders of magnitude faster that regular expressions, particularly when it is used to match reoccuring values, such as URI paths.&lt;/p&gt;

&lt;h3 id=&#34;a-name-24-sect-object-substitution:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;24&#34; /&gt;&amp;sect;Object substitution&lt;/h3&gt;

&lt;p&gt;Often there is a need to substitute an object into the XML stream either during serialization or deserialization. For example it may be more convinient to use several XML documents to represent a configuration that can be deserialized in to a single object graph transparently. For example take the following XML.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;registry&amp;gt;
    &amp;lt;import name=&amp;quot;external.xml&amp;quot; class=&amp;quot;example.ExternalDefinition&amp;quot;/&amp;gt;
    &amp;lt;define name=&amp;quot;blah&amp;quot; class=&amp;quot;example.DefaultDefinition&amp;quot;&amp;gt;
       &amp;lt;property key=&amp;quot;a&amp;quot;&amp;gt;Some value&amp;lt;/property&amp;gt;
       &amp;lt;property key=&amp;quot;b&amp;quot;&amp;gt;Some other value&amp;lt;/property&amp;gt;
    &amp;lt;/define&amp;gt;
&amp;lt;/registry&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above XML document there is an import XML element, which references a file external.xml. Given that this external file contains further definitions it would be nice to be able to replace the import with the definition from the file. In such cases the Resolve annotation can be used. Below is an example of how to annotate your class to substitute the objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
private class Registry {

   @ElementList(inline=true)
   private Dictionary&amp;lt;Definition&amp;gt; import;

   @ElementList(inline=true)
   private Dictionary&amp;lt;Definition&amp;gt; define;

   public Definition getDefinition(String name) {
      Definition value = define.get(name);

      if(value == null) {
         value = import.get(name);
      }
      return value;
   }
}

public interface Definition {

   public String getProperty(String key);
}

@Root(name=&amp;quot;define&amp;quot;)
public class DefaultDefinition implements Definition {

   @ElementList(inline=true)
   private Dictionary&amp;lt;Property&amp;gt; list;

   public String getProperty(String key) {
      return list.get(key);
   }
}

@Root(name=&amp;quot;import&amp;quot;)
public class ExternalDefinition implements Definition {

   @Element
   private File name;

   public String getProperty(String key) {
      throw new IllegalStateException(&amp;quot;Method not supported&amp;quot;);
   }    

   @Resolve
   public Definition substitute() throws Exception {
      return new Persister().read(Definition.class, name);
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this form of substitution objects can be replaced in such a way that deserialized objects can be used as factories for other object instances. This is similar to the Java serialization concept of readResolve and writeReplace methods.&lt;/p&gt;

&lt;h3 id=&#34;a-name-25-sect-serializing-java-language-types:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;25&#34; /&gt;&amp;sect;Serializing Java language types&lt;/h3&gt;

&lt;p&gt;A common requirement of any serialization framework is to be able to serialize and deserialize existing types without modification. In particular types from the Java class libraries, like dates, locales, and files. For many of the Java class library types there is a corrosponding Transform implementation, which enables the serialization and deserialization of that type. For example the java.util.Date type has a transform that accepts a date instance and transforms that into a string, which can be embedded in to the generated XML document during serialization. For deserialization the same transform is used, however this time it converts the string value back in to a date instance. The code snippet below demonstrates how a such transformations make it possible to use such a type when implementing your class XML schema.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class DateList {

   @Attribute
   private Date created;

   @ElementList
   private List&amp;lt;Date&amp;gt; list;

   public Date getCreationDate() {
      retrun created;
   }

   public List&amp;lt;Date&amp;gt; getDates() {
      return list;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the date object is used like any other Java primitive, it can be used with any of the XML annotations. Such objects can also be used with the CycleStrategy so that references to a single instance within your object graph can be maintained throughout serialization and deserialization operations. Below is an example of the XML document generated.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dateList created=&amp;quot;2007-01-03 18:05:11.234 GMT&amp;quot;&amp;gt;
    &amp;lt;list&amp;gt;
        &amp;lt;date&amp;gt;2007-01-03 18:05:11.234 GMT&amp;lt;/date&amp;gt;
        &amp;lt;date&amp;gt;2007-01-03 18:05:11.234 GMT&amp;lt;/date&amp;gt;
    &amp;lt;/list&amp;gt;
&amp;lt;/dateList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using standard Java types, such as the Date type, can be used with any of the XML annotations. The set of supported types is shown below. Of particular note are the primitive array types, which when used with the ElementArray annotation enable support for multidimentional arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char
char[]
java.lang.Character
java.lang.Character[]
int
int[]
java.lang.Integer
java.lang.Integer[]
short
short[]
java.lang.Short
java.lang.Short[]
long        
long[]
java.lang.Long
java.lang.Long[]
double
double[]
java.lang.Double
java.lang.Double[]
byte
byte[]
java.lang.Byte
java.lang.Byte[]
float       
float[]        
java.lang.Float        
java.lang.Float[]        
boolean
boolean[]
java.lang.Boolean
java.lang.Boolean[]
java.lang.String
java.lang.String[]
java.util.Date
java.util.Locale
java.util.Currency
java.util.TimeZone
java.util.GregorianCalendar
java.net.URL
java.io.File
java.math.BigInteger
java.math.BigDecimal
java.sql.Date
java.sql.Time
java.sql.Timestamp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example take the following code snippet, here points on a graph are represented as a multidimentional array of integers. The array is annotated in such a way that it can be serialized and deserialized seamlessly. Each index of the array holds an array of type int, which is transformed using the Transformer in to a comma separated list of integer values. Obviously this is not of much use in a real world situation, however it does illustrate how the transformable types can be integrated seamlessly with existing XML annotations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Graph {

   @ElementArray(entry=&amp;quot;point&amp;quot;)
   private int[][] points;

   public Graph() {
      super();
   }

   @Validate
   private void validate() throws Exception {
      for(int[] array : points) {
         if(array.length != 2) {
            throw new InvalidPointException(&amp;quot;Point can not have %s values&amp;quot;, array.length);
         }
      }
   }

   public int[][] getPoints() {
      return points;      
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above code example the resulting XML generated would look like the XML document below. Here each index of the element array represents an array of integers within the comma separated list. Such structures also work well with the cycle strategy in maintaining references.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;graph&amp;gt;
   &amp;lt;points length=&amp;quot;4&amp;quot;&amp;gt;
      &amp;lt;point&amp;gt;3, 5&amp;lt;/point&amp;gt;
      &amp;lt;point&amp;gt;5, 6&amp;lt;/point&amp;gt;
      &amp;lt;point&amp;gt;5, 1&amp;lt;/point&amp;gt;
      &amp;lt;point&amp;gt;3, 2&amp;lt;/point&amp;gt;
   &amp;lt;/points&amp;gt;
&amp;lt;/graph&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-26-sect-styling-serialized-xml:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;26&#34; /&gt;&amp;sect;Styling serialized XML&lt;/h3&gt;

&lt;p&gt;In order to serialize objects in a consistent format a Style implementation can be used to format the elements and attributes written to the XML document. Styling of XML allows both serialization and deserialization to be performed. So once serialized in a styled XML format you can deserialize the same document back in to an object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class PersonProfile {

   @Attribute
   private String firstName;

   @Attribute
   private String lastName;

   @Element
   private PersonAddress personAddress;

   @Element
   private Date personDOB;

   public Date getDateOfBirth() {
      return personDOB;
   }

   public String getFirstName() {
      return firstName;
   }

   public String getLastName() {
      return lastName;
   }

   public PersonAddress getAddress() {
      return personAddress;
   }
}

@Root
public class PersonAddress {

   @Element
   private String houseNumber;

   @Element
   private String streetName;

   @Element
   private String city;

   public String getHouseNumber() {
      return houseNumber;
   }

   public String getStreetName() {
      return streetName;
   }

   public String getCity() {
      return city;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, taking the above annotated objects. An instance of the person profile can be serialized in to an XML document that is styled with a hyphenated format. This produces a consistently formated result which is just as deserializable as a serialization that is not styled.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;person-profile first-name=&amp;quot;Niall&amp;quot; last-name=&amp;quot;Gallagher&amp;quot;&amp;gt;
   &amp;lt;person-DOB&amp;gt;10/10/2008&amp;lt;/person-DOB&amp;gt;
   &amp;lt;person-address&amp;gt;
      &amp;lt;house-number&amp;gt;10&amp;lt;/house-number&amp;gt;
      &amp;lt;street-name&amp;gt;Sesame Street&amp;lt;/street-name&amp;gt;
      &amp;lt;city&amp;gt;Disney Land&amp;lt;/city&amp;gt;
   &amp;lt;/person-address&amp;gt;
&amp;lt;/person-profile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to serialize an object in a styled format either the HyphenStyle or CamelCaseStyle can be used. If neither suits one can always be implemented. Also, for convenience any of the elements or attributes can be overridden with a specific string by setting it to the style instance. The code snippet below shows how to serialize the object in the hyphenated style above.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Style style = new HyphenStyle();
Format format = new Format(style);
Serializer serializer = new Persister(format);

serializer.write(personDetail, file);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-27-sect-version-tolerant-serialization:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;27&#34; /&gt;&amp;sect;Version tolerant serialization&lt;/h3&gt;

&lt;p&gt;In order to serialize objects in a version tolerant format a Version annotation can be introduced to the class. This will allow a later, modified class to be read from XML generated by the original class. For example take the following code snippet showing an annotated class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Namespace(prefix=&amp;quot;p&amp;quot;, reference=&amp;quot;http://www.domain.com/person&amp;quot;)
public class Person {

  @Attribute
  private String name;

  @Element
  private String height;

  @Element
  private String weight;

  public String getName() {
     return name;
  }

  public String getHeight() {
     return height;
  }

  public String getWeight() {
     return weight;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above annotated class schema will generate XML in a format compatible with that class. For example, a serialization of the class could result in the following XML snippet. This shows the height and weight elements as well as the name attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p:person name=&amp;quot;John Doe&amp;quot; xmlns:p=&amp;quot;http://www.domain.com/person&amp;quot;&amp;gt;
    &amp;lt;height&amp;gt;185&amp;lt;/height&amp;gt;
    &amp;lt;weight&amp;gt;84&amp;lt;/height&amp;gt;
&amp;lt;/p:person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having used this class schema to serialize instances of the Person class, It could later be extended or modified as follows and still read and write in a format compatible with the old class schema like so, even though the resulting XML has changed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Namespace(prefix=&amp;quot;p&amp;quot;, reference=&amp;quot;http://www.domain.com/person&amp;quot;)
public class Person {

  @Version(revision=1.1)
  private double version;

  @Attribute
  private String name;

  @Attribute
  private int age;

  @Element
  private int height;

  public String getName() {
     return name;
  }

  public int getHeight() {
     return height;
  }

  public int getAge() {
     return age;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the version attribute is annotated with the special Version annotation. This will read the previously generated XML and compare the version attribute of the person element and compare it to the revision attribute of the annotation. If the version annotation does not exist the initial 2.0 version is assumed. So when using the new modified class, which is revision 1.1, with the old serialized XML the serializer will determine that the two have differing versions. So when deserializing it will ignore the excess weight element and ignore the fact that the age attribute does not exist. It will do this for all attributes and elements that do not match.&lt;/p&gt;

&lt;p&gt;This is quite similar to the C# XML serialization version capability. Where the initial version of each class is 1.0 (implicitly) and subsequent versions increase. This tells the serializer how it should approach deserialization of different versions. The later version of the class when serialized will explicitly write the version as follows.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p:person version=&amp;quot;1.1&amp;quot; name=&amp;quot;John Doe&amp;quot; age=&amp;quot;60&amp;quot; xmlns:p=&amp;quot;http://www.domain.com/person&amp;quot;&amp;gt;
    &amp;lt;height&amp;gt;185&amp;lt;/height&amp;gt;
&amp;lt;/p:person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-28-sect-serializing-static-final-fields:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;28&#34; /&gt;&amp;sect;Serializing static final fields&lt;/h3&gt;

&lt;p&gt;Often there is a need to add elements and attributes to an XML document that do not change. In such an event it is often attractive to declare these fields as static final fields. When annotating static final fields they form part of the XML schema and contribute to the validation of the document but do not get set when deserializing the XML in to a object instance. So should a required static final field not exist in the source XML then an exception is thrown when deserializing, much like what would happen if the field was mutable. For example take the code snippet below, which shows an immutable static final field used with mutable fields.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Citation {

   @Element(name=&amp;quot;author&amp;quot;)
   private static final String AUTHOR = &amp;quot;Niall Gallagher&amp;quot;;

   @Element
   private String title;

   @Element   
   private String date;

   public Date getDate() {
      return date;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above annotated object describes a simple citation. The citation object itself contains a static final field that will be written to the resulting XML document when serialized. However, on deserialization the values read from the XML will not change the annotated final static field. Instead the deserialization process will simply validate the presence of the elements and attributes within the document. This results in an object that will always write the same value for the annotated final static elements or attributes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;citation&amp;gt;
   &amp;lt;author&amp;gt;Niall Gallagher&amp;lt;/author&amp;gt;
   &amp;lt;title&amp;gt;Simple XML Serialization&amp;lt;/author&amp;gt;
   &amp;lt;date&amp;gt;12 January 2010&amp;lt;/date&amp;gt;
&amp;lt;/citation&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-29-sect-overriding-serialization-with-converters:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;29&#34; /&gt;&amp;sect;Overriding serialization with converters&lt;/h3&gt;

&lt;p&gt;Often times there is a need to serialize an object that can not be annotated. Such objects may exist in third party dependencies or packages. To serialize these objects a Converter object can be implemented. A converter can be used to intercept the normal serialization process. Interception of the normal serialization process can be done in several different ways, for example take the code snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class Example {

   @Element
   @Convert(ExternalConverter.class)
   private External external;

   public External getExternal() {
      return external;
   }
}

public class ExternalConverter implements Converter&amp;lt;External&amp;gt; {

   public External read(InputNode node) {
      String name = node.getAttribute(&amp;quot;name&amp;quot;);
      String value = node.getAttribute(&amp;quot;value&amp;quot;);

      return new External(name, value);
   }

   public void write(OutputNode node, External external) {
      String name = external.getName();
      String value = external.getValue();

      node.setAttribute(&amp;quot;name&amp;quot;, name);
      node.setAttribute(&amp;quot;value&amp;quot;, value);
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code snippet also shows a field annotated with the Convert annotation. The converter specified by the annotation will be used to intercept the normal serialization process and produce a customized XML element. Take the XML below, this is produced when the example object is serialized.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;example&amp;gt;
    &amp;lt;external name=&amp;quot;book&amp;quot; value=&amp;quot;Shantaram&amp;quot;/&amp;gt;
&amp;lt;/example&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interception of the normal serialization process is performed using a Strategy implementation and so does not form part of the core serialization process. Instead a specific strategy needs to be provided to the persister as is shown in the code snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Strategy strategy = new AnnotationStrategy();
Serializer serializer = new Persister(strategy);

serializer.read(Example.class, file);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without the specification of the AnnotationStrategy the interception could not be performed, as the core serialization process will not acknowledge the Convert annotation. So in effect this strategy extends the core serialization process in an independent and transparent manner. Another even more transparent way to intercept the normal serialization process is to use another strategy implementation. The RegistryStrategy allows bindings to be registered between classes and converters, there is no need for additional annotations as was required for the previous example. Below is an example of how to establish bindings between a class and a converter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Registry registry = new Registry();
Strategy strategy = new RegistryStrategy(registry);
Serializer serializer = new Persister(strategy);

registry.bind(External.class, ExternalConverter.class);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As many bindings as is required can be established with a registry. Also, if more complex converters are required a converter instance can be registered. Such a converter could have a reference to the Persister object so that nested serialization can be performed. This registry strategy also ensures that objects within Java collection objects can be serialized with registered converters. To illustrate how a complex converter could be registered take a look at the snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Registry registry = new Registry();
Strategy strategy = new RegistryStrategy(registry);
Serializer serializer = new Persister(strategy);
ComplexConverter converter = new ComplexConverter(serializer);

registry.bind(ComplexObject.class, converter);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-30-sect-intercepting-the-serialization-process:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;30&#34; /&gt;&amp;sect;Intercepting the serialization process&lt;/h3&gt;

&lt;p&gt;Interception of the serialization process can be useful in several scenarios, for example if attributes are to be added or removed from an XML element then that element can be intercepted and modified during the serialization process. One useful application of interception is to change attribute names or values. For example, the &amp;ldquo;class&amp;rdquo; annotations added by the TreeStrategy could be intercepted and changed to a language neutral format that does not contain the Java class name. Below is an example of how to use a Visitor to add debug comments to an obect which is to be serialized.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
@Default
public class CommentExample {

    private String name;

    private BigDecimal number;

    private Date date;     
}

public class CommentVisitor implements Visitor {

   public void write(Type type, NodeMap&amp;lt;OutputNode&amp;gt; node) {
      OutputNode element = node.getNode();
      Class type = type.getType();
      String comment = type.getName();

      if(!element.isRoot()) {
         element.setComment(comment);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above visitor implementation will get the OutputNode that represents the XML element for the provided map of attributes. If the element does not represent the root element in the XML document then every element will have an associated comment, which descrives the class it represents. Such a visitor can be useful when serializing large document structures. The XML snippet below provides an example of what would be written.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;commentExample&amp;gt;
    &amp;lt;!-- java.lang.String --&amp;gt;
    &amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;
    &amp;lt;!-- java.math.BigDecimal --&amp;gt;
    &amp;lt;number&amp;gt;100.0&amp;lt;/number&amp;gt;
    &amp;lt;!-- java.lang.Integer --&amp;gt;
    &amp;lt;value&amp;gt;18&amp;lt;/value&amp;gt;
&amp;lt;/commentExample&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To add a visitor to serialization the VisitorStrategy must be used. This strategy takes a visitor implementation and if required a strategy to delegate to. As usual, this strategy implementation can then be used to construct a persister, which can then serialize and deserialize objects.&lt;/p&gt;

&lt;h3 id=&#34;a-name-31-sect-mapping-with-xpath-expressions:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;31&#34; /&gt;&amp;sect;Mapping with XPath expressions&lt;/h3&gt;

&lt;p&gt;At times it is useful to have your object model map to complex XML documents, without having to write an annotated class to map to the required elements and attributes. For such scenarios the Path annotation can be used. This requires the user to specify an XPath expression for a field or method. For example take annotated fields below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Root
public class ServerDeployment {

   @Attribute
   @Path(&amp;quot;group&amp;quot;)
   private ServerType type;

   @Element
   @Path(&amp;quot;group/server[1]/details&amp;quot;)
   private Server primary;

   @Element
   @Path(&amp;quot;group/server[2]/details&amp;quot;)
   private Server secondary;

   public Server getPrimary() {
      return primary;
   }

   public Server getSecondary() {
      return secondary;
   }
}

@Root
public class Server {

   @Attribute
   private String host;

   @Attribute
   private int port;
}

public enum ServerType {
   WINDOWS,
   LINUX,
   SOLARIS
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code shows annotations applied to two objects. One contains XPath expressions that tell the serialization process how to read and write the details to an from the document. Here the expression defines a server within wrapper elements. When serializing such objects, the following XML results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;serverDeployment&amp;gt;
   &amp;lt;group type=&amp;quot;LINUX&amp;quot;&amp;gt;
      &amp;lt;server&amp;gt;
         &amp;lt;details&amp;gt;
            &amp;lt;primary host=&amp;quot;host1.domain.com&amp;quot; port=&amp;quot;4567&amp;quot;/&amp;gt;
         &amp;lt;/details&amp;gt;
      &amp;lt;/server&amp;gt;
      &amp;lt;server&amp;gt;
         &amp;lt;details&amp;gt;
            &amp;lt;secondary host=&amp;quot;host2.domain.com&amp;quot; port=&amp;quot;4567&amp;quot;/&amp;gt;
         &amp;lt;/details&amp;gt;
      &amp;lt;/server&amp;gt;
   &amp;lt;/group&amp;gt;
&amp;lt;/serverDeployment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen the XPath expressions defined have been used to determine the structure of the XML document. Such expressions allow a complex XML format to be serialized in to two simple objects. This can greatly reduce the number of types required to map an object to an XML structure. Both attributes and elements can be mapped in this manner.&lt;/p&gt;

&lt;p&gt;When ordering elements with the Order annotation these wrapper elements can be sorted. To order wrapper elements an XPath expression can be used to identify the wrapper. Simply place the expression in the order annotation along with any element or attribute names and it is ordered as required. For example, take the following code snippet.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Default
@Order(elements={&amp;quot;name[1]/first&amp;quot;, &amp;quot;name[1]/surname&amp;quot;, &amp;quot;age/date&amp;quot;, &amp;quot;name[2]/nickname&amp;quot;})
public class Person {

   @Path(&amp;quot;name[1]&amp;quot;)
   private String first;

   @Path(&amp;quot;name[1]&amp;quot;)
   private String surname;

   @Path(&amp;quot;name[2]&amp;quot;)
   private String nickname;

   @Path(&amp;quot;age&amp;quot;)
   private String date;

   public String getName() {
      return first;
   }

   public String getSurname() {
      return surname;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like ordering of elements or attributes without XPath expressions, a reference is all that is needed to ensure order. For the above code the serialization of the object will result in the following XML.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;person&amp;gt;
   &amp;lt;name&amp;gt;
      &amp;lt;first&amp;gt;Jack&amp;lt;/first&amp;gt;
      &amp;lt;surname&amp;gt;Daniels&amp;lt;/surname&amp;gt;
   &amp;lt;/name&amp;gt;
   &amp;lt;age&amp;gt;
       &amp;lt;birth&amp;gt;19/10/1912&amp;lt;/birth&amp;gt;
   &amp;lt;/age&amp;gt;
   &amp;lt;name&amp;gt;
      &amp;lt;nickname&amp;gt;JD&amp;lt;/nickname&amp;gt;
   &amp;lt;/name&amp;gt;
&amp;lt;/person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above XML snippet we have serialized a single object in to multiple elements and ensured the order of the elements is as we required. Ordering can be applied to elements and attributes with Path annotations as easily as it can to those without, and both can be mixed within the same annotation. Using this type of ordering it is possible to generate very predictible results. One thing to note when using such annotations, is that only a subset of the XPath expression syntax is supported. For example, element and attribute references can not be taken from the root of the document, only references within the current context are allowed.&lt;/p&gt;

&lt;h3 id=&#34;a-name-32-sect-dynamic-serialization-with-unions:3e5d75d4214fa22bb75ff866d8c58f37&#34;&gt;&lt;a name=&#34;32&#34; /&gt;&amp;sect;Dynamic serialization with unions&lt;/h3&gt;

&lt;p&gt;In order to perform dynamic serialization where element names bind to specific types the ElementUnion annotation can be used. This allows different XML schema classes to be associated with a single annotated field or method. Serialization of the associated instance determines the XML element name using the instance type. On deserialization the XML element name is then used to determine the schema class to use. For example, take the following set of annotated classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Shape {

   public double area();
}

@Root
public class Circle implements Shape {

   @Element
   private double radius;

   public Circle(@Element(name=&amp;quot;radius&amp;quot;) double radius) {
      this.radius = radius;
   }

   public double area() {
      return Math.PI * Math.pow(radius, 2.0);
   }
}

@Root
public class Rectangle implements Shape {

   @Element
   private double width;

   @Element
   private double height;

   public Rectangle(
      @Element(name=&amp;quot;width&amp;quot;) double width,
      @Element(name=&amp;quot;height&amp;quot;) double height)
   {
      this.height = height;
      this.width = width;
   }

   public double area() {
      return width * height;
   }
}

@Root
public class Diagram {

   @ElementUnion({
      @Element(name=&amp;quot;circle&amp;quot;, type=Circle.class),
      @Element(name=&amp;quot;rectangle&amp;quot;, type=Rectangle.class)
   })
   private Shape shape;

   public Diagram() {
      super();
   }

   public void setShape(Shape shape){
      this.shape = shape;
   }

   public Shape getShape() {
      return shape;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above set of classes can now be used to dynamically deserialize different XML documents using a single schema class. For example, take the XML snippet below, this shows what is generated when the shape is assigned an instance of the circle type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;diagram&amp;gt;
   &amp;lt;circle&amp;gt;
      &amp;lt;radius&amp;gt;3.0&amp;lt;/radius&amp;gt;
   &amp;lt;/circle&amp;gt;
&amp;lt;/diagram&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if the shape field is assigned an instance of the square type then serialization of the diagram results in a different XML document. See the XML snippet below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;diagram&amp;gt;
   &amp;lt;rectangle&amp;gt;
      &amp;lt;width&amp;gt;5.0&amp;lt;/width&amp;gt;
      &amp;lt;height&amp;gt;11.0&amp;lt;/heigth&amp;gt;
   &amp;lt;/rectangle&amp;gt;
&amp;lt;/diagram&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Providing dynamic serialization capabilities via the ElementUnion annotation ensures that more complex XML documents can be handled with ease. Typically, such unions will be required for a list of similar types. To tackle lists the ElementListUnion annotation can be used. This can be used as a union of inline lists to collect similar XML declarations in to a single list. For example, take the annotated classes below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Operation {

   public void execute();
}

@Default
public class Delete implements Operation {

   private File file;

   public Delete(@Element(name=&amp;quot;file&amp;quot;) File file) {
      this.file = file;
   }

   public void execute() {
      file.delete();
   }
}

@Default
public class MakeDirectory implements Operation {

   private File path;

   private MakeDirectory(@Element(name=&amp;quot;path&amp;quot;) File path) {
      this.path = path;
   }

   public void execute() {
      path.mkdirs();
   }
}

@Default
public class Move implements Operation {

   private File source;
   private File destination;

   public Move(
         @Element(name=&amp;quot;source&amp;quot;) File source,
         @Element(name=&amp;quot;destination&amp;quot;) File destination)
   {
      this.source = source;
      this.destination = destination;
   }

   public void execute() {
      source.renameTo(destination);
   }
}

@Root
public class Task {

   @ElementListUnion({
      @ElementList(entry=&amp;quot;delete&amp;quot;, inline=true, type=Delete.class),
      @ElementList(entry=&amp;quot;mkdir&amp;quot;, inline=true, type=MakeDirectory.class),
      @ElementList(entry=&amp;quot;move&amp;quot;, inline=true, type=Move.class)
   })
   private List&amp;lt;Operation&amp;gt; operations;

   @Attribute
   private String name;

   public Task(@Attribute(name=&amp;quot;name&amp;quot;) String name) {
      this.operations = new LinkedList&amp;lt;Operation&amp;gt;();
      this.name = name;
   }

   public void add(Operation operation) {
      operations.add(operation);
   }

   public void execute() {
      for(Operation operation : operations) {
         operation.execute();
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the above set of annotated classes a list of operations can be defined in an XML document. Each type inserted in to the list can be resolved using the XML element name. Below is an example XML document generated from the annotated classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;task name=&amp;quot;setup&amp;quot;&amp;gt;
   &amp;lt;delete&amp;gt;
      &amp;lt;file&amp;gt;C:\workspace\classes&amp;lt;/file&amp;gt;
   &amp;lt;/delete&amp;gt;
   &amp;lt;mkdir&amp;gt;
      &amp;lt;path&amp;gt;C:\workspace\classes&amp;lt;/path&amp;gt;
   &amp;lt;/mkdir&amp;gt;
   &amp;lt;move&amp;gt;
      &amp;lt;source&amp;gt;C:\worksace\classes&amp;lt;/source&amp;gt;
      &amp;lt;destination&amp;gt;C:\workspace\build&amp;lt;/destination&amp;gt;
   &amp;lt;/move&amp;gt;
&amp;lt;/task&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://simple.sourceforge.net/download/stream/doc/tutorial/tutorial.php&#34; title=&#34;SimpleXML Tutorial&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TypeScript Language Specification</title>
      <link>http://alimy.me/post/dev_201602021955/</link>
      <pubDate>Tue, 02 Feb 2016 19:55:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201602021955/</guid>
      <description>

&lt;p&gt;&lt;br/&gt;
Version 1.8 &lt;a href=&#34;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md&#34; title=&#34;Microsoft/TypeScript@GitHub&#34;&gt;[GitHub]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;January, 2016&lt;/p&gt;

&lt;p&gt;Microsoft is making this Specification available under the Open Web Foundation Final Specification Agreement Version 1.0 (&amp;ldquo;OWF 1.0&amp;rdquo;) as of October 1, 2012. The OWF 1.0 is available at &lt;a href=&#34;http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0&#34; title=&#34;http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;TypeScript is a trademark of Microsoft Corporation.&lt;/p&gt;

&lt;h2 id=&#34;table-of-contents:11c61217b547eb355969114f07ce6b46&#34;&gt;Table of Contents&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;1 Introduction&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1.1&#34;&gt;1.1 Ambient Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.2&#34;&gt;1.2 Function Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.3&#34;&gt;1.3 Object Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.4&#34;&gt;1.4 Structural Subtyping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.5&#34;&gt;1.5 Contextual Typing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.6&#34;&gt;1.6 Classes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.7&#34;&gt;1.7 Enum Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.8&#34;&gt;1.8 Overloading on String Parameters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.9&#34;&gt;1.9 Generic Types and Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.10&#34;&gt;1.10 Namespaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1.11&#34;&gt;1.11 Modules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;2 Basic Concepts&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#2.1&#34;&gt;2.1 Grammar Conventions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2.2&#34;&gt;2.2 Names&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#2.2.1&#34;&gt;2.2.1 Reserved Words&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2.2.2&#34;&gt;2.2.2 Property Names&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2.2.3&#34;&gt;2.2.3 Computed Property Names&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2.3&#34;&gt;2.3 Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2.4&#34;&gt;2.4 Scopes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;3 Types&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3.1&#34;&gt;3.1 The Any Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2&#34;&gt;3.2 Primitive Types&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3.2.1&#34;&gt;3.2.1 The Number Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2.2&#34;&gt;3.2.2 The Boolean Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2.3&#34;&gt;3.2.3 The String Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2.4&#34;&gt;3.2.4 The Symbol Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2.5&#34;&gt;3.2.5 The Void Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2.6&#34;&gt;3.2.6 The Null Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2.7&#34;&gt;3.2.7 The Undefined Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2.8&#34;&gt;3.2.8 Enum Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.2.9&#34;&gt;3.2.9 String Literal Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.3&#34;&gt;3.3 Object Types&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3.3.1&#34;&gt;3.3.1 Named Type References&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.3.2&#34;&gt;3.3.2 Array Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.3.3&#34;&gt;3.3.3 Tuple Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.3.4&#34;&gt;3.3.4 Function Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.3.5&#34;&gt;3.3.5 Constructor Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.3.6&#34;&gt;3.3.6 Members&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.4&#34;&gt;3.4 Union Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.5&#34;&gt;3.5 Intersection Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.6&#34;&gt;3.6 Type Parameters&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3.6.1&#34;&gt;3.6.1 Type Parameter Lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.6.2&#34;&gt;3.6.2 Type Argument Lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.6.3&#34;&gt;3.6.3 This-types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.7&#34;&gt;3.7 Named Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8&#34;&gt;3.8 Specifying Types&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.1&#34;&gt;3.8.1 Predefined Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.2&#34;&gt;3.8.2 Type References&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.3&#34;&gt;3.8.3 Object Type Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.4&#34;&gt;3.8.4 Array Type Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.5&#34;&gt;3.8.5 Tuple Type Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.6&#34;&gt;3.8.6 Union Type Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.7&#34;&gt;3.8.7 Intersection Type Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.8&#34;&gt;3.8.8 Function Type Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.9&#34;&gt;3.8.9 Constructor Type Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.10&#34;&gt;3.8.10 Type Queries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.8.11&#34;&gt;3.8.11 This-Type References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.9&#34;&gt;3.9 Specifying Members&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3.9.1&#34;&gt;3.9.1 Property Signatures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.9.2&#34;&gt;3.9.2 Call Signatures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.9.3&#34;&gt;3.9.3 Construct Signatures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.9.4&#34;&gt;3.9.4 Index Signatures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.9.5&#34;&gt;3.9.5 Method Signatures&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.10&#34;&gt;3.10 Type Aliases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.11&#34;&gt;3.11 Type Relationships&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3.11.1&#34;&gt;3.11.1 Apparent Members&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.11.2&#34;&gt;3.11.2 Type and Member Identity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.11.3&#34;&gt;3.11.3 Subtypes and Supertypes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.11.4&#34;&gt;3.11.4 Assignment Compatibility&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.11.5&#34;&gt;3.11.5 Excess Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.11.6&#34;&gt;3.11.6 Contextual Signature Instantiation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.11.7&#34;&gt;3.11.7 Type Inference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.11.8&#34;&gt;3.11.8 Recursive Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3.12&#34;&gt;3.12 Widened Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;4 Expressions&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4.1&#34;&gt;4.1 Values and References&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.2&#34;&gt;4.2 The this Keyword&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.3&#34;&gt;4.3 Identifiers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.4&#34;&gt;4.4 Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.5&#34;&gt;4.5 Object Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.6&#34;&gt;4.6 Array Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.7&#34;&gt;4.7 Template Literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.8&#34;&gt;4.8 Parentheses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.9&#34;&gt;4.9 The super Keyword&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4.9.1&#34;&gt;4.9.1 Super Calls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.9.2&#34;&gt;4.9.2 Super Property Access&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.10&#34;&gt;4.10 Function Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.11&#34;&gt;4.11 Arrow Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.12&#34;&gt;4.12 Class Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.13&#34;&gt;4.13 Property Access&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.14&#34;&gt;4.14 The new Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.15&#34;&gt;4.15 Function Calls&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4.15.1&#34;&gt;4.15.1 Overload Resolution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.15.2&#34;&gt;4.15.2 Type Argument Inference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.15.3&#34;&gt;4.15.3 Grammar Ambiguities&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.16&#34;&gt;4.16 Type Assertions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.17&#34;&gt;4.17 JSX Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.18&#34;&gt;4.18 Unary Operators&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4.18.1&#34;&gt;4.18.1 The ++ and &amp;ndash; operators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.18.2&#34;&gt;4.18.2 The +, –, and ~ operators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.18.3&#34;&gt;4.18.3 The ! operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.18.4&#34;&gt;4.18.4 The delete Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.18.5&#34;&gt;4.18.5 The void Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.18.6&#34;&gt;4.18.6 The typeof Operator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.19&#34;&gt;4.19 Binary Operators&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4.19.1&#34;&gt;4.19.1 The *, /, %, –, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;gt;&amp;gt;&amp;gt;, &amp;amp;, ^, and | operators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.19.2&#34;&gt;4.19.2 The + operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.19.3&#34;&gt;4.19.3 The &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, ==, !=, ===, and !== operators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.19.4&#34;&gt;4.19.4 The instanceof operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.19.5&#34;&gt;4.19.5 The in operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.19.6&#34;&gt;4.19.6 The &amp;amp;&amp;amp; operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.19.7&#34;&gt;4.19.7 The || operator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.20&#34;&gt;4.20 The Conditional Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.21&#34;&gt;4.21 Assignment Operators&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4.21.1&#34;&gt;4.21.1 Destructuring Assignment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.22&#34;&gt;4.22 The Comma Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.23&#34;&gt;4.23 Contextually Typed Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4.24&#34;&gt;4.24 Type Guards&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5&#34;&gt;5 Statements&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#5.1&#34;&gt;5.1 Blocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.2&#34;&gt;5.2 Variable Statements&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#5.2.1&#34;&gt;5.2.1 Simple Variable Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.2.2&#34;&gt;5.2.2 Destructuring Variable Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.2.3&#34;&gt;5.2.3 Implied Type&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.3&#34;&gt;5.3 Let and Const Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.4&#34;&gt;5.4 If, Do, and While Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.5&#34;&gt;5.5 For Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.6&#34;&gt;5.6 For-In Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.7&#34;&gt;5.7 For-Of Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.8&#34;&gt;5.8 Continue Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.9&#34;&gt;5.9 Break Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.10&#34;&gt;5.10 Return Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.11&#34;&gt;5.11 With Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.12&#34;&gt;5.12 Switch Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.13&#34;&gt;5.13 Throw Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5.14&#34;&gt;5.14 Try Statements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6&#34;&gt;6 Functions&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#6.1&#34;&gt;6.1 Function Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6.2&#34;&gt;6.2 Function Overloads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6.3&#34;&gt;6.3 Function Implementations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6.4&#34;&gt;6.4 Destructuring Parameter Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6.5&#34;&gt;6.5 Generic Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6.6&#34;&gt;6.6 Code Generation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6.7&#34;&gt;6.7 Generator Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6.8&#34;&gt;6.8 Asynchronous Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6.9&#34;&gt;6.9 Type Guard Functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7&#34;&gt;7 Interfaces&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#7.1&#34;&gt;7.1 Interface Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7.2&#34;&gt;7.2 Declaration Merging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7.3&#34;&gt;7.3 Interfaces Extending Classes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7.4&#34;&gt;7.4 Dynamic Type Checks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8&#34;&gt;8 Classes&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#8.1&#34;&gt;8.1 Class Declarations&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#8.1.1&#34;&gt;8.1.1 Class Heritage Specification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.1.2&#34;&gt;8.1.2 Class Body&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.2&#34;&gt;8.2 Members&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#8.2.1&#34;&gt;8.2.1 Instance and Static Members&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.2.2&#34;&gt;8.2.2 Accessibility&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.2.3&#34;&gt;8.2.3 Inheritance and Overriding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.2.4&#34;&gt;8.2.4 Class Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.2.5&#34;&gt;8.2.5 Constructor Function Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.3&#34;&gt;8.3 Constructor Declarations&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#8.3.1&#34;&gt;8.3.1 Constructor Parameters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.3.2&#34;&gt;8.3.2 Super Calls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.3.3&#34;&gt;8.3.3 Automatic Constructors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.4&#34;&gt;8.4 Property Member Declarations&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#8.4.1&#34;&gt;8.4.1 Member Variable Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.4.2&#34;&gt;8.4.2 Member Function Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.4.3&#34;&gt;8.4.3 Member Accessor Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.4.4&#34;&gt;8.4.4 Dynamic Property Declarations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.5&#34;&gt;8.5 Index Member Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.6&#34;&gt;8.6 Decorators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.7&#34;&gt;8.7 Code Generation&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#8.7.1&#34;&gt;8.7.1 Classes Without Extends Clauses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8.7.2&#34;&gt;8.7.2 Classes With Extends Clauses&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9&#34;&gt;9 Enums&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#9.1&#34;&gt;9.1 Enum Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9.2&#34;&gt;9.2 Enum Members&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9.3&#34;&gt;9.3 Declaration Merging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9.4&#34;&gt;9.4 Constant Enum Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9.5&#34;&gt;9.5 Code Generation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10&#34;&gt;10 Namespaces&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#10.1&#34;&gt;10.1 Namespace Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10.2&#34;&gt;10.2 Namespace Body&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10.3&#34;&gt;10.3 Import Alias Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10.4&#34;&gt;10.4 Export Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10.5&#34;&gt;10.5 Declaration Merging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10.6&#34;&gt;10.6 Code Generation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11&#34;&gt;11 Scripts and Modules&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11.1&#34;&gt;11.1 Programs and Source Files&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11.1.1&#34;&gt;11.1.1 Source Files Dependencies&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11.2&#34;&gt;11.2 Scripts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11.3&#34;&gt;11.3 Modules&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11.3.1&#34;&gt;11.3.1 Module Names&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11.3.2&#34;&gt;11.3.2 Import Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11.3.3&#34;&gt;11.3.3 Import Require Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11.3.4&#34;&gt;11.3.4 Export Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11.3.5&#34;&gt;11.3.5 Export Assignments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11.3.6&#34;&gt;11.3.6 CommonJS Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11.3.7&#34;&gt;11.3.7 AMD Modules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12&#34;&gt;12 Ambients&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#12.1&#34;&gt;12.1 Ambient Declarations&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#12.1.1&#34;&gt;12.1.1 Ambient Variable Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12.1.2&#34;&gt;12.1.2 Ambient Function Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12.1.3&#34;&gt;12.1.3 Ambient Class Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12.1.4&#34;&gt;12.1.4 Ambient Enum Declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12.1.5&#34;&gt;12.1.5 Ambient Namespace Declarations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12.2&#34;&gt;12.2 Ambient Module Declarations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#A&#34;&gt;A Grammar&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#A.1&#34;&gt;A.1 Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#A.2&#34;&gt;A.2 Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#A.3&#34;&gt;A.3 Statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#A.4&#34;&gt;A.4 Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#A.5&#34;&gt;A.5 Interfaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#A.6&#34;&gt;A.6 Classes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#A.7&#34;&gt;A.7 Enums&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#A.8&#34;&gt;A.8 Namespaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#A.9&#34;&gt;A.9 Scripts and Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#A.10&#34;&gt;A.10 Ambients&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-1-1-introduction:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1&#34;/&gt;1 Introduction&lt;/h1&gt;

&lt;p&gt;JavaScript applications such as web e-mail, maps, document editing, and collaboration tools are becoming an increasingly important part of the everyday computing. We designed TypeScript to meet the needs of the JavaScript programming teams that build and maintain large JavaScript programs. TypeScript helps programming teams to define interfaces between software components and to gain insight into the behavior of existing JavaScript libraries. TypeScript also enables teams to reduce naming conflicts by organizing their code into dynamically-loadable modules. TypeScript&amp;rsquo;s optional type system enables JavaScript programmers to use highly-productive development tools and practices: static checking, symbol-based navigation, statement completion, and code re-factoring.&lt;/p&gt;

&lt;p&gt;TypeScript is a syntactic sugar for JavaScript. TypeScript syntax is a superset of ECMAScript 2015 (ES2015) syntax. Every JavaScript program is also a TypeScript program. The TypeScript compiler performs only file-local transformations on TypeScript programs and does not re-order variables declared in TypeScript. This leads to JavaScript output that closely matches the TypeScript input. TypeScript does not transform variable names, making tractable the direct debugging of emitted JavaScript. TypeScript optionally provides source maps, enabling source-level debugging. TypeScript tools typically emit JavaScript upon file save, preserving the test, edit, refresh cycle commonly used in JavaScript development.&lt;/p&gt;

&lt;p&gt;TypeScript syntax includes all features of ECMAScript 2015, including classes and modules, and provides the ability to translate these features into ECMAScript 3 or 5 compliant code.&lt;/p&gt;

&lt;p&gt;Classes enable programmers to express common object-oriented patterns in a standard way, making features like inheritance more readable and interoperable. Modules enable programmers to organize their code into components while avoiding naming conflicts. The TypeScript compiler provides module code generation options that support either static or dynamic loading of module contents.&lt;/p&gt;

&lt;p&gt;TypeScript also provides to JavaScript programmers a system of optional type annotations. These type annotations are like the JSDoc comments found in the Closure system, but in TypeScript they are integrated directly into the language syntax. This integration makes the code more readable and reduces the maintenance cost of synchronizing type annotations with their corresponding variables.&lt;/p&gt;

&lt;p&gt;The TypeScript type system enables programmers to express limits on the capabilities of JavaScript objects, and to use tools that enforce these limits. To minimize the number of annotations needed for tools to become useful, the TypeScript type system makes extensive use of type inference. For example, from the following statement, TypeScript will infer that the variable &amp;lsquo;i&amp;rsquo; has the type number.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var i = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TypeScript will infer from the following function definition that the function f has return type string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function f() {  
    return &amp;quot;hello&amp;quot;;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To benefit from this inference, a programmer can use the TypeScript language service. For example, a code editor can incorporate the TypeScript language service and use the service to find the members of a string object as in the following screen shot.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;img src=&#34;http://alimy.me/images/post/20160202225901.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this example, the programmer benefits from type inference without providing type annotations. Some beneficial tools, however, do require the programmer to provide type annotations. In TypeScript, we can express a parameter requirement as in the following code fragment.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function f(s: string) {  
    return s;  
}

f({});       // Error  
f(&amp;quot;hello&amp;quot;);  // Ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This optional type annotation on the parameter &amp;rsquo;s&amp;rsquo; lets the TypeScript type checker know that the programmer expects parameter &amp;rsquo;s&amp;rsquo; to be of type &amp;lsquo;string&amp;rsquo;. Within the body of function &amp;lsquo;f&amp;rsquo;, tools can assume &amp;rsquo;s&amp;rsquo; is of type &amp;lsquo;string&amp;rsquo; and provide operator type checking and member completion consistent with this assumption. Tools can also signal an error on the first call to &amp;lsquo;f&amp;rsquo;, because &amp;lsquo;f&amp;rsquo; expects a string, not an object, as its parameter. For the function &amp;lsquo;f&amp;rsquo;, the TypeScript compiler will emit the following JavaScript code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function f(s) {  
    return s;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the JavaScript output, all type annotations have been erased. In general, TypeScript erases all type information before emiting JavaScript.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-1-1-1-ambient-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.1&#34;/&gt;1.1 Ambient Declarations&lt;/h2&gt;

&lt;p&gt;An ambient declaration introduces a variable into a TypeScript scope, but has zero impact on the emitted JavaScript program. Programmers can use ambient declarations to tell the TypeScript compiler that some other component will supply a variable. For example, by default the TypeScript compiler will print an error for uses of undefined variables. To add some of the common variables defined by browsers, a TypeScript programmer can use ambient declarations. The following example declares the &amp;lsquo;document&amp;rsquo; object supplied by browsers. Because the declaration does not specify a type, the type &amp;lsquo;any&amp;rsquo; is inferred. The type &amp;lsquo;any&amp;rsquo; means that a tool can assume nothing about the shape or behavior of the document object. Some of the examples below will illustrate how programmers can use types to further characterize the expected behavior of an object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;declare var document;  
document.title = &amp;quot;Hello&amp;quot;;  // Ok because document has been declared
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the case of &amp;lsquo;document&amp;rsquo;, the TypeScript compiler automatically supplies a declaration, because TypeScript by default includes a file &amp;lsquo;lib.d.ts&amp;rsquo; that provides interface declarations for the built-in JavaScript library as well as the Document Object Model.&lt;/p&gt;

&lt;p&gt;The TypeScript compiler does not include by default an interface for jQuery, so to use jQuery, a programmer could supply a declaration such as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;declare var $;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Section &lt;a href=&#34;#1.3&#34;&gt;1.3&lt;/a&gt; provides a more extensive example of how a programmer can add type information for jQuery and other libraries.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-2-1-2-function-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.2&#34;/&gt;1.2 Function Types&lt;/h2&gt;

&lt;p&gt;Function expressions are a powerful feature of JavaScript. They enable function definitions to create closures: functions that capture information from the lexical scope surrounding the function&amp;rsquo;s definition. Closures are currently JavaScript&amp;rsquo;s only way of enforcing data encapsulation. By capturing and using environment variables, a closure can retain information that cannot be accessed from outside the closure. JavaScript programmers often use closures to express event handlers and other asynchronous callbacks, in which another software component, such as the DOM, will call back into JavaScript through a handler function.&lt;/p&gt;

&lt;p&gt;TypeScript function types make it possible for programmers to express the expected &lt;em&gt;signature&lt;/em&gt; of a function. A function signature is a sequence of parameter types plus a return type. The following example uses function types to express the callback signature requirements of an asynchronous voting mechanism.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function vote(candidate: string, callback: (result: string) =&amp;gt; any) {  
   // ...  
}

vote(&amp;quot;BigPig&amp;quot;,  
     function(result: string) {  
         if (result === &amp;quot;BigPig&amp;quot;) {  
            // ...  
         }  
     }  
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, the second parameter to &amp;lsquo;vote&amp;rsquo; has the function type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;(result: string) =&amp;gt; any
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which means the second parameter is a function returning type &amp;lsquo;any&amp;rsquo; that has a single parameter of type &amp;lsquo;string&amp;rsquo; named &amp;lsquo;result&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Section &lt;a href=&#34;#3.9.2&#34;&gt;3.9.2&lt;/a&gt; provides additional information about function types.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-3-1-3-object-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.3&#34;/&gt;1.3 Object Types&lt;/h2&gt;

&lt;p&gt;TypeScript programmers use &lt;em&gt;object types&lt;/em&gt; to declare their expectations of object behavior. The following code uses an &lt;em&gt;object type literal&lt;/em&gt; to specify the return type of the &amp;lsquo;MakePoint&amp;rsquo; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var MakePoint: () =&amp;gt; {  
    x: number; y: number;  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Programmers can give names to object types; we call named object types &lt;em&gt;interfaces&lt;/em&gt;. For example, in the following code, an interface declares one required field (name) and one optional field (favoriteColor).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Friend {  
    name: string;  
    favoriteColor?: string;  
}

function add(friend: Friend) {  
    var name = friend.name;  
}

add({ name: &amp;quot;Fred&amp;quot; });  // Ok  
add({ favoriteColor: &amp;quot;blue&amp;quot; });  // Error, name required  
add({ name: &amp;quot;Jill&amp;quot;, favoriteColor: &amp;quot;green&amp;quot; });  // Ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TypeScript object types model the diversity of behaviors that a JavaScript object can exhibit. For example, the jQuery library defines an object, &amp;lsquo;$&amp;rsquo;, that has methods, such as &amp;lsquo;get&amp;rsquo; (which sends an Ajax message), and fields, such as &amp;lsquo;browser&amp;rsquo; (which gives browser vendor information). However, jQuery clients can also call &amp;lsquo;$&amp;rsquo; as a function. The behavior of this function depends on the type of parameters passed to the function.&lt;/p&gt;

&lt;p&gt;The following code fragment captures a small subset of jQuery behavior, just enough to use jQuery in a simple way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface JQuery {  
    text(content: string);  
}  

interface JQueryStatic {  
    get(url: string, callback: (data: string) =&amp;gt; any);     
    (query: string): JQuery;  
}

declare var $: JQueryStatic;

$.get(&amp;quot;http://mysite.org/divContent&amp;quot;,  
      function (data: string) {  
          $(&amp;quot;div&amp;quot;).text(data);  
      }  
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;lsquo;JQueryStatic&amp;rsquo; interface references another interface: &amp;lsquo;JQuery&amp;rsquo;. This interface represents a collection of one or more DOM elements. The jQuery library can perform many operations on such a collection, but in this example the jQuery client only needs to know that it can set the text content of each jQuery element in a collection by passing a string to the &amp;lsquo;text&amp;rsquo; method. The &amp;lsquo;JQueryStatic&amp;rsquo; interface also contains a method, &amp;lsquo;get&amp;rsquo;, that performs an Ajax get operation on the provided URL and arranges to invoke the provided callback upon receipt of a response.&lt;/p&gt;

&lt;p&gt;Finally, the &amp;lsquo;JQueryStatic&amp;rsquo; interface contains a bare function signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;(query: string): JQuery;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The bare signature indicates that instances of the interface are callable. This example illustrates that TypeScript function types are just special cases of TypeScript object types. Specifically, function types are object types that contain one or more call signatures. For this reason we can write any function type as an object type literal. The following example uses both forms to describe the same type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var f: { (): string; };  
var sameType: () =&amp;gt; string = f;     // Ok  
var nope: () =&amp;gt; number = sameType;  // Error: type mismatch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We mentioned above that the &amp;lsquo;$&amp;rsquo; function behaves differently depending on the type of its parameter. So far, our jQuery typing only captures one of these behaviors: return an object of type &amp;lsquo;JQuery&amp;rsquo; when passed a string. To specify multiple behaviors, TypeScript supports &lt;em&gt;overloading&lt;/em&gt; of function signatures in object types. For example, we can add an additional call signature to the &amp;lsquo;JQueryStatic&amp;rsquo; interface.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;(ready: () =&amp;gt; any): any;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This signature denotes that a function may be passed as the parameter of the &amp;lsquo;$&amp;rsquo; function. When a function is passed to &amp;lsquo;$&amp;rsquo;, the jQuery library will invoke that function when a DOM document is ready. Because TypeScript supports overloading, tools can use TypeScript to show all available function signatures with their documentation tips and to give the correct documentation once a function has been called with a particular signature.&lt;/p&gt;

&lt;p&gt;A typical client would not need to add any additional typing but could just use a community-supplied typing to discover (through statement completion with documentation tips) and verify (through static checking) correct use of the library, as in the following screen shot.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;img src=&#34;http://alimy.me/images/post/20160202225902.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Section &lt;a href=&#34;#3.3&#34;&gt;3.3&lt;/a&gt; provides additional information about object types.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-4-1-4-structural-subtyping:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.4&#34;/&gt;1.4 Structural Subtyping&lt;/h2&gt;

&lt;p&gt;Object types are compared &lt;em&gt;structurally&lt;/em&gt;. For example, in the code fragment below, class &amp;lsquo;CPoint&amp;rsquo; matches interface &amp;lsquo;Point&amp;rsquo; because &amp;lsquo;CPoint&amp;rsquo; has all of the required members of &amp;lsquo;Point&amp;rsquo;. A class may optionally declare that it implements an interface, so that the compiler will check the declaration for structural compatibility. The example also illustrates that an object type can match the type inferred from an object literal, as long as the object literal supplies all of the required members.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Point {  
    x: number;  
    y: number;  
}

function getX(p: Point) {  
    return p.x;  
}

class CPoint {  
    x: number;  
    y: number;  
    constructor(x: number,  y: number) {  
        this.x = x;  
        this.y = y;  
    }  
}

getX(new CPoint(0, 0));  // Ok, fields match

getX({ x: 0, y: 0, color: &amp;quot;red&amp;quot; });  // Extra fields Ok

getX({ x: 0 });  // Error: supplied parameter does not match
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See section &lt;a href=&#34;#3.11&#34;&gt;3.11&lt;/a&gt; for more information about type comparisons.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-5-1-5-contextual-typing:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.5&#34;/&gt;1.5 Contextual Typing&lt;/h2&gt;

&lt;p&gt;Ordinarily, TypeScript type inference proceeds &amp;ldquo;bottom-up&amp;rdquo;: from the leaves of an expression tree to its root. In the following example, TypeScript infers &amp;lsquo;number&amp;rsquo; as the return type of the function &amp;lsquo;mul&amp;rsquo; by flowing type information bottom up in the return expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function mul(a: number, b: number) {  
    return a * b;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For variables and parameters without a type annotation or a default value, TypeScript infers type &amp;lsquo;any&amp;rsquo;, ensuring that compilers do not need non-local information about a function&amp;rsquo;s call sites to infer the function&amp;rsquo;s return type. Generally, this bottom-up approach provides programmers with a clear intuition about the flow of type information.&lt;/p&gt;

&lt;p&gt;However, in some limited contexts, inference proceeds &amp;ldquo;top-down&amp;rdquo; from the context of an expression. Where this happens, it is called contextual typing. Contextual typing helps tools provide excellent information when a programmer is using a type but may not know all of the details of the type. For example, in the jQuery example, above, the programmer supplies a function expression as the second parameter to the &amp;lsquo;get&amp;rsquo; method. During typing of that expression, tools can assume that the type of the function expression is as given in the &amp;lsquo;get&amp;rsquo; signature and can provide a template that includes parameter names and types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;$.get(&amp;quot;http://mysite.org/divContent&amp;quot;,  
      function (data) {  
          $(&amp;quot;div&amp;quot;).text(data);  // TypeScript infers data is a string  
      }  
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Contextual typing is also useful for writing out object literals. As the programmer types the object literal, the contextual type provides information that enables tools to provide completion for object member names.&lt;/p&gt;

&lt;p&gt;Section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt; provides additional information about contextually typed expressions.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-6-1-6-classes:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.6&#34;/&gt;1.6 Classes&lt;/h2&gt;

&lt;p&gt;JavaScript practice has two very common design patterns: the module pattern and the class pattern. Roughly speaking, the module pattern uses closures to hide names and to encapsulate private data, while the class pattern uses prototype chains to implement many variations on object-oriented inheritance mechanisms. Libraries such as &amp;lsquo;prototype.js&amp;rsquo; are typical of this practice. TypeScript&amp;rsquo;s namespaces are a formalization of the module pattern. (The term &amp;ldquo;module pattern&amp;rdquo; is somewhat unfortunate now that ECMAScript 2015 formally supports modules in a manner different from what the module pattern prescribes. For this reason, TypeScript uses the term &amp;ldquo;namespace&amp;rdquo; for its formalization of the module pattern.)&lt;/p&gt;

&lt;p&gt;This section and the namespace section below will show how TypeScript emits consistent, idiomatic JavaScript when emitting ECMAScript 3 or 5 compliant code for classes and namespaces. The goal of TypeScript&amp;rsquo;s translation is to emit exactly what a programmer would type when implementing a class or namespace unaided by a tool. This section will also describe how TypeScript infers a type for each class declaration. We&amp;rsquo;ll start with a simple BankAccount class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class BankAccount {  
    balance = 0;  
    deposit(credit: number) {  
        this.balance += credit;  
        return this.balance;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This class generates the following JavaScript code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var BankAccount = (function () {  
    function BankAccount() {  
        this.balance = 0;  
    }  
    BankAccount.prototype.deposit = function(credit) {  
        this.balance += credit;  
        return this.balance;  
    };  
    return BankAccount;  
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This TypeScript class declaration creates a variable named &amp;lsquo;BankAccount&amp;rsquo; whose value is the constructor function for &amp;lsquo;BankAccount&amp;rsquo; instances. This declaration also creates an instance type of the same name. If we were to write this type as an interface it would look like the following.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface BankAccount {  
    balance: number;  
    deposit(credit: number): number;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we were to write out the function type declaration for the &amp;lsquo;BankAccount&amp;rsquo; constructor variable, it would have the following form.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var BankAccount: new() =&amp;gt; BankAccount;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function signature is prefixed with the keyword &amp;lsquo;new&amp;rsquo; indicating that the &amp;lsquo;BankAccount&amp;rsquo; function must be called as a constructor. It is possible for a function&amp;rsquo;s type to have both call and constructor signatures. For example, the type of the built-in JavaScript Date object includes both kinds of signatures.&lt;/p&gt;

&lt;p&gt;If we want to start our bank account with an initial balance, we can add to the &amp;lsquo;BankAccount&amp;rsquo; class a constructor declaration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class BankAccount {  
    balance: number;  
    constructor(initially: number) {  
        this.balance = initially;  
    }  
    deposit(credit: number) {  
        this.balance += credit;  
        return this.balance;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version of the &amp;lsquo;BankAccount&amp;rsquo; class requires us to introduce a constructor parameter and then assign it to the &amp;lsquo;balance&amp;rsquo; field. To simplify this common case, TypeScript accepts the following shorthand syntax.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class BankAccount {  
    constructor(public balance: number) {  
    }  
    deposit(credit: number) {  
        this.balance += credit;  
        return this.balance;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;lsquo;public&amp;rsquo; keyword denotes that the constructor parameter is to be retained as a field. Public is the default accessibility for class members, but a programmer can also specify private or protected accessibility for a class member. Accessibility is a design-time construct; it is enforced during static type checking but does not imply any runtime enforcement.&lt;/p&gt;

&lt;p&gt;TypeScript classes also support inheritance, as in the following example.* *&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class CheckingAccount extends BankAccount {  
    constructor(balance: number) {  
        super(balance);  
    }  
    writeCheck(debit: number) {  
        this.balance -= debit;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, the class &amp;lsquo;CheckingAccount&amp;rsquo; &lt;em&gt;derives&lt;/em&gt; from class &amp;lsquo;BankAccount&amp;rsquo;. The constructor for &amp;lsquo;CheckingAccount&amp;rsquo; calls the constructor for class &amp;lsquo;BankAccount&amp;rsquo; using the &amp;lsquo;super&amp;rsquo; keyword. In the emitted JavaScript code, the prototype of &amp;lsquo;CheckingAccount&amp;rsquo; will chain to the prototype of &amp;lsquo;BankAccount&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;TypeScript classes may also specify static members. Static class members become properties of the class constructor.&lt;/p&gt;

&lt;p&gt;Section &lt;a href=&#34;#8&#34;&gt;8&lt;/a&gt; provides additional information about classes.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-7-1-7-enum-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.7&#34;/&gt;1.7 Enum Types&lt;/h2&gt;

&lt;p&gt;TypeScript enables programmers to summarize a set of numeric constants as an &lt;em&gt;enum type&lt;/em&gt;. The example below creates an enum type to represent operators in a calculator application.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;const enum Operator {  
    ADD,  
    DIV,  
    MUL,  
    SUB  
}

function compute(op: Operator, a: number, b: number) {  
    console.log(&amp;quot;the operator is&amp;quot; + Operator[op]);  
    // ...  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, the compute function logs the operator &amp;lsquo;op&amp;rsquo; using a feature of enum types: reverse mapping from the enum value (&amp;lsquo;op&amp;rsquo;) to the string corresponding to that value. For example, the declaration of &amp;lsquo;Operator&amp;rsquo; automatically assigns integers, starting from zero, to the listed enum members. Section &lt;a href=&#34;#9&#34;&gt;9&lt;/a&gt; describes how programmers can also explicitly assign integers to enum members, and can use any string to name an enum member.&lt;/p&gt;

&lt;p&gt;When enums are declared with the &lt;code&gt;const&lt;/code&gt; modifier, the TypeScript compiler will emit for an enum member a JavaScript constant corresponding to that member&amp;rsquo;s assigned value (annotated with a comment). This improves performance on many JavaScript engines.&lt;/p&gt;

&lt;p&gt;For example, the &amp;lsquo;compute&amp;rsquo; function could contain a switch statement like the following.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;switch (op) {  
    case Operator.ADD:  
        // execute add  
        break;  
    case Operator.DIV:  
        // execute div  
        break;  
    // ...  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this switch statement, the compiler will generate the following code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;switch (op) {  
    case 0 /* Operator.ADD */:  
        // execute add  
        break;  
    case 1 /* Operator.DIV */:  
        // execute div  
        break;  
    // ...  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript implementations can use these explicit constants to generate efficient code for this switch statement, for example by building a jump table indexed by case value.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-8-1-8-overloading-on-string-parameters:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.8&#34;/&gt;1.8 Overloading on String Parameters&lt;/h2&gt;

&lt;p&gt;An important goal of TypeScript is to provide accurate and straightforward types for existing JavaScript programming patterns. To that end, TypeScript includes generic types, discussed in the next section, and &lt;em&gt;overloading on string parameters&lt;/em&gt;, the topic of this section.&lt;/p&gt;

&lt;p&gt;JavaScript programming interfaces often include functions whose behavior is discriminated by a string constant passed to the function. The Document Object Model makes heavy use of this pattern. For example, the following screen shot shows that the &amp;lsquo;createElement&amp;rsquo; method of the &amp;lsquo;document&amp;rsquo; object has multiple signatures, some of which identify the types returned when specific strings are passed into the method.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;img src=&#34;http://alimy.me/images/post/20160202225903.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The following code fragment uses this feature. Because the &amp;lsquo;span&amp;rsquo; variable is inferred to have the type &amp;lsquo;HTMLSpanElement&amp;rsquo;, the code can reference without static error the &amp;lsquo;isMultiline&amp;rsquo; property of &amp;lsquo;span&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var span = document.createElement(&amp;quot;span&amp;quot;);  
span.isMultiLine = false;  // OK: HTMLSpanElement has isMultiline property
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the following screen shot, a programming tool combines information from overloading on string parameters with contextual typing to infer that the type of the variable &amp;lsquo;e&amp;rsquo; is &amp;lsquo;MouseEvent&amp;rsquo; and that therefore &amp;lsquo;e&amp;rsquo; has a &amp;lsquo;clientX&amp;rsquo; property.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;img src=&#34;http://alimy.me/images/post/20160202225904.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Section &lt;a href=&#34;#3.9.2.4&#34;&gt;3.9.2.4&lt;/a&gt; provides details on how to use string literals in function signatures.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-9-1-9-generic-types-and-functions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.9&#34;/&gt;1.9 Generic Types and Functions&lt;/h2&gt;

&lt;p&gt;Like overloading on string parameters, &lt;em&gt;generic types&lt;/em&gt; make it easier for TypeScript to accurately capture the behavior of JavaScript libraries. Because they enable type information to flow from client code, through library code, and back into client code, generic types may do more than any other TypeScript feature to support detailed API descriptions.&lt;/p&gt;

&lt;p&gt;To illustrate this, let&amp;rsquo;s take a look at part of the TypeScript interface for the built-in JavaScript array type. You can find this interface in the &amp;lsquo;lib.d.ts&amp;rsquo; file that accompanies a TypeScript distribution.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Array&amp;lt;T&amp;gt; {  
    reverse(): T[];  
    sort(compareFn?: (a: T, b: T) =&amp;gt; number): T[];  
    // ...   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interface definitions, like the one above, can have one or more &lt;em&gt;type parameters&lt;/em&gt;. In this case the &amp;lsquo;Array&amp;rsquo; interface has a single parameter, &amp;rsquo;T&amp;rsquo;, that defines the element type for the array. The &amp;lsquo;reverse&amp;rsquo; method returns an array with the same element type. The sort method takes an optional parameter, &amp;lsquo;compareFn&amp;rsquo;, whose type is a function that takes two parameters of type &amp;rsquo;T&amp;rsquo; and returns a number. Finally, sort returns an array with element type &amp;rsquo;T&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Functions can also have generic parameters. For example, the array interface contains a &amp;lsquo;map&amp;rsquo; method, defined as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;map&amp;lt;U&amp;gt;(func: (value: T, index: number, array: T[]) =&amp;gt; U, thisArg?: any): U[];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The map method, invoked on an array &amp;lsquo;a&amp;rsquo; with element type &amp;rsquo;T&amp;rsquo;, will apply function &amp;lsquo;func&amp;rsquo; to each element of &amp;lsquo;a&amp;rsquo;, returning a value of type &amp;lsquo;U&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;The TypeScript compiler can often infer generic method parameters, making it unnecessary for the programmer to explicitly provide them. In the following example, the compiler infers that parameter &amp;lsquo;U&amp;rsquo; of the map method has type &amp;lsquo;string&amp;rsquo;, because the function passed to map returns a string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function numberToString(a: number[]) {  
    var stringArray = a.map(v =&amp;gt; v.toString());  
    return stringArray;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler infers in this example that the &amp;lsquo;numberToString&amp;rsquo; function returns an array of strings.&lt;/p&gt;

&lt;p&gt;In TypeScript, classes can also have type parameters. The following code declares a class that implements a linked list of items of type &amp;rsquo;T&amp;rsquo;. This code illustrates how programmers can &lt;em&gt;constrain&lt;/em&gt; type parameters to extend a specific type. In this case, the items on the list must extend the type &amp;lsquo;NamedItem&amp;rsquo;. This enables the programmer to implement the &amp;lsquo;log&amp;rsquo; function, which logs the name of the item.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface NamedItem {  
    name: string;  
}

class List&amp;lt;T extends NamedItem&amp;gt; {  
    next: List&amp;lt;T&amp;gt; = null;

    constructor(public item: T) {  
    }

    insertAfter(item: T) {  
        var temp = this.next;  
        this.next = new List(item);  
        this.next.next = temp;  
    }

    log() {  
        console.log(this.item.name);  
    }

    // ...  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Section &lt;a href=&#34;#3.7&#34;&gt;3.7&lt;/a&gt; provides further information about generic types.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-10-1-10-namespaces:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.10&#34;/&gt;1.10 Namespaces&lt;/h2&gt;

&lt;p&gt;Classes and interfaces support large-scale JavaScript development by providing a mechanism for describing how to use a software component that can be separated from that component&amp;rsquo;s implementation. TypeScript enforces &lt;em&gt;encapsulation&lt;/em&gt; of implementation in classes at design time (by restricting use of private and protected members), but cannot enforce encapsulation at runtime because all object properties are accessible at runtime. Future versions of JavaScript may provide &lt;em&gt;private names&lt;/em&gt; which would enable runtime enforcement of private and protected members.&lt;/p&gt;

&lt;p&gt;In JavaScript, a very common way to enforce encapsulation at runtime is to use the module pattern: encapsulate private fields and methods using closure variables. The module pattern is a natural way to provide organizational structure and dynamic loading options by drawing a boundary around a software component. The module pattern can also provide the ability to introduce namespaces, avoiding use of the global namespace for most software components.&lt;/p&gt;

&lt;p&gt;The following example illustrates the JavaScript module pattern.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;(function(exports) {  
    var key = generateSecretKey();  
    function sendMessage(message) {  
        sendSecureMessage(message, key);  
    }  
    exports.sendMessage = sendMessage;  
})(MessageModule);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example illustrates the two essential elements of the module pattern: a &lt;em&gt;module closure&lt;/em&gt; and a &lt;em&gt;module&lt;/em&gt; &lt;em&gt;object&lt;/em&gt;. The module closure is a function that encapsulates the module&amp;rsquo;s implementation, in this case the variable &amp;lsquo;key&amp;rsquo; and the function &amp;lsquo;sendMessage&amp;rsquo;. The module object contains the exported variables and functions of the module. Simple modules may create and return the module object. The module above takes the module object as a parameter, &amp;lsquo;exports&amp;rsquo;, and adds the &amp;lsquo;sendMessage&amp;rsquo; property to the module object. This &lt;em&gt;augmentation&lt;/em&gt; approach simplifies dynamic loading of modules and also supports separation of module code into multiple files.&lt;/p&gt;

&lt;p&gt;The example assumes that an outer lexical scope defines the functions &amp;lsquo;generateSecretKey&amp;rsquo; and &amp;lsquo;sendSecureMessage&amp;rsquo;; it also assumes that the outer scope has assigned the module object to the variable &amp;lsquo;MessageModule&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;TypeScript namespaces provide a mechanism for succinctly expressing the module pattern. In TypeScript, programmers can combine the module pattern with the class pattern by nesting namespaces and classes within an outer namespace.&lt;/p&gt;

&lt;p&gt;The following example shows the definition and use of a simple namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;namespace M {  
    var s = &amp;quot;hello&amp;quot;;  
    export function f() {  
        return s;  
    }  
}

M.f();  
M.s;  // Error, s is not exported
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, variable &amp;rsquo;s&amp;rsquo; is a private feature of the namespace, but function &amp;lsquo;f&amp;rsquo; is exported from the namespace and accessible to code outside of the namespace. If we were to describe the effect of namespace &amp;rsquo;M&amp;rsquo; in terms of interfaces and variables, we would write&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface M {  
    f(): string;  
}

var M: M;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interface &amp;rsquo;M&amp;rsquo; summarizes the externally visible behavior of namespace &amp;rsquo;M&amp;rsquo;. In this example, we can use the same name for the interface as for the initialized variable because in TypeScript type names and variable names do not conflict: each lexical scope contains a variable declaration space and type declaration space (see section &lt;a href=&#34;#2.3&#34;&gt;2.3&lt;/a&gt; for more details).&lt;/p&gt;

&lt;p&gt;The TypeScript compiler emits the following JavaScript code for the namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var M;  
(function(M) {  
    var s = &amp;quot;hello&amp;quot;;  
    function f() {  
        return s;  
    }  
    M.f = f;  
})(M || (M = {}));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the compiler assumes that the namespace object resides in global variable &amp;rsquo;M&amp;rsquo;, which may or may not have been initialized to the desired namespace object.&lt;/p&gt;

&lt;h2 id=&#34;a-name-1-11-1-11-modules:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;1.11&#34;/&gt;1.11 Modules&lt;/h2&gt;

&lt;p&gt;TypeScript also supports ECMAScript 2015 modules, which are files that contain top-level &lt;em&gt;export&lt;/em&gt; and &lt;em&gt;import&lt;/em&gt; directives. For this type of module the TypeScript compiler can emit both ECMAScript 2015 compliant code and down-level ECMAScript 3 or 5 compliant code for a variety of module loading systems, including CommonJS, Asynchronous Module Definition (AMD), and Universal Module Definition (UMD).&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-2-2-basic-concepts:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;2&#34;/&gt;2 Basic Concepts&lt;/h1&gt;

&lt;p&gt;The remainder of this document is the formal specification of the TypeScript programming language and is intended to be read as an adjunct to the &lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/&#34;&gt;ECMAScript 2015 Language Specification&lt;/a&gt; (specifically, the ECMA-262 Standard, 6th Edition). This document describes the syntactic grammar added by TypeScript along with the compile-time processing and type checking performed by the TypeScript compiler, but it only minimally discusses the run-time behavior of programs since that is covered by the ECMAScript specification.&lt;/p&gt;

&lt;h2 id=&#34;a-name-2-1-2-1-grammar-conventions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;2.1&#34;/&gt;2.1 Grammar Conventions&lt;/h2&gt;

&lt;p&gt;The syntactic grammar added by TypeScript language is specified throughout this document using the existing conventions and production names of the ECMAScript grammar. In places where TypeScript augments an existing grammar production it is so noted. For example:&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;Declaration:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;…&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The &amp;lsquo;&lt;em&gt;( Modified )&lt;/em&gt;&amp;rsquo; annotation indicates that an existing grammar production is being replaced, and the &amp;lsquo;…&amp;rsquo; references the contents of the original grammar production.&lt;/p&gt;

&lt;p&gt;Similar to the ECMAScript grammar, if the phrase &amp;ldquo;&lt;em&gt;[no LineTerminator here]&lt;/em&gt;&amp;rdquo; appears in the right-hand side of a production of the syntactic grammar, it indicates that the production is not a match if a &lt;em&gt;LineTerminator&lt;/em&gt; occurs in the input stream at the indicated position.&lt;/p&gt;

&lt;h2 id=&#34;a-name-2-2-2-2-names:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;2.2&#34;/&gt;2.2 Names&lt;/h2&gt;

&lt;p&gt;A core purpose of the TypeScript compiler is to track the named entities in a program and validate that they are used according to their designated meaning. Names in TypeScript can be written in several ways, depending on context. Specifically, a name can be written as&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;an &lt;em&gt;IdentifierName&lt;/em&gt;,&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;StringLiteral&lt;/em&gt; in a property name,&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;NumericLiteral&lt;/em&gt; in a property name, or&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;ComputedPropertyName&lt;/em&gt; that denotes a well-known symbol (&lt;a href=&#34;#2.2.3&#34;&gt;2.2.3&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most commonly, names are written to conform with the &lt;em&gt;Identifier&lt;/em&gt; production, which is any &lt;em&gt;IdentifierName&lt;/em&gt; that isn&amp;rsquo;t a reserved word.&lt;/p&gt;

&lt;h3 id=&#34;a-name-2-2-1-2-2-1-reserved-words:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;2.2.1&#34;/&gt;2.2.1 Reserved Words&lt;/h3&gt;

&lt;p&gt;The following keywords are reserved and cannot be used as an &lt;em&gt;Identifier&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;break             case              catch             class  
const             continue          debugger          default  
delete            do                else              enum  
export            extends           false             finally  
for               function          if                import  
in                instanceof        new               null  
return            super             switch            this  
throw             true              try               typeof  
var               void              while             with
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following keywords cannot be used as identifiers in strict mode code, but are otherwise not restricted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;implements        interface         let               package  
private           protected         public            static  
yield
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following keywords cannot be used as user defined type names, but are otherwise not restricted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;any               boolean           number            string  
symbol
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following keywords have special meaning in certain contexts, but are valid identifiers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;abstract          as                async             await  
constructor       declare           from              get  
is                module            namespace         of  
require           set               type
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-2-2-2-2-2-2-property-names:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;2.2.2&#34;/&gt;2.2.2 Property Names&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;PropertyName&lt;/em&gt; production from the ECMAScript grammar is reproduced below:&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;LiteralPropertyName&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ComputedPropertyName&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;LiteralPropertyName:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierName&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;StringLiteral&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NumericLiteral&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ComputedPropertyName:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;[&lt;/code&gt;&amp;emsp;&lt;em&gt;AssignmentExpression&lt;/em&gt;&amp;emsp;&lt;code&gt;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A property name can be any identifier (including a reserved word), a string literal, a numeric literal, or a computed property name. String literals may be used to give properties names that are not valid identifiers, such as names containing blanks. Numeric literal property names are equivalent to string literal property names with the string representation of the numeric literal, as defined in the ECMAScript specification.&lt;/p&gt;

&lt;h3 id=&#34;a-name-2-2-3-2-2-3-computed-property-names:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;2.2.3&#34;/&gt;2.2.3 Computed Property Names&lt;/h3&gt;

&lt;p&gt;ECMAScript 2015 permits object literals and classes to declare members with computed property names. A computed property name specifies an expression that computes the actual property name at run-time. Because the final property name isn&amp;rsquo;t known at compile-time, TypeScript can only perform limited checks for entities declared with computed property names. However, a subset of computed property names known as &lt;strong&gt;&lt;em&gt;well-known symbols&lt;/em&gt;&lt;/strong&gt; can be used anywhere a &lt;em&gt;PropertyName&lt;/em&gt; is expected, including property names within types. A computed property name is a well-known symbol if it is of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;[ Symbol . xxx ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a well-known symbol, the identifier to the right of the dot must denote a property of the primitive type &lt;code&gt;symbol&lt;/code&gt; in the type of the global variable &amp;lsquo;Symbol&amp;rsquo;, or otherwise an error occurs.&lt;/p&gt;

&lt;p&gt;In a &lt;em&gt;PropertyName&lt;/em&gt; that specifies a &lt;em&gt;ComputedPropertyName&lt;/em&gt;, the computed property name is required to denote a well-known symbol unless the property name occurs in a property assignment of an object literal (&lt;a href=&#34;#4.5&#34;&gt;4.5&lt;/a&gt;) or a property member declaration in a non-ambient class (&lt;a href=&#34;#8.4&#34;&gt;8.4&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Below is an example of an interface that declares a property with a well-known symbol name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Iterable&amp;lt;T&amp;gt; {  
    [Symbol.iterator](): Iterator&amp;lt;T&amp;gt;;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;TODO: Update to reflect treatment of &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/5535&#34;&gt;computed property names with literal expressions&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-2-3-2-3-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;2.3&#34;/&gt;2.3 Declarations&lt;/h2&gt;

&lt;p&gt;Declarations introduce names in their associated &lt;strong&gt;&lt;em&gt;declaration spaces&lt;/em&gt;&lt;/strong&gt;. A name must be unique in its declaration space and can denote a &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt;, a &lt;strong&gt;&lt;em&gt;type&lt;/em&gt;&lt;/strong&gt;, or a &lt;strong&gt;&lt;em&gt;namespace&lt;/em&gt;&lt;/strong&gt;, or some combination thereof. Effectively, a single name can have as many as three distinct meanings. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var X: string;    // Value named X

type X = number;  // Type named X

namespace X {     // Namespace named X  
    type Y = string;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A name that denotes a value has an associated type (section &lt;a href=&#34;#3&#34;&gt;3&lt;/a&gt;) and can be referenced in expressions (section &lt;a href=&#34;#4.3&#34;&gt;4.3&lt;/a&gt;). A name that denotes a type can be used by itself in a type reference or on the right hand side of a dot in a type reference (&lt;a href=&#34;#3.8.2&#34;&gt;3.8.2&lt;/a&gt;). A name that denotes a namespace can be used one the left hand side of a dot in a type reference.&lt;/p&gt;

&lt;p&gt;When a name with multiple meanings is referenced, the context in which the reference occurs determines the meaning. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var n: X;        // X references type  
var s: X.Y = X;  // First X references namespace, second X references value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first line, X references the type X because it occurs in a type position. In the second line, the first X references the namespace X because it occurs before a dot in a type name, and the second X references the variable X because it occurs in an expression.&lt;/p&gt;

&lt;p&gt;Declarations introduce the following meanings for the name they declare:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A variable, parameter, function, generator, member variable, member function, member accessor, or enum member declaration introduces a value meaning.&lt;/li&gt;
&lt;li&gt;An interface, type alias, or type parameter declaration introduces a type meaning.&lt;/li&gt;
&lt;li&gt;A class declaration introduces a value meaning (the constructor function) and a type meaning (the class type).&lt;/li&gt;
&lt;li&gt;An enum declaration introduces a value meaning (the enum instance) and a type meaning (the enum type).&lt;/li&gt;
&lt;li&gt;A namespace declaration introduces a namespace meaning (the type and namespace container) and, if the namespace is instantiated (section &lt;a href=&#34;#10.1&#34;&gt;10.1&lt;/a&gt;), a value meaning (the namespace instance).&lt;/li&gt;
&lt;li&gt;An import or export declaration introduces the meaning(s) of the imported or exported entity.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Below are some examples of declarations that introduce multiple meanings for a name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class C {      // Value and type named C  
    x: string;  
}

namespace N {  // Value and namespace named N  
    export var x: string;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declaration spaces exist as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The global namespace, each module, and each declared namespace has a declaration space for its contained entities (whether local or exported).&lt;/li&gt;
&lt;li&gt;Each module has a declaration space for its exported entities. All export declarations in the module contribute to this declaration space.&lt;/li&gt;
&lt;li&gt;Each declared namespace has a declaration space for its exported entities. All export declarations in the namespace contribute to this declaration space. A declared namespace’s declaration space is shared with other declared namespaces that have the same root container and the same qualified name starting from that root container.&lt;/li&gt;
&lt;li&gt;Each class declaration has a declaration space for instance members and type parameters, and a declaration space for static members.&lt;/li&gt;
&lt;li&gt;Each interface declaration has a declaration space for members and type parameters. An interface&amp;rsquo;s declaration space is shared with other interfaces that have the same root container and the same qualified name starting from that root container.&lt;/li&gt;
&lt;li&gt;Each enum declaration has a declaration space for its enum members. An enum&amp;rsquo;s declaration space is shared with other enums that have the same root container and the same qualified name starting from that root container.&lt;/li&gt;
&lt;li&gt;Each type alias declaration has a declaration space for its type parameters.&lt;/li&gt;
&lt;li&gt;Each function-like declaration (including function declarations, constructor declarations, member function declarations, member accessor declarations, function expressions, and arrow functions) has a declaration space for locals and type parameters. This declaration space includes parameter declarations, all local var and function declarations, and local let, const, class, interface, type alias, and enum declarations that occur immediately within the function body and are not further nested in blocks.&lt;/li&gt;
&lt;li&gt;Each statement block has a declaration space for local let, const, class, interface, type alias, and enum declarations that occur immediately within that block.&lt;/li&gt;
&lt;li&gt;Each object literal has a declaration space for its properties.&lt;/li&gt;
&lt;li&gt;Each object type literal has a declaration space for its members.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Top-level declarations in a source file with no top-level import or export declarations belong to the &lt;strong&gt;&lt;em&gt;global namespace&lt;/em&gt;&lt;/strong&gt;. Top-level declarations in a source file with one or more top-level import or export declarations belong to the &lt;strong&gt;&lt;em&gt;module&lt;/em&gt;&lt;/strong&gt; represented by that source file.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;&lt;em&gt;container&lt;/em&gt;&lt;/strong&gt; of an entity is defined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The container of an entity declared in a namespace declaration is that namespace declaration.&lt;/li&gt;
&lt;li&gt;The container of an entity declared in a module is that module.&lt;/li&gt;
&lt;li&gt;The container of an entity declared in the global namespace is the global namespace.&lt;/li&gt;
&lt;li&gt;The container of a module is the global namespace.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;strong&gt;&lt;em&gt;root container&lt;/em&gt;&lt;/strong&gt; of an entity is defined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The root container of a non-exported entity is the entity’s container.&lt;/li&gt;
&lt;li&gt;The root container of an exported entity is the root container of the entity&amp;rsquo;s container.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Intuitively, the root container of an entity is the outermost module or namespace body from within which the entity is reachable.&lt;/p&gt;

&lt;p&gt;Interfaces, enums, and namespaces are &amp;ldquo;open ended,&amp;rdquo; meaning that interface, enum, and namespace declarations with the same qualified name relative to a common root are automatically merged. For further details, see sections &lt;a href=&#34;#7.2&#34;&gt;7.2&lt;/a&gt;, &lt;a href=&#34;#9.3&#34;&gt;9.3&lt;/a&gt;, and &lt;a href=&#34;#10.5&#34;&gt;10.5&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Instance and static members in a class are in separate declaration spaces. Thus the following is permitted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class C {  
    x: number;          // Instance member  
    static x: string;   // Static member  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-2-4-2-4-scopes:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;2.4&#34;/&gt;2.4 Scopes&lt;/h2&gt;

&lt;p&gt;The &lt;strong&gt;&lt;em&gt;scope&lt;/em&gt;&lt;/strong&gt; of a name is the region of program text within which it is possible to refer to the entity declared by that name without qualification of the name. The scope of a name depends on the context in which the name is declared. The contexts are listed below in order from outermost to innermost:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The scope of a name declared in the global namespace is the entire program text.&lt;/li&gt;
&lt;li&gt;The scope of a name declared in a module is the source file of that module.&lt;/li&gt;
&lt;li&gt;The scope of an exported name declared within a namespace declaration is the body of that namespace declaration and every namespace declaration with the same root and the same qualified name relative to that root.&lt;/li&gt;
&lt;li&gt;The scope of a non-exported name declared within a namespace declaration is the body of that namespace declaration.&lt;/li&gt;
&lt;li&gt;The scope of a type parameter name declared in a class or interface declaration is that entire declaration, including constraints, extends clause, implements clause, and declaration body, but not including static member declarations.&lt;/li&gt;
&lt;li&gt;The scope of a type parameter name declared in a type alias declaration is that entire type alias declaration.&lt;/li&gt;
&lt;li&gt;The scope of a member name declared in an enum declaration is the body of that declaration and every enum declaration with the same root and the same qualified name relative to that root.&lt;/li&gt;
&lt;li&gt;The scope of a type parameter name declared in a call or construct signature is that entire signature declaration, including constraints, parameter list, and return type. If the signature is part of a function implementation, the scope includes the function body.&lt;/li&gt;
&lt;li&gt;The scope of a parameter name declared in a call or construct signature is the remainder of the signature declaration. If the signature is part of a function-like declaration with a body (including a function declaration, constructor declaration, member function declaration, member accessor declaration, function expression, or arrow function), the scope includes the body of that function-like declaration.&lt;/li&gt;
&lt;li&gt;The scope of a local var or function name declared anywhere in the body of a function-like declaration is the body of that function-like declaration.&lt;/li&gt;
&lt;li&gt;The scope of a local let, const, class, interface, type alias, or enum declaration declared immediately within the body of a function-like declaration is the body of that function-like declaration.&lt;/li&gt;
&lt;li&gt;The scope of a local let, const, class, interface, type alias, or enum declaration declared immediately within a statement block is the body of that statement block.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scopes may overlap, for example through nesting of namespaces and functions. When the scopes of two names overlap, the name with the innermost declaration takes precedence and access to the outer name is either not possible or only possible by qualification.&lt;/p&gt;

&lt;p&gt;When an identifier is resolved as a &lt;em&gt;PrimaryExpression&lt;/em&gt; (section &lt;a href=&#34;#4.3&#34;&gt;4.3&lt;/a&gt;), only names in scope with a value meaning are considered and other names are ignored.&lt;/p&gt;

&lt;p&gt;When an identifier is resolved as a &lt;em&gt;TypeName&lt;/em&gt; (section &lt;a href=&#34;#3.8.2&#34;&gt;3.8.2&lt;/a&gt;), only names in scope with a type meaning are considered and other names are ignored.&lt;/p&gt;

&lt;p&gt;When an identifier is resolved as a &lt;em&gt;NamespaceName&lt;/em&gt; (section &lt;a href=&#34;#3.8.2&#34;&gt;3.8.2&lt;/a&gt;), only names in scope with a namespace meaning are considered and other names are ignored.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/3158&#34;&gt;Include specific rules for alias resolution&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Note that class and interface members are never directly in scope—they can only be accessed by applying the dot (&amp;lsquo;.&amp;rsquo;) operator to a class or interface instance. This even includes members of the current instance in a constructor or member function, which are accessed by applying the dot operator to &lt;code&gt;this&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As the rules above imply, locally declared entities in a namespace are closer in scope than exported entities declared in other namespace declarations for the same namespace. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x = 1;  
namespace M {  
    export var x = 2;  
    console.log(x);     // 2  
}  
namespace M {  
    console.log(x);     // 2  
}  
namespace M {  
    var x = 3;  
    console.log(x);     // 3  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-3-3-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3&#34;/&gt;3 Types&lt;/h1&gt;

&lt;p&gt;TypeScript adds optional static types to JavaScript. Types are used to place static constraints on program entities such as functions, variables, and properties so that compilers and development tools can offer better verification and assistance during software development. TypeScript&amp;rsquo;s &lt;em&gt;static&lt;/em&gt; compile-time type system closely models the &lt;em&gt;dynamic&lt;/em&gt; run-time type system of JavaScript, allowing programmers to accurately express the type relationships that are expected to exist when their programs run and have those assumptions pre-validated by the TypeScript compiler. TypeScript&amp;rsquo;s type analysis occurs entirely at compile-time and adds no run-time overhead to program execution.&lt;/p&gt;

&lt;p&gt;All types in TypeScript are subtypes of a single top type called the Any type. The &lt;code&gt;any&lt;/code&gt; keyword references this type. The Any type is the one type that can represent &lt;em&gt;any&lt;/em&gt; JavaScript value with no constraints. All other types are categorized as &lt;strong&gt;&lt;em&gt;primitive types&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;object types&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;union types&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;intersection types&lt;/em&gt;&lt;/strong&gt;, or &lt;strong&gt;&lt;em&gt;type parameters&lt;/em&gt;&lt;/strong&gt;. These types introduce various static constraints on their values.&lt;/p&gt;

&lt;p&gt;The primitive types are the Number, Boolean, String, Symbol, Void, Null, and Undefined types along with user defined enum types. The &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, and &lt;code&gt;void&lt;/code&gt; keywords reference the Number, Boolean, String, Symbol, and Void primitive types respectively. The Void type exists purely to indicate the absence of a value, such as in a function with no return value. It is not possible to explicitly reference the Null and Undefined types—only &lt;em&gt;values&lt;/em&gt; of those types can be referenced, using the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; literals.&lt;/p&gt;

&lt;p&gt;The object types are all class, interface, array, tuple, function, and constructor types. Class and interface types are introduced through class and interface declarations and are referenced by the name given to them in their declarations. Class and interface types may be &lt;strong&gt;&lt;em&gt;generic types&lt;/em&gt;&lt;/strong&gt; which have one or more type parameters.&lt;/p&gt;

&lt;p&gt;Union types represent values that have one of multiple types, and intersection types represent values that simultaneously have more than one type.&lt;/p&gt;

&lt;p&gt;Declarations of classes, properties, functions, variables and other language entities associate types with those entities. The mechanism by which a type is formed and associated with a language entity depends on the particular kind of entity. For example, a namespace declaration associates the namespace with an anonymous type containing a set of properties corresponding to the exported variables and functions in the namespace, and a function declaration associates the function with an anonymous type containing a call signature corresponding to the parameters and return type of the function. Types can be associated with variables through explicit &lt;strong&gt;&lt;em&gt;type annotations&lt;/em&gt;&lt;/strong&gt;, such as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x: number;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or through implicit &lt;strong&gt;&lt;em&gt;type inference&lt;/em&gt;&lt;/strong&gt;, as in&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which infers the type of &amp;lsquo;x&amp;rsquo; to be the Number primitive type because that is the type of the value used to initialize &amp;lsquo;x&amp;rsquo;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-3-1-3-1-the-any-type:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.1&#34;/&gt;3.1 The Any Type&lt;/h2&gt;

&lt;p&gt;The Any type is used to represent any JavaScript value. A value of the Any type supports the same operations as a value in JavaScript and minimal static type checking is performed for operations on Any values. Specifically, properties of any name can be accessed through an Any value and Any values can be called as functions or constructors with any argument list.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;any&lt;/code&gt; keyword references the Any type. In general, in places where a type is not explicitly provided and TypeScript cannot infer one, the Any type is assumed.&lt;/p&gt;

&lt;p&gt;The Any type is a supertype of all types, and is assignable to and from all types.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x: any;             // Explicitly typed  
var y;                  // Same as y: any  
var z: { a; b; };       // Same as z: { a: any; b: any; }

function f(x) {         // Same as f(x: any): void  
    console.log(x);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-3-2-3-2-primitive-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.2&#34;/&gt;3.2 Primitive Types&lt;/h2&gt;

&lt;p&gt;The primitive types are the Number, Boolean, String, Symbol, Void, Null, and Undefined types and all user defined enum types.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-2-1-3-2-1-the-number-type:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.2.1&#34;/&gt;3.2.1 The Number Type&lt;/h3&gt;

&lt;p&gt;The Number primitive type corresponds to the similarly named JavaScript primitive type and represents double-precision 64-bit format IEEE 754 floating point values.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;number&lt;/code&gt; keyword references the Number primitive type and numeric literals may be used to write values of the Number primitive type.&lt;/p&gt;

&lt;p&gt;For purposes of determining type relationships (section &lt;a href=&#34;#3.11&#34;&gt;3.11&lt;/a&gt;) and accessing properties (section &lt;a href=&#34;#4.13&#34;&gt;4.13&lt;/a&gt;), the Number primitive type behaves as an object type with the same properties as the global interface type &amp;lsquo;Number&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x: number;          // Explicitly typed  
var y = 0;              // Same as y: number = 0  
var z = 123.456;        // Same as z: number = 123.456  
var s = z.toFixed(2);   // Property of Number interface
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-2-2-3-2-2-the-boolean-type:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.2.2&#34;/&gt;3.2.2 The Boolean Type&lt;/h3&gt;

&lt;p&gt;The Boolean primitive type corresponds to the similarly named JavaScript primitive type and represents logical values that are either true or false.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;boolean&lt;/code&gt; keyword references the Boolean primitive type and the &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; literals reference the two Boolean truth values.&lt;/p&gt;

&lt;p&gt;For purposes of determining type relationships (section &lt;a href=&#34;#3.11&#34;&gt;3.11&lt;/a&gt;) and accessing properties (section &lt;a href=&#34;#4.13&#34;&gt;4.13&lt;/a&gt;), the Boolean primitive type behaves as an object type with the same properties as the global interface type &amp;lsquo;Boolean&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var b: boolean;         // Explicitly typed  
var yes = true;         // Same as yes: boolean = true  
var no = false;         // Same as no: boolean = false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-2-3-3-2-3-the-string-type:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.2.3&#34;/&gt;3.2.3 The String Type&lt;/h3&gt;

&lt;p&gt;The String primitive type corresponds to the similarly named JavaScript primitive type and represents sequences of characters stored as Unicode UTF-16 code units.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;string&lt;/code&gt; keyword references the String primitive type and string literals may be used to write values of the String primitive type.&lt;/p&gt;

&lt;p&gt;For purposes of determining type relationships (section &lt;a href=&#34;#3.11&#34;&gt;3.11&lt;/a&gt;) and accessing properties (section &lt;a href=&#34;#4.13&#34;&gt;4.13&lt;/a&gt;), the String primitive type behaves as an object type with the same properties as the global interface type &amp;lsquo;String&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var s: string;          // Explicitly typed  
var empty = &amp;quot;&amp;quot;;         // Same as empty: string = &amp;quot;&amp;quot;  
var abc = &#39;abc&#39;;        // Same as abc: string = &amp;quot;abc&amp;quot;  
var c = abc.charAt(2);  // Property of String interface
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-2-4-3-2-4-the-symbol-type:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.2.4&#34;/&gt;3.2.4 The Symbol Type&lt;/h3&gt;

&lt;p&gt;The Symbol primitive type corresponds to the similarly named JavaScript primitive type and represents unique tokens that may be used as keys for object properties.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;symbol&lt;/code&gt; keyword references the Symbol primitive type. Symbol values are obtained using the global object &amp;lsquo;Symbol&amp;rsquo; which has a number of methods and properties and can be invoked as a function. In particular, the global object &amp;lsquo;Symbol&amp;rsquo; defines a number of well-known symbols (&lt;a href=&#34;#2.2.3&#34;&gt;2.2.3&lt;/a&gt;) that can be used in a manner similar to identifiers. Note that the &amp;lsquo;Symbol&amp;rsquo; object is available only in ECMAScript 2015 environments.&lt;/p&gt;

&lt;p&gt;For purposes of determining type relationships (section &lt;a href=&#34;#3.11&#34;&gt;3.11&lt;/a&gt;) and accessing properties (section &lt;a href=&#34;#4.13&#34;&gt;4.13&lt;/a&gt;), the Symbol primitive type behaves as an object type with the same properties as the global interface type &amp;lsquo;Symbol&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var secretKey = Symbol();  
var obj = {};  
obj[secretKey] = &amp;quot;secret message&amp;quot;;  // Use symbol as property key  
obj[Symbol.toStringTag] = &amp;quot;test&amp;quot;;   // Use of well-known symbol
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-2-5-3-2-5-the-void-type:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.2.5&#34;/&gt;3.2.5 The Void Type&lt;/h3&gt;

&lt;p&gt;The Void type, referenced by the &lt;code&gt;void&lt;/code&gt; keyword, represents the absence of a value and is used as the return type of functions with no return value.&lt;/p&gt;

&lt;p&gt;The only possible values for the Void type are &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;. The Void type is a subtype of the Any type and a supertype of the Null and Undefined types, but otherwise Void is unrelated to all other types.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: We might consider disallowing declaring variables of type Void as they serve no useful purpose. However, because Void is permitted as a type argument to a generic type or function it is not feasible to disallow Void properties or parameters&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-2-6-3-2-6-the-null-type:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.2.6&#34;/&gt;3.2.6 The Null Type&lt;/h3&gt;

&lt;p&gt;The Null type corresponds to the similarly named JavaScript primitive type and is the type of the &lt;code&gt;null&lt;/code&gt; literal.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;null&lt;/code&gt; literal references the one and only value of the Null type. It is not possible to directly reference the Null type itself.&lt;/p&gt;

&lt;p&gt;The Null type is a subtype of all types, except the Undefined type. This means that &lt;code&gt;null&lt;/code&gt; is considered a valid value for all primitive types, object types, union types, intersection types, and type parameters, including even the Number and Boolean primitive types.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var n: number = null;   // Primitives can be null  
var x = null;           // Same as x: any = null  
var e: Null;            // Error, can&#39;t reference Null type
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-2-7-3-2-7-the-undefined-type:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.2.7&#34;/&gt;3.2.7 The Undefined Type&lt;/h3&gt;

&lt;p&gt;The Undefined type corresponds to the similarly named JavaScript primitive type and is the type of the &lt;code&gt;undefined&lt;/code&gt; literal.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;undefined&lt;/code&gt; literal denotes the value given to all uninitialized variables and is the one and only value of the Undefined type. It is not possible to directly reference the Undefined type itself.&lt;/p&gt;

&lt;p&gt;The undefined type is a subtype of all types. This means that &lt;code&gt;undefined&lt;/code&gt; is considered a valid value for all primitive types, object types, union types, intersection types, and type parameters.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var n: number;          // Same as n: number = undefined  
var x = undefined;      // Same as x: any = undefined  
var e: Undefined;       // Error, can&#39;t reference Undefined type
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-2-8-3-2-8-enum-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.2.8&#34;/&gt;3.2.8 Enum Types&lt;/h3&gt;

&lt;p&gt;Enum types are distinct user defined subtypes of the Number primitive type. Enum types are declared using enum declarations (section &lt;a href=&#34;#9.1&#34;&gt;9.1&lt;/a&gt;) and referenced using type references (section &lt;a href=&#34;#3.8.2&#34;&gt;3.8.2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Enum types are assignable to the Number primitive type, and vice versa, but different enum types are not assignable to each other.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-2-9-3-2-9-string-literal-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.2.9&#34;/&gt;3.2.9 String Literal Types&lt;/h3&gt;

&lt;p&gt;Specialized signatures (section &lt;a href=&#34;#3.9.2.4&#34;&gt;3.9.2.4&lt;/a&gt;) permit string literals to be used as types in parameter type annotations. String literal types are permitted only in that context and nowhere else.&lt;/p&gt;

&lt;p&gt;All string literal types are subtypes of the String primitive type.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Update to reflect &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/5185&#34;&gt;expanded support for string literal types&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-3-3-3-3-object-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.3&#34;/&gt;3.3 Object Types&lt;/h2&gt;

&lt;p&gt;Object types are composed from properties, call signatures, construct signatures, and index signatures, collectively called members.&lt;/p&gt;

&lt;p&gt;Class and interface type references, array types, tuple types, function types, and constructor types are all classified as object types. Multiple constructs in the TypeScript language create object types, including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object type literals (section &lt;a href=&#34;#3.8.3&#34;&gt;3.8.3&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Array type literals (section &lt;a href=&#34;#3.8.4&#34;&gt;3.8.4&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Tuple type literals (section &lt;a href=&#34;#3.8.5&#34;&gt;3.8.5&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Function type literals (section &lt;a href=&#34;#3.8.8&#34;&gt;3.8.8&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Constructor type literals (section &lt;a href=&#34;#3.8.9&#34;&gt;3.8.9&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Object literals (section &lt;a href=&#34;#4.5&#34;&gt;4.5&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Array literals (section &lt;a href=&#34;#4.6&#34;&gt;4.6&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Function expressions (section &lt;a href=&#34;#4.10&#34;&gt;4.10&lt;/a&gt;) and function declarations (&lt;a href=&#34;#6.1&#34;&gt;6.1&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Constructor function types created by class declarations (section &lt;a href=&#34;#8.2.5&#34;&gt;8.2.5&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Namespace instance types created by namespace declarations (section &lt;a href=&#34;#10.3&#34;&gt;10.3&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;a-name-3-3-1-3-3-1-named-type-references:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.3.1&#34;/&gt;3.3.1 Named Type References&lt;/h3&gt;

&lt;p&gt;Type references (section &lt;a href=&#34;#3.8.2&#34;&gt;3.8.2&lt;/a&gt;) to class and interface types are classified as object types. Type references to generic class and interface types include type arguments that are substituted for the type parameters of the class or interface to produce an actual object type.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-3-2-3-3-2-array-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.3.2&#34;/&gt;3.3.2 Array Types&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Array types&lt;/em&gt;&lt;/strong&gt; represent JavaScript arrays with a common element type. Array types are named type references created from the generic interface type &amp;lsquo;Array&amp;rsquo; in the global namespace with the array element type as a type argument. Array type literals (section &lt;a href=&#34;#3.8.4&#34;&gt;3.8.4&lt;/a&gt;) provide a shorthand notation for creating such references.&lt;/p&gt;

&lt;p&gt;The declaration of the &amp;lsquo;Array&amp;rsquo; interface includes a property &amp;lsquo;length&amp;rsquo; and a numeric index signature for the element type, along with other members:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Array&amp;lt;T&amp;gt; {  
    length: number;  
    [x: number]: T;  
    // Other members  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Array literals (section &lt;a href=&#34;#4.6&#34;&gt;4.6&lt;/a&gt;) may be used to create values of array types. For example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var a: string[] = [&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A type is said to be an &lt;strong&gt;&lt;em&gt;array-like type&lt;/em&gt;&lt;/strong&gt; if it is assignable (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) to the type &lt;code&gt;any[]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-3-3-3-3-3-tuple-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.3.3&#34;/&gt;3.3.3 Tuple Types&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Tuple types&lt;/em&gt;&lt;/strong&gt; represent JavaScript arrays with individually tracked element types. Tuple types are written using tuple type literals (section &lt;a href=&#34;#3.8.5&#34;&gt;3.8.5&lt;/a&gt;). A tuple type combines a set of numerically named properties with the members of an array type. Specifically, a tuple type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;[ T0, T1, ..., Tn ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;combines the set of properties&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{  
    0: T0;  
    1: T1;  
    ...  
    n: Tn;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with the members of an array type whose element type is the union type (section &lt;a href=&#34;#3.4&#34;&gt;3.4&lt;/a&gt;) of the tuple element types.&lt;/p&gt;

&lt;p&gt;Array literals (section &lt;a href=&#34;#4.6&#34;&gt;4.6&lt;/a&gt;) may be used to create values of tuple types. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var t: [number, string] = [3, &amp;quot;three&amp;quot;];  
var n = t[0];  // Type of n is number  
var s = t[1];  // Type of s is string  
var i: number;  
var x = t[i];  // Type of x is number | string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Named tuple types can be created by declaring interfaces that derive from Array&amp;lt;T&amp;gt; and introduce numerically named properties. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface KeyValuePair&amp;lt;K, V&amp;gt; extends Array&amp;lt;K | V&amp;gt; { 0: K; 1: V; }

var x: KeyValuePair&amp;lt;number, string&amp;gt; = [10, &amp;quot;ten&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A type is said to be a &lt;strong&gt;&lt;em&gt;tuple-like type&lt;/em&gt;&lt;/strong&gt; if it has a property with the numeric name &amp;lsquo;0&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-3-4-3-3-4-function-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.3.4&#34;/&gt;3.3.4 Function Types&lt;/h3&gt;

&lt;p&gt;An object type containing one or more call signatures is said to be a &lt;strong&gt;&lt;em&gt;function type&lt;/em&gt;&lt;/strong&gt;. Function types may be written using function type literals (section &lt;a href=&#34;#3.8.8&#34;&gt;3.8.8&lt;/a&gt;) or by including call signatures in object type literals.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-3-5-3-3-5-constructor-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.3.5&#34;/&gt;3.3.5 Constructor Types&lt;/h3&gt;

&lt;p&gt;An object type containing one or more construct signatures is said to be a &lt;strong&gt;&lt;em&gt;constructor type&lt;/em&gt;&lt;/strong&gt;. Constructor types may be written using constructor type literals (section &lt;a href=&#34;#3.8.9&#34;&gt;3.8.9&lt;/a&gt;) or by including construct signatures in object type literals.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-3-6-3-3-6-members:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.3.6&#34;/&gt;3.3.6 Members&lt;/h3&gt;

&lt;p&gt;Every object type is composed from zero or more of the following kinds of members:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Properties&lt;/em&gt;&lt;/strong&gt;, which define the names and types of the properties of objects of the given type. Property names are unique within their type.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Call signatures&lt;/em&gt;&lt;/strong&gt;, which define the possible parameter lists and return types associated with applying call operations to objects of the given type.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Construct signatures&lt;/em&gt;&lt;/strong&gt;, which define the possible parameter lists and return types associated with applying the &lt;code&gt;new&lt;/code&gt; operator to objects of the given type.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Index signatures&lt;/em&gt;&lt;/strong&gt;, which define type constraints for properties in the given type. An object type can have at most one string index signature and one numeric index signature.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Properties are either &lt;strong&gt;&lt;em&gt;public&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;private&lt;/em&gt;&lt;/strong&gt;, or &lt;strong&gt;&lt;em&gt;protected&lt;/em&gt;&lt;/strong&gt; and are either &lt;strong&gt;&lt;em&gt;required&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;optional&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Properties in a class declaration may be designated public, private, or protected, while properties declared in other contexts are always considered public. Private members are only accessible within their declaring class, as described in section &lt;a href=&#34;#8.2.2&#34;&gt;8.2.2&lt;/a&gt;, and private properties match only themselves in subtype and assignment compatibility checks, as described in section &lt;a href=&#34;#3.11&#34;&gt;3.11&lt;/a&gt;. Protected members are only accessible within their declaring class and classes derived from it, as described in section &lt;a href=&#34;#8.2.2&#34;&gt;8.2.2&lt;/a&gt;, and protected properties match only themselves and overrides in subtype and assignment compatibility checks, as described in section &lt;a href=&#34;#3.11&#34;&gt;3.11&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Properties in an object type literal or interface declaration may be designated required or optional, while properties declared in other contexts are always considered required. Properties that are optional in the target type of an assignment may be omitted from source objects, as described in section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Call and construct signatures may be &lt;strong&gt;&lt;em&gt;specialized&lt;/em&gt;&lt;/strong&gt; (section &lt;a href=&#34;#3.9.2.4&#34;&gt;3.9.2.4&lt;/a&gt;) by including parameters with string literal types. Specialized signatures are used to express patterns where specific string values for some parameters cause the types of other parameters or the function result to become further specialized.&lt;/p&gt;

&lt;h2 id=&#34;a-name-3-4-3-4-union-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.4&#34;/&gt;3.4 Union Types&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Union types&lt;/em&gt;&lt;/strong&gt; represent values that may have one of several distinct representations. A value of a union type &lt;em&gt;A&lt;/em&gt; | &lt;em&gt;B&lt;/em&gt; is a value that is &lt;em&gt;either&lt;/em&gt; of type &lt;em&gt;A&lt;/em&gt; or type &lt;em&gt;B&lt;/em&gt;. Union types are written using union type literals (section &lt;a href=&#34;#3.8.6&#34;&gt;3.8.6&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;A union type encompasses an ordered set of constituent types. While it is generally true that &lt;em&gt;A&lt;/em&gt; | &lt;em&gt;B&lt;/em&gt; is equivalent to &lt;em&gt;B&lt;/em&gt; | &lt;em&gt;A&lt;/em&gt;, the order of the constituent types may matter when determining the call and construct signatures of the union type.&lt;/p&gt;

&lt;p&gt;Union types have the following subtype relationships:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A union type &lt;em&gt;U&lt;/em&gt; is a subtype of a type &lt;em&gt;T&lt;/em&gt; if each type in &lt;em&gt;U&lt;/em&gt; is a subtype of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;A type &lt;em&gt;T&lt;/em&gt; is a subtype of a union type &lt;em&gt;U&lt;/em&gt; if &lt;em&gt;T&lt;/em&gt; is a subtype of any type in &lt;em&gt;U&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Similarly, union types have the following assignability relationships:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A union type &lt;em&gt;U&lt;/em&gt; is assignable to a type &lt;em&gt;T&lt;/em&gt; if each type in &lt;em&gt;U&lt;/em&gt; is assignable to &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;A type &lt;em&gt;T&lt;/em&gt; is assignable to a union type &lt;em&gt;U&lt;/em&gt; if &lt;em&gt;T&lt;/em&gt; is assignable to any type in &lt;em&gt;U&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The || and conditional operators (section &lt;a href=&#34;#4.19.7&#34;&gt;4.19.7&lt;/a&gt; and &lt;a href=&#34;#4.20&#34;&gt;4.20&lt;/a&gt;) may produce values of union types, and array literals (section &lt;a href=&#34;#4.6&#34;&gt;4.6&lt;/a&gt;) may produce array values that have union types as their element types.&lt;/p&gt;

&lt;p&gt;Type guards (section &lt;a href=&#34;#4.24&#34;&gt;4.24&lt;/a&gt;) may be used to narrow a union type to a more specific type. In particular, type guards are useful for narrowing union type values to a non-union type values.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x: string | number;  
var test: boolean;  
x = &amp;quot;hello&amp;quot;;            // Ok  
x = 42;                 // Ok  
x = test;               // Error, boolean not assignable  
x = test ? 5 : &amp;quot;five&amp;quot;;  // Ok  
x = test ? 0 : false;   // Error, number | boolean not assignable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it is possible to assign &amp;lsquo;x&amp;rsquo; a value of type &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, or the union type &lt;code&gt;string | number&lt;/code&gt;, but not any other type. To access a value in &amp;lsquo;x&amp;rsquo;, a type guard can be used to first narrow the type of &amp;lsquo;x&amp;rsquo; to either &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var n = typeof x === &amp;quot;string&amp;quot; ? x.length : x;  // Type of n is number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For purposes of property access and function calls, the apparent members (section &lt;a href=&#34;#3.11.1&#34;&gt;3.11.1&lt;/a&gt;) of a union type are those that are present in every one of its constituent types, with types that are unions of the respective apparent members in the constituent types. The following example illustrates the merging of member types that occurs when union types are created from object types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface A {  
    a: string;  
    b: number;  
}

interface B {  
    a: number;  
    b: number;  
    c: number;  
}

var x: A | B;  
var a = x.a;  // a has type string | number  
var b = x.b;  // b has type number  
var c = x.c;  // Error, no property c in union type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &amp;lsquo;x.a&amp;rsquo; has a union type because the type of &amp;lsquo;a&amp;rsquo; is different in &amp;lsquo;A&amp;rsquo; and &amp;lsquo;B&amp;rsquo;, whereas &amp;lsquo;x.b&amp;rsquo; simply has type number because that is the type of &amp;lsquo;b&amp;rsquo; in both &amp;lsquo;A&amp;rsquo; and &amp;lsquo;B&amp;rsquo;. Also note that there is no property &amp;lsquo;x.c&amp;rsquo; because only &amp;lsquo;B&amp;rsquo; has a property &amp;lsquo;c&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;When used as a contextual type (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;), a union type has those members that are present in any of its constituent types, with types that are unions of the respective members in the constituent types. Specifically, a union type used as a contextual type has the apparent members defined in section &lt;a href=&#34;#3.11.1&#34;&gt;3.11.1&lt;/a&gt;, except that a particular member need only be present in one or more constituent types instead of all constituent types.&lt;/p&gt;

&lt;h2 id=&#34;a-name-3-5-3-5-intersection-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.5&#34;/&gt;3.5 Intersection Types&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Intersection types&lt;/em&gt;&lt;/strong&gt; represent values that simultaneously have multiple types. A value of an intersection type &lt;em&gt;A&lt;/em&gt; &amp;amp; &lt;em&gt;B&lt;/em&gt; is a value that is &lt;em&gt;both&lt;/em&gt; of type &lt;em&gt;A&lt;/em&gt; and type &lt;em&gt;B&lt;/em&gt;. Intersection types are written using intersection type literals (section &lt;a href=&#34;#3.8.7&#34;&gt;3.8.7&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;An intersection type encompasses an ordered set of constituent types. While it is generally true that &lt;em&gt;A&lt;/em&gt; &amp;amp; &lt;em&gt;B&lt;/em&gt; is equivalent to &lt;em&gt;B&lt;/em&gt; &amp;amp; &lt;em&gt;A&lt;/em&gt;, the order of the constituent types may matter when determining the call and construct signatures of the intersection type.&lt;/p&gt;

&lt;p&gt;Intersection types have the following subtype relationships:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An intersection type &lt;em&gt;I&lt;/em&gt; is a subtype of a type &lt;em&gt;T&lt;/em&gt; if any type in &lt;em&gt;I&lt;/em&gt; is a subtype of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;A type &lt;em&gt;T&lt;/em&gt; is a subtype of an intersection type &lt;em&gt;I&lt;/em&gt; if &lt;em&gt;T&lt;/em&gt; is a subtype of each type in &lt;em&gt;I&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Similarly, intersection types have the following assignability relationships:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An intersection type &lt;em&gt;I&lt;/em&gt; is assignable to a type &lt;em&gt;T&lt;/em&gt; if any type in &lt;em&gt;I&lt;/em&gt; is assignable to &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;A type &lt;em&gt;T&lt;/em&gt; is assignable to an intersection type &lt;em&gt;I&lt;/em&gt; if &lt;em&gt;T&lt;/em&gt; is assignable to each type in &lt;em&gt;I&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For purposes of property access and function calls, the apparent members (section &lt;a href=&#34;#3.11.1&#34;&gt;3.11.1&lt;/a&gt;) of an intersection type are those that are present in one or more of its constituent types, with types that are intersections of the respective apparent members in the constituent types. The following examples illustrate the merging of member types that occurs when intersection types are created from object types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface A { a: number }  
interface B { b: number }

var ab: A &amp;amp; B = { a: 1, b: 1 };  
var a: A = ab;  // A &amp;amp; B assignable to A  
var b: B = ab;  // A &amp;amp; B assignable to B

interface X { p: A }  
interface Y { p: B }

var xy: X &amp;amp; Y = { p: ab };  // X &amp;amp; Y has property p of type A &amp;amp; B

type F1 = (a: string, b: string) =&amp;gt; void;  
type F2 = (a: number, b: number) =&amp;gt; void;

var f: F1 &amp;amp; F2 = (a: string | number, b: string | number) =&amp;gt; { };  
f(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;);  // Ok  
f(1, 2);              // Ok  
f(1, &amp;quot;test&amp;quot;);         // Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The union and intersection type operators can be applied to type parameters. This capability can for example be used to model functions that merge objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function extend&amp;lt;T, U&amp;gt;(first: T, second: U): T &amp;amp; U {  
    // Extend first with properties of second  
}

var x = extend({ a: &amp;quot;hello&amp;quot; }, { b: 42 });  
var s = x.a;  
var n = x.b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is possible to create intersection types for which no values other than null or undefined are possible. For example, intersections of primitive types such as &lt;code&gt;string &amp;amp; number&lt;/code&gt; fall into this category.&lt;/p&gt;

&lt;h2 id=&#34;a-name-3-6-3-6-type-parameters:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.6&#34;/&gt;3.6 Type Parameters&lt;/h2&gt;

&lt;p&gt;A type parameter represents an actual type that the parameter is bound to in a generic type reference or a generic function call. Type parameters have constraints that establish upper bounds for their actual type arguments.&lt;/p&gt;

&lt;p&gt;Since a type parameter represents a multitude of different type arguments, type parameters have certain restrictions compared to other types. In particular, a type parameter cannot be used as a base class or interface.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-6-1-3-6-1-type-parameter-lists:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.6.1&#34;/&gt;3.6.1 Type Parameter Lists&lt;/h3&gt;

&lt;p&gt;Class, interface, type alias, and function declarations may optionally include lists of type parameters enclosed in &amp;lt; and &amp;gt; brackets. Type parameters are also permitted in call signatures of object, function, and constructor type literals.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameters:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;&amp;lt;&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameterList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeParameter&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameter:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;Constraint&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;Constraint:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;extends&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Type parameter names must be unique. A compile-time error occurs if two or more type parameters in the same &lt;em&gt;TypeParameterList&lt;/em&gt; have the same name.&lt;/p&gt;

&lt;p&gt;The scope of a type parameter extends over the entire declaration with which the type parameter list is associated, with the exception of static member declarations in classes.&lt;/p&gt;

&lt;p&gt;A type parameter may have an associated type parameter &lt;strong&gt;&lt;em&gt;constraint&lt;/em&gt;&lt;/strong&gt; that establishes an upper bound for type arguments. Type parameters may be referenced in type parameter constraints within the same type parameter list, including even constraint declarations that occur to the left of the type parameter.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;&lt;em&gt;base constraint&lt;/em&gt;&lt;/strong&gt; of a type parameter &lt;em&gt;T&lt;/em&gt; is defined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;T&lt;/em&gt; has no declared constraint, &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s base constraint is the empty object type &lt;code&gt;{}&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s declared constraint is a type parameter, &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s base constraint is that of the type parameter.&lt;/li&gt;
&lt;li&gt;Otherwise, &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s base constraint is &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s declared constraint.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface G&amp;lt;T, U extends V, V extends Function&amp;gt; { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the base constraint of &amp;rsquo;T&amp;rsquo; is the empty object type and the base constraint of &amp;lsquo;U&amp;rsquo; and &amp;lsquo;V&amp;rsquo; is &amp;lsquo;Function&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;For purposes of determining type relationships (section &lt;a href=&#34;#3.11&#34;&gt;3.11&lt;/a&gt;), type parameters appear to be subtypes of their base constraint. Likewise, in property accesses (section &lt;a href=&#34;#4.13&#34;&gt;4.13&lt;/a&gt;), &lt;code&gt;new&lt;/code&gt; operations (section &lt;a href=&#34;#4.14&#34;&gt;4.14&lt;/a&gt;), and function calls (section &lt;a href=&#34;#4.15&#34;&gt;4.15&lt;/a&gt;), type parameters appear to have the members of their base constraint, but no other members.&lt;/p&gt;

&lt;p&gt;It is an error for a type parameter to directly or indirectly be a constraint for itself. For example, both of the following declarations are invalid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface A&amp;lt;T extends T&amp;gt; { }

interface B&amp;lt;T extends U, U extends T&amp;gt; { }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-6-2-3-6-2-type-argument-lists:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.6.2&#34;/&gt;3.6.2 Type Argument Lists&lt;/h3&gt;

&lt;p&gt;A type reference (section &lt;a href=&#34;#3.8.2&#34;&gt;3.8.2&lt;/a&gt;) to a generic type must include a list of type arguments enclosed in angle brackets and separated by commas. Similarly, a call (section &lt;a href=&#34;#4.15&#34;&gt;4.15&lt;/a&gt;) to a generic function may explicitly include a type argument list instead of relying on type inference.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArguments:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;&amp;lt;&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeArgumentList&lt;/em&gt;&amp;emsp;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArgumentList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArgument&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArgumentList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeArgument&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArgument:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Type arguments correspond one-to-one with type parameters of the generic type or function being referenced. A type argument list is required to specify exactly one type argument for each corresponding type parameter, and each type argument for a constrained type parameter is required to &lt;strong&gt;&lt;em&gt;satisfy&lt;/em&gt;&lt;/strong&gt; the constraint of that type parameter. A type argument satisfies a type parameter constraint if the type argument is assignable to (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) the constraint type once type arguments are substituted for type parameters.&lt;/p&gt;

&lt;p&gt;Given the declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface G&amp;lt;T, U extends Function&amp;gt; { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a type reference of the form &amp;lsquo;G&amp;lt;A, B&amp;gt;&amp;rsquo; places no requirements on &amp;lsquo;A&amp;rsquo; but requires &amp;lsquo;B&amp;rsquo; to be assignable to &amp;lsquo;Function&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;The process of substituting type arguments for type parameters in a generic type or generic signature is known as &lt;strong&gt;&lt;em&gt;instantiating&lt;/em&gt;&lt;/strong&gt; the generic type or signature. Instantiation of a generic type or signature can fail if the supplied type arguments do not satisfy the constraints of their corresponding type parameters.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-6-3-3-6-3-this-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.6.3&#34;/&gt;3.6.3 This-types&lt;/h3&gt;

&lt;p&gt;Every class and interface has a &lt;strong&gt;&lt;em&gt;this-type&lt;/em&gt;&lt;/strong&gt; that represents the actual type of instances of the class or interface within the declaration of the class or interface. The this-type is referenced using the keyword &lt;code&gt;this&lt;/code&gt; in a type position. Within instance methods and constructors of a class, the type of the expression &lt;code&gt;this&lt;/code&gt; (section &lt;a href=&#34;#4.2&#34;&gt;4.2&lt;/a&gt;) is the this-type of the class.&lt;/p&gt;

&lt;p&gt;Classes and interfaces support inheritance and therefore the instance represented by &lt;code&gt;this&lt;/code&gt; in a method isn&amp;rsquo;t necessarily an instance of the containing class—it may in fact be an instance of a derived class or interface. To model this relationship, the this-type of a class or interface is classified as a type parameter. Unlike other type parameters, it is not possible to explicitly pass a type argument for a this-type. Instead, in a type reference to a class or interface type, the type reference &lt;em&gt;itself&lt;/em&gt; is implicitly passed as a type argument for the this-type. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class A {  
    foo() {  
        return this;  
    }  
}

class B extends A {  
    bar() {  
        return this;  
    }  
}

let b: B;  
let x = b.foo().bar();  // Fluent pattern works, type of x is B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the declaration of &lt;code&gt;b&lt;/code&gt; above, the type reference &lt;code&gt;B&lt;/code&gt; is itself passed as a type argument for B&amp;rsquo;s this-type. Thus, the referenced type is an instantiation of class &lt;code&gt;B&lt;/code&gt; where all occurrences of the type &lt;code&gt;this&lt;/code&gt; are replaced with &lt;code&gt;B&lt;/code&gt;, and for that reason the &lt;code&gt;foo&lt;/code&gt; method of &lt;code&gt;B&lt;/code&gt; actually returns &lt;code&gt;B&lt;/code&gt; (as opposed to &lt;code&gt;A&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The this-type of a given class or interface type &lt;em&gt;C&lt;/em&gt; implicitly has a constraint consisting of a type reference to &lt;em&gt;C&lt;/em&gt; with &lt;em&gt;C&lt;/em&gt;&amp;rsquo;s own type parameters passed as type arguments and with that type reference passed as the type argument for the this-type.&lt;/p&gt;

&lt;h2 id=&#34;a-name-3-7-3-7-named-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.7&#34;/&gt;3.7 Named Types&lt;/h2&gt;

&lt;p&gt;Classes, interfaces, enums, and type aliases are &lt;strong&gt;&lt;em&gt;named types&lt;/em&gt;&lt;/strong&gt; that are introduced through class declarations (section &lt;a href=&#34;#8.1&#34;&gt;8.1&lt;/a&gt;), interface declarations (section &lt;a href=&#34;#7.1&#34;&gt;7.1&lt;/a&gt;), enum declarations (&lt;a href=&#34;#9.1&#34;&gt;9.1&lt;/a&gt;), and type alias declarations (section &lt;a href=&#34;#3.10&#34;&gt;3.10&lt;/a&gt;). Classes, interfaces, and type aliases may have type parameters and are then called &lt;strong&gt;&lt;em&gt;generic types&lt;/em&gt;&lt;/strong&gt;. Conversely, named types without type parameters are called &lt;strong&gt;&lt;em&gt;non-generic types&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Interface declarations only introduce named types, whereas class declarations introduce named types &lt;em&gt;and&lt;/em&gt; constructor functions that create instances of implementations of those named types. The named types introduced by class and interface declarations have only minor differences (classes can&amp;rsquo;t declare optional members and interfaces can&amp;rsquo;t declare private or protected members) and are in most contexts interchangeable. In particular, class declarations with only public members introduce named types that function exactly like those created by interface declarations.&lt;/p&gt;

&lt;p&gt;Named types are referenced through &lt;strong&gt;&lt;em&gt;type references&lt;/em&gt;&lt;/strong&gt; (section &lt;a href=&#34;#3.8.2&#34;&gt;3.8.2&lt;/a&gt;) that specify a type name and, if applicable, the type arguments to be substituted for the type parameters of the named type.&lt;/p&gt;

&lt;p&gt;Named types are technically not types—only &lt;em&gt;references&lt;/em&gt; to named types are. This distinction is particularly evident with generic types: Generic types are &amp;ldquo;templates&amp;rdquo; from which multiple &lt;em&gt;actual&lt;/em&gt; types can be created by writing type references that supply type arguments to substitute in place of the generic type&amp;rsquo;s type parameters. This substitution process is known as &lt;strong&gt;&lt;em&gt;instantiating&lt;/em&gt;&lt;/strong&gt; a generic type. Only once a generic type is instantiated does it denote an actual type.&lt;/p&gt;

&lt;p&gt;TypeScript has a structural type system, and therefore an instantiation of a generic type is indistinguishable from an equivalent manually written expansion. For example, given the declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Pair&amp;lt;T1, T2&amp;gt; { first: T1; second: T2; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the type reference&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;Pair&amp;lt;string, Entity&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is indistinguishable from the type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{ first: string; second: Entity; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-3-8-3-8-specifying-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8&#34;/&gt;3.8 Specifying Types&lt;/h2&gt;

&lt;p&gt;Types are specified either by referencing their keyword or name, or by writing object type literals, array type literals, tuple type literals, function type literals, constructor type literals, or type queries.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;Type:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;UnionOrIntersectionOrPrimaryType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructorType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;UnionOrIntersectionOrPrimaryType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;UnionType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IntersectionOrPrimaryType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;IntersectionOrPrimaryType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IntersectionType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PrimaryType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PrimaryType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ParenthesizedType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PredefinedType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeReference&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ObjectType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ArrayType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TupleType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeQuery&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ThisType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ParenthesizedType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Parentheses are required around union, intersection, function, or constructor types when they are used as array element types; around union, function, or constructor types in intersection types; and around function or constructor types in union types. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;(string | number)[]  
((x: string) =&amp;gt; string) | ((x: number) =&amp;gt; number)  
(A | B) &amp;amp; (C | D)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The different forms of type notations are described in the following sections.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-8-1-3-8-1-predefined-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.1&#34;/&gt;3.8.1 Predefined Types&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; keywords reference the Any type and the Number, Boolean, String, Symbol, and Void primitive types respectively.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PredefinedType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;any&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;number&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;boolean&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;string&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;symbol&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;void&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The predefined type keywords are reserved and cannot be used as names of user defined types.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-8-2-3-8-2-type-references:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.2&#34;/&gt;3.8.2 Type References&lt;/h3&gt;

&lt;p&gt;A type reference references a named type or type parameter through its name and, in the case of a generic type, supplies a type argument list.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeReference:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeName&lt;/em&gt;&amp;emsp;&lt;em&gt;[no LineTerminator here]&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeArguments&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeName:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceName&lt;/em&gt;&amp;emsp;&lt;code&gt;.&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceName:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceName&lt;/em&gt;&amp;emsp;&lt;code&gt;.&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;TypeReference&lt;/em&gt; consists of a &lt;em&gt;TypeName&lt;/em&gt; that a references a named type or type parameter. A reference to a generic type must be followed by a list of &lt;em&gt;TypeArguments&lt;/em&gt; (section &lt;a href=&#34;#3.6.2&#34;&gt;3.6.2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;TypeName&lt;/em&gt; is either a single identifier or a sequence of identifiers separated by dots. In a type name, all identifiers but the last one refer to namespaces and the last identifier refers to a named type.&lt;/p&gt;

&lt;p&gt;Resolution of a &lt;em&gt;TypeName&lt;/em&gt; consisting of a single identifier is described in section &lt;a href=&#34;#2.4&#34;&gt;2.4&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Resolution of a &lt;em&gt;TypeName&lt;/em&gt; of the form &lt;em&gt;N.X&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is a &lt;em&gt;NamespaceName&lt;/em&gt; and &lt;em&gt;X&lt;/em&gt; is an &lt;em&gt;IdentifierReference&lt;/em&gt;, proceeds by first resolving the namespace name &lt;em&gt;N&lt;/em&gt;. If the resolution of &lt;em&gt;N&lt;/em&gt; is successful and the export member set (sections &lt;a href=&#34;#10.4&#34;&gt;10.4&lt;/a&gt; and &lt;a href=&#34;#11.3.4.4&#34;&gt;11.3.4.4&lt;/a&gt;) of the resulting namespace contains a named type &lt;em&gt;X&lt;/em&gt;, then &lt;em&gt;N.X&lt;/em&gt; refers to that member. Otherwise, &lt;em&gt;N.X&lt;/em&gt; is undefined.&lt;/p&gt;

&lt;p&gt;Resolution of a &lt;em&gt;NamespaceName&lt;/em&gt; consisting of a single identifier is described in section &lt;a href=&#34;#2.4&#34;&gt;2.4&lt;/a&gt;. Identifiers declared in namespace declarations (section &lt;a href=&#34;#10.1&#34;&gt;10.1&lt;/a&gt;) or import declarations (sections &lt;a href=&#34;#10.3&#34;&gt;10.3&lt;/a&gt;, &lt;a href=&#34;#11.3.2&#34;&gt;11.3.2&lt;/a&gt;, and &lt;a href=&#34;#11.3.3&#34;&gt;11.3.3&lt;/a&gt;) may be classified as namespaces.&lt;/p&gt;

&lt;p&gt;Resolution of a &lt;em&gt;NamespaceName&lt;/em&gt; of the form &lt;em&gt;N.X&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is a &lt;em&gt;NamespaceName&lt;/em&gt; and &lt;em&gt;X&lt;/em&gt; is an &lt;em&gt;IdentifierReference&lt;/em&gt;, proceeds by first resolving the namespace name &lt;em&gt;N&lt;/em&gt;. If the resolution of &lt;em&gt;N&lt;/em&gt; is successful and the export member set (sections &lt;a href=&#34;#10.4&#34;&gt;10.4&lt;/a&gt; and &lt;a href=&#34;#11.3.4.4&#34;&gt;11.3.4.4&lt;/a&gt;) of the resulting namespace contains an exported namespace member &lt;em&gt;X&lt;/em&gt;, then &lt;em&gt;N.X&lt;/em&gt; refers to that member. Otherwise, &lt;em&gt;N.X&lt;/em&gt; is undefined.&lt;/p&gt;

&lt;p&gt;A type reference to a generic type is required to specify exactly one type argument for each type parameter of the referenced generic type, and each type argument must be assignable to (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) the constraint of the corresponding type parameter or otherwise an error occurs. An example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface A { a: string; }

interface B extends A { b: string; }

interface C extends B { c: string; }

interface G&amp;lt;T, U extends B&amp;gt; {  
    x: T;  
    y: U;  
}

var v1: G&amp;lt;A, C&amp;gt;;               // Ok  
var v2: G&amp;lt;{ a: string }, C&amp;gt;;   // Ok, equivalent to G&amp;lt;A, C&amp;gt;  
var v3: G&amp;lt;A, A&amp;gt;;               // Error, A not valid argument for U  
var v4: G&amp;lt;G&amp;lt;A, B&amp;gt;, C&amp;gt;;         // Ok  
var v5: G&amp;lt;any, any&amp;gt;;           // Ok  
var v6: G&amp;lt;any&amp;gt;;                // Error, wrong number of arguments  
var v7: G;                     // Error, no arguments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A type argument is simply a &lt;em&gt;Type&lt;/em&gt; and may itself be a type reference to a generic type, as demonstrated by &amp;lsquo;v4&amp;rsquo; in the example above.&lt;/p&gt;

&lt;p&gt;As described in section &lt;a href=&#34;#3.7&#34;&gt;3.7&lt;/a&gt;, a type reference to a generic type &lt;em&gt;G&lt;/em&gt; designates a type wherein all occurrences of &lt;em&gt;G&lt;/em&gt;&amp;rsquo;s type parameters have been replaced with the actual type arguments supplied in the type reference. For example, the declaration of &amp;lsquo;v1&amp;rsquo; above is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var v1: {  
    x: { a: string; }  
    y: { a: string; b: string; c: string };  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-8-3-3-8-3-object-type-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.3&#34;/&gt;3.8.3 Object Type Literals&lt;/h3&gt;

&lt;p&gt;An object type literal defines an object type by specifying the set of members that are statically considered to be present in instances of the type. Object type literals can be given names using interface declarations but are otherwise anonymous.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ObjectType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeBody&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeBody:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMemberList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMember&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeMember&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeMember&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMember:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertySignature&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructSignature&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IndexSignature&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;MethodSignature&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The members of an object type literal are specified as a combination of property, call, construct, index, and method signatures. Object type members are described in section &lt;a href=&#34;#3.9&#34;&gt;3.9&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-8-4-3-8-4-array-type-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.4&#34;/&gt;3.8.4 Array Type Literals&lt;/h3&gt;

&lt;p&gt;An array type literal is written as an element type followed by an open and close square bracket.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ArrayType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PrimaryType&lt;/em&gt;&amp;emsp;&lt;em&gt;[no LineTerminator here]&lt;/em&gt;&amp;emsp;&lt;code&gt;[&lt;/code&gt;&amp;emsp;&lt;code&gt;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;An array type literal references an array type (section &lt;a href=&#34;#3.3.2&#34;&gt;3.3.2&lt;/a&gt;) with the given element type. An array type literal is simply shorthand notation for a reference to the generic interface type &amp;lsquo;Array&amp;rsquo; in the global namespace with the element type as a type argument.&lt;/p&gt;

&lt;p&gt;When union, intersection, function, or constructor types are used as array element types they must be enclosed in parentheses. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;(string | number)[]  
(() =&amp;gt; string))[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, array types can be written using the &amp;lsquo;Array&amp;lt;T&amp;gt;&amp;rsquo; notation. For example, the types above are equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;Array&amp;lt;string | number&amp;gt;  
Array&amp;lt;() =&amp;gt; string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-8-5-3-8-5-tuple-type-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.5&#34;/&gt;3.8.5 Tuple Type Literals&lt;/h3&gt;

&lt;p&gt;A tuple type literal is written as a sequence of element types, separated by commas and enclosed in square brackets.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TupleType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;[&lt;/code&gt;&amp;emsp;&lt;em&gt;TupleElementTypes&lt;/em&gt;&amp;emsp;&lt;code&gt;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TupleElementTypes:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TupleElementType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TupleElementTypes&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;TupleElementType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TupleElementType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A tuple type literal references a tuple type (section &lt;a href=&#34;#3.3.3&#34;&gt;3.3.3&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-8-6-3-8-6-union-type-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.6&#34;/&gt;3.8.6 Union Type Literals&lt;/h3&gt;

&lt;p&gt;A union type literal is written as a sequence of types separated by vertical bars.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;UnionType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;UnionOrIntersectionOrPrimaryType&lt;/em&gt;&amp;emsp;&lt;code&gt;|&lt;/code&gt;&amp;emsp;&lt;em&gt;IntersectionOrPrimaryType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A union type literal references a union type (section &lt;a href=&#34;#3.4&#34;&gt;3.4&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-8-7-3-8-7-intersection-type-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.7&#34;/&gt;3.8.7 Intersection Type Literals&lt;/h3&gt;

&lt;p&gt;An intersection type literal is written as a sequence of types separated by ampersands.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;IntersectionType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IntersectionOrPrimaryType&lt;/em&gt;&amp;emsp;&lt;code&gt;&amp;amp;&lt;/code&gt;&amp;emsp;&lt;em&gt;PrimaryType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;An intersection type literal references an intersection type (section &lt;a href=&#34;#3.5&#34;&gt;3.5&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-8-8-3-8-8-function-type-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.8&#34;/&gt;3.8.8 Function Type Literals&lt;/h3&gt;

&lt;p&gt;A function type literal specifies the type parameters, regular parameters, and return type of a call signature.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A function type literal is shorthand for an object type containing a single call signature. Specifically, a function type literal of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt; T1, T2, ... &amp;gt; ( p1, p2, ... ) =&amp;gt; R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is exactly equivalent to the object type literal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{ &amp;lt; T1, T2, ... &amp;gt; ( p1, p2, ... ) : R }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that function types with multiple call or construct signatures cannot be written as function type literals but must instead be written as object type literals.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-8-9-3-8-9-constructor-type-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.9&#34;/&gt;3.8.9 Constructor Type Literals&lt;/h3&gt;

&lt;p&gt;A constructor type literal specifies the type parameters, regular parameters, and return type of a construct signature.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructorType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;new&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A constructor type literal is shorthand for an object type containing a single construct signature. Specifically, a constructor type literal of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;new &amp;lt; T1, T2, ... &amp;gt; ( p1, p2, ... ) =&amp;gt; R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is exactly equivalent to the object type literal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{ new &amp;lt; T1, T2, ... &amp;gt; ( p1, p2, ... ) : R }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that constructor types with multiple construct signatures cannot be written as constructor type literals but must instead be written as object type literals.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-8-10-3-8-10-type-queries:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.10&#34;/&gt;3.8.10 Type Queries&lt;/h3&gt;

&lt;p&gt;A type query obtains the type of an expression.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeQuery:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;typeof&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeQueryExpression&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeQueryExpression:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeQueryExpression&lt;/em&gt;&amp;emsp;&lt;code&gt;.&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierName&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A type query consists of the keyword &lt;code&gt;typeof&lt;/code&gt; followed by an expression. The expression is restricted to a single identifier or a sequence of identifiers separated by periods. The expression is processed as an identifier expression (section &lt;a href=&#34;#4.3&#34;&gt;4.3&lt;/a&gt;) or property access expression (section &lt;a href=&#34;#4.13&#34;&gt;4.13&lt;/a&gt;), the widened type (section &lt;a href=&#34;#3.12&#34;&gt;3.12&lt;/a&gt;) of which becomes the result. Similar to other static typing constructs, type queries are erased from the generated JavaScript code and add no run-time overhead.&lt;/p&gt;

&lt;p&gt;Type queries are useful for capturing anonymous types that are generated by various constructs such as object literals, function declarations, and namespace declarations. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var a = { x: 10, y: 20 };  
var b: typeof a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above, &amp;lsquo;b&amp;rsquo; is given the same type as &amp;lsquo;a&amp;rsquo;, namely &lt;code&gt;{ x: number; y: number; }&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If a declaration includes a type annotation that references the entity being declared through a circular path of type queries or type references containing type queries, the resulting type is the Any type. For example, all of the following variables are given the type Any:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var c: typeof c;  
var d: typeof e;  
var e: typeof d;  
var f: Array&amp;lt;typeof f&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if a circular path of type queries includes at least one &lt;em&gt;ObjectType&lt;/em&gt;, &lt;em&gt;FunctionType&lt;/em&gt; or &lt;em&gt;ConstructorType&lt;/em&gt;, the construct denotes a recursive type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var g: { x: typeof g; };  
var h: () =&amp;gt; typeof h;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &amp;lsquo;g&amp;rsquo; and &amp;lsquo;g.x&amp;rsquo; have the same recursive type, and likewise &amp;lsquo;h&amp;rsquo; and &amp;lsquo;h()&amp;rsquo; have the same recursive type.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-8-11-3-8-11-this-type-references:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.8.11&#34;/&gt;3.8.11 This-Type References&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;this&lt;/code&gt; keyword is used to reference the this-type (section &lt;a href=&#34;#3.6.3&#34;&gt;3.6.3&lt;/a&gt;) of a class or interface.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ThisType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;this&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The meaning of a &lt;em&gt;ThisType&lt;/em&gt; depends on the closest enclosing &lt;em&gt;FunctionDeclaration&lt;/em&gt;, &lt;em&gt;FunctionExpression&lt;/em&gt;, &lt;em&gt;PropertyDefinition&lt;/em&gt;, &lt;em&gt;ClassElement&lt;/em&gt;, or &lt;em&gt;TypeMember&lt;/em&gt;, known as the root declaration of the &lt;em&gt;ThisType&lt;/em&gt;, as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When the root declaration is an instance member or constructor of a class, the &lt;em&gt;ThisType&lt;/em&gt; references the this-type of that class.&lt;/li&gt;
&lt;li&gt;When the root declaration is a member of an interface type, the &lt;em&gt;ThisType&lt;/em&gt; references the this-type of that interface.&lt;/li&gt;
&lt;li&gt;Otherwise, the &lt;em&gt;ThisType&lt;/em&gt; is an error.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that in order to avoid ambiguities it is not possible to reference the this-type of a class or interface in a nested object type literal. In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface ListItem {  
    getHead(): this;  
    getTail(): this;  
    getHeadAndTail(): { head: this, tail: this };  // Error  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the &lt;code&gt;this&lt;/code&gt; references on the last line are in error because their root declarations are not members of a class or interface. The recommended way to reference the this-type of an outer class or interface in an object type literal is to declare an intermediate generic type and pass &lt;code&gt;this&lt;/code&gt; as a type argument. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;type HeadAndTail&amp;lt;T&amp;gt; = { head: T, tail: T };

interface ListItem {  
    getHead(): this;  
    getTail(): this;  
    getHeadAndTail(): HeadAndTail&amp;lt;this&amp;gt;;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-3-9-3-9-specifying-members:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.9&#34;/&gt;3.9 Specifying Members&lt;/h2&gt;

&lt;p&gt;The members of an object type literal (section &lt;a href=&#34;#3.8.3&#34;&gt;3.8.3&lt;/a&gt;) are specified as a combination of property, call, construct, index, and method signatures.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-9-1-3-9-1-property-signatures:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.9.1&#34;/&gt;3.9.1 Property Signatures&lt;/h3&gt;

&lt;p&gt;A property signature declares the name and type of a property member.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PropertySignature:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;code&gt;?&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAnnotation:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;PropertyName&lt;/em&gt; (&lt;a href=&#34;#2.2.2&#34;&gt;2.2.2&lt;/a&gt;) of a property signature must be unique within its containing type, and must denote a well-known symbol if it is a computed property name (&lt;a href=&#34;#2.2.3&#34;&gt;2.2.3&lt;/a&gt;). If the property name is followed by a question mark, the property is optional. Otherwise, the property is required.&lt;/p&gt;

&lt;p&gt;If a property signature omits a &lt;em&gt;TypeAnnotation&lt;/em&gt;, the Any type is assumed.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-9-2-3-9-2-call-signatures:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.9.2&#34;/&gt;3.9.2 Call Signatures&lt;/h3&gt;

&lt;p&gt;A call signature defines the type parameters, parameter list, and return type associated with applying a call operation (section &lt;a href=&#34;#4.15&#34;&gt;4.15&lt;/a&gt;) to an instance of the containing type. A type may &lt;strong&gt;&lt;em&gt;overload&lt;/em&gt;&lt;/strong&gt; call operations by defining multiple different call signatures.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;CallSignature:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A call signature that includes &lt;em&gt;TypeParameters&lt;/em&gt; (section &lt;a href=&#34;#3.6.1&#34;&gt;3.6.1&lt;/a&gt;) is called a &lt;strong&gt;&lt;em&gt;generic call signature&lt;/em&gt;&lt;/strong&gt;. Conversely, a call signature with no &lt;em&gt;TypeParameters&lt;/em&gt; is called a non-generic call signature.&lt;/p&gt;

&lt;p&gt;As well as being members of object type literals, call signatures occur in method signatures (section &lt;a href=&#34;#3.9.5&#34;&gt;3.9.5&lt;/a&gt;), function expressions (section &lt;a href=&#34;#4.10&#34;&gt;4.10&lt;/a&gt;), and function declarations (section &lt;a href=&#34;#6.1&#34;&gt;6.1&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;An object type containing call signatures is said to be a &lt;strong&gt;&lt;em&gt;function type&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;a-name-3-9-2-1-3-9-2-1-type-parameters:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.9.2.1&#34;/&gt;3.9.2.1 Type Parameters&lt;/h4&gt;

&lt;p&gt;Type parameters (section &lt;a href=&#34;#3.6.1&#34;&gt;3.6.1&lt;/a&gt;) in call signatures provide a mechanism for expressing the relationships of parameter and return types in call operations. For example, a signature might introduce a type parameter and use it as both a parameter type and a return type, in effect describing a function that returns a value of the same type as its argument.&lt;/p&gt;

&lt;p&gt;Type parameters may be referenced in parameter types and return type annotations, but not in type parameter constraints, of the call signature in which they are introduced.&lt;/p&gt;

&lt;p&gt;Type arguments (section &lt;a href=&#34;#3.6.2&#34;&gt;3.6.2&lt;/a&gt;) for call signature type parameters may be explicitly specified in a call operation or may, when possible, be inferred (section &lt;a href=&#34;#4.15.2&#34;&gt;4.15.2&lt;/a&gt;) from the types of the regular arguments in the call. An &lt;strong&gt;&lt;em&gt;instantiation&lt;/em&gt;&lt;/strong&gt; of a generic call signature for a particular set of type arguments is the call signature formed by replacing each type parameter with its corresponding type argument.&lt;/p&gt;

&lt;p&gt;Some examples of call signatures with type parameters follow below.&lt;/p&gt;

&lt;p&gt;A function taking an argument of any type, returning a value of that same type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt;T&amp;gt;(x: T): T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A function taking two values of the same type, returning an array of that type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt;T&amp;gt;(x: T, y: T): T[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A function taking two arguments of different types, returning an object with properties &amp;lsquo;x&amp;rsquo; and &amp;lsquo;y&amp;rsquo; of those types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt;T, U&amp;gt;(x: T, y: U): { x: T; y: U; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A function taking an array of one type and a function argument, returning an array of another type, where the function argument takes a value of the first array element type and returns a value of the second array element type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt;T, U&amp;gt;(a: T[], f: (x: T) =&amp;gt; U): U[]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;a-name-3-9-2-2-3-9-2-2-parameter-list:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.9.2.2&#34;/&gt;3.9.2.2 Parameter List&lt;/h4&gt;

&lt;p&gt;A signature&amp;rsquo;s parameter list consists of zero or more required parameters, followed by zero or more optional parameters, finally followed by an optional rest parameter.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ParameterList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameterList&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RestParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;OptionalParameterList&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;RestParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;RestParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;OptionalParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;RestParameter&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;RequiredParameter&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameter:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;BindingIdentifierOrPattern&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;em&gt;StringLiteral&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;public&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;private&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;protected&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifierOrPattern:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingPattern&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameterList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;OptionalParameter&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameter:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;BindingIdentifierOrPattern&lt;/em&gt;&amp;emsp;&lt;code&gt;?&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;BindingIdentifierOrPattern&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;?&lt;/code&gt;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;em&gt;StringLiteral&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;RestParameter:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;...&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A parameter declaration may specify either an identifier or a binding pattern (&lt;a href=&#34;#5.2.2&#34;&gt;5.2.2&lt;/a&gt;). The identifiers specified in parameter declarations and binding patterns in a parameter list must be unique within that parameter list.&lt;/p&gt;

&lt;p&gt;The type of a parameter in a signature is determined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the declaration includes a type annotation, the parameter is of that type.&lt;/li&gt;
&lt;li&gt;Otherwise, if the declaration includes an initializer expression (which is permitted only when the parameter list occurs in conjunction with a function body), the parameter type is the widened form (section &lt;a href=&#34;#3.12&#34;&gt;3.12&lt;/a&gt;) of the type of the initializer expression.&lt;/li&gt;
&lt;li&gt;Otherwise, if the declaration specifies a binding pattern, the parameter type is the implied type of that binding pattern (section &lt;a href=&#34;#5.2.3&#34;&gt;5.2.3&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Otherwise, if the parameter is a rest parameter, the parameter type is &lt;code&gt;any[]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Otherwise, the parameter type is &lt;code&gt;any&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A parameter is permitted to include a &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, or &lt;code&gt;protected&lt;/code&gt; modifier only if it occurs in the parameter list of a &lt;em&gt;ConstructorImplementation&lt;/em&gt; (section &lt;a href=&#34;#8.3.1&#34;&gt;8.3.1&lt;/a&gt;) and only if it doesn&amp;rsquo;t specify a &lt;em&gt;BindingPattern&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A type annotation for a rest parameter must denote an array type.&lt;/p&gt;

&lt;p&gt;When a parameter type annotation specifies a string literal type, the containing signature is a specialized signature (section &lt;a href=&#34;#3.9.2.4&#34;&gt;3.9.2.4&lt;/a&gt;). Specialized signatures are not permitted in conjunction with a function body, i.e. the &lt;em&gt;FunctionExpression&lt;/em&gt;, &lt;em&gt;FunctionImplementation&lt;/em&gt;, &lt;em&gt;MemberFunctionImplementation&lt;/em&gt;, and &lt;em&gt;ConstructorImplementation&lt;/em&gt; grammar productions do not permit parameters with string literal types.&lt;/p&gt;

&lt;p&gt;A parameter can be marked optional by following its name or binding pattern with a question mark (&lt;code&gt;?&lt;/code&gt;) or by including an initializer. Initializers (including binding property or element initializers) are permitted only when the parameter list occurs in conjunction with a function body, i.e. only in a &lt;em&gt;FunctionExpression&lt;/em&gt;, &lt;em&gt;FunctionImplementation&lt;/em&gt;, &lt;em&gt;MemberFunctionImplementation&lt;/em&gt;, or &lt;em&gt;ConstructorImplementation&lt;/em&gt; grammar production.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Update to reflect &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/2797&#34;&gt;binding parameter cannot be optional in implementation signature&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Update to reflect &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/4022&#34;&gt;required parameters support initializers&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;a-name-3-9-2-3-3-9-2-3-return-type:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.9.2.3&#34;/&gt;3.9.2.3 Return Type&lt;/h4&gt;

&lt;p&gt;If present, a call signature&amp;rsquo;s return type annotation specifies the type of the value computed and returned by a call operation. A &lt;code&gt;void&lt;/code&gt; return type annotation is used to indicate that a function has no return value.&lt;/p&gt;

&lt;p&gt;When a call signature with no return type annotation occurs in a context without a function body, the return type is assumed to be the Any type.&lt;/p&gt;

&lt;p&gt;When a call signature with no return type annotation occurs in a context that has a function body (specifically, a function implementation, a member function implementation, or a member accessor declaration), the return type is inferred from the function body as described in section &lt;a href=&#34;#6.3&#34;&gt;6.3&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;a-name-3-9-2-4-3-9-2-4-specialized-signatures:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.9.2.4&#34;/&gt;3.9.2.4 Specialized Signatures&lt;/h4&gt;

&lt;p&gt;When a parameter type annotation specifies a string literal type (section &lt;a href=&#34;#3.2.9&#34;&gt;3.2.9&lt;/a&gt;), the containing signature is considered a specialized signature. Specialized signatures are used to express patterns where specific string values for some parameters cause the types of other parameters or the function result to become further specialized. For example, the declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Document {  
    createElement(tagName: &amp;quot;div&amp;quot;): HTMLDivElement;   
    createElement(tagName: &amp;quot;span&amp;quot;): HTMLSpanElement;  
    createElement(tagName: &amp;quot;canvas&amp;quot;): HTMLCanvasElement;  
    createElement(tagName: string): HTMLElement;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;states that calls to &amp;lsquo;createElement&amp;rsquo; with the string literals &amp;ldquo;div&amp;rdquo;, &amp;ldquo;span&amp;rdquo;, and &amp;ldquo;canvas&amp;rdquo; return values of type &amp;lsquo;HTMLDivElement&amp;rsquo;, &amp;lsquo;HTMLSpanElement&amp;rsquo;, and &amp;lsquo;HTMLCanvasElement&amp;rsquo; respectively, and that calls with all other string expressions return values of type &amp;lsquo;HTMLElement&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;When writing overloaded declarations such as the one above it is important to list the non-specialized signature last. This is because overload resolution (section &lt;a href=&#34;#4.15.1&#34;&gt;4.15.1&lt;/a&gt;) processes the candidates in declaration order and picks the first one that matches.&lt;/p&gt;

&lt;p&gt;Every specialized call or construct signature in an object type must be assignable to at least one non-specialized call or construct signature in the same object type (where a call signature &lt;em&gt;A&lt;/em&gt; is considered assignable to another call signature &lt;em&gt;B&lt;/em&gt; if an object type containing only &lt;em&gt;A&lt;/em&gt; would be assignable to an object type containing only &lt;em&gt;B&lt;/em&gt;). For example, the &amp;lsquo;createElement&amp;rsquo; property in the example above is of a type that contains three specialized signatures, all of which are assignable to the non-specialized signature in the type.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-9-3-3-9-3-construct-signatures:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.9.3&#34;/&gt;3.9.3 Construct Signatures&lt;/h3&gt;

&lt;p&gt;A construct signature defines the parameter list and return type associated with applying the &lt;code&gt;new&lt;/code&gt; operator (section &lt;a href=&#34;#4.14&#34;&gt;4.14&lt;/a&gt;) to an instance of the containing type. A type may overload &lt;code&gt;new&lt;/code&gt; operations by defining multiple construct signatures with different parameter lists.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructSignature:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;new&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The type parameters, parameter list, and return type of a construct signature are subject to the same rules as a call signature.&lt;/p&gt;

&lt;p&gt;A type containing construct signatures is said to be a &lt;strong&gt;&lt;em&gt;constructor type&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-9-4-3-9-4-index-signatures:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.9.4&#34;/&gt;3.9.4 Index Signatures&lt;/h3&gt;

&lt;p&gt;An index signature defines a type constraint for properties in the containing type.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;IndexSignature:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;[&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;code&gt;string&lt;/code&gt;&amp;emsp;&lt;code&gt;]&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;[&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;code&gt;number&lt;/code&gt;&amp;emsp;&lt;code&gt;]&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;There are two kinds of index signatures:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;String index signatures&lt;/em&gt;&lt;/strong&gt;, specified using index type &lt;code&gt;string&lt;/code&gt;, define type constraints for all properties and numeric index signatures in the containing type. Specifically, in a type with a string index signature of type &lt;em&gt;T&lt;/em&gt;, all properties and numeric index signatures must have types that are assignable to &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Numeric index signatures&lt;/em&gt;&lt;/strong&gt;, specified using index type &lt;code&gt;number&lt;/code&gt;, define type constraints for all numerically named properties in the containing type. Specifically, in a type with a numeric index signature of type &lt;em&gt;T&lt;/em&gt;, all numerically named properties must have types that are assignable to &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A &lt;strong&gt;&lt;em&gt;numerically named property&lt;/em&gt;&lt;/strong&gt; is a property whose name is a valid numeric literal. Specifically, a property with a name &lt;em&gt;N&lt;/em&gt; for which ToString(ToNumber(&lt;em&gt;N&lt;/em&gt;)) is identical to &lt;em&gt;N&lt;/em&gt;, where ToString and ToNumber are the abstract operations defined in ECMAScript specification.&lt;/p&gt;

&lt;p&gt;An object type can contain at most one string index signature and one numeric index signature.&lt;/p&gt;

&lt;p&gt;Index signatures affect the determination of the type that results from applying a bracket notation property access to an instance of the containing type, as described in section &lt;a href=&#34;#4.13&#34;&gt;4.13&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-9-5-3-9-5-method-signatures:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.9.5&#34;/&gt;3.9.5 Method Signatures&lt;/h3&gt;

&lt;p&gt;A method signature is shorthand for declaring a property of a function type.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;MethodSignature:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;code&gt;?&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If the &lt;em&gt;PropertyName&lt;/em&gt; is a computed property name (&lt;a href=&#34;#2.2.3&#34;&gt;2.2.3&lt;/a&gt;), it must specify a well-known symbol. If the &lt;em&gt;PropertyName&lt;/em&gt; is followed by a question mark, the property is optional. Otherwise, the property is required. Only object type literals and interfaces can declare optional properties.&lt;/p&gt;

&lt;p&gt;A method signature of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;f &amp;lt; T1, T2, ... &amp;gt; ( p1, p2, ... ) : R
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to the property declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;f : { &amp;lt; T1, T2, ... &amp;gt; ( p1, p2, ... ) : R }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A literal type may &lt;strong&gt;&lt;em&gt;overload&lt;/em&gt;&lt;/strong&gt; a method by declaring multiple method signatures with the same name but differing parameter lists. Overloads must either all be required (question mark omitted) or all be optional (question mark included). A set of overloaded method signatures correspond to a declaration of a single property with a type composed from an equivalent set of call signatures. Specifically&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;f &amp;lt; T1, T2, ... &amp;gt; ( p1, p2, ... ) : R ;  
f &amp;lt; U1, U2, ... &amp;gt; ( q1, q2, ... ) : S ;  
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;f : {  
    &amp;lt; T1, T2, ... &amp;gt; ( p1, p2, ... ) : R ;  
    &amp;lt; U1, U2, ... &amp;gt; ( q1, q2, ... ) : S ;  
    ...  
} ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the following example of an object type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{  
    func1(x: number): number;         // Method signature  
    func2: (x: number) =&amp;gt; number;     // Function type literal  
    func3: { (x: number): number };   // Object type literal  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the properties &amp;lsquo;func1&amp;rsquo;, &amp;lsquo;func2&amp;rsquo;, and &amp;lsquo;func3&amp;rsquo; are all of the same type, namely an object type with a single call signature taking a number and returning a number. Likewise, in the object type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{  
    func4(x: number): number;  
    func4(s: string): string;  
    func5: {  
        (x: number): number;  
        (s: string): string;  
    };  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the properties &amp;lsquo;func4&amp;rsquo; and &amp;lsquo;func5&amp;rsquo; are of the same type, namely an object type with two call signatures taking and returning number and string respectively.&lt;/p&gt;

&lt;h2 id=&#34;a-name-3-10-3-10-type-aliases:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.10&#34;/&gt;3.10 Type Aliases&lt;/h2&gt;

&lt;p&gt;A type alias declaration introduces a &lt;strong&gt;&lt;em&gt;type alias&lt;/em&gt;&lt;/strong&gt; in the containing declaration space.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;type&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;=&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A type alias serves as an alias for the type specified in the type alias declaration. Unlike an interface declaration, which always introduces a named object type, a type alias declaration can introduce a name for any kind of type, including primitive, union, and intersection types.&lt;/p&gt;

&lt;p&gt;A type alias may optionally have type parameters (section &lt;a href=&#34;#3.6.1&#34;&gt;3.6.1&lt;/a&gt;) that serve as placeholders for actual types to be provided when the type alias is referenced in type references. A type alias with type parameters is called a &lt;strong&gt;&lt;em&gt;generic type alias&lt;/em&gt;&lt;/strong&gt;. The type parameters of a generic type alias declaration are in scope and may be referenced in the aliased &lt;em&gt;Type&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Type aliases are referenced using type references (&lt;a href=&#34;#3.8.2&#34;&gt;3.8.2&lt;/a&gt;). Type references to generic type aliases produce instantiations of the aliased type with the given type arguments. Writing a reference to a non-generic type alias has exactly the same effect as writing the aliased type itself, and writing a reference to a generic type alias has exactly the same effect as writing the resulting instantiation of the aliased type.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;BindingIdentifier&lt;/em&gt; of a type alias declaration may not be one of the predefined type names (section &lt;a href=&#34;#3.8.1&#34;&gt;3.8.1&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;It is an error for the type specified in a type alias to depend on that type alias. Types have the following dependencies:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A type alias &lt;em&gt;directly depends on&lt;/em&gt; the type it aliases.&lt;/li&gt;
&lt;li&gt;A type reference &lt;em&gt;directly depends on&lt;/em&gt; the referenced type and each of the type arguments, if any.&lt;/li&gt;
&lt;li&gt;A union or intersection type &lt;em&gt;directly depends on&lt;/em&gt; each of the constituent types.&lt;/li&gt;
&lt;li&gt;An array type &lt;em&gt;directly depends on&lt;/em&gt; its element type.&lt;/li&gt;
&lt;li&gt;A tuple type &lt;em&gt;directly depends on&lt;/em&gt; each of its element types.&lt;/li&gt;
&lt;li&gt;A type query &lt;em&gt;directly depends on&lt;/em&gt; the type of the referenced entity.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given this definition, the complete set of types upon which a type depends is the transitive closure of the &lt;em&gt;directly depends on&lt;/em&gt; relationship. Note that object type literals, function type literals, and constructor type literals do not depend on types referenced within them and are therefore permitted to circularly reference themselves through type aliases.&lt;/p&gt;

&lt;p&gt;Some examples of type alias declarations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;type StringOrNumber = string | number;  
type Text = string | { text: string };  
type NameLookup = Dictionary&amp;lt;string, Person&amp;gt;;  
type ObjectStatics = typeof Object;  
type Callback&amp;lt;T&amp;gt; = (data: T) =&amp;gt; void;  
type Pair&amp;lt;T&amp;gt; = [T, T];  
type Coordinates = Pair&amp;lt;number&amp;gt;;  
type Tree&amp;lt;T&amp;gt; = T | { left: Tree&amp;lt;T&amp;gt;, right: Tree&amp;lt;T&amp;gt; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interface types have many similarities to type aliases for object type literals, but since interface types offer more capabilities they are generally preferred to type aliases. For example, the interface type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Point {  
    x: number;  
    y: number;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;could be written as the type alias&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;type Point = {  
    x: number;  
    y: number;  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, doing so means the following capabilities are lost:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An interface can be named in an extends or implements clause, but a type alias for an object type literal cannot.&lt;/li&gt;
&lt;li&gt;An interface can have multiple merged declarations, but a type alias for an object type literal cannot.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-3-11-3-11-type-relationships:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.11&#34;/&gt;3.11 Type Relationships&lt;/h2&gt;

&lt;p&gt;Types in TypeScript have identity, subtype, supertype, and assignment compatibility relationships as defined in the following sections.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-11-1-3-11-1-apparent-members:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.11.1&#34;/&gt;3.11.1 Apparent Members&lt;/h3&gt;

&lt;p&gt;The &lt;strong&gt;&lt;em&gt;apparent members&lt;/em&gt;&lt;/strong&gt; of a type are the members observed in subtype, supertype, and assignment compatibility relationships, as well as in the type checking of property accesses (section &lt;a href=&#34;#4.13&#34;&gt;4.13&lt;/a&gt;), &lt;code&gt;new&lt;/code&gt; operations (section &lt;a href=&#34;#4.14&#34;&gt;4.14&lt;/a&gt;), and function calls (section &lt;a href=&#34;#4.15&#34;&gt;4.15&lt;/a&gt;). The apparent members of a type are determined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The apparent members of the primitive type Number and all enum types are the apparent members of the global interface type &amp;lsquo;Number&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;The apparent members of the primitive type Boolean are the apparent members of the global interface type &amp;lsquo;Boolean&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;The apparent members of the primitive type String and all string literal types are the apparent members of the global interface type &amp;lsquo;String&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;The apparent members of a type parameter are the apparent members of the constraint (section &lt;a href=&#34;#3.6.1&#34;&gt;3.6.1&lt;/a&gt;) of that type parameter.&lt;/li&gt;
&lt;li&gt;The apparent members of an object type &lt;em&gt;T&lt;/em&gt; are the combination of the following:

&lt;ul&gt;
&lt;li&gt;The declared and/or inherited members of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The properties of the global interface type &amp;lsquo;Object&amp;rsquo; that aren&amp;rsquo;t hidden by properties with the same name in &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;T&lt;/em&gt; has one or more call or construct signatures, the properties of the global interface type &amp;lsquo;Function&amp;rsquo; that aren&amp;rsquo;t hidden by properties with the same name in &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The apparent members of a union type &lt;em&gt;U&lt;/em&gt; are determined as follows:

&lt;ul&gt;
&lt;li&gt;When all constituent types of &lt;em&gt;U&lt;/em&gt; have an apparent property named &lt;em&gt;N&lt;/em&gt;, &lt;em&gt;U&lt;/em&gt; has an apparent property named &lt;em&gt;N&lt;/em&gt; of a union type of the respective property types.&lt;/li&gt;
&lt;li&gt;When all constituent types of &lt;em&gt;U&lt;/em&gt; have an apparent call signature with a parameter list &lt;em&gt;P&lt;/em&gt;, &lt;em&gt;U&lt;/em&gt; has an apparent call signature with the parameter list &lt;em&gt;P&lt;/em&gt; and a return type that is a union of the respective return types. The call signatures appear in the same order as in the first constituent type.&lt;/li&gt;
&lt;li&gt;When all constituent types of &lt;em&gt;U&lt;/em&gt; have an apparent construct signature with a parameter list &lt;em&gt;P&lt;/em&gt;, &lt;em&gt;U&lt;/em&gt; has an apparent construct signature with the parameter list &lt;em&gt;P&lt;/em&gt; and a return type that is a union of the respective return types. The construct signatures appear in the same order as in the first constituent type.&lt;/li&gt;
&lt;li&gt;When all constituent types of &lt;em&gt;U&lt;/em&gt; have an apparent string index signature, &lt;em&gt;U&lt;/em&gt; has an apparent string index signature of a union type of the respective string index signature types.&lt;/li&gt;
&lt;li&gt;When all constituent types of &lt;em&gt;U&lt;/em&gt; have an apparent numeric index signature, &lt;em&gt;U&lt;/em&gt; has an apparent numeric index signature of a union type of the respective numeric index signature types.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The apparent members of an intersection type &lt;em&gt;I&lt;/em&gt; are determined as follows:

&lt;ul&gt;
&lt;li&gt;When one of more constituent types of &lt;em&gt;I&lt;/em&gt; have an apparent property named &lt;em&gt;N&lt;/em&gt;, &lt;em&gt;I&lt;/em&gt; has an apparent property named &lt;em&gt;N&lt;/em&gt; of an intersection type of the respective property types.&lt;/li&gt;
&lt;li&gt;When one or more constituent types of &lt;em&gt;I&lt;/em&gt; have a call signature &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;I&lt;/em&gt; has the apparent call signature &lt;em&gt;S&lt;/em&gt;. The signatures are ordered as a concatenation of the signatures of each constituent type in the order of the constituent types within &lt;em&gt;I&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;When one or more constituent types of &lt;em&gt;I&lt;/em&gt; have a construct signature &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;I&lt;/em&gt; has the apparent construct signature &lt;em&gt;S&lt;/em&gt;. The signatures are ordered as a concatenation of the signatures of each constituent type in the order of the constituent types within &lt;em&gt;I&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;When one or more constituent types of &lt;em&gt;I&lt;/em&gt; have an apparent string index signature, &lt;em&gt;I&lt;/em&gt; has an apparent string index signature of an intersection type of the respective string index signature types.&lt;/li&gt;
&lt;li&gt;When one or more constituent types of &lt;em&gt;I&lt;/em&gt; have an apparent numeric index signature, &lt;em&gt;I&lt;/em&gt; has an apparent numeric index signature of an intersection type of the respective numeric index signature types.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If a type is not one of the above, it is considered to have no apparent members.&lt;/p&gt;

&lt;p&gt;In effect, a type&amp;rsquo;s apparent members make it a subtype of the &amp;lsquo;Object&amp;rsquo; or &amp;lsquo;Function&amp;rsquo; interface unless the type defines members that are incompatible with those of the &amp;lsquo;Object&amp;rsquo; or &amp;lsquo;Function&amp;rsquo; interface—which, for example, occurs if the type defines a property with the same name as a property in the &amp;lsquo;Object&amp;rsquo; or &amp;lsquo;Function&amp;rsquo; interface but with a type that isn&amp;rsquo;t a subtype of that in the &amp;lsquo;Object&amp;rsquo; or &amp;lsquo;Function&amp;rsquo; interface.&lt;/p&gt;

&lt;p&gt;Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var o: Object = { x: 10, y: 20 };         // Ok  
var f: Function = (x: number) =&amp;gt; x * x;   // Ok  
var err: Object = { toString: 0 };        // Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last assignment is an error because the object literal has a &amp;lsquo;toString&amp;rsquo; method that isn&amp;rsquo;t compatible with that of &amp;lsquo;Object&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-11-2-3-11-2-type-and-member-identity:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.11.2&#34;/&gt;3.11.2 Type and Member Identity&lt;/h3&gt;

&lt;p&gt;Two types are considered &lt;strong&gt;&lt;em&gt;identical&lt;/em&gt;&lt;/strong&gt; when&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;they are both the Any type,&lt;/li&gt;
&lt;li&gt;they are the same primitive type,&lt;/li&gt;
&lt;li&gt;they are the same type parameter,&lt;/li&gt;
&lt;li&gt;they are union types with identical sets of constituent types, or&lt;/li&gt;
&lt;li&gt;they are intersection types with identical sets of constituent types, or&lt;/li&gt;
&lt;li&gt;they are object types with identical sets of members.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two members are considered identical when&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;they are public properties with identical names, optionality, and types,&lt;/li&gt;
&lt;li&gt;they are private or protected properties originating in the same declaration and having identical types,&lt;/li&gt;
&lt;li&gt;they are identical call signatures,&lt;/li&gt;
&lt;li&gt;they are identical construct signatures, or&lt;/li&gt;
&lt;li&gt;they are index signatures of identical kind with identical types.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two call or construct signatures are considered identical when they have the same number of type parameters with identical type parameter constraints and, after substituting type Any for the type parameters introduced by the signatures, identical number of parameters with identical kind (required, optional or rest) and types, and identical return types.&lt;/p&gt;

&lt;p&gt;Note that, except for primitive types and classes with private or protected members, it is structure, not naming, of types that determines identity. Also, note that parameter names are not significant when determining identity of signatures.&lt;/p&gt;

&lt;p&gt;Private and protected properties match only if they originate in the same declaration and have identical types. Two distinct types might contain properties that originate in the same declaration if the types are separate parameterized references to the same generic class. In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class C&amp;lt;T&amp;gt; { private x: T; }

interface X { f(): string; }

interface Y { f(): string; }

var a: C&amp;lt;X&amp;gt;;  
var b: C&amp;lt;Y&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the variables &amp;lsquo;a&amp;rsquo; and &amp;lsquo;b&amp;rsquo; are of identical types because the two type references to &amp;lsquo;C&amp;rsquo; create types with a private member &amp;lsquo;x&amp;rsquo; that originates in the same declaration, and because the two private &amp;lsquo;x&amp;rsquo; members have types with identical sets of members once the type arguments &amp;lsquo;X&amp;rsquo; and &amp;lsquo;Y&amp;rsquo; are substituted.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-11-3-3-11-3-subtypes-and-supertypes:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.11.3&#34;/&gt;3.11.3 Subtypes and Supertypes&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;S&lt;/em&gt; is a &lt;strong&gt;&lt;em&gt;subtype&lt;/em&gt;&lt;/strong&gt; of a type &lt;em&gt;T&lt;/em&gt;, and &lt;em&gt;T&lt;/em&gt; is a &lt;strong&gt;&lt;em&gt;supertype&lt;/em&gt;&lt;/strong&gt; of &lt;em&gt;S&lt;/em&gt;, if &lt;em&gt;S&lt;/em&gt; has no excess properties with respect to &lt;em&gt;T&lt;/em&gt; (&lt;a href=&#34;#3.11.5&#34;&gt;3.11.5&lt;/a&gt;) and one of the following is true:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; and &lt;em&gt;T&lt;/em&gt; are identical types.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; is the Any type.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is the Undefined type.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is the Null type and &lt;em&gt;T&lt;/em&gt; is not the Undefined type.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is an enum type and &lt;em&gt;T&lt;/em&gt; is the primitive type Number.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is a string literal type and &lt;em&gt;T&lt;/em&gt; is the primitive type String.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is a union type and each constituent type of &lt;em&gt;S&lt;/em&gt; is a subtype of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is an intersection type and at least one constituent type of &lt;em&gt;S&lt;/em&gt; is a subtype of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; is a union type and &lt;em&gt;S&lt;/em&gt; is a subtype of at least one constituent type of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; is an intersection type and &lt;em&gt;S&lt;/em&gt; is a subtype of each constituent type of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is a type parameter and the constraint of &lt;em&gt;S&lt;/em&gt; is a subtype of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is an object type, an intersection type, an enum type, or the Number, Boolean, or String primitive type, &lt;em&gt;T&lt;/em&gt; is an object type, and for each member &lt;em&gt;M&lt;/em&gt; in &lt;em&gt;T&lt;/em&gt;, one of the following is true:

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; is a property and &lt;em&gt;S&lt;/em&gt; has an apparent property &lt;em&gt;N&lt;/em&gt; where&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; have the same name,&lt;/li&gt;
&lt;li&gt;the type of &lt;em&gt;N&lt;/em&gt; is a subtype of that of &lt;em&gt;M&lt;/em&gt;,&lt;/li&gt;
&lt;li&gt;if &lt;em&gt;M&lt;/em&gt; is a required property, &lt;em&gt;N&lt;/em&gt; is also a required property, and&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; are both public, &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; are both private and originate in the same declaration, &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; are both protected and originate in the same declaration, or &lt;em&gt;M&lt;/em&gt; is protected and &lt;em&gt;N&lt;/em&gt; is declared in a class derived from the class in which &lt;em&gt;M&lt;/em&gt; is declared.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; is a non-specialized call or construct signature and &lt;em&gt;S&lt;/em&gt; has an apparent call or construct signature &lt;em&gt;N&lt;/em&gt; where, when &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; are instantiated using type Any as the type argument for all type parameters declared by &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; (if any),&lt;/li&gt;
&lt;li&gt;the signatures are of the same kind (call or construct),&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; has a rest parameter or the number of non-optional parameters in &lt;em&gt;N&lt;/em&gt; is less than or equal to the total number of parameters in &lt;em&gt;M&lt;/em&gt;,&lt;/li&gt;
&lt;li&gt;for parameter positions that are present in both signatures, each parameter type in &lt;em&gt;N&lt;/em&gt; is a subtype or supertype of the corresponding parameter type in &lt;em&gt;M&lt;/em&gt;, and&lt;/li&gt;
&lt;li&gt;the result type of &lt;em&gt;M&lt;/em&gt; is Void, or the result type of &lt;em&gt;N&lt;/em&gt; is a subtype of that of &lt;em&gt;M&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; is a string index signature of type &lt;em&gt;U&lt;/em&gt;, and &lt;em&gt;U&lt;/em&gt; is the Any type or &lt;em&gt;S&lt;/em&gt; has an apparent string index signature of a type that is a subtype of &lt;em&gt;U&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; is a numeric index signature of type &lt;em&gt;U&lt;/em&gt;, and &lt;em&gt;U&lt;/em&gt; is the Any type or &lt;em&gt;S&lt;/em&gt; has an apparent string or numeric index signature of a type that is a subtype of &lt;em&gt;U&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When comparing call or construct signatures, parameter names are ignored and rest parameters correspond to an unbounded expansion of optional parameters of the rest parameter element type.&lt;/p&gt;

&lt;p&gt;Note that specialized call and construct signatures (section &lt;a href=&#34;#3.9.2.4&#34;&gt;3.9.2.4&lt;/a&gt;) are not significant when determining subtype and supertype relationships.&lt;/p&gt;

&lt;p&gt;Also note that type parameters are not considered object types. Thus, the only subtypes of a type parameter &lt;em&gt;T&lt;/em&gt; are &lt;em&gt;T&lt;/em&gt; itself and other type parameters that are directly or indirectly constrained to &lt;em&gt;T&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-11-4-3-11-4-assignment-compatibility:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.11.4&#34;/&gt;3.11.4 Assignment Compatibility&lt;/h3&gt;

&lt;p&gt;Types are required to be assignment compatible in certain circumstances, such as expression and variable types in assignment statements and argument and parameter types in function calls.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;S&lt;/em&gt; is &lt;strong&gt;&lt;em&gt;assignable to&lt;/em&gt;&lt;/strong&gt; a type &lt;em&gt;T&lt;/em&gt;, and &lt;em&gt;T&lt;/em&gt; is &lt;strong&gt;&lt;em&gt;assignable from&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;S&lt;/em&gt;, if &lt;em&gt;S&lt;/em&gt; has no excess properties with respect to &lt;em&gt;T&lt;/em&gt; (&lt;a href=&#34;#3.11.5&#34;&gt;3.11.5&lt;/a&gt;) and one of the following is true:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; and &lt;em&gt;T&lt;/em&gt; are identical types.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; or &lt;em&gt;T&lt;/em&gt; is the Any type.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is the Undefined type.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is the Null type and &lt;em&gt;T&lt;/em&gt; is not the Undefined type.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; or &lt;em&gt;T&lt;/em&gt; is an enum type and the other is the primitive type Number.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is a string literal type and &lt;em&gt;T&lt;/em&gt; is the primitive type String.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is a union type and each constituent type of &lt;em&gt;S&lt;/em&gt; is assignable to &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is an intersection type and at least one constituent type of &lt;em&gt;S&lt;/em&gt; is assignable to &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; is a union type and &lt;em&gt;S&lt;/em&gt; is assignable to at least one constituent type of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; is an intersection type and &lt;em&gt;S&lt;/em&gt; is assignable to each constituent type of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is a type parameter and the constraint of &lt;em&gt;S&lt;/em&gt; is assignable to &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is an object type, an intersection type, an enum type, or the Number, Boolean, or String primitive type, &lt;em&gt;T&lt;/em&gt; is an object type, and for each member &lt;em&gt;M&lt;/em&gt; in &lt;em&gt;T&lt;/em&gt;, one of the following is true:

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; is a property and &lt;em&gt;S&lt;/em&gt; has an apparent property &lt;em&gt;N&lt;/em&gt; where&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; have the same name,&lt;/li&gt;
&lt;li&gt;the type of &lt;em&gt;N&lt;/em&gt; is assignable to that of &lt;em&gt;M&lt;/em&gt;,&lt;/li&gt;
&lt;li&gt;if &lt;em&gt;M&lt;/em&gt; is a required property, &lt;em&gt;N&lt;/em&gt; is also a required property, and&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; are both public, &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; are both private and originate in the same declaration, &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; are both protected and originate in the same declaration, or &lt;em&gt;M&lt;/em&gt; is protected and &lt;em&gt;N&lt;/em&gt; is declared in a class derived from the class in which &lt;em&gt;M&lt;/em&gt; is declared.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; is an optional property and &lt;em&gt;S&lt;/em&gt; has no apparent property of the same name as &lt;em&gt;M&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; is a non-specialized call or construct signature and &lt;em&gt;S&lt;/em&gt; has an apparent call or construct signature &lt;em&gt;N&lt;/em&gt; where, when &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; are instantiated using type Any as the type argument for all type parameters declared by &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; (if any),&lt;/li&gt;
&lt;li&gt;the signatures are of the same kind (call or construct),&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; has a rest parameter or the number of non-optional parameters in &lt;em&gt;N&lt;/em&gt; is less than or equal to the total number of parameters in &lt;em&gt;M&lt;/em&gt;,&lt;/li&gt;
&lt;li&gt;for parameter positions that are present in both signatures, each parameter type in &lt;em&gt;N&lt;/em&gt; is assignable to or from the corresponding parameter type in &lt;em&gt;M&lt;/em&gt;, and&lt;/li&gt;
&lt;li&gt;the result type of &lt;em&gt;M&lt;/em&gt; is Void, or the result type of &lt;em&gt;N&lt;/em&gt; is assignable to that of &lt;em&gt;M&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; is a string index signature of type &lt;em&gt;U&lt;/em&gt;, and &lt;em&gt;U&lt;/em&gt; is the Any type or &lt;em&gt;S&lt;/em&gt; has an apparent string index signature of a type that is assignable to &lt;em&gt;U&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; is a numeric index signature of type &lt;em&gt;U&lt;/em&gt;, and &lt;em&gt;U&lt;/em&gt; is the Any type or &lt;em&gt;S&lt;/em&gt; has an apparent string or numeric index signature of a type that is assignable to &lt;em&gt;U&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When comparing call or construct signatures, parameter names are ignored and rest parameters correspond to an unbounded expansion of optional parameters of the rest parameter element type.&lt;/p&gt;

&lt;p&gt;Note that specialized call and construct signatures (section &lt;a href=&#34;#3.9.2.4&#34;&gt;3.9.2.4&lt;/a&gt;) are not significant when determining assignment compatibility.&lt;/p&gt;

&lt;p&gt;The assignment compatibility and subtyping rules differ only in that&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the Any type is assignable to, but not a subtype of, all types,&lt;/li&gt;
&lt;li&gt;the primitive type Number is assignable to, but not a subtype of, all enum types, and&lt;/li&gt;
&lt;li&gt;an object type without a particular property is assignable to an object type in which that property is optional.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The assignment compatibility rules imply that, when assigning values or passing parameters, optional properties must either be present and of a compatible type, or not be present at all. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function foo(x: { id: number; name?: string; }) { }

foo({ id: 1234 });                 // Ok  
foo({ id: 1234, name: &amp;quot;hello&amp;quot; });  // Ok  
foo({ id: 1234, name: false });    // Error, name of wrong type  
foo({ name: &amp;quot;hello&amp;quot; });            // Error, id required but missing
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-11-5-3-11-5-excess-properties:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.11.5&#34;/&gt;3.11.5 Excess Properties&lt;/h3&gt;

&lt;p&gt;The subtype and assignment compatibility relationships require that source types have no excess properties with respect to their target types. The purpose of this check is to detect excess or misspelled properties in object literals.&lt;/p&gt;

&lt;p&gt;A source type &lt;em&gt;S&lt;/em&gt; is considered to have excess properties with respect to a target type &lt;em&gt;T&lt;/em&gt; if&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is a fresh object literal type, as defined below, and&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; has one or more properties that aren&amp;rsquo;t expected in &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A property &lt;em&gt;P&lt;/em&gt; is said to be expected in a type &lt;em&gt;T&lt;/em&gt; if one of the following is true:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; is not an object, union, or intersection type.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; is an object type and

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; has a property with the same name as &lt;em&gt;P&lt;/em&gt;,&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; has a string or numeric index signature,&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; has no properties, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; is the global type &amp;lsquo;Object&amp;rsquo;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt; is a union or intersection type and &lt;em&gt;P&lt;/em&gt; is expected in at least one of the constituent types of &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The type inferred for an object literal (as described in section &lt;a href=&#34;#4.5&#34;&gt;4.5&lt;/a&gt;) is considered a &lt;strong&gt;&lt;em&gt;fresh object literal type&lt;/em&gt;&lt;/strong&gt;. The freshness disappears when an object literal type is widened (&lt;a href=&#34;#3.12&#34;&gt;3.12&lt;/a&gt;) or is the type of the expression in a type assertion (&lt;a href=&#34;#4.16&#34;&gt;4.16&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Consider the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface CompilerOptions {  
    strict?: boolean;  
    sourcePath?: string;  
    targetPath?: string;  
}

var options: CompilerOptions = {  
    strict: true,  
    sourcepath: &amp;quot;./src&amp;quot;,  // Error, excess or misspelled property  
    targetpath: &amp;quot;./bin&amp;quot;   // Error, excess or misspelled property  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;lsquo;CompilerOptions&amp;rsquo; type contains only optional properties, so without the excess property check, &lt;em&gt;any&lt;/em&gt; object literal would be assignable to the &amp;lsquo;options&amp;rsquo; variable (because a misspelled property would just be considered an excess property of a different name).&lt;/p&gt;

&lt;p&gt;In cases where excess properties are expected, an index signature can be added to the target type as an indicator of intent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface InputElement {  
    name: string;  
    visible?: boolean;  
    [x: string]: any;            // Allow additional properties of any type  
}

var address: InputElement = {  
    name: &amp;quot;Address&amp;quot;,  
    visible: true,  
    help: &amp;quot;Enter address here&amp;quot;,  // Allowed because of index signature  
    shortcut: &amp;quot;Alt-A&amp;quot;            // Allowed because of index signature  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-3-11-6-3-11-6-contextual-signature-instantiation:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.11.6&#34;/&gt;3.11.6 Contextual Signature Instantiation&lt;/h3&gt;

&lt;p&gt;During type argument inference in a function call (section &lt;a href=&#34;#4.15.2&#34;&gt;4.15.2&lt;/a&gt;) it is in certain circumstances necessary to instantiate a generic call signature of an argument expression in the context of a non-generic call signature of a parameter such that further inferences can be made. A generic call signature &lt;em&gt;A&lt;/em&gt; is &lt;strong&gt;&lt;em&gt;instantiated in the context of&lt;/em&gt;&lt;/strong&gt; non-generic call signature &lt;em&gt;B&lt;/em&gt; as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Using the process described in &lt;a href=&#34;#3.11.7&#34;&gt;3.11.7&lt;/a&gt;, inferences for &lt;em&gt;A&lt;/em&gt;&amp;rsquo;s type parameters are made from each parameter type in &lt;em&gt;B&lt;/em&gt; to the corresponding parameter type in &lt;em&gt;A&lt;/em&gt; for those parameter positions that are present in both signatures, where rest parameters correspond to an unbounded expansion of optional parameters of the rest parameter element type.&lt;/li&gt;
&lt;li&gt;The inferred type argument for each type parameter is the union type of the set of inferences made for that type parameter. However, if the union type does not satisfy the constraint of the type parameter, the inferred type argument is instead the constraint.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;a-name-3-11-7-3-11-7-type-inference:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.11.7&#34;/&gt;3.11.7 Type Inference&lt;/h3&gt;

&lt;p&gt;In certain contexts, inferences for a given set of type parameters are made &lt;em&gt;from&lt;/em&gt; a type &lt;em&gt;S&lt;/em&gt;, in which those type parameters do not occur, &lt;em&gt;to&lt;/em&gt; another type &lt;em&gt;T&lt;/em&gt;, in which those type parameters do occur. Inferences consist of a set of candidate type arguments collected for each of the type parameters. The inference process recursively relates &lt;em&gt;S&lt;/em&gt; and &lt;em&gt;T&lt;/em&gt; to gather as many inferences as possible:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;T&lt;/em&gt; is one of the type parameters for which inferences are being made, &lt;em&gt;S&lt;/em&gt; is added to the set of inferences for that type parameter.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;S&lt;/em&gt; and &lt;em&gt;T&lt;/em&gt; are references to the same generic type, inferences are made from each type argument in &lt;em&gt;S&lt;/em&gt; to each corresponding type argument in &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;S&lt;/em&gt; and &lt;em&gt;T&lt;/em&gt; are tuple types with the same number of elements, inferences are made from each element type in &lt;em&gt;S&lt;/em&gt; to each corresponding element type in &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;T&lt;/em&gt; is a union or intersection type:

&lt;ul&gt;
&lt;li&gt;First, inferences are made from &lt;em&gt;S&lt;/em&gt; to each constituent type in &lt;em&gt;T&lt;/em&gt; that isn&amp;rsquo;t simply one of the type parameters for which inferences are being made.&lt;/li&gt;
&lt;li&gt;If the first step produced no inferences then if T is a union type and exactly one constituent type in &lt;em&gt;T&lt;/em&gt; is simply a type parameter for which inferences are being made, inferences are made from &lt;em&gt;S&lt;/em&gt; to that type parameter.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;S&lt;/em&gt; is a union or intersection type, inferences are made from each constituent type in &lt;em&gt;S&lt;/em&gt; to &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;S&lt;/em&gt; and &lt;em&gt;T&lt;/em&gt; are object types, then for each member &lt;em&gt;M&lt;/em&gt; in &lt;em&gt;T&lt;/em&gt;:

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;M&lt;/em&gt; is a property and &lt;em&gt;S&lt;/em&gt; contains a property &lt;em&gt;N&lt;/em&gt; with the same name as &lt;em&gt;M&lt;/em&gt;, inferences are made from the type of &lt;em&gt;N&lt;/em&gt; to the type of &lt;em&gt;M&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;M&lt;/em&gt; is a call signature and a corresponding call signature &lt;em&gt;N&lt;/em&gt; exists in &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;N&lt;/em&gt; is instantiated with the Any type as an argument for each type parameter (if any) and inferences are made from parameter types in &lt;em&gt;N&lt;/em&gt; to the corresponding parameter types in &lt;em&gt;M&lt;/em&gt; for positions that are present in both signatures, and from the return type of &lt;em&gt;N&lt;/em&gt; to the return type of &lt;em&gt;M&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;M&lt;/em&gt; is a construct signature and a corresponding construct signature &lt;em&gt;N&lt;/em&gt; exists in &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;N&lt;/em&gt; is instantiated with the Any type as an argument for each type parameter (if any) and inferences are made from parameter types in &lt;em&gt;N&lt;/em&gt; to the corresponding parameter types in &lt;em&gt;M&lt;/em&gt; for positions that are present in both signatures, and from the return type of &lt;em&gt;N&lt;/em&gt; to the return type of &lt;em&gt;M&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;M&lt;/em&gt; is a string index signature and &lt;em&gt;S&lt;/em&gt; contains a string index signature &lt;em&gt;N&lt;/em&gt;, inferences are made from the type of &lt;em&gt;N&lt;/em&gt; to the type of &lt;em&gt;M&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;M&lt;/em&gt; is a numeric index signature and &lt;em&gt;S&lt;/em&gt; contains a numeric index signature &lt;em&gt;N&lt;/em&gt;, inferences are made from the type of &lt;em&gt;N&lt;/em&gt; to the type of &lt;em&gt;M&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;M&lt;/em&gt; is a numeric index signature and &lt;em&gt;S&lt;/em&gt; contains a string index signature &lt;em&gt;N&lt;/em&gt;, inferences are made from the type of &lt;em&gt;N&lt;/em&gt; to the type of &lt;em&gt;M&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When comparing call or construct signatures, signatures in &lt;em&gt;S&lt;/em&gt; correspond to signatures of the same kind in &lt;em&gt;T&lt;/em&gt; pairwise in declaration order. If &lt;em&gt;S&lt;/em&gt; and &lt;em&gt;T&lt;/em&gt; have different numbers of a given kind of signature, the excess &lt;em&gt;first&lt;/em&gt; signatures in declaration order of the longer list are ignored.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Update to reflect &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/5738&#34;&gt;improved union and intersection type inference&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-3-11-8-3-11-8-recursive-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.11.8&#34;/&gt;3.11.8 Recursive Types&lt;/h3&gt;

&lt;p&gt;Classes and interfaces can reference themselves in their internal structure, in effect creating recursive types with infinite nesting. For example, the type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface A { next: A; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;contains an infinitely nested sequence of &amp;lsquo;next&amp;rsquo; properties. Types such as this are perfectly valid but require special treatment when determining type relationships. Specifically, when comparing types &lt;em&gt;S&lt;/em&gt; and &lt;em&gt;T&lt;/em&gt; for a given relationship (identity, subtype, or assignability), the relationship in question is assumed to be true for every directly or indirectly nested occurrence of the same &lt;em&gt;S&lt;/em&gt; and the same &lt;em&gt;T&lt;/em&gt; (where same means originating in the same declaration and, if applicable, having identical type arguments). For example, consider the identity relationship between &amp;lsquo;A&amp;rsquo; above and &amp;lsquo;B&amp;rsquo; below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface B { next: C; }

interface C { next: D; }

interface D { next: B; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To determine whether &amp;lsquo;A&amp;rsquo; and &amp;lsquo;B&amp;rsquo; are identical, first the &amp;lsquo;next&amp;rsquo; properties of type &amp;lsquo;A&amp;rsquo; and &amp;lsquo;C&amp;rsquo; are compared. That leads to comparing the &amp;lsquo;next&amp;rsquo; properties of type &amp;lsquo;A&amp;rsquo; and &amp;rsquo;D&amp;rsquo;, which leads to comparing the &amp;lsquo;next&amp;rsquo; properties of type &amp;lsquo;A&amp;rsquo; and &amp;lsquo;B&amp;rsquo;. Since &amp;lsquo;A&amp;rsquo; and &amp;lsquo;B&amp;rsquo; are already being compared this relationship is by definition true. That in turn causes the other comparisons to be true, and therefore the final result is true.&lt;/p&gt;

&lt;p&gt;When this same technique is used to compare generic type references, two type references are considered the same when they originate in the same declaration and have identical type arguments.&lt;/p&gt;

&lt;p&gt;In certain circumstances, generic types that directly or indirectly reference themselves in a recursive fashion can lead to infinite series of distinct instantiations. For example, in the type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface List&amp;lt;T&amp;gt; {  
    data: T;  
    next: List&amp;lt;T&amp;gt;;  
    owner: List&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;List&amp;lt;T&amp;gt;&amp;rsquo; has a member &amp;lsquo;owner&amp;rsquo; of type &amp;lsquo;List&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;&amp;lsquo;, which has a member &amp;lsquo;owner&amp;rsquo; of type &amp;lsquo;List&amp;lt;List&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&amp;lsquo;, which has a member &amp;lsquo;owner&amp;rsquo; of type &amp;lsquo;List&amp;lt;List&amp;lt;List&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;rsquo; and so on, ad infinitum. Since type relationships are determined structurally, possibly exploring the constituent types to their full depth, in order to determine type relationships involving infinitely expanding generic types it may be necessary for the compiler to terminate the recursion at some point with the assumption that no further exploration will change the outcome.&lt;/p&gt;

&lt;h2 id=&#34;a-name-3-12-3-12-widened-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;3.12&#34;/&gt;3.12 Widened Types&lt;/h2&gt;

&lt;p&gt;In several situations TypeScript infers types from context, alleviating the need for the programmer to explicitly specify types that appear obvious. For example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var name = &amp;quot;Steve&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;infers the type of &amp;lsquo;name&amp;rsquo; to be the String primitive type since that is the type of the value used to initialize it. When inferring the type of a variable, property or function result from an expression, the &lt;strong&gt;&lt;em&gt;widened&lt;/em&gt;&lt;/strong&gt; form of the source type is used as the inferred type of the target. The widened form of a type is the type in which all occurrences of the Null and Undefined types have been replaced with the type &lt;code&gt;any&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The following example shows the results of widening types to produce inferred variable types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var a = null;                 // var a: any  
var b = undefined;            // var b: any  
var c = { x: 0, y: null };    // var c: { x: number, y: any }  
var d = [ null, undefined ];  // var d: any[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-4-4-expressions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4&#34;/&gt;4 Expressions&lt;/h1&gt;

&lt;p&gt;This chapter describes the manner in which TypeScript provides type inference and type checking for JavaScript expressions. TypeScript&amp;rsquo;s type analysis occurs entirely at compile-time and adds no run-time overhead to expression evaluation.&lt;/p&gt;

&lt;p&gt;TypeScript&amp;rsquo;s typing rules define a type for every expression construct. For example, the type of the literal 123 is the Number primitive type, and the type of the object literal { a: 10, b: &amp;ldquo;hello&amp;rdquo; } is { a: number; b: string; }. The sections in this chapter describe these rules in detail.&lt;/p&gt;

&lt;p&gt;In addition to type inference and type checking, TypeScript augments JavaScript expressions with the following constructs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Optional parameter and return type annotations in function expressions and arrow functions.&lt;/li&gt;
&lt;li&gt;Type arguments in function calls.&lt;/li&gt;
&lt;li&gt;Type assertions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unless otherwise noted in the sections that follow, TypeScript expressions and the JavaScript expressions generated from them are identical.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-1-4-1-values-and-references:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.1&#34;/&gt;4.1 Values and References&lt;/h2&gt;

&lt;p&gt;Expressions are classified as &lt;strong&gt;&lt;em&gt;values&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;references&lt;/em&gt;&lt;/strong&gt;. References are the subset of expressions that are permitted as the target of an assignment. Specifically, references are combinations of identifiers (section &lt;a href=&#34;#4.3&#34;&gt;4.3&lt;/a&gt;), parentheses (section &lt;a href=&#34;#4.8&#34;&gt;4.8&lt;/a&gt;), and property accesses (section &lt;a href=&#34;#4.13&#34;&gt;4.13&lt;/a&gt;). All other expression constructs described in this chapter are classified as values.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-2-4-2-the-this-keyword:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.2&#34;/&gt;4.2 The this Keyword&lt;/h2&gt;

&lt;p&gt;The type of &lt;code&gt;this&lt;/code&gt; in an expression depends on the location in which the reference takes place:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In a constructor, instance member function, instance member accessor, or instance member variable initializer, &lt;code&gt;this&lt;/code&gt; is of the this-type (section &lt;a href=&#34;#3.6.3&#34;&gt;3.6.3&lt;/a&gt;) of the containing class.&lt;/li&gt;
&lt;li&gt;In a static member function or static member accessor, the type of &lt;code&gt;this&lt;/code&gt; is the constructor function type of the containing class.&lt;/li&gt;
&lt;li&gt;In a function declaration or a function expression, &lt;code&gt;this&lt;/code&gt; is of type Any.&lt;/li&gt;
&lt;li&gt;In the global namespace, &lt;code&gt;this&lt;/code&gt; is of type Any.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In all other contexts it is a compile-time error to reference &lt;code&gt;this&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that an arrow function (section &lt;a href=&#34;#4.11&#34;&gt;4.11&lt;/a&gt;) has no &lt;code&gt;this&lt;/code&gt; parameter but rather preserves the &lt;code&gt;this&lt;/code&gt; of its enclosing context.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-3-4-3-identifiers:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.3&#34;/&gt;4.3 Identifiers&lt;/h2&gt;

&lt;p&gt;When an expression is an &lt;em&gt;IdentifierReference&lt;/em&gt;, the expression refers to the most nested namespace, class, enum, function, variable, or parameter with that name whose scope (section &lt;a href=&#34;#2.4&#34;&gt;2.4&lt;/a&gt;) includes the location of the reference. The type of such an expression is the type associated with the referenced entity:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For a namespace, the object type associated with the namespace instance.&lt;/li&gt;
&lt;li&gt;For a class, the constructor type associated with the constructor function object.&lt;/li&gt;
&lt;li&gt;For an enum, the object type associated with the enum object.&lt;/li&gt;
&lt;li&gt;For a function, the function type associated with the function object.&lt;/li&gt;
&lt;li&gt;For a variable, the type of the variable.&lt;/li&gt;
&lt;li&gt;For a parameter, the type of the parameter.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An identifier expression that references a variable or parameter is classified as a reference. An identifier expression that references any other kind of entity is classified as a value (and therefore cannot be the target of an assignment).&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-4-4-4-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.4&#34;/&gt;4.4 Literals&lt;/h2&gt;

&lt;p&gt;Literals are typed as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The type of the &lt;code&gt;null&lt;/code&gt; literal is the Null primitive type.&lt;/li&gt;
&lt;li&gt;The type of the literals &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; is the Boolean primitive type.&lt;/li&gt;
&lt;li&gt;The type of numeric literals is the Number primitive type.&lt;/li&gt;
&lt;li&gt;The type of string literals is the String primitive type.&lt;/li&gt;
&lt;li&gt;The type of regular expression literals is the global interface type &amp;lsquo;RegExp&amp;rsquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-4-5-4-5-object-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.5&#34;/&gt;4.5 Object Literals&lt;/h2&gt;

&lt;p&gt;Object literals are extended to support type annotations in methods and get and set accessors.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyDefinition:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;CoverInitializedName&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;GetAccessor&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;SetAccessor&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;GetAccessor:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;get&lt;/code&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;SetAccessor:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;set&lt;/code&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifierOrPattern&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The type of an object literal is an object type with the set of properties specified by the property assignments in the object literal. A get and set accessor may specify the same property name, but otherwise it is an error to specify multiple property assignments for the same property.&lt;/p&gt;

&lt;p&gt;A shorthand property assignment of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;prop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;prop : prop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, a property assignment of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;f ( ... ) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;f : function ( ... ) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each property assignment in an object literal is processed as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the object literal is contextually typed and the contextual type contains a property with a matching name, the property assignment is contextually typed by the type of that property.&lt;/li&gt;
&lt;li&gt;Otherwise, if the object literal is contextually typed, if the contextual type contains a numeric index signature, and if the property assignment specifies a numeric property name, the property assignment is contextually typed by the type of the numeric index signature.&lt;/li&gt;
&lt;li&gt;Otherwise, if the object literal is contextually typed and the contextual type contains a string index signature, the property assignment is contextually typed by the type of the string index signature.&lt;/li&gt;
&lt;li&gt;Otherwise, the property assignment is processed without a contextual type.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The type of a property introduced by a property assignment of the form &lt;em&gt;Name&lt;/em&gt; &lt;code&gt;:&lt;/code&gt; &lt;em&gt;Expr&lt;/em&gt; is the type of &lt;em&gt;Expr&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A get accessor declaration is processed in the same manner as an ordinary function declaration (section &lt;a href=&#34;#6.1&#34;&gt;6.1&lt;/a&gt;) with no parameters. A set accessor declaration is processed in the same manner as an ordinary function declaration with a single parameter and a Void return type. When both a get and set accessor is declared for a property:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If both accessors include type annotations, the specified types must be identical.&lt;/li&gt;
&lt;li&gt;If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.&lt;/li&gt;
&lt;li&gt;If neither accessor includes a type annotation, the inferred return type of the get accessor becomes the parameter type of the set accessor.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If a get accessor is declared for a property, the return type of the get accessor becomes the type of the property. If only a set accessor is declared for a property, the parameter type (which may be type Any if no type annotation is present) of the set accessor becomes the type of the property.&lt;/p&gt;

&lt;p&gt;When an object literal is contextually typed by a type that includes a string index signature, the resulting type of the object literal includes a string index signature with the union type of the types of the properties declared in the object literal, or the Undefined type if the object literal is empty. Likewise, when an object literal is contextually typed by a type that includes a numeric index signature, the resulting type of the object literal includes a numeric index signature with the union type of the types of the numerically named properties (section &lt;a href=&#34;#3.9.4&#34;&gt;3.9.4&lt;/a&gt;) declared in the object literal, or the Undefined type if the object literal declares no numerically named properties.&lt;/p&gt;

&lt;p&gt;If the &lt;em&gt;PropertyName&lt;/em&gt; of a property assignment is a computed property name that doesn&amp;rsquo;t denote a well-known symbol (&lt;a href=&#34;#2.2.3&#34;&gt;2.2.3&lt;/a&gt;), the construct is considered a &lt;strong&gt;&lt;em&gt;dynamic property assignment&lt;/em&gt;&lt;/strong&gt;. The following rules apply to dynamic property assignments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A dynamic property assignment does not introduce a property in the type of the object literal.&lt;/li&gt;
&lt;li&gt;The property name expression of a dynamic property assignment must be of type Any or the String, Number, or Symbol primitive type.&lt;/li&gt;
&lt;li&gt;The name associated with a dynamic property assignment is considered to be a numeric property name if the property name expression is of type Any or the Number primitive type.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-4-6-4-6-array-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.6&#34;/&gt;4.6 Array Literals&lt;/h2&gt;

&lt;p&gt;An array literal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;[ expr1, expr2, ..., exprN ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;denotes a value of an array type (section &lt;a href=&#34;#3.3.2&#34;&gt;3.3.2&lt;/a&gt;) or a tuple type (section &lt;a href=&#34;#3.3.3&#34;&gt;3.3.3&lt;/a&gt;) depending on context.&lt;/p&gt;

&lt;p&gt;Each element expression in a non-empty array literal is processed as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the array literal contains no spread elements, and if the array literal is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;) by a type &lt;em&gt;T&lt;/em&gt; and &lt;em&gt;T&lt;/em&gt; has a property with the numeric name &lt;em&gt;N&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is the index of the element expression in the array literal, the element expression is contextually typed by the type of that property.&lt;/li&gt;
&lt;li&gt;Otherwise, if the array literal is contextually typed by a type &lt;em&gt;T&lt;/em&gt; with a numeric index signature, the element expression is contextually typed by the type of the numeric index signature.&lt;/li&gt;
&lt;li&gt;Otherwise, the element expression is not contextually typed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The resulting type an array literal expression is determined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the array literal is empty, the resulting type is an array type with the element type Undefined.&lt;/li&gt;
&lt;li&gt;Otherwise, if the array literal contains no spread elements and is contextually typed by a tuple-like type (section &lt;a href=&#34;#3.3.3&#34;&gt;3.3.3&lt;/a&gt;), the resulting type is a tuple type constructed from the types of the element expressions.&lt;/li&gt;
&lt;li&gt;Otherwise, if the array literal contains no spread elements and is an array assignment pattern in a destructuring assignment (section &lt;a href=&#34;#4.21.1&#34;&gt;4.21.1&lt;/a&gt;), the resulting type is a tuple type constructed from the types of the element expressions.&lt;/li&gt;
&lt;li&gt;Otherwise, the resulting type is an array type with an element type that is the union of the types of the non-spread element expressions and the numeric index signature types of the spread element expressions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A spread element must specify an expression of an array-like type (section &lt;a href=&#34;#3.3.2&#34;&gt;3.3.2&lt;/a&gt;), or otherwise an error occurs.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: The compiler currently doesn&amp;rsquo;t support applying the spread operator to a string (to spread the individual characters of a string into a string array). This will eventually be allowed, but only when the code generation target is ECMAScript 2015 or later&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Document spreading an &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/2498&#34;&gt;iterator&lt;/a&gt; into an array literal&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The rules above mean that an array literal is always of an array type, unless it is contextually typed by a tuple-like type. For example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var a = [1, 2];                          // number[]  
var b = [&amp;quot;hello&amp;quot;, true];                 // (string | boolean)[]  
var c: [number, string] = [3, &amp;quot;three&amp;quot;];  // [number, string]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the output target is ECMAScript 3 or 5, array literals containing spread elements are rewritten to invocations of the &lt;code&gt;concat&lt;/code&gt; method. For example, the assignments&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var a = [2, 3, 4];  
var b = [0, 1, ...a, 5, 6];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;are rewritten to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var a = [2, 3, 4];  
var b = [0, 1].concat(a, [5, 6]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-4-7-4-7-template-literals:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.7&#34;/&gt;4.7 Template Literals&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;TODO: &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/960&#34;&gt;Template literals&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-8-4-8-parentheses:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.8&#34;/&gt;4.8 Parentheses&lt;/h2&gt;

&lt;p&gt;A parenthesized expression&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;( expr )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;has the same type and classification as the contained expression itself. Specifically, if the contained expression is classified as a reference, so is the parenthesized expression.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-9-4-9-the-super-keyword:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.9&#34;/&gt;4.9 The super Keyword&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;super&lt;/code&gt; keyword can be used in expressions to reference base class properties and the base class constructor.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-9-1-4-9-1-super-calls:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.9.1&#34;/&gt;4.9.1 Super Calls&lt;/h3&gt;

&lt;p&gt;Super calls consist of the keyword &lt;code&gt;super&lt;/code&gt; followed by an argument list enclosed in parentheses. Super calls are only permitted in constructors of derived classes, as described in section &lt;a href=&#34;#8.3.2&#34;&gt;8.3.2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A super call invokes the constructor of the base class on the instance referenced by &lt;code&gt;this&lt;/code&gt;. A super call is processed as a function call (section &lt;a href=&#34;#4.15&#34;&gt;4.15&lt;/a&gt;) using the construct signatures of the base class constructor function type as the initial set of candidate signatures for overload resolution. Type arguments cannot be explicitly specified in a super call. If the base class is a generic class, the type arguments used to process a super call are always those specified in the &lt;code&gt;extends&lt;/code&gt; clause that references the base class.&lt;/p&gt;

&lt;p&gt;The type of a super call expression is Void.&lt;/p&gt;

&lt;p&gt;The JavaScript code generated for a super call is specified in section &lt;a href=&#34;#8.7.2&#34;&gt;8.7.2&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-9-2-4-9-2-super-property-access:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.9.2&#34;/&gt;4.9.2 Super Property Access&lt;/h3&gt;

&lt;p&gt;A super property access consists of the keyword &lt;code&gt;super&lt;/code&gt; followed by a dot and an identifier. Super property accesses are used to access base class member functions from derived classes and are permitted in contexts where &lt;code&gt;this&lt;/code&gt; (section &lt;a href=&#34;#4.2&#34;&gt;4.2&lt;/a&gt;) references a derived class instance or a derived class constructor function. Specifically:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In a constructor, instance member function, instance member accessor, or instance member variable initializer where &lt;code&gt;this&lt;/code&gt; references a derived class instance, a super property access is permitted and must specify a public instance member function of the base class.&lt;/li&gt;
&lt;li&gt;In a static member function or static member accessor where &lt;code&gt;this&lt;/code&gt; references the constructor function object of a derived class, a super property access is permitted and must specify a public static member function of the base class.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Super property accesses are not permitted in other contexts, and it is not possible to access other kinds of base class members in a super property access. Note that super property accesses are not permitted inside function expressions nested in the above constructs because &lt;code&gt;this&lt;/code&gt; is of type Any in such function expressions.&lt;/p&gt;

&lt;p&gt;Super property accesses are typically used to access overridden base class member functions from derived class member functions. For an example of this, see section &lt;a href=&#34;#8.4.2&#34;&gt;8.4.2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The JavaScript code generated for a super property access is specified in section &lt;a href=&#34;#8.7.2&#34;&gt;8.7.2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Update section to include &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/3970&#34;&gt;bracket notation in super property access&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-10-4-10-function-expressions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.10&#34;/&gt;4.10 Function Expressions&lt;/h2&gt;

&lt;p&gt;Function expressions are extended from JavaScript to optionally include parameter and return type annotations.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionExpression:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;function&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The descriptions of function declarations provided in chapter &lt;a href=&#34;#6&#34;&gt;6&lt;/a&gt; apply to function expressions as well, except that function expressions do not support overloading.&lt;/p&gt;

&lt;p&gt;The type of a function expression is an object type containing a single call signature with parameter and return types inferred from the function expression&amp;rsquo;s signature and body.&lt;/p&gt;

&lt;p&gt;When a function expression with no type parameters and no parameter type annotations is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;) by a type &lt;em&gt;T&lt;/em&gt; and a contextual signature &lt;em&gt;S&lt;/em&gt; can be extracted from &lt;em&gt;T&lt;/em&gt;, the function expression is processed as if it had explicitly specified parameter type annotations as they exist in &lt;em&gt;S&lt;/em&gt;. Parameters are matched by position and need not have matching names. If the function expression has fewer parameters than &lt;em&gt;S&lt;/em&gt;, the additional parameters in &lt;em&gt;S&lt;/em&gt; are ignored. If the function expression has more parameters than &lt;em&gt;S&lt;/em&gt;, the additional parameters are all considered to have type Any.&lt;/p&gt;

&lt;p&gt;Likewise, when a function expression with no return type annotation is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;) by a function type &lt;em&gt;T&lt;/em&gt; and a contextual signature &lt;em&gt;S&lt;/em&gt; can be extracted from &lt;em&gt;T&lt;/em&gt;, expressions in contained return statements (section &lt;a href=&#34;#5.10&#34;&gt;5.10&lt;/a&gt;) are contextually typed by the return type of &lt;em&gt;S&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A contextual signature &lt;em&gt;S&lt;/em&gt; is extracted from a function type &lt;em&gt;T&lt;/em&gt; as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;T&lt;/em&gt; is a function type with exactly one call signature, and if that call signature is non-generic, &lt;em&gt;S&lt;/em&gt; is that signature.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;T&lt;/em&gt; is a union type, let &lt;em&gt;U&lt;/em&gt; be the set of element types in &lt;em&gt;T&lt;/em&gt; that have call signatures. If each type in &lt;em&gt;U&lt;/em&gt; has exactly one call signature and that call signature is non-generic, and if all of the signatures are identical ignoring return types, then &lt;em&gt;S&lt;/em&gt; is a signature with the same parameters and a union of the return types.&lt;/li&gt;
&lt;li&gt;Otherwise, no contextual signature can be extracted from &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var f: (s: string) =&amp;gt; string = function (s) {  
    return s.toLowerCase();  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the function expression is contextually typed by the type of &amp;lsquo;f&amp;rsquo;, and since the function expression has no type parameters or type annotations its parameter type information is extracted from the contextual type, thus inferring the type of &amp;rsquo;s&amp;rsquo; to be the String primitive type.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-11-4-11-arrow-functions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.11&#34;/&gt;4.11 Arrow Functions&lt;/h2&gt;

&lt;p&gt;Arrow functions are extended from JavaScript to optionally include parameter and return type annotations.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ArrowFormalParameters:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The descriptions of function declarations provided in chapter &lt;a href=&#34;#6&#34;&gt;6&lt;/a&gt; apply to arrow functions as well, except that arrow functions do not support overloading.&lt;/p&gt;

&lt;p&gt;The type of an arrow function is determined in the same manner as a function expression (section &lt;a href=&#34;#4.10&#34;&gt;4.10&lt;/a&gt;). Likewise, parameters of an arrow function and return statements in the body of an arrow function are contextually typed in the same manner as for function expressions.&lt;/p&gt;

&lt;p&gt;When an arrow function with an expression body and no return type annotation is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;) by a function type &lt;em&gt;T&lt;/em&gt; and a contextual signature &lt;em&gt;S&lt;/em&gt; can be extracted from &lt;em&gt;T&lt;/em&gt;, the expression body is contextually typed by the return type of &lt;em&gt;S&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;An arrow function expression of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;( ... ) =&amp;gt; expr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is exactly equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;( ... ) =&amp;gt; { return expr ; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Furthermore, arrow function expressions of the forms&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;id =&amp;gt; { ... }  
id =&amp;gt; expr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;are exactly equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;( id ) =&amp;gt; { ... }  
( id ) =&amp;gt; expr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus, the following examples are all equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;(x) =&amp;gt; { return Math.sin(x); }  
(x) =&amp;gt; Math.sin(x)  
x =&amp;gt; { return Math.sin(x); }  
x =&amp;gt; Math.sin(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A function expression introduces a new dynamically bound &lt;code&gt;this&lt;/code&gt;, whereas an arrow function expression preserves the &lt;code&gt;this&lt;/code&gt; of its enclosing context. Arrow function expressions are particularly useful for writing callbacks, which otherwise often have an undefined or unexpected &lt;code&gt;this&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Messenger {  
    message = &amp;quot;Hello World&amp;quot;;  
    start() {  
        setTimeout(() =&amp;gt; alert(this.message), 3000);  
    }  
};

var messenger = new Messenger();  
messenger.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the use of an arrow function expression causes the callback to have the same &lt;code&gt;this&lt;/code&gt; as the surrounding &amp;lsquo;start&amp;rsquo; method. Writing the callback as a standard function expression it becomes necessary to manually arrange access to the surrounding &lt;code&gt;this&lt;/code&gt;, for example by copying it into a local variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Messenger {  
    message = &amp;quot;Hello World&amp;quot;;  
    start() {  
        var _this = this;  
        setTimeout(function() { alert(_this.message); }, 3000);  
    }  
};

var messenger = new Messenger();  
messenger.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The TypeScript compiler applies this type of transformation to rewrite arrow function expressions into standard function expressions.&lt;/p&gt;

&lt;p&gt;A construct of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt; T &amp;gt; ( ... ) =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;could be parsed as an arrow function expression with a type parameter or a type assertion applied to an arrow function with no type parameter. It is resolved as the former, but parentheses can be used to select the latter meaning:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt; T &amp;gt; ( ( ... ) =&amp;gt; { ... } )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-4-12-4-12-class-expressions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.12&#34;/&gt;4.12 Class Expressions&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/497&#34;&gt;class expressions&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-13-4-13-property-access:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.13&#34;/&gt;4.13 Property Access&lt;/h2&gt;

&lt;p&gt;A property access uses either dot notation or bracket notation. A property access expression is always classified as a reference.&lt;/p&gt;

&lt;p&gt;A dot notation property access of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;object . name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;object&lt;/em&gt; is an expression and &lt;em&gt;name&lt;/em&gt; is an identifier (including, possibly, a reserved word), is used to access the property with the given name on the given object. A dot notation property access is processed as follows at compile-time:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;object&lt;/em&gt; is of type Any, any &lt;em&gt;name&lt;/em&gt; is permitted and the property access is of type Any.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;name&lt;/em&gt; denotes an accessible apparent property (section &lt;a href=&#34;#3.11.1&#34;&gt;3.11.1&lt;/a&gt;) in the widened type (section &lt;a href=&#34;#3.12&#34;&gt;3.12&lt;/a&gt;) of &lt;em&gt;object&lt;/em&gt;, the property access is of the type of that property. Public members are always accessible, but private and protected members of a class have restricted accessibility, as described in &lt;a href=&#34;#8.2.2&#34;&gt;8.2.2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Otherwise, the property access is invalid and a compile-time error occurs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A bracket notation property access of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;object [ index ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;object&lt;/em&gt; and &lt;em&gt;index&lt;/em&gt; are expressions, is used to access the property with the name computed by the index expression on the given object. A bracket notation property access is processed as follows at compile-time:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;index&lt;/em&gt; is a string literal or a numeric literal and &lt;em&gt;object&lt;/em&gt; has an apparent property (section &lt;a href=&#34;#3.11.1&#34;&gt;3.11.1&lt;/a&gt;) with the name given by that literal (converted to its string representation in the case of a numeric literal), the property access is of the type of that property.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;object&lt;/em&gt; has an apparent numeric index signature and &lt;em&gt;index&lt;/em&gt; is of type Any, the Number primitive type, or an enum type, the property access is of the type of that index signature.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;object&lt;/em&gt; has an apparent string index signature and &lt;em&gt;index&lt;/em&gt; is of type Any, the String or Number primitive type, or an enum type, the property access is of the type of that index signature.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;index&lt;/em&gt; is of type Any, the String or Number primitive type, or an enum type, the property access is of type Any.&lt;/li&gt;
&lt;li&gt;Otherwise, the property access is invalid and a compile-time error occurs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;TODO: Indexing with &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/1978&#34;&gt;symbols&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The rules above mean that properties are strongly typed when accessed using bracket notation with the literal representation of their name. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var type = {  
    name: &amp;quot;boolean&amp;quot;,  
    primitive: true  
};

var s = type[&amp;quot;name&amp;quot;];       // string  
var b = type[&amp;quot;primitive&amp;quot;];  // boolean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tuple types assign numeric names to each of their elements and elements are therefore strongly typed when accessed using bracket notation with a numeric literal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var data: [string, number] = [&amp;quot;five&amp;quot;, 5];  
var s = data[0];  // string  
var n = data[1];  // number
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-4-14-4-14-the-new-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.14&#34;/&gt;4.14 The new Operator&lt;/h2&gt;

&lt;p&gt;A &lt;code&gt;new&lt;/code&gt; operation has one of the following forms:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;new C  
new C ( ... )  
new C &amp;lt; ... &amp;gt; ( ... )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;C&lt;/em&gt; is an expression. The first form is equivalent to supplying an empty argument list. &lt;em&gt;C&lt;/em&gt; must be of type Any or of an object type with one or more construct or call signatures. The operation is processed as follows at compile-time:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;C&lt;/em&gt; is of type Any, any argument list is permitted and the result of the operation is of type Any.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;C&lt;/em&gt; has one or more apparent construct signatures (section &lt;a href=&#34;#3.11.1&#34;&gt;3.11.1&lt;/a&gt;), the expression is processed in the same manner as a function call, but using the construct signatures as the initial set of candidate signatures for overload resolution. The result type of the function call becomes the result type of the operation.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;C&lt;/em&gt; has no apparent construct signatures but one or more apparent call signatures, the expression is processed as a function call. A compile-time error occurs if the result of the function call is not Void. The type of the result of the operation is Any.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-4-15-4-15-function-calls:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.15&#34;/&gt;4.15 Function Calls&lt;/h2&gt;

&lt;p&gt;Function calls are extended from JavaScript to support optional type arguments.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;Arguments:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArguments&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ArgumentList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A function call takes one of the forms&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;func ( ... )  
func &amp;lt; ... &amp;gt; ( ... )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;func&lt;/em&gt; is an expression of a function type or of type Any. The function expression is followed by an optional type argument list (section &lt;a href=&#34;#3.6.2&#34;&gt;3.6.2&lt;/a&gt;) and an argument list.&lt;/p&gt;

&lt;p&gt;If &lt;em&gt;func&lt;/em&gt; is of type Any, or of an object type that has no call or construct signatures but is a subtype of the Function interface, the call is an &lt;strong&gt;&lt;em&gt;untyped function call&lt;/em&gt;&lt;/strong&gt;. In an untyped function call no type arguments are permitted, argument expressions can be of any type and number, no contextual types are provided for the argument expressions, and the result is always of type Any.&lt;/p&gt;

&lt;p&gt;If &lt;em&gt;func&lt;/em&gt; has apparent call signatures (section &lt;a href=&#34;#3.11.1&#34;&gt;3.11.1&lt;/a&gt;) the call is a &lt;strong&gt;&lt;em&gt;typed function call&lt;/em&gt;&lt;/strong&gt;. TypeScript employs &lt;strong&gt;&lt;em&gt;overload resolution&lt;/em&gt;&lt;/strong&gt; in typed function calls in order to support functions with multiple call signatures. Furthermore, TypeScript may perform &lt;strong&gt;&lt;em&gt;type argument inference&lt;/em&gt;&lt;/strong&gt; to automatically determine type arguments in generic function calls.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-15-1-4-15-1-overload-resolution:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.15.1&#34;/&gt;4.15.1 Overload Resolution&lt;/h3&gt;

&lt;p&gt;The purpose of overload resolution in a function call is to ensure that at least one signature is applicable, to provide contextual types for the arguments, and to determine the result type of the function call, which could differ between the multiple applicable signatures. Overload resolution has no impact on the run-time behavior of a function call. Since JavaScript doesn&amp;rsquo;t support function overloading, all that matters at run-time is the name of the function.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Describe use of &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/3970&#34;&gt;wildcard function types&lt;/a&gt; in overload resolution&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The compile-time processing of a typed function call consists of the following steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First, a list of candidate signatures is constructed from the call signatures in the function type in declaration order. For classes and interfaces, inherited signatures are considered to follow explicitly declared signatures in &lt;code&gt;extends&lt;/code&gt; clause order.

&lt;ul&gt;
&lt;li&gt;A non-generic signature is a candidate when&lt;/li&gt;
&lt;li&gt;the function call has no type arguments, and&lt;/li&gt;
&lt;li&gt;the signature is applicable with respect to the argument list of the function call.&lt;/li&gt;
&lt;li&gt;A generic signature is a candidate in a function call without type arguments when&lt;/li&gt;
&lt;li&gt;type inference (section &lt;a href=&#34;#4.15.2&#34;&gt;4.15.2&lt;/a&gt;) succeeds for each type parameter,&lt;/li&gt;
&lt;li&gt;once the inferred type arguments are substituted for their associated type parameters, the signature is applicable with respect to the argument list of the function call.&lt;/li&gt;
&lt;li&gt;A generic signature is a candidate in a function call with type arguments when&lt;/li&gt;
&lt;li&gt;The signature has the same number of type parameters as were supplied in the type argument list,&lt;/li&gt;
&lt;li&gt;the type arguments satisfy their constraints, and&lt;/li&gt;
&lt;li&gt;once the type arguments are substituted for their associated type parameters, the signature is applicable with respect to the argument list of the function call.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;If the list of candidate signatures is empty, the function call is an error.&lt;/li&gt;
&lt;li&gt;Otherwise, if the candidate list contains one or more signatures for which the type of each argument expression is a subtype of each corresponding parameter type, the return type of the first of those signatures becomes the return type of the function call.&lt;/li&gt;
&lt;li&gt;Otherwise, the return type of the first signature in the candidate list becomes the return type of the function call.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A signature is said to be an &lt;strong&gt;&lt;em&gt;applicable signature&lt;/em&gt;&lt;/strong&gt; with respect to an argument list when&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the number of arguments is not less than the number of required parameters,&lt;/li&gt;
&lt;li&gt;the number of arguments is not greater than the number of parameters, and&lt;/li&gt;
&lt;li&gt;for each argument expression &lt;em&gt;e&lt;/em&gt; and its corresponding parameter &lt;em&gt;P,&lt;/em&gt; when &lt;em&gt;e&lt;/em&gt; is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;) by the type of &lt;em&gt;P&lt;/em&gt;, no errors ensue and the type of &lt;em&gt;e&lt;/em&gt; is assignable to (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) the type of &lt;em&gt;P&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;TODO: &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/1931&#34;&gt;Spread operator in function calls&lt;/a&gt; and spreading an &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/2498&#34;&gt;iterator&lt;/a&gt; into a function call&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-15-2-4-15-2-type-argument-inference:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.15.2&#34;/&gt;4.15.2 Type Argument Inference&lt;/h3&gt;

&lt;p&gt;Given a signature &amp;lt; &lt;em&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; , &lt;em&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; , … , &lt;em&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt; &amp;gt; ( &lt;em&gt;p&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; : &lt;em&gt;P&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; , &lt;em&gt;p&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; : &lt;em&gt;P&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; , … , &lt;em&gt;p&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt; : &lt;em&gt;P&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt; ), where each parameter type &lt;em&gt;P&lt;/em&gt; references zero or more of the type parameters &lt;em&gt;T&lt;/em&gt;, and an argument list ( &lt;em&gt;e&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; , &lt;em&gt;e&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; , … , &lt;em&gt;e&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt; ), the task of type argument inference is to find a set of type arguments *A&lt;sub&gt;1&lt;/sub&gt;*…&lt;em&gt;A&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt; to substitute for *T&lt;sub&gt;1&lt;/sub&gt;*…&lt;em&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt; such that the argument list becomes an applicable signature.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Update &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/1186&#34;&gt;type argument inference and overload resolution rules&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Type argument inference produces a set of candidate types for each type parameter. Given a type parameter &lt;em&gt;T&lt;/em&gt; and set of candidate types, the actual inferred type argument is determined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the set of candidate argument types is empty, the inferred type argument for &lt;em&gt;T&lt;/em&gt; is &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s constraint.&lt;/li&gt;
&lt;li&gt;Otherwise, if at least one of the candidate types is a supertype of all of the other candidate types, let &lt;em&gt;C&lt;/em&gt; denote the widened form (section &lt;a href=&#34;#3.12&#34;&gt;3.12&lt;/a&gt;) of the first such candidate type. If &lt;em&gt;C&lt;/em&gt; satisfies &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s constraint, the inferred type argument for &lt;em&gt;T&lt;/em&gt; is &lt;em&gt;C&lt;/em&gt;. Otherwise, the inferred type argument for &lt;em&gt;T&lt;/em&gt; is &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s constraint.&lt;/li&gt;
&lt;li&gt;Otherwise, if no candidate type is a supertype of all of the other candidate types, type inference has fails and no type argument is inferred for &lt;em&gt;T&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to compute candidate types, the argument list is processed as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Initially all inferred type arguments are considered &lt;strong&gt;&lt;em&gt;unfixed&lt;/em&gt;&lt;/strong&gt; with an empty set of candidate types.&lt;/li&gt;
&lt;li&gt;Proceeding from left to right, each argument expression &lt;em&gt;e&lt;/em&gt; is &lt;strong&gt;&lt;em&gt;inferentially typed&lt;/em&gt;&lt;/strong&gt; by its corresponding parameter type &lt;em&gt;P&lt;/em&gt;, possibly causing some inferred type arguments to become &lt;strong&gt;&lt;em&gt;fixed&lt;/em&gt;&lt;/strong&gt;, and candidate type inferences (section &lt;a href=&#34;#3.11.7&#34;&gt;3.11.7&lt;/a&gt;) are made for unfixed inferred type arguments from the type computed for &lt;em&gt;e&lt;/em&gt; to &lt;em&gt;P&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The process of inferentially typing an expression &lt;em&gt;e&lt;/em&gt; by a type &lt;em&gt;T&lt;/em&gt; is the same as that of contextually typing &lt;em&gt;e&lt;/em&gt; by &lt;em&gt;T&lt;/em&gt;, with the following exceptions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Where expressions contained within &lt;em&gt;e&lt;/em&gt; would be contextually typed, they are instead inferentially typed.&lt;/li&gt;
&lt;li&gt;When a function expression is inferentially typed (section &lt;a href=&#34;#4.10&#34;&gt;4.10&lt;/a&gt;) and a type assigned to a parameter in that expression references type parameters for which inferences are being made, the corresponding inferred type arguments to become &lt;strong&gt;&lt;em&gt;fixed&lt;/em&gt;&lt;/strong&gt; and no further candidate inferences are made for them.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;e&lt;/em&gt; is an expression of a function type that contains exactly one generic call signature and no other members, and &lt;em&gt;T&lt;/em&gt; is a function type with exactly one non-generic call signature and no other members, then any inferences made for type parameters referenced by the parameters of &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s call signature are &lt;strong&gt;&lt;em&gt;fixed&lt;/em&gt;&lt;/strong&gt;, and &lt;em&gt;e&lt;/em&gt;&amp;rsquo;s type is changed to a function type with &lt;em&gt;e&lt;/em&gt;&amp;rsquo;s call signature instantiated in the context of &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s call signature (section &lt;a href=&#34;#3.11.6&#34;&gt;3.11.6&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function choose&amp;lt;T&amp;gt;(x: T, y: T): T {  
    return Math.random() &amp;lt; 0.5 ? x : y;  
}

var x = choose(10, 20);     // Ok, x of type number  
var y = choose(&amp;quot;Five&amp;quot;, 5);  // Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first call to &amp;lsquo;choose&amp;rsquo;, two inferences are made from &amp;lsquo;number&amp;rsquo; to &amp;rsquo;T&amp;rsquo;, one for each parameter. Thus, &amp;lsquo;number&amp;rsquo; is inferred for &amp;rsquo;T&amp;rsquo; and the call is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x = choose&amp;lt;number&amp;gt;(10, 20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the second call to &amp;lsquo;choose&amp;rsquo;, an inference is made from type &amp;lsquo;string&amp;rsquo; to &amp;rsquo;T&amp;rsquo; for the first parameter and an inference is made from type &amp;lsquo;number&amp;rsquo; to &amp;rsquo;T&amp;rsquo; for the second parameter. Since neither &amp;lsquo;string&amp;rsquo; nor &amp;lsquo;number&amp;rsquo; is a supertype of the other, type inference fails. That in turn means there are no applicable signatures and the function call is an error.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function map&amp;lt;T, U&amp;gt;(a: T[], f: (x: T) =&amp;gt; U): U[] {  
    var result: U[] = [];  
    for (var i = 0; i &amp;lt; a.length; i++) result.push(f(a[i]));  
    return result;  
}

var names = [&amp;quot;Peter&amp;quot;, &amp;quot;Paul&amp;quot;, &amp;quot;Mary&amp;quot;];  
var lengths = map(names, s =&amp;gt; s.length);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;inferences for &amp;rsquo;T&amp;rsquo; and &amp;lsquo;U&amp;rsquo; in the call to &amp;lsquo;map&amp;rsquo; are made as follows: For the first parameter, inferences are made from the type &amp;lsquo;string[]&amp;rsquo; (the type of &amp;lsquo;names&amp;rsquo;) to the type &amp;rsquo;T[]&amp;lsquo;, inferring &amp;lsquo;string&amp;rsquo; for &amp;rsquo;T&amp;rsquo;. For the second parameter, inferential typing of the arrow expression &amp;rsquo;s =&amp;gt; s.length&amp;rsquo; causes &amp;rsquo;T&amp;rsquo; to become fixed such that the inferred type &amp;lsquo;string&amp;rsquo; can be used for the parameter &amp;rsquo;s&amp;rsquo;. The return type of the arrow expression can then be determined, and inferences are made from the type &amp;lsquo;(s: string) =&amp;gt; number&amp;rsquo; to the type &amp;lsquo;(x: T) =&amp;gt; U&amp;rsquo;, inferring &amp;lsquo;number&amp;rsquo; for &amp;lsquo;U&amp;rsquo;. Thus the call to &amp;lsquo;map&amp;rsquo; is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var lengths = map&amp;lt;string, number&amp;gt;(names, s =&amp;gt; s.length);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the resulting type of &amp;lsquo;lengths&amp;rsquo; is therefore &amp;lsquo;number[]&amp;lsquo;.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function zip&amp;lt;S, T, U&amp;gt;(x: S[], y: T[], combine: (x: S) =&amp;gt; (y: T) =&amp;gt; U): U[] {  
    var len = Math.max(x.length, y.length);  
    var result: U[] = [];  
    for (var i = 0; i &amp;lt; len; i++) result.push(combine(x[i])(y[i]));  
    return result;  
}

var names = [&amp;quot;Peter&amp;quot;, &amp;quot;Paul&amp;quot;, &amp;quot;Mary&amp;quot;];  
var ages = [7, 9, 12];  
var pairs = zip(names, ages, s =&amp;gt; n =&amp;gt; ({ name: s, age: n }));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;inferences for &amp;rsquo;S&amp;rsquo;, &amp;rsquo;T&amp;rsquo; and &amp;lsquo;U&amp;rsquo; in the call to &amp;lsquo;zip&amp;rsquo; are made as follows: Using the first two parameters, inferences of &amp;lsquo;string&amp;rsquo; for &amp;rsquo;S&amp;rsquo; and &amp;lsquo;number&amp;rsquo; for &amp;rsquo;T&amp;rsquo; are made. For the third parameter, inferential typing of the outer arrow expression causes &amp;rsquo;S&amp;rsquo; to become fixed such that the inferred type &amp;lsquo;string&amp;rsquo; can be used for the parameter &amp;rsquo;s&amp;rsquo;. When a function expression is inferentially typed, its return expression(s) are also inferentially typed. Thus, the inner arrow function is inferentially typed, causing &amp;rsquo;T&amp;rsquo; to become fixed such that the inferred type &amp;lsquo;number&amp;rsquo; can be used for the parameter &amp;lsquo;n&amp;rsquo;. The return type of the inner arrow function can then be determined, which in turn determines the return type of the function returned from the outer arrow function, and inferences are made from the type &amp;lsquo;(s: string) =&amp;gt; (n: number) =&amp;gt; { name: string; age: number }&amp;rsquo; to the type &amp;lsquo;(x: S) =&amp;gt; (y: T) =&amp;gt; R&amp;rsquo;, inferring &amp;lsquo;{ name: string; age: number }&amp;rsquo; for &amp;lsquo;R&amp;rsquo;. Thus the call to &amp;lsquo;zip&amp;rsquo; is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var pairs = zip&amp;lt;string, number, { name: string; age: number }&amp;gt;(  
    names, ages, s =&amp;gt; n =&amp;gt; ({ name: s, age: n }));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the resulting type of &amp;lsquo;pairs&amp;rsquo; is therefore &amp;lsquo;{ name: string; age: number }[]&amp;lsquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-15-3-4-15-3-grammar-ambiguities:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.15.3&#34;/&gt;4.15.3 Grammar Ambiguities&lt;/h3&gt;

&lt;p&gt;The inclusion of type arguments in the &lt;em&gt;Arguments&lt;/em&gt; production (section &lt;a href=&#34;#4.15&#34;&gt;4.15&lt;/a&gt;) gives rise to certain ambiguities in the grammar for expressions. For example, the statement&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;f(g&amp;lt;A, B&amp;gt;(7));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;could be interpreted as  a call to &amp;lsquo;f&amp;rsquo; with two arguments, &amp;lsquo;g &amp;lt; A&amp;rsquo; and &amp;lsquo;B &amp;gt; (7)&amp;rsquo;. Alternatively, it could be interpreted as a call to &amp;lsquo;f&amp;rsquo; with one argument, which is a call to a generic function &amp;lsquo;g&amp;rsquo; with two type arguments and one regular argument.&lt;/p&gt;

&lt;p&gt;The grammar ambiguity is resolved as follows: In a context where one possible interpretation of a sequence of tokens is an &lt;em&gt;Arguments&lt;/em&gt; production, if the initial sequence of tokens forms a syntactically correct &lt;em&gt;TypeArguments&lt;/em&gt; production and is followed by a &amp;lsquo;&lt;code&gt;(&lt;/code&gt;&amp;rsquo; token, then the sequence of tokens is processed an &lt;em&gt;Arguments&lt;/em&gt; production, and any other possible interpretation is discarded. Otherwise, the sequence of tokens is not considered an &lt;em&gt;Arguments&lt;/em&gt; production.&lt;/p&gt;

&lt;p&gt;This rule means that the call to &amp;lsquo;f&amp;rsquo; above is interpreted as a call with one argument, which is a call to a generic function &amp;lsquo;g&amp;rsquo; with two type arguments and one regular argument. However, the statements&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;f(g &amp;lt; A, B &amp;gt; 7);  
f(g &amp;lt; A, B &amp;gt; +(7));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;are both interpreted as calls to &amp;lsquo;f&amp;rsquo; with two arguments.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-16-4-16-type-assertions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.16&#34;/&gt;4.16 Type Assertions&lt;/h2&gt;

&lt;p&gt;TypeScript extends the JavaScript expression grammar with the ability to assert a type for an expression:&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;UnaryExpression:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;…&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;&amp;lt;&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&amp;emsp;&lt;code&gt;&amp;gt;&lt;/code&gt;&amp;emsp;&lt;em&gt;UnaryExpression&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A type assertion expression consists of a type enclosed in &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; followed by a unary expression. Type assertion expressions are purely a compile-time construct. Type assertions are &lt;em&gt;not&lt;/em&gt; checked at run-time and have no impact on the emitted JavaScript (and therefore no run-time cost). The type and the enclosing &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; are simply removed from the generated code.&lt;/p&gt;

&lt;p&gt;In a type assertion expression of the form &amp;lt; &lt;em&gt;T&lt;/em&gt; &amp;gt; &lt;em&gt;e&lt;/em&gt;, &lt;em&gt;e&lt;/em&gt; is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;) by &lt;em&gt;T&lt;/em&gt; and the resulting type of* e* is required to be assignable to &lt;em&gt;T&lt;/em&gt;, or &lt;em&gt;T&lt;/em&gt; is required to be assignable to the widened form of the resulting type of &lt;em&gt;e&lt;/em&gt;, or otherwise a compile-time error occurs. The type of the result is &lt;em&gt;T&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Type assertions check for assignment compatibility in both directions. Thus, type assertions allow type conversions that &lt;em&gt;might&lt;/em&gt; be correct, but aren&amp;rsquo;t &lt;em&gt;known&lt;/em&gt; to be correct. In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Shape { ... }

class Circle extends Shape { ... }

function createShape(kind: string): Shape {  
    if (kind === &amp;quot;circle&amp;quot;) return new Circle();  
    ...  
}

var circle = &amp;lt;Circle&amp;gt; createShape(&amp;quot;circle&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the type annotations indicate that the &amp;lsquo;createShape&amp;rsquo; function &lt;em&gt;might&lt;/em&gt; return a &amp;lsquo;Circle&amp;rsquo; (because &amp;lsquo;Circle&amp;rsquo; is a subtype of &amp;lsquo;Shape&amp;rsquo;), but isn&amp;rsquo;t &lt;em&gt;known&lt;/em&gt; to do so (because its return type is &amp;lsquo;Shape&amp;rsquo;). Therefore, a type assertion is needed to treat the result as a &amp;lsquo;Circle&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;As mentioned above, type assertions are not checked at run-time and it is up to the programmer to guard against errors, for example using the &lt;code&gt;instanceof&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var shape = createShape(shapeKind);  
if (shape instanceof Circle) {  
    var circle = &amp;lt;Circle&amp;gt; shape;  
    ...  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/3564&#34;&gt;as operator&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-17-4-17-jsx-expressions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.17&#34;/&gt;4.17 JSX Expressions&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/3203&#34;&gt;JSX expressions&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-18-4-18-unary-operators:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.18&#34;/&gt;4.18 Unary Operators&lt;/h2&gt;

&lt;p&gt;The subsections that follow specify the compile-time processing rules of the unary operators. In general, if the operand of a unary operator does not meet the stated requirements, a compile-time error occurs and the result of the operation defaults to type Any in further processing.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-18-1-4-18-1-the-and-operators:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.18.1&#34;/&gt;4.18.1 The ++ and &amp;ndash; operators&lt;/h3&gt;

&lt;p&gt;These operators, in prefix or postfix form, require their operand to be of type Any, the Number primitive type, or an enum type, and classified as a reference (section &lt;a href=&#34;#4.1&#34;&gt;4.1&lt;/a&gt;). They produce a result of the Number primitive type.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-18-2-4-18-2-the-and-operators:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.18.2&#34;/&gt;4.18.2 The +, –, and ~ operators&lt;/h3&gt;

&lt;p&gt;These operators permit their operand to be of any type and produce a result of the Number primitive type.&lt;/p&gt;

&lt;p&gt;The unary + operator can conveniently be used to convert a value of any type to the Number primitive type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function getValue() { ... }

var n = +getValue();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example above converts the result of &amp;lsquo;getValue()&amp;rsquo; to a number if it isn&amp;rsquo;t a number already. The type inferred for &amp;lsquo;n&amp;rsquo; is the Number primitive type regardless of the return type of &amp;lsquo;getValue&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-18-3-4-18-3-the-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.18.3&#34;/&gt;4.18.3 The ! operator&lt;/h3&gt;

&lt;p&gt;The ! operator permits its operand to be of any type and produces a result of the Boolean primitive type.&lt;/p&gt;

&lt;p&gt;Two unary ! operators in sequence can conveniently be used to convert a value of any type to the Boolean primitive type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function getValue() { ... }

var b = !!getValue();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example above converts the result of &amp;lsquo;getValue()&amp;rsquo; to a Boolean if it isn&amp;rsquo;t a Boolean already. The type inferred for &amp;lsquo;b&amp;rsquo; is the Boolean primitive type regardless of the return type of &amp;lsquo;getValue&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-18-4-4-18-4-the-delete-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.18.4&#34;/&gt;4.18.4 The delete Operator&lt;/h3&gt;

&lt;p&gt;The &amp;lsquo;delete&amp;rsquo; operator takes an operand of any type and produces a result of the Boolean primitive type.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-18-5-4-18-5-the-void-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.18.5&#34;/&gt;4.18.5 The void Operator&lt;/h3&gt;

&lt;p&gt;The &amp;lsquo;void&amp;rsquo; operator takes an operand of any type and produces the value &amp;lsquo;undefined&amp;rsquo;. The type of the result is the Undefined type (&lt;a href=&#34;#3.2.7&#34;&gt;3.2.7&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-18-6-4-18-6-the-typeof-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.18.6&#34;/&gt;4.18.6 The typeof Operator&lt;/h3&gt;

&lt;p&gt;The &amp;lsquo;typeof&amp;rsquo; operator takes an operand of any type and produces a value of the String primitive type. In positions where a type is expected, &amp;lsquo;typeof&amp;rsquo; can also be used in a type query (section &lt;a href=&#34;#3.8.10&#34;&gt;3.8.10&lt;/a&gt;) to produce the type of an expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x = 5;  
var y = typeof x;  // Use in an expression  
var z: typeof x;   // Use in a type query
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above, &amp;lsquo;x&amp;rsquo; is of type &amp;lsquo;number&amp;rsquo;, &amp;lsquo;y&amp;rsquo; is of type &amp;lsquo;string&amp;rsquo; because when used in an expression, &amp;lsquo;typeof&amp;rsquo; produces a value of type string (in this case the string &amp;ldquo;number&amp;rdquo;), and &amp;lsquo;z&amp;rsquo; is of type &amp;lsquo;number&amp;rsquo; because when used in a type query, &amp;lsquo;typeof&amp;rsquo; obtains the type of an expression.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-19-4-19-binary-operators:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.19&#34;/&gt;4.19 Binary Operators&lt;/h2&gt;

&lt;p&gt;The subsections that follow specify the compile-time processing rules of the binary operators. In general, if the operands of a binary operator do not meet the stated requirements, a compile-time error occurs and the result of the operation defaults to type any in further processing. Tables that summarize the compile-time processing rules for operands of the Any type, the Boolean, Number, and String primitive types, and all other types (the Other column in the tables) are provided.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-19-1-4-19-1-the-lt-lt-and-operators:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.19.1&#34;/&gt;4.19.1 The *, /, %, –, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;gt;&amp;gt;&amp;gt;, &amp;amp;, ^, and | operators&lt;/h3&gt;

&lt;p&gt;These operators require their operands to be of type Any, the Number primitive type, or an enum type. Operands of an enum type are treated as having the primitive type Number. If one operand is the &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; value, it is treated as having the type of the other operand. The result is always of the Number primitive type.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Any&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Boolean&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Number&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;String&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Other&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Other&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;TODO: Document the &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/4812&#34;&gt;exponentation operator&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-19-2-4-19-2-the-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.19.2&#34;/&gt;4.19.2 The + operator&lt;/h3&gt;

&lt;p&gt;The binary + operator requires both operands to be of the Number primitive type or an enum type, or at least one of the operands to be of type Any or the String primitive type. Operands of an enum type are treated as having the primitive type Number. If one operand is the &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; value, it is treated as having the type of the other operand. If both operands are of the Number primitive type, the result is of the Number primitive type. If one or both operands are of the String primitive type, the result is of the String primitive type. Otherwise, the result is of type Any.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Any&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Boolean&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Number&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;String&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Other&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Other&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;A value of any type can converted to the String primitive type by adding an empty string:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function getValue() { ... }

var s = getValue() + &amp;quot;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example above converts the result of &amp;lsquo;getValue()&amp;rsquo; to a string if it isn&amp;rsquo;t a string already. The type inferred for &amp;rsquo;s&amp;rsquo; is the String primitive type regardless of the return type of &amp;lsquo;getValue&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-19-3-4-19-3-the-lt-lt-and-operators:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.19.3&#34;/&gt;4.19.3 The &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, ==, !=, ===, and !== operators&lt;/h3&gt;

&lt;p&gt;These operators require one or both of the operand types to be assignable to the other. The result is always of the Boolean primitive type.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Any&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Boolean&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Number&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;String&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Other&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Other&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;a-name-4-19-4-4-19-4-the-instanceof-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.19.4&#34;/&gt;4.19.4 The instanceof operator&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;instanceof&lt;/code&gt; operator requires the left operand to be of type Any, an object type, or a type parameter type, and the right operand to be of type Any or a subtype of the &amp;lsquo;Function&amp;rsquo; interface type. The result is always of the Boolean primitive type.&lt;/p&gt;

&lt;p&gt;Note that object types containing one or more call or construct signatures are automatically subtypes of the &amp;lsquo;Function&amp;rsquo; interface type, as described in section &lt;a href=&#34;#3.3&#34;&gt;3.3&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-19-5-4-19-5-the-in-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.19.5&#34;/&gt;4.19.5 The in operator&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; operator requires the left operand to be of type Any, the String primitive type, or the Number primitive type, and the right operand to be of type Any, an object type, or a type parameter type. The result is always of the Boolean primitive type.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-19-6-4-19-6-the-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.19.6&#34;/&gt;4.19.6 The &amp;amp;&amp;amp; operator&lt;/h3&gt;

&lt;p&gt;The &amp;amp;&amp;amp; operator permits the operands to be of any type and produces a result of the same type as the second operand.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Any&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Boolean&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Number&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;String&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Other&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Other&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Other&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Other&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Other&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Other&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Other&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;a-name-4-19-7-4-19-7-the-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.19.7&#34;/&gt;4.19.7 The || operator&lt;/h3&gt;

&lt;p&gt;The || operator permits the operands to be of any type.&lt;/p&gt;

&lt;p&gt;If the || expression is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;), the operands are contextually typed by the same type. Otherwise, the left operand is not contextually typed and the right operand is contextually typed by the type of the left operand.&lt;/p&gt;

&lt;p&gt;The type of the result is the union type of the two operand types.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Any&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Boolean&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Number&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;String&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Other&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Boolean&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;N&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;S&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;N&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Number&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;S&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;S&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;S&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Other&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Any&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;N&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;a-name-4-20-4-20-the-conditional-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.20&#34;/&gt;4.20 The Conditional Operator&lt;/h2&gt;

&lt;p&gt;In a conditional expression of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;test ? expr1 : expr2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the &lt;em&gt;test&lt;/em&gt; expression may be of any type.&lt;/p&gt;

&lt;p&gt;If the conditional expression is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;), &lt;em&gt;expr1&lt;/em&gt; and &lt;em&gt;expr2&lt;/em&gt; are contextually typed by the same type. Otherwise, &lt;em&gt;expr1&lt;/em&gt; and &lt;em&gt;expr2&lt;/em&gt; are not contextually typed.&lt;/p&gt;

&lt;p&gt;The type of the result is the union type of the types of &lt;em&gt;expr1&lt;/em&gt; and &lt;em&gt;expr2&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-21-4-21-assignment-operators:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.21&#34;/&gt;4.21 Assignment Operators&lt;/h2&gt;

&lt;p&gt;An assignment of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;v = expr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;requires &lt;em&gt;v&lt;/em&gt; to be classified as a reference (section &lt;a href=&#34;#4.1&#34;&gt;4.1&lt;/a&gt;) or as an assignment pattern (section &lt;a href=&#34;#4.21.1&#34;&gt;4.21.1&lt;/a&gt;). The &lt;em&gt;expr&lt;/em&gt; expression is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;) by the type of &lt;em&gt;v&lt;/em&gt;, and the type of &lt;em&gt;expr&lt;/em&gt; must be assignable to (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) the type of &lt;em&gt;v&lt;/em&gt;, or otherwise a compile-time error occurs. The result is a value with the type of &lt;em&gt;expr&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A compound assignment of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;v ??= expr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where ??= is one of the compound assignment operators&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;*=   /=   %=   +=   -=   &amp;lt;&amp;lt;=   &amp;gt;&amp;gt;=   &amp;gt;&amp;gt;&amp;gt;=   &amp;amp;=   ^=   |=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is subject to the same requirements, and produces a value of the same type, as the corresponding non-compound operation. A compound assignment furthermore requires &lt;em&gt;v&lt;/em&gt; to be classified as a reference (section &lt;a href=&#34;#4.1&#34;&gt;4.1&lt;/a&gt;) and the type of the non-compound operation to be assignable to the type of &lt;em&gt;v&lt;/em&gt;. Note that &lt;em&gt;v&lt;/em&gt; is not permitted to be an assignment pattern in a compound assignment.&lt;/p&gt;

&lt;h3 id=&#34;a-name-4-21-1-4-21-1-destructuring-assignment:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.21.1&#34;/&gt;4.21.1 Destructuring Assignment&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;&lt;em&gt;destructuring assignment&lt;/em&gt;&lt;/strong&gt; is an assignment operation in which the left hand operand is a destructuring assignment pattern as defined by the &lt;em&gt;AssignmentPattern&lt;/em&gt; production in the ECMAScript 2015 specification.&lt;/p&gt;

&lt;p&gt;In a destructuring assignment expression, the type of the expression on the right must be assignable to the assignment target on the left. An expression of type &lt;em&gt;S&lt;/em&gt; is considered assignable to an assignment target &lt;em&gt;V&lt;/em&gt; if one of the following is true:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;V&lt;/em&gt; is variable and &lt;em&gt;S&lt;/em&gt; is assignable to the type of &lt;em&gt;V&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;V&lt;/em&gt; is an object assignment pattern and, for each assignment property &lt;em&gt;P&lt;/em&gt; in &lt;em&gt;V&lt;/em&gt;,

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is the type Any, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; has an apparent property with the property name specified in &lt;em&gt;P&lt;/em&gt; of a type that is assignable to the target given in &lt;em&gt;P&lt;/em&gt;, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;P&lt;/em&gt; specifies a numeric property name and &lt;em&gt;S&lt;/em&gt; has a numeric index signature of a type that is assignable to the target given in &lt;em&gt;P&lt;/em&gt;, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; has a string index signature of a type that is assignable to the target given in &lt;em&gt;P&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;V&lt;/em&gt; is an array assignment pattern, &lt;em&gt;S&lt;/em&gt; is the type Any or an array-like type (section &lt;a href=&#34;#3.3.2&#34;&gt;3.3.2&lt;/a&gt;), and, for each assignment element &lt;em&gt;E&lt;/em&gt; in &lt;em&gt;V&lt;/em&gt;,

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is the type Any, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is a tuple-like type (section &lt;a href=&#34;#3.3.3&#34;&gt;3.3.3&lt;/a&gt;) with a property named &lt;em&gt;N&lt;/em&gt; of a type that is assignable to the target given in &lt;em&gt;E&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is the numeric index of &lt;em&gt;E&lt;/em&gt; in the array assignment pattern, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S&lt;/em&gt; is not a tuple-like type and the numeric index signature type of &lt;em&gt;S&lt;/em&gt; is assignable to the target given in &lt;em&gt;E&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;TODO: &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/2713&#34;&gt;Update to specify behavior when assignment element E is a rest element&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In an assignment property or element that includes a default value, the type of the default value must be assignable to the target given in the assignment property or element.&lt;/p&gt;

&lt;p&gt;When the output target is ECMAScript 2015 or higher, destructuring variable assignments remain unchanged in the emitted JavaScript code. When the output target is ECMAScript 3 or 5, destructuring variable assignments are rewritten to series of simple assignments. For example, the destructuring assignment&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x = 1;  
var y = 2;  
[x, y] = [y, x];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is rewritten to the simple variable assignments&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x = 1;  
var y = 2;  
_a = [y, x], x = _a[0], y = _a[1];  
var _a;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-4-22-4-22-the-comma-operator:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.22&#34;/&gt;4.22 The Comma Operator&lt;/h2&gt;

&lt;p&gt;The comma operator permits the operands to be of any type and produces a result that is of the same type as the second operand.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-23-4-23-contextually-typed-expressions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.23&#34;/&gt;4.23 Contextually Typed Expressions&lt;/h2&gt;

&lt;p&gt;Type checking of an expression is improved in several contexts by factoring in the type of the destination of the value computed by the expression. In such situations, the expression is said to be &lt;strong&gt;&lt;em&gt;contextually typed&lt;/em&gt;&lt;/strong&gt; by the type of the destination. An expression is contextually typed in the following circumstances:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In a variable, parameter, binding property, binding element, or member declaration, an initializer expression is contextually typed by

&lt;ul&gt;
&lt;li&gt;the type given in the declaration&amp;rsquo;s type annotation, if any, or otherwise&lt;/li&gt;
&lt;li&gt;for a parameter, the type provided by a contextual signature (section &lt;a href=&#34;#4.10&#34;&gt;4.10&lt;/a&gt;), if any, or otherwise&lt;/li&gt;
&lt;li&gt;the type implied by the binding pattern in the declaration (section &lt;a href=&#34;#5.2.3&#34;&gt;5.2.3&lt;/a&gt;), if any.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;In the body of a function declaration, function expression, arrow function, method declaration, or get accessor declaration that has a return type annotation, return expressions are contextually typed by the type given in the return type annotation.&lt;/li&gt;
&lt;li&gt;In the body of a function expression or arrow function that has no return type annotation, if the function expression or arrow function is contextually typed by a function type with exactly one call signature, and if that call signature is non-generic, return expressions are contextually typed by the return type of that call signature.&lt;/li&gt;
&lt;li&gt;In the body of a constructor declaration, return expressions are contextually typed by the containing class type.&lt;/li&gt;
&lt;li&gt;In the body of a get accessor with no return type annotation, if a matching set accessor exists and that set accessor has a parameter type annotation, return expressions are contextually typed by the type given in the set accessor&amp;rsquo;s parameter type annotation.&lt;/li&gt;
&lt;li&gt;In a typed function call, argument expressions are contextually typed by their corresponding parameter types.&lt;/li&gt;
&lt;li&gt;In a contextually typed object literal, each property value expression is contextually typed by

&lt;ul&gt;
&lt;li&gt;the type of the property with a matching name in the contextual type, if any, or otherwise&lt;/li&gt;
&lt;li&gt;for a numerically named property, the numeric index type of the contextual type, if any, or otherwise&lt;/li&gt;
&lt;li&gt;the string index type of the contextual type, if any.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;In a contextually typed array literal expression containing no spread elements, an element expression at index &lt;em&gt;N&lt;/em&gt; is contextually typed by

&lt;ul&gt;
&lt;li&gt;the type of the property with the numeric name &lt;em&gt;N&lt;/em&gt; in the contextual type, if any, or otherwise&lt;/li&gt;
&lt;li&gt;the numeric index type of the contextual type, if any.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;In a contextually typed array literal expression containing one or more spread elements, an element expression at index &lt;em&gt;N&lt;/em&gt; is contextually typed by the numeric index type of the contextual type, if any.&lt;/li&gt;
&lt;li&gt;In a contextually typed parenthesized expression, the contained expression is contextually typed by the same type.&lt;/li&gt;
&lt;li&gt;In a type assertion, the expression is contextually typed by the indicated type.&lt;/li&gt;
&lt;li&gt;In a || operator expression, if the expression is contextually typed, the operands are contextually typed by the same type. Otherwise, the right expression is contextually typed by the type of the left expression.&lt;/li&gt;
&lt;li&gt;In a contextually typed conditional operator expression, the operands are contextually typed by the same type.&lt;/li&gt;
&lt;li&gt;In an assignment expression, the right hand expression is contextually typed by the type of the left hand expression.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the following example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface EventObject {  
    x: number;  
    y: number;  
}

interface EventHandlers {  
    mousedown?: (event: EventObject) =&amp;gt; void;  
    mouseup?: (event: EventObject) =&amp;gt; void;  
    mousemove?: (event: EventObject) =&amp;gt; void;  
}

function setEventHandlers(handlers: EventHandlers) { ... }

setEventHandlers({  
    mousedown: e =&amp;gt; { startTracking(e.x, e.y); },  
    mouseup: e =&amp;gt; { endTracking(); }  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the object literal passed to &amp;lsquo;setEventHandlers&amp;rsquo; is contextually typed to the &amp;lsquo;EventHandlers&amp;rsquo; type. This causes the two property assignments to be contextually typed to the unnamed function type &amp;lsquo;(event: EventObject) =&amp;gt; void&amp;rsquo;, which in turn causes the &amp;lsquo;e&amp;rsquo; parameters in the arrow function expressions to automatically be typed as &amp;lsquo;EventObject&amp;rsquo;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-4-24-4-24-type-guards:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;4.24&#34;/&gt;4.24 Type Guards&lt;/h2&gt;

&lt;p&gt;Type guards are particular expression patterns involving the &amp;lsquo;typeof&amp;rsquo; and &amp;lsquo;instanceof&amp;rsquo; operators that cause the types of variables or parameters to be &lt;strong&gt;&lt;em&gt;narrowed&lt;/em&gt;&lt;/strong&gt; to more specific types. For example, in the code below, knowledge of the static type of &amp;lsquo;x&amp;rsquo; in combination with a &amp;lsquo;typeof&amp;rsquo; check makes it safe to narrow the type of &amp;lsquo;x&amp;rsquo; to string in the first branch of the &amp;lsquo;if&amp;rsquo; statement and number in the second branch of the &amp;lsquo;if&amp;rsquo; statement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function foo(x: number | string) {  
    if (typeof x === &amp;quot;string&amp;quot;) {  
        return x.length;  // x has type string here  
    }  
    else {  
        return x + 1;     // x has type number here  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The type of a variable or parameter is narrowed in the following situations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In the true branch statement of an &amp;lsquo;if&amp;rsquo; statement, the type of a variable or parameter is &lt;em&gt;narrowed&lt;/em&gt; by a type guard in the &amp;lsquo;if&amp;rsquo; condition &lt;em&gt;when true&lt;/em&gt;, provided no part of the &amp;lsquo;if&amp;rsquo; statement contains assignments to the variable or parameter.&lt;/li&gt;
&lt;li&gt;In the false branch statement of an &amp;lsquo;if&amp;rsquo; statement, the type of a variable or parameter is &lt;em&gt;narrowed&lt;/em&gt; by a type guard in the &amp;lsquo;if&amp;rsquo; condition &lt;em&gt;when false&lt;/em&gt;, provided no part of the &amp;lsquo;if&amp;rsquo; statement contains assignments to the variable or parameter.&lt;/li&gt;
&lt;li&gt;In the true expression of a conditional expression, the type of a variable or parameter is &lt;em&gt;narrowed&lt;/em&gt; by a type guard in the condition &lt;em&gt;when true&lt;/em&gt;, provided no part of the conditional expression contains assignments to the variable or parameter.&lt;/li&gt;
&lt;li&gt;In the false expression of a conditional expression, the type of a variable or parameter is &lt;em&gt;narrowed&lt;/em&gt; by a type guard in the condition &lt;em&gt;when false&lt;/em&gt;, provided no part of the conditional expression contains assignments to the variable or parameter.&lt;/li&gt;
&lt;li&gt;In the right operand of a &amp;amp;&amp;amp; operation, the type of a variable or parameter is &lt;em&gt;narrowed&lt;/em&gt; by a type guard in the left operand &lt;em&gt;when true&lt;/em&gt;, provided neither operand contains assignments to the variable or parameter.&lt;/li&gt;
&lt;li&gt;In the right operand of a || operation, the type of a variable or parameter is &lt;em&gt;narrowed&lt;/em&gt; by a type guard in the left operand &lt;em&gt;when false&lt;/em&gt;, provided neither operand contains assignments to the variable or parameter.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A type guard is simply an expression that follows a particular pattern. The process of narrowing the type of a variable &lt;em&gt;x&lt;/em&gt; by a type guard &lt;em&gt;when true&lt;/em&gt; or &lt;em&gt;when false&lt;/em&gt; depends on the type guard as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A type guard of the form &lt;code&gt;x instanceof C&lt;/code&gt;, where &lt;em&gt;x&lt;/em&gt; is not of type Any, &lt;em&gt;C&lt;/em&gt; is of a subtype of the global type &amp;lsquo;Function&amp;rsquo;, and &lt;em&gt;C&lt;/em&gt; has a property named &amp;lsquo;prototype&amp;rsquo;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;when true&lt;/em&gt;, narrows the type of &lt;em&gt;x&lt;/em&gt; to the type of the &amp;lsquo;prototype&amp;rsquo; property in &lt;em&gt;C&lt;/em&gt; provided it is a subtype of the type of &lt;em&gt;x&lt;/em&gt;, or, if the type of &lt;em&gt;x&lt;/em&gt; is a union type, removes from the type of &lt;em&gt;x&lt;/em&gt; all constituent types that aren&amp;rsquo;t subtypes of the type of the &amp;lsquo;prototype&amp;rsquo; property in &lt;em&gt;C&lt;/em&gt;, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;when false&lt;/em&gt;, has no effect on the type of &lt;em&gt;x&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A type guard of the form &lt;code&gt;typeof x === s&lt;/code&gt;, where &lt;em&gt;s&lt;/em&gt; is a string literal with the value &amp;lsquo;string&amp;rsquo;, &amp;lsquo;number&amp;rsquo;, or &amp;lsquo;boolean&amp;rsquo;,

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;when true&lt;/em&gt;, narrows the type of &lt;em&gt;x&lt;/em&gt; to the given primitive type provided it is a subtype of the type of &lt;em&gt;x&lt;/em&gt;, or, if the type of &lt;em&gt;x&lt;/em&gt; is a union type, removes from the type of &lt;em&gt;x&lt;/em&gt; all constituent types that aren&amp;rsquo;t subtypes of the given primitive type, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;when false&lt;/em&gt;, removes the primitive type from the type of &lt;em&gt;x&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A type guard of the form &lt;code&gt;typeof x === s&lt;/code&gt;, where &lt;em&gt;s&lt;/em&gt; is a string literal with any value but &amp;lsquo;string&amp;rsquo;, &amp;lsquo;number&amp;rsquo;, or &amp;lsquo;boolean&amp;rsquo;,

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;when true&lt;/em&gt;, if &lt;em&gt;x&lt;/em&gt; is a union type, removes from the type of &lt;em&gt;x&lt;/em&gt; all constituent types that are subtypes of the string, number, or boolean primitive type, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;when false&lt;/em&gt;, has no effect on the type of &lt;em&gt;x&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A type guard of the form &lt;code&gt;typeof x !== s&lt;/code&gt;, where &lt;em&gt;s&lt;/em&gt; is a string literal,

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;when true&lt;/em&gt;, narrows the type of x by &lt;code&gt;typeof x === s&lt;/code&gt; &lt;em&gt;when false&lt;/em&gt;, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;when false&lt;/em&gt;, narrows the type of x by &lt;code&gt;typeof x === s&lt;/code&gt; &lt;em&gt;when true&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A type guard of the form &lt;code&gt;!expr&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;when true&lt;/em&gt;, narrows the type of &lt;em&gt;x&lt;/em&gt; by &lt;em&gt;expr&lt;/em&gt; &lt;em&gt;when false&lt;/em&gt;, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;when false&lt;/em&gt;, narrows the type of &lt;em&gt;x&lt;/em&gt; by &lt;em&gt;expr&lt;/em&gt; &lt;em&gt;when true&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A type guard of the form &lt;code&gt;expr1 &amp;amp;&amp;amp; expr2&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;when true&lt;/em&gt;, narrows the type of &lt;em&gt;x&lt;/em&gt; by &lt;em&gt;expr&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; &lt;em&gt;when true&lt;/em&gt; and then by &lt;em&gt;expr&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; &lt;em&gt;when true&lt;/em&gt;, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;when false&lt;/em&gt;, narrows the type of &lt;em&gt;x&lt;/em&gt; to &lt;em&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; | &lt;em&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;, where &lt;em&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; is the type of &lt;em&gt;x&lt;/em&gt; narrowed by &lt;em&gt;expr&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; &lt;em&gt;when false&lt;/em&gt;, and &lt;em&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; is the type of &lt;em&gt;x&lt;/em&gt; narrowed by &lt;em&gt;expr&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; &lt;em&gt;when true&lt;/em&gt; and then by &lt;em&gt;expr&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; &lt;em&gt;when false&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A type guard of the form &lt;code&gt;expr1 || expr2&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;when true&lt;/em&gt;, narrows the type of &lt;em&gt;x&lt;/em&gt; to &lt;em&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; | &lt;em&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;, where &lt;em&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; is the type of &lt;em&gt;x&lt;/em&gt; narrowed by &lt;em&gt;expr&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; &lt;em&gt;when true&lt;/em&gt;, and &lt;em&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; is the type of &lt;em&gt;x&lt;/em&gt; narrowed by &lt;em&gt;expr&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; &lt;em&gt;when false&lt;/em&gt; and then by &lt;em&gt;expr&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; &lt;em&gt;when true&lt;/em&gt;, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;when false&lt;/em&gt;, narrows the type of &lt;em&gt;x&lt;/em&gt; by &lt;em&gt;expr&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; &lt;em&gt;when false&lt;/em&gt; and then by &lt;em&gt;expr&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt; &lt;em&gt;when false&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A type guard of any other form has no effect on the type of &lt;em&gt;x&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the rules above, when a narrowing operation would remove all constituent types from a union type, the operation has no effect on the union type.&lt;/p&gt;

&lt;p&gt;Note that type guards affect types of variables and parameters only and have no effect on members of objects such as properties. Also note that it is possible to defeat a type guard by calling a function that changes the type of the guarded variable.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/1007&#34;&gt;user defined type guard functions&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function isLongString(obj: any) {  
    return typeof obj === &amp;quot;string&amp;quot; &amp;amp;&amp;amp; obj.length &amp;gt; 100;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the &lt;code&gt;obj&lt;/code&gt; parameter has type &lt;code&gt;string&lt;/code&gt; in the right operand of the &amp;amp;&amp;amp; operator.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function processValue(value: number | (() =&amp;gt; number)) {  
    var x = typeof value !== &amp;quot;number&amp;quot; ? value() : value;  
    // Process number in x  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the value parameter has type &lt;code&gt;() =&amp;gt; number&lt;/code&gt; in the first conditional expression and type &lt;code&gt;number&lt;/code&gt; in the second conditional expression, and the inferred type of x is &lt;code&gt;number&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function f(x: string | number | boolean) {  
    if (typeof x === &amp;quot;string&amp;quot; || typeof x === &amp;quot;number&amp;quot;) {  
        var y = x;  // Type of y is string | number  
    }  
    else {  
        var z = x;  // Type of z is boolean  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the type of x is &lt;code&gt;string | number | boolean&lt;/code&gt; in the left operand of the || operator, &lt;code&gt;number | boolean&lt;/code&gt; in the right operand of the || operator, &lt;code&gt;string | number&lt;/code&gt; in the first branch of the if statement, and &lt;code&gt;boolean&lt;/code&gt; in the second branch of the if statement.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class C {  
    data: string | string[];  
    getData() {  
        var data = this.data;  
        return typeof data === &amp;quot;string&amp;quot; ? data : data.join(&amp;quot; &amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the type of the &lt;code&gt;data&lt;/code&gt; variable is &lt;code&gt;string&lt;/code&gt; in the first conditional expression and &lt;code&gt;string[]&lt;/code&gt; in the second conditional expression, and the inferred type of &lt;code&gt;getData&lt;/code&gt; is &lt;code&gt;string&lt;/code&gt;. Note that the &lt;code&gt;data&lt;/code&gt; property must be copied to a local variable for the type guard to have an effect.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class NamedItem {  
    name: string;  
}

function getName(obj: Object) {  
    return obj instanceof NamedItem ? obj.name : &amp;quot;unknown&amp;quot;;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the type of &lt;code&gt;obj&lt;/code&gt; is narrowed to &lt;code&gt;NamedItem&lt;/code&gt; in the first conditional expression, and the inferred type of the &lt;code&gt;getName&lt;/code&gt; function is &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-5-5-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5&#34;/&gt;5 Statements&lt;/h1&gt;

&lt;p&gt;This chapter describes the static type checking TypeScript provides for JavaScript statements. TypeScript itself does not introduce any new statement constructs, but it does extend the grammar for local declarations to include interface, type alias, and enum declarations.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-1-5-1-blocks:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.1&#34;/&gt;5.1 Blocks&lt;/h2&gt;

&lt;p&gt;Blocks are extended to include local interface, type alias, and enum declarations (classes are already included by the ECMAScript 2015 grammar).&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;Declaration:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;…&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Local class, interface, type alias, and enum declarations are block scoped, similar to let and const declarations.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-2-5-2-variable-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.2&#34;/&gt;5.2 Variable Statements&lt;/h2&gt;

&lt;p&gt;Variable statements are extended to include optional type annotations.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;VariableDeclaration:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;SimpleVariableDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DestructuringVariableDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A variable declaration is either a simple variable declaration or a destructuring variable declaration.&lt;/p&gt;

&lt;h3 id=&#34;a-name-5-2-1-5-2-1-simple-variable-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.2.1&#34;/&gt;5.2.1 Simple Variable Declarations&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;&lt;em&gt;simple variable declaration&lt;/em&gt;&lt;/strong&gt; introduces a single named variable and optionally assigns it an initial value.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;SimpleVariableDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The type &lt;em&gt;T&lt;/em&gt; of a variable introduced by a simple variable declaration is determined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the declaration includes a type annotation, &lt;em&gt;T&lt;/em&gt; is that type.&lt;/li&gt;
&lt;li&gt;Otherwise, if the declaration includes an initializer expression, &lt;em&gt;T&lt;/em&gt; is the widened form (section &lt;a href=&#34;#3.12&#34;&gt;3.12&lt;/a&gt;) of the type of the initializer expression.&lt;/li&gt;
&lt;li&gt;Otherwise, &lt;em&gt;T&lt;/em&gt; is the Any type.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When a variable declaration specifies both a type annotation and an initializer expression, the type of the initializer expression is required to be assignable to (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) the type given in the type annotation.&lt;/p&gt;

&lt;p&gt;Multiple declarations for the same variable name in the same declaration space are permitted, provided that each declaration associates the same type with the variable.&lt;/p&gt;

&lt;p&gt;When a variable declaration has a type annotation, it is an error for that type annotation to use the &lt;code&gt;typeof&lt;/code&gt; operator to reference the variable being declared.&lt;/p&gt;

&lt;p&gt;Below are some examples of simple variable declarations and their associated types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var a;                          // any  
var b: number;                  // number  
var c = 1;                      // number  
var d = { x: 1, y: &amp;quot;hello&amp;quot; };   // { x: number; y: string; }  
var e: any = &amp;quot;test&amp;quot;;            // any
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following is permitted because all declarations of the single variable &amp;lsquo;x&amp;rsquo; associate the same type (Number) with &amp;lsquo;x&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x = 1;  
var x: number;  
if (x == 1) {  
    var x = 2;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the following example, all five variables are of the same type, &amp;lsquo;{ x: number; y: number; }&amp;lsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Point { x: number; y: number; }

var a = { x: 0, y: &amp;lt;number&amp;gt; undefined };  
var b: Point = { x: 0, y: undefined };  
var c = &amp;lt;Point&amp;gt; { x: 0, y: undefined };  
var d: { x: number; y: number; } = { x: 0, y: undefined };  
var e = &amp;lt;{ x: number; y: number; }&amp;gt; { x: 0, y: undefined };
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-5-2-2-5-2-2-destructuring-variable-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.2.2&#34;/&gt;5.2.2 Destructuring Variable Declarations&lt;/h3&gt;

&lt;p&gt;A &lt;strong&gt;&lt;em&gt;destructuring variable declaration&lt;/em&gt;&lt;/strong&gt; introduces zero or more named variables and initializes them with values extracted from properties of an object or elements of an array.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DestructuringVariableDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingPattern&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Each binding property or element that specifies an identifier introduces a variable by that name. The type of the variable is the widened form (section &lt;a href=&#34;#3.12&#34;&gt;3.12&lt;/a&gt;) of the type associated with the binding property or element, as defined in the following.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Document destructuring an &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/2498&#34;&gt;iterator&lt;/a&gt; into an array&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The type &lt;em&gt;T&lt;/em&gt; associated with a destructuring variable declaration is determined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the declaration includes a type annotation, &lt;em&gt;T&lt;/em&gt; is that type.&lt;/li&gt;
&lt;li&gt;Otherwise, if the declaration includes an initializer expression, &lt;em&gt;T&lt;/em&gt; is the type of that initializer expression.&lt;/li&gt;
&lt;li&gt;Otherwise, &lt;em&gt;T&lt;/em&gt; is the Any type.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The type &lt;em&gt;T&lt;/em&gt; associated with a binding property is determined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Let &lt;em&gt;S&lt;/em&gt; be the type associated with the immediately containing destructuring variable declaration, binding property, or binding element.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;S&lt;/em&gt; is the Any type:

&lt;ul&gt;
&lt;li&gt;If the binding property specifies an initializer expression, &lt;em&gt;T&lt;/em&gt; is the type of that initializer expression.&lt;/li&gt;
&lt;li&gt;Otherwise, &lt;em&gt;T&lt;/em&gt; is the Any type.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Let &lt;em&gt;P&lt;/em&gt; be the property name specified in the binding property.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;S&lt;/em&gt; has an apparent property with the name &lt;em&gt;P&lt;/em&gt;, &lt;em&gt;T&lt;/em&gt; is the type of that property.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;S&lt;/em&gt; has a numeric index signature and &lt;em&gt;P&lt;/em&gt; is a numerical name, &lt;em&gt;T&lt;/em&gt; is the type of the numeric index signature.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;S&lt;/em&gt; has a string index signature, &lt;em&gt;T&lt;/em&gt; is the type of the string index signature.&lt;/li&gt;
&lt;li&gt;Otherwise, no type is associated with the binding property and an error occurs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The type &lt;em&gt;T&lt;/em&gt; associated with a binding element is determined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Let &lt;em&gt;S&lt;/em&gt; be the type associated with the immediately containing destructuring variable declaration, binding property, or binding element.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;S&lt;/em&gt; is the Any type:

&lt;ul&gt;
&lt;li&gt;If the binding element specifies an initializer expression, &lt;em&gt;T&lt;/em&gt; is the type of that initializer expression.&lt;/li&gt;
&lt;li&gt;Otherwise, &lt;em&gt;T&lt;/em&gt; is the Any type.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;S&lt;/em&gt; is not an array-like type (section &lt;a href=&#34;#3.3.2&#34;&gt;3.3.2&lt;/a&gt;), no type is associated with the binding property and an error occurs.&lt;/li&gt;
&lt;li&gt;If the binding element is a rest element, &lt;em&gt;T&lt;/em&gt; is an array type with an element type &lt;em&gt;E&lt;/em&gt;, where &lt;em&gt;E&lt;/em&gt; is the type of the numeric index signature of &lt;em&gt;S&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;S&lt;/em&gt; is a tuple-like type (section &lt;a href=&#34;#3.3.3&#34;&gt;3.3.3&lt;/a&gt;):

&lt;ul&gt;
&lt;li&gt;Let &lt;em&gt;N&lt;/em&gt; be the zero-based index of the binding element in the array binding pattern.&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;S&lt;/em&gt; has a property with the numerical name &lt;em&gt;N&lt;/em&gt;, &lt;em&gt;T&lt;/em&gt; is the type of that property.&lt;/li&gt;
&lt;li&gt;Otherwise, no type is associated with the binding element and an error occurs.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;S&lt;/em&gt; has a numeric index signature, &lt;em&gt;T&lt;/em&gt; is the type of the numeric index signature.&lt;/li&gt;
&lt;li&gt;Otherwise, no type is associated with the binding element and an error occurs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When a destructuring variable declaration, binding property, or binding element specifies an initializer expression, the type of the initializer expression is required to be assignable to the widened form of the type associated with the destructuring variable declaration, binding property, or binding element.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Update rules to reflect &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/4598&#34;&gt;improved checking of destructuring with literal initializers&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;When the output target is ECMAScript 2015 or higher, except for removing the optional type annotation, destructuring variable declarations remain unchanged in the emitted JavaScript code.&lt;/p&gt;

&lt;p&gt;When the output target is ECMAScript 3 or 5, destructuring variable declarations are rewritten to simple variable declarations. For example, an object destructuring declaration of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var { x, p: y, q: z = false } = getSomeObject();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is rewritten to the simple variable declarations&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var _a = getSomeObject(),  
    x = _a.x,  
    y = _a.p,  
    _b = _a.q,  
    z = _b === void 0 ? false : _b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;lsquo;_a&amp;rsquo; and &amp;lsquo;_b&amp;rsquo; temporary variables exist to ensure the assigned expression is evaluated only once, and the expression &amp;lsquo;void 0&amp;rsquo; simply denotes the JavaScript value &amp;lsquo;undefined&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Similarly, an array destructuring declaration of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var [x, y, z = 10] = getSomeArray();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is rewritten to the simple variable declarations&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var _a = getSomeArray(),  
    x = _a[0],  
    y = _a[1],  
    _b = _a[2],  
    z = _b === void 0 ? 10 : _b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Combining both forms of destructuring, the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var { x, p: [y, z = 10] = getSomeArray() } = getSomeObject();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is rewritten to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var _a = getSomeObject(),  
    x = _a.x,  
    _b = _a.p,  
    _c = _b === void 0 ? getSomeArray() : _b,  
    y = _c[0],  
    _d = _c[1],  
    z = _d === void 0 ? 10 : _d;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-5-2-3-5-2-3-implied-type:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.2.3&#34;/&gt;5.2.3 Implied Type&lt;/h3&gt;

&lt;p&gt;A variable, parameter, binding property, or binding element declaration that specifies a binding pattern has an &lt;strong&gt;&lt;em&gt;implied type&lt;/em&gt;&lt;/strong&gt; which is determined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the declaration specifies an object binding pattern, the implied type is an object type with a set of properties corresponding to the specified binding property declarations. The type of each property is the type implied by its binding property declaration, and a property is optional when its binding property declaration specifies an initializer expression.&lt;/li&gt;
&lt;li&gt;If the declaration specifies an array binding pattern without a rest element, the implied type is a tuple type with elements corresponding to the specified binding element declarations. The type of each element is the type implied by its binding element declaration.&lt;/li&gt;
&lt;li&gt;If the declaration specifies an array binding pattern with a rest element, the implied type is an array type with an element type of Any.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The implied type of a binding property or binding element declaration is&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the type of the declaration&amp;rsquo;s initializer expression, if any, or otherwise&lt;/li&gt;
&lt;li&gt;the implied type of the binding pattern specified in the declaration, if any, or otherwise&lt;/li&gt;
&lt;li&gt;the type Any.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function f({ a, b = &amp;quot;hello&amp;quot;, c = 1 }) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the implied type of the binding pattern in the function&amp;rsquo;s parameter is &amp;lsquo;{ a: any; b?: string; c?: number; }&amp;lsquo;. Since the parameter has no type annotation, this becomes the type of the parameter.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var [a, b, c] = [1, &amp;quot;hello&amp;quot;, true];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the array literal initializer expression is contextually typed by the implied type of the binding pattern, specifically the tuple type &amp;lsquo;[any, any, any]&amp;lsquo;. Because the contextual type is a tuple type, the resulting type of the array literal is the tuple type &amp;lsquo;[number, string, boolean]&amp;lsquo;, and the destructuring declaration thus gives the types number, string, and boolean to a, b, and c respectively.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-3-5-3-let-and-const-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.3&#34;/&gt;5.3 Let and Const Declarations&lt;/h2&gt;

&lt;p&gt;Let and const declarations are exended to include optional type annotations.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;LexicalBinding:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;SimpleLexicalBinding&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DestructuringLexicalBinding&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;SimpleLexicalBinding:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DestructuringLexicalBinding:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingPattern&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Document scoping and types of &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/904&#34;&gt;let and const declarations&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-4-5-4-if-do-and-while-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.4&#34;/&gt;5.4 If, Do, and While Statements&lt;/h2&gt;

&lt;p&gt;Expressions controlling &amp;lsquo;if&amp;rsquo;, &amp;lsquo;do&amp;rsquo;, and &amp;lsquo;while&amp;rsquo; statements can be of any type (and not just type Boolean).&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-5-5-5-for-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.5&#34;/&gt;5.5 For Statements&lt;/h2&gt;

&lt;p&gt;Variable declarations in &amp;lsquo;for&amp;rsquo; statements are extended in the same manner as variable declarations in variable statements (section &lt;a href=&#34;#5.2&#34;&gt;5.2&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-6-5-6-for-in-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.6&#34;/&gt;5.6 For-In Statements&lt;/h2&gt;

&lt;p&gt;In a &amp;lsquo;for-in&amp;rsquo; statement of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;for (v in expr) statement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;v&lt;/em&gt; must be an expression classified as a reference of type Any or the String primitive type, and &lt;em&gt;expr&lt;/em&gt; must be an expression of type Any, an object type, or a type parameter type.&lt;/p&gt;

&lt;p&gt;In a &amp;lsquo;for-in&amp;rsquo; statement of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;for (var v in expr) statement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;v&lt;/em&gt; must be a variable declaration without a type annotation that declares a variable of type Any, and &lt;em&gt;expr&lt;/em&gt; must be an expression of type Any, an object type, or a type parameter type.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-7-5-7-for-of-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.7&#34;/&gt;5.7 For-Of Statements&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/7&#34;&gt;for-of statements&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-8-5-8-continue-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.8&#34;/&gt;5.8 Continue Statements&lt;/h2&gt;

&lt;p&gt;A &amp;lsquo;continue&amp;rsquo; statement is required to be nested, directly or indirectly (but not crossing function boundaries), within an iteration (&amp;lsquo;do&amp;rsquo;, &amp;lsquo;while&amp;rsquo;, &amp;lsquo;for&amp;rsquo;, or &amp;lsquo;for-in&amp;rsquo;) statement. When a &amp;lsquo;continue&amp;rsquo; statement includes a target label, that target label must appear in the label set of an enclosing (but not crossing function boundaries) iteration statement.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-9-5-9-break-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.9&#34;/&gt;5.9 Break Statements&lt;/h2&gt;

&lt;p&gt;A &amp;lsquo;break&amp;rsquo; statement is required to be nested, directly or indirectly (but not crossing function boundaries), within an iteration (&amp;lsquo;do&amp;rsquo;, &amp;lsquo;while&amp;rsquo;, &amp;lsquo;for&amp;rsquo;, or &amp;lsquo;for-in&amp;rsquo;) or &amp;lsquo;switch&amp;rsquo; statement. When a &amp;lsquo;break&amp;rsquo; statement includes a target label, that target label must appear in the label set of an enclosing (but not crossing function boundaries) statement.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-10-5-10-return-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.10&#34;/&gt;5.10 Return Statements&lt;/h2&gt;

&lt;p&gt;It is an error for a &amp;lsquo;return&amp;rsquo; statement to occur outside a function body. Specifically, &amp;lsquo;return&amp;rsquo; statements are not permitted at the global level or in namespace bodies.&lt;/p&gt;

&lt;p&gt;A &amp;lsquo;return&amp;rsquo; statement without an expression returns the value &amp;lsquo;undefined&amp;rsquo; and is permitted in the body of any function, regardless of the return type of the function.&lt;/p&gt;

&lt;p&gt;When a &amp;lsquo;return&amp;rsquo; statement includes an expression, if the containing function includes a return type annotation, the return expression is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;) by that return type and must be of a type that is assignable to the return type. Otherwise, if the containing function is contextually typed by a type &lt;em&gt;T&lt;/em&gt;, &lt;em&gt;Expr&lt;/em&gt; is contextually typed by &lt;em&gt;T&lt;/em&gt;&amp;rsquo;s return type.&lt;/p&gt;

&lt;p&gt;In a function implementation without a return type annotation, the return type is inferred from the &amp;lsquo;return&amp;rsquo; statements in the function body, as described in section &lt;a href=&#34;#6.3&#34;&gt;6.3&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function f(): (x: string) =&amp;gt; number {  
    return s =&amp;gt; s.length;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the arrow expression in the &amp;lsquo;return&amp;rsquo; statement is contextually typed by the return type of &amp;lsquo;f&amp;rsquo;, thus giving type &amp;lsquo;string&amp;rsquo; to &amp;rsquo;s&amp;rsquo;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-11-5-11-with-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.11&#34;/&gt;5.11 With Statements&lt;/h2&gt;

&lt;p&gt;Use of the &amp;lsquo;with&amp;rsquo; statement in TypeScript is an error, as is the case in ECMAScript 5&amp;rsquo;s strict mode. Furthermore, within the body of a &amp;lsquo;with&amp;rsquo; statement, TypeScript considers every identifier occurring in an expression (section &lt;a href=&#34;#4.3&#34;&gt;4.3&lt;/a&gt;) to be of the Any type regardless of its declared type. Because the &amp;lsquo;with&amp;rsquo; statement puts a statically unknown set of identifiers in scope in front of those that are statically known, it is not possible to meaningfully assign a static type to any identifier.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-12-5-12-switch-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.12&#34;/&gt;5.12 Switch Statements&lt;/h2&gt;

&lt;p&gt;In a &amp;lsquo;switch&amp;rsquo; statement, each &amp;lsquo;case&amp;rsquo; expression must be of a type that is assignable to or from (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) the type of the &amp;lsquo;switch&amp;rsquo; expression.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-13-5-13-throw-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.13&#34;/&gt;5.13 Throw Statements&lt;/h2&gt;

&lt;p&gt;The expression specified in a &amp;lsquo;throw&amp;rsquo; statement can be of any type.&lt;/p&gt;

&lt;h2 id=&#34;a-name-5-14-5-14-try-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;5.14&#34;/&gt;5.14 Try Statements&lt;/h2&gt;

&lt;p&gt;The variable introduced by a &amp;lsquo;catch&amp;rsquo; clause of a &amp;lsquo;try&amp;rsquo; statement is always of type Any. It is not possible to include a type annotation in a &amp;lsquo;catch&amp;rsquo; clause.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-6-6-functions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;6&#34;/&gt;6 Functions&lt;/h1&gt;

&lt;p&gt;TypeScript extends JavaScript functions to include type parameters, parameter and return type annotations, overloads, default parameter values, and rest parameters.&lt;/p&gt;

&lt;h2 id=&#34;a-name-6-1-6-1-function-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;6.1&#34;/&gt;6.1 Function Declarations&lt;/h2&gt;

&lt;p&gt;Function declarations are extended to permit the function body to be omitted in overload declarations.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionDeclaration:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;function&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;function&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;FunctionDeclaration&lt;/em&gt; introduces a named value of a function type in the containing declaration space. The &lt;em&gt;BindingIdentifier&lt;/em&gt; is optional only when the function declaration occurs in an export default declaration (section &lt;a href=&#34;#11.3.4.2&#34;&gt;11.3.4.2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Function declarations that specify a body are called &lt;strong&gt;&lt;em&gt;function implementations&lt;/em&gt;&lt;/strong&gt; and function declarations without a body are called &lt;strong&gt;&lt;em&gt;function overloads&lt;/em&gt;&lt;/strong&gt;. It is possible to specify multiple overloads for the same function (i.e. for the same name in the same declaration space), but a function can have at most one implementation. All declarations for the same function must specify the same set of modifiers (i.e. the same combination of &lt;code&gt;declare&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;, and &lt;code&gt;default&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;When a function has overload declarations, the overloads determine the call signatures of the type given to the function object and the function implementation signature (if any) must be assignable to that type. Otherwise, the function implementation itself determines the call signature.&lt;/p&gt;

&lt;p&gt;When a function has both overloads and an implementation, the overloads must precede the implementation and all of the declarations must be consecutive with no intervening grammatical elements.&lt;/p&gt;

&lt;h2 id=&#34;a-name-6-2-6-2-function-overloads:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;6.2&#34;/&gt;6.2 Function Overloads&lt;/h2&gt;

&lt;p&gt;Function overloads allow a more accurate specification of the patterns of invocation supported by a function than is possible with a single signature. The compile-time processing of a call to an overloaded function chooses the best candidate overload for the particular arguments and the return type of that overload becomes the result type the function call expression. Thus, using overloads it is possible to statically describe the manner in which a function&amp;rsquo;s return type varies based on its arguments. Overload resolution in function calls is described further in section &lt;a href=&#34;#4.15&#34;&gt;4.15&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Function overloads are purely a compile-time construct. They have no impact on the emitted JavaScript and thus no run-time cost.&lt;/p&gt;

&lt;p&gt;The parameter list of a function overload cannot specify default values for parameters. In other words, an overload may use only the &lt;code&gt;?&lt;/code&gt; form when specifying optional parameters.&lt;/p&gt;

&lt;p&gt;The following is an example of a function with overloads.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function attr(name: string): string;  
function attr(name: string, value: string): Accessor;  
function attr(map: any): Accessor;  
function attr(nameOrMap: any, value?: string): any {  
    if (nameOrMap &amp;amp;&amp;amp; typeof nameOrMap === &amp;quot;string&amp;quot;) {  
        // handle string case  
    }  
    else {  
        // handle map case  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that each overload and the final implementation specify the same identifier. The type of the local variable &amp;lsquo;attr&amp;rsquo; introduced by this declaration is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var attr: {  
    (name: string): string;  
    (name: string, value: string): Accessor;  
    (map: any): Accessor;  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the signature of the actual function implementation is not included in the type.&lt;/p&gt;

&lt;h2 id=&#34;a-name-6-3-6-3-function-implementations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;6.3&#34;/&gt;6.3 Function Implementations&lt;/h2&gt;

&lt;p&gt;A function implementation without a return type annotation is said to be an &lt;strong&gt;&lt;em&gt;implicitly typed function&lt;/em&gt;&lt;/strong&gt;. The return type of an implicitly typed function &lt;em&gt;f&lt;/em&gt; is inferred from its function body as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If there are no return statements with expressions in &lt;em&gt;f&lt;/em&gt;&amp;rsquo;s function body, the inferred return type is Void.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;f&lt;/em&gt;&amp;rsquo;s function body directly references &lt;em&gt;f&lt;/em&gt; or references any implicitly typed functions that through this same analysis reference &lt;em&gt;f&lt;/em&gt;, the inferred return type is Any.&lt;/li&gt;
&lt;li&gt;Otherwise, if &lt;em&gt;f&lt;/em&gt; is a contextually typed function expression (section &lt;a href=&#34;#4.10&#34;&gt;4.10&lt;/a&gt;), the inferred return type is the union type (section &lt;a href=&#34;#3.4&#34;&gt;3.4&lt;/a&gt;) of the types of the return statement expressions in the function body, ignoring return statements with no expressions.&lt;/li&gt;
&lt;li&gt;Otherwise, the inferred return type is the first of the types of the return statement expressions in the function body that is a supertype (section &lt;a href=&#34;#3.11.3&#34;&gt;3.11.3&lt;/a&gt;) of each of the others, ignoring return statements with no expressions. A compile-time error occurs if no return statement expression has a type that is a supertype of each of the others.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function f(x: number) {  
    if (x &amp;lt;= 0) return x;  
    return g(x);  
}

function g(x: number) {  
    return f(x - 1);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the inferred return type for &amp;lsquo;f&amp;rsquo; and &amp;lsquo;g&amp;rsquo; is Any because the functions reference themselves through a cycle with no return type annotations. Adding an explicit return type &amp;lsquo;number&amp;rsquo; to either breaks the cycle and causes the return type &amp;lsquo;number&amp;rsquo; to be inferred for the other.&lt;/p&gt;

&lt;p&gt;An explicitly typed function whose return type isn&amp;rsquo;t the Void type, the Any type, or a union type containing the Void or Any type as a constituent must have at least one return statement somewhere in its body. An exception to this rule is if the function implementation consists of a single &amp;lsquo;throw&amp;rsquo; statement.&lt;/p&gt;

&lt;p&gt;The type of &amp;lsquo;this&amp;rsquo; in a function implementation is the Any type.&lt;/p&gt;

&lt;p&gt;In the signature of a function implementation, a parameter can be marked optional by following it with an initializer. When a parameter declaration includes both a type annotation and an initializer, the initializer expression is contextually typed (section &lt;a href=&#34;#4.23&#34;&gt;4.23&lt;/a&gt;) by the stated type and must be assignable to the stated type, or otherwise a compile-time error occurs. When a parameter declaration has no type annotation but includes an initializer, the type of the parameter is the widened form (section &lt;a href=&#34;#3.12&#34;&gt;3.12&lt;/a&gt;) of the type of the initializer expression.&lt;/p&gt;

&lt;p&gt;Initializer expressions are evaluated in the scope of the function body but are not permitted to reference local variables and are only permitted to access parameters that are declared to the left of the parameter they initialize, unless the parameter reference occurs in a nested function expression.&lt;/p&gt;

&lt;p&gt;When the output target is ECMAScript 3 or 5, for each parameter with an initializer, a statement that substitutes the default value for an omitted argument is included in the generated JavaScript, as described in section &lt;a href=&#34;#6.6&#34;&gt;6.6&lt;/a&gt;. The example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function strange(x: number, y = x * 2, z = x + y) {  
    return z;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generates JavaScript that is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function strange(x, y, z) {  
    if (y === void 0) { y = x * 2; }  
    if (z === void 0) { z = x + y; }  
    return z;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var x = 1;  
function f(a = x) {  
    var x = &amp;quot;hello&amp;quot;;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the local variable &amp;lsquo;x&amp;rsquo; is in scope in the parameter initializer (thus hiding the outer &amp;lsquo;x&amp;rsquo;), but it is an error to reference it because it will always be uninitialized at the time the parameter initializer is evaluated.&lt;/p&gt;

&lt;h2 id=&#34;a-name-6-4-6-4-destructuring-parameter-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;6.4&#34;/&gt;6.4 Destructuring Parameter Declarations&lt;/h2&gt;

&lt;p&gt;Parameter declarations can specify binding patterns (section &lt;a href=&#34;#3.9.2.2&#34;&gt;3.9.2.2&lt;/a&gt;) and are then called &lt;strong&gt;&lt;em&gt;destructuring parameter declarations&lt;/em&gt;&lt;/strong&gt;. Similar to a destructuring variable declaration (section &lt;a href=&#34;#5.2.2&#34;&gt;5.2.2&lt;/a&gt;), a destructuring parameter declaration introduces zero or more named locals and initializes them with values extracted from properties or elements of the object or array passed as an argument for the parameter.&lt;/p&gt;

&lt;p&gt;The type of local introduced in a destructuring parameter declaration is determined in the same manner as a local introduced by a destructuring variable declaration, except the type &lt;em&gt;T&lt;/em&gt; associated with a destructuring parameter declaration is determined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the declaration includes a type annotation, &lt;em&gt;T&lt;/em&gt; is that type.&lt;/li&gt;
&lt;li&gt;If the declaration occurs in a function expression for which a contextual signature is available (section &lt;a href=&#34;#4.10&#34;&gt;4.10&lt;/a&gt;), &lt;em&gt;T&lt;/em&gt; is the type obtained from the contextual signature.&lt;/li&gt;
&lt;li&gt;Otherwise, if the declaration includes an initializer expression, &lt;em&gt;T&lt;/em&gt; is the widened form (section &lt;a href=&#34;#3.12&#34;&gt;3.12&lt;/a&gt;) of the type of the initializer expression.&lt;/li&gt;
&lt;li&gt;Otherwise, if the declaration specifies a binding pattern, &lt;em&gt;T&lt;/em&gt; is the implied type of that binding pattern (section &lt;a href=&#34;#5.2.3&#34;&gt;5.2.3&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Otherwise, if the parameter is a rest parameter, &lt;em&gt;T&lt;/em&gt; is &lt;code&gt;any[]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Otherwise, &lt;em&gt;T&lt;/em&gt; is &lt;code&gt;any&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When the output target is ECMAScript 2015 or higher, except for removing the optional type annotation, destructuring parameter declarations remain unchanged in the emitted JavaScript code. When the output target is ECMAScript 3 or 5, destructuring parameter declarations are rewritten to local variable declarations.&lt;/p&gt;

&lt;p&gt;The example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function drawText({ text = &amp;quot;&amp;quot;, location: [x, y] = [0, 0], bold = false }) {  
    // Draw text  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;declares a function &lt;code&gt;drawText&lt;/code&gt; that takes a single parameter of the type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{ text?: string; location?: [number, number]; bold?: boolean; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the output target is ECMAScript 3 or 5, the function is rewritten to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function drawText(_a) {  
    var _b = _a.text,  
        text = _b === void 0 ? &amp;quot;&amp;quot; : _b,  
        _c = _a.location,  
        _d = _c === void 0 ? [0, 0] : _c,  
        x = _d[0],  
        y = _d[1],  
        _e = _a.bold,  
        bold = _e === void 0 ? false : _e;  
    // Draw text  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Destructuring parameter declarations do not permit type annotations on the individual binding patterns, as such annotations would conflict with the already established meaning of colons in object literals. Type annotations must instead be written on the top-level parameter declaration. For example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface DrawTextInfo {  
    text?: string;  
    location?: [number, number];  
    bold?: boolean;  
}

function drawText({ text, location: [x, y], bold }: DrawTextInfo) {  
    // Draw text  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-6-5-6-5-generic-functions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;6.5&#34;/&gt;6.5 Generic Functions&lt;/h2&gt;

&lt;p&gt;A function implementation may include type parameters in its signature (section &lt;a href=&#34;#3.9.2.1&#34;&gt;3.9.2.1&lt;/a&gt;) and is then called a &lt;strong&gt;&lt;em&gt;generic function&lt;/em&gt;&lt;/strong&gt;. Type parameters provide a mechanism for expressing relationships between parameter and return types in call operations. Type parameters have no run-time representation—they are purely a compile-time construct.&lt;/p&gt;

&lt;p&gt;Type parameters declared in the signature of a function implementation are in scope in the signature and body of that function implementation.&lt;/p&gt;

&lt;p&gt;The following is an example of a generic function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Comparable {  
    localeCompare(other: any): number;  
}

function compare&amp;lt;T extends Comparable&amp;gt;(x: T, y: T): number {  
    if (x == null) return y == null ? 0 : -1;  
    if (y == null) return 1;  
    return x.localeCompare(y);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &amp;lsquo;x&amp;rsquo; and &amp;lsquo;y&amp;rsquo; parameters are known to be subtypes of the constraint &amp;lsquo;Comparable&amp;rsquo; and therefore have a &amp;lsquo;compareTo&amp;rsquo; member. This is described further in section &lt;a href=&#34;#3.6.1&#34;&gt;3.6.1&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The type arguments of a call to a generic function may be explicitly specified in a call operation or may, when possible, be inferred (section &lt;a href=&#34;#4.15.2&#34;&gt;4.15.2&lt;/a&gt;) from the types of the regular arguments in the call. In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Person {  
    name: string;  
    localeCompare(other: Person) {  
        return compare(this.name, other.name);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the type argument to &amp;lsquo;compare&amp;rsquo; is automatically inferred to be the String type because the two arguments are strings.&lt;/p&gt;

&lt;h2 id=&#34;a-name-6-6-6-6-code-generation:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;6.6&#34;/&gt;6.6 Code Generation&lt;/h2&gt;

&lt;p&gt;A function declaration generates JavaScript code that is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function &amp;lt;FunctionName&amp;gt;(&amp;lt;FunctionParameters&amp;gt;) {  
    &amp;lt;DefaultValueAssignments&amp;gt;  
    &amp;lt;FunctionStatements&amp;gt;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;FunctionName&lt;/em&gt; is the name of the function (or nothing in the case of a function expression).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;FunctionParameters&lt;/em&gt; is a comma separated list of the function&amp;rsquo;s parameter names.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;DefaultValueAssignments&lt;/em&gt; is a sequence of default property value assignments, one for each parameter with a default value, in the order they are declared, of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;if (&amp;lt;Parameter&amp;gt; === void 0) { &amp;lt;Parameter&amp;gt; = &amp;lt;Default&amp;gt;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;Parameter&lt;/em&gt; is the parameter name and &lt;em&gt;Default&lt;/em&gt; is the default value expression.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;FunctionStatements&lt;/em&gt; is the code generated for the statements specified in the function body.&lt;/p&gt;

&lt;h2 id=&#34;a-name-6-7-6-7-generator-functions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;6.7&#34;/&gt;6.7 Generator Functions&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/2873&#34;&gt;generator functions&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-6-8-6-8-asynchronous-functions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;6.8&#34;/&gt;6.8 Asynchronous Functions&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/1664&#34;&gt;asynchronous functions&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-6-9-6-9-type-guard-functions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;6.9&#34;/&gt;6.9 Type Guard Functions&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/1007&#34;&gt;type guard functions&lt;/a&gt;, including &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/5906&#34;&gt;this type predicates&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-7-7-interfaces:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;7&#34;/&gt;7 Interfaces&lt;/h1&gt;

&lt;p&gt;Interfaces provide the ability to name and parameterize object types and to compose existing named object types into new ones.&lt;/p&gt;

&lt;p&gt;Interfaces have no run-time representation—they are purely a compile-time construct. Interfaces are particularly useful for documenting and validating the required shape of properties, objects passed as parameters, and objects returned from functions.&lt;/p&gt;

&lt;p&gt;Because TypeScript has a structural type system, an interface type with a particular set of members is considered identical to, and can be substituted for, another interface type or object type literal with an identical set of members (see section &lt;a href=&#34;#3.11.2&#34;&gt;3.11.2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Class declarations may reference interfaces in their implements clause to validate that they provide an implementation of the interfaces.&lt;/p&gt;

&lt;h2 id=&#34;a-name-7-1-7-1-interface-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;7.1&#34;/&gt;7.1 Interface Declarations&lt;/h2&gt;

&lt;p&gt;An interface declaration declares an &lt;strong&gt;&lt;em&gt;interface type&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;interface&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;InterfaceExtendsClause&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;ObjectType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceExtendsClause:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;extends&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassOrInterfaceTypeList&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassOrInterfaceTypeList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ClassOrInterfaceType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ClassOrInterfaceTypeList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassOrInterfaceType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassOrInterfaceType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeReference&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;InterfaceDeclaration&lt;/em&gt; introduces a named type (section &lt;a href=&#34;#3.7&#34;&gt;3.7&lt;/a&gt;) in the containing declaration space. The &lt;em&gt;BindingIdentifier&lt;/em&gt; of an interface declaration may not be one of the predefined type names (section &lt;a href=&#34;#3.8.1&#34;&gt;3.8.1&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;An interface may optionally have type parameters (section &lt;a href=&#34;#3.6.1&#34;&gt;3.6.1&lt;/a&gt;) that serve as placeholders for actual types to be provided when the interface is referenced in type references. An interface with type parameters is called a &lt;strong&gt;&lt;em&gt;generic interface&lt;/em&gt;&lt;/strong&gt;. The type parameters of a generic interface declaration are in scope in the entire declaration and may be referenced in the &lt;em&gt;InterfaceExtendsClause&lt;/em&gt; and &lt;em&gt;ObjectType&lt;/em&gt; body.&lt;/p&gt;

&lt;p&gt;An interface can inherit from zero or more &lt;strong&gt;&lt;em&gt;base types&lt;/em&gt;&lt;/strong&gt; which are specified in the &lt;em&gt;InterfaceExtendsClause&lt;/em&gt;. The base types must be type references to class or interface types.&lt;/p&gt;

&lt;p&gt;An interface has the members specified in the &lt;em&gt;ObjectType&lt;/em&gt; of its declaration and furthermore inherits all base type members that aren&amp;rsquo;t hidden by declarations in the interface:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A property declaration hides a public base type property with the same name.&lt;/li&gt;
&lt;li&gt;A string index signature declaration hides a base type string index signature.&lt;/li&gt;
&lt;li&gt;A numeric index signature declaration hides a base type numeric index signature.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following constraints must be satisfied by an interface declaration or otherwise a compile-time error occurs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An interface declaration may not, directly or indirectly, specify a base type that originates in the same declaration. In other words an interface cannot, directly or indirectly, be a base type of itself, regardless of type arguments.&lt;/li&gt;
&lt;li&gt;An interface cannot declare a property with the same name as an inherited private or protected property.&lt;/li&gt;
&lt;li&gt;Inherited properties with the same name must be identical (section &lt;a href=&#34;#3.11.2&#34;&gt;3.11.2&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;All properties of the interface must satisfy the constraints implied by the index signatures of the interface as specified in section &lt;a href=&#34;#3.9.4&#34;&gt;3.9.4&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The this-type (section &lt;a href=&#34;#3.6.3&#34;&gt;3.6.3&lt;/a&gt;) of the declared interface must be assignable (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) to each of the base type references.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An interface is permitted to inherit identical members from multiple base types and will in that case only contain one occurrence of each particular member.&lt;/p&gt;

&lt;p&gt;Below is an example of two interfaces that contain properties with the same name but different types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Mover {  
    move(): void;  
    getStatus(): { speed: number; };  
}

interface Shaker {  
    shake(): void;  
    getStatus(): { frequency: number; };  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An interface that extends &amp;lsquo;Mover&amp;rsquo; and &amp;lsquo;Shaker&amp;rsquo; must declare a new &amp;lsquo;getStatus&amp;rsquo; property as it would otherwise inherit two &amp;lsquo;getStatus&amp;rsquo; properties with different types. The new &amp;lsquo;getStatus&amp;rsquo; property must be declared such that the resulting &amp;lsquo;MoverShaker&amp;rsquo; is a subtype of both &amp;lsquo;Mover&amp;rsquo; and &amp;lsquo;Shaker&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface MoverShaker extends Mover, Shaker {  
    getStatus(): { speed: number; frequency: number; };  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since function and constructor types are just object types containing call and construct signatures, interfaces can be used to declare named function and constructor types. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface StringComparer { (a: string, b: string): number; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This declares type &amp;lsquo;StringComparer&amp;rsquo; to be a function type taking two strings and returning a number.&lt;/p&gt;

&lt;h2 id=&#34;a-name-7-2-7-2-declaration-merging:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;7.2&#34;/&gt;7.2 Declaration Merging&lt;/h2&gt;

&lt;p&gt;Interfaces are &amp;ldquo;open-ended&amp;rdquo; and interface declarations with the same qualified name relative to a common root (as defined in section &lt;a href=&#34;#2.3&#34;&gt;2.3&lt;/a&gt;) contribute to a single interface.&lt;/p&gt;

&lt;p&gt;When a generic interface has multiple declarations, all declarations must have identical type parameter lists, i.e. identical type parameter names with identical constraints in identical order.&lt;/p&gt;

&lt;p&gt;In an interface with multiple declarations, the &lt;code&gt;extends&lt;/code&gt; clauses are merged into a single set of base types and the bodies of the interface declarations are merged into a single object type. Declaration merging produces a declaration order that corresponds to &lt;em&gt;prepending&lt;/em&gt; the members of each interface declaration, in the order the members are written, to the combined list of members in the order of the interface declarations. Thus, members declared in the last interface declaration will appear first in the declaration order of the merged type.&lt;/p&gt;

&lt;p&gt;For example, a sequence of declarations in this order:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Document {  
    createElement(tagName: any): Element;  
}

interface Document {  
    createElement(tagName: string): HTMLElement;  
}

interface Document {  
    createElement(tagName: &amp;quot;div&amp;quot;): HTMLDivElement;   
    createElement(tagName: &amp;quot;span&amp;quot;): HTMLSpanElement;  
    createElement(tagName: &amp;quot;canvas&amp;quot;): HTMLCanvasElement;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to the following single declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Document {  
    createElement(tagName: &amp;quot;div&amp;quot;): HTMLDivElement;   
    createElement(tagName: &amp;quot;span&amp;quot;): HTMLSpanElement;  
    createElement(tagName: &amp;quot;canvas&amp;quot;): HTMLCanvasElement;  
    createElement(tagName: string): HTMLElement;  
    createElement(tagName: any): Element;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the members of the last interface declaration appear first in the merged declaration. Also note that the relative order of members declared in the same interface body is preserved.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/3333&#34;&gt;class and interface declaration merging&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-7-3-7-3-interfaces-extending-classes:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;7.3&#34;/&gt;7.3 Interfaces Extending Classes&lt;/h2&gt;

&lt;p&gt;When an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. When a class containing private or protected members is the base type of an interface type, that interface type can only be implemented by that class or a descendant class. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Control {  
    private state: any;  
}

interface SelectableControl extends Control {  
    select(): void;  
}

class Button extends Control {  
    select() { }  
}

class TextBox extends Control {  
    select() { }  
}

class Image extends Control {  
}

class Location {  
    select() { }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, &amp;lsquo;SelectableControl&amp;rsquo; contains all of the members of &amp;lsquo;Control&amp;rsquo;, including the private &amp;lsquo;state&amp;rsquo; property. Since &amp;lsquo;state&amp;rsquo; is a private member it is only possible for descendants of &amp;lsquo;Control&amp;rsquo; to implement &amp;lsquo;SelectableControl&amp;rsquo;. This is because only descendants of &amp;lsquo;Control&amp;rsquo; will have a &amp;lsquo;state&amp;rsquo; private member that originates in the same declaration, which is a requirement for private members to be compatible (section &lt;a href=&#34;#3.11&#34;&gt;3.11&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Within the &amp;lsquo;Control&amp;rsquo; class it is possible to access the &amp;lsquo;state&amp;rsquo; private member through an instance of &amp;lsquo;SelectableControl&amp;rsquo;. Effectively, a &amp;lsquo;SelectableControl&amp;rsquo; acts like a &amp;lsquo;Control&amp;rsquo; that is known to have a &amp;lsquo;select&amp;rsquo; method. The &amp;lsquo;Button&amp;rsquo; and &amp;lsquo;TextBox&amp;rsquo; classes are subtypes of &amp;lsquo;SelectableControl&amp;rsquo; (because they both inherit from &amp;lsquo;Control&amp;rsquo; and have a &amp;lsquo;select&amp;rsquo; method), but the &amp;lsquo;Image&amp;rsquo; and &amp;lsquo;Location&amp;rsquo; classes are not.&lt;/p&gt;

&lt;h2 id=&#34;a-name-7-4-7-4-dynamic-type-checks:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;7.4&#34;/&gt;7.4 Dynamic Type Checks&lt;/h2&gt;

&lt;p&gt;TypeScript does not provide a direct mechanism for dynamically testing whether an object implements a particular interface. Instead, TypeScript code can use the JavaScript technique of checking whether an appropriate set of members are present on the object. For example, given the declarations in section &lt;a href=&#34;#7.1&#34;&gt;7.1&lt;/a&gt;, the following is a dynamic check for the &amp;lsquo;MoverShaker&amp;rsquo; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var obj: any = getSomeObject();  
if (obj &amp;amp;&amp;amp; obj.move &amp;amp;&amp;amp; obj.shake &amp;amp;&amp;amp; obj.getStatus) {  
    var moverShaker = &amp;lt;MoverShaker&amp;gt; obj;  
    ...  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If such a check is used often it can be abstracted into a function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function asMoverShaker(obj: any): MoverShaker {  
    return obj &amp;amp;&amp;amp; obj.move &amp;amp;&amp;amp; obj.shake &amp;amp;&amp;amp; obj.getStatus ? obj : null;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-8-8-classes:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8&#34;/&gt;8 Classes&lt;/h1&gt;

&lt;p&gt;TypeScript extends JavaScript classes to include type parameters, implements clauses, accessibility modifiers, member variable declarations, and parameter property declarations in constructors.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/3578&#34;&gt;abstract classes&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-8-1-8-1-class-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.1&#34;/&gt;8.1 Class Declarations&lt;/h2&gt;

&lt;p&gt;A class declaration declares a &lt;strong&gt;&lt;em&gt;class type&lt;/em&gt;&lt;/strong&gt; and a &lt;strong&gt;&lt;em&gt;constructor function&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassDeclaration:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;class&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;ClassHeritage&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;ClassDeclaration&lt;/em&gt; introduces a named type (the class type) and a named value (the constructor function) in the containing declaration space. The class type is formed from the instance members declared in the class body and the instance members inherited from the base class. The constructor function is given an anonymous type formed from the constructor declaration, the static member declarations in the class body, and the static members inherited from the base class. The constructor function initializes and returns an instance of the class type.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;BindingIdentifier&lt;/em&gt; of a class declaration may not be one of the predefined type names (section &lt;a href=&#34;#3.8.1&#34;&gt;3.8.1&lt;/a&gt;). The &lt;em&gt;BindingIdentifier&lt;/em&gt; is optional only when the class declaration occurs in an export default declaration (section &lt;a href=&#34;#11.3.4.2&#34;&gt;11.3.4.2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;A class may optionally have type parameters (section &lt;a href=&#34;#3.6.1&#34;&gt;3.6.1&lt;/a&gt;) that serve as placeholders for actual types to be provided when the class is referenced in type references. A class with type parameters is called a &lt;strong&gt;&lt;em&gt;generic class&lt;/em&gt;&lt;/strong&gt;. The type parameters of a generic class declaration are in scope in the entire declaration and may be referenced in the &lt;em&gt;ClassHeritage&lt;/em&gt; and &lt;em&gt;ClassBody&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The following example introduces both a named type called &amp;lsquo;Point&amp;rsquo; (the class type) and a named value called &amp;lsquo;Point&amp;rsquo; (the constructor function) in the containing declaration space.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Point {  
    constructor(public x: number, public y: number) { }  
    public length() { return Math.sqrt(this.x * this.x + this.y * this.y); }  
    static origin = new Point(0, 0);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The named type &amp;lsquo;Point&amp;rsquo; is exactly equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Point {  
    x: number;  
    y: number;  
    length(): number;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The named value &amp;lsquo;Point&amp;rsquo; is a constructor function whose type corresponds to the declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var Point: {  
    new(x: number, y: number): Point;  
    origin: Point;  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The context in which a class is referenced distinguishes between the class type and the constructor function. For example, in the assignment statement&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var p: Point = new Point(10, 20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the identifier &amp;lsquo;Point&amp;rsquo; in the type annotation refers to the class type, whereas the identifier &amp;lsquo;Point&amp;rsquo; in the &lt;code&gt;new&lt;/code&gt; expression refers to the constructor function object.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-1-1-8-1-1-class-heritage-specification:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.1.1&#34;/&gt;8.1.1 Class Heritage Specification&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;TODO: Update this section to reflect &lt;a href=&#34;https://github.com/Microsoft/TypeScript/pull/3516&#34;&gt;expressions in class extends clauses&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The heritage specification of a class consists of optional &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;implements&lt;/code&gt; clauses. The &lt;code&gt;extends&lt;/code&gt; clause specifies the base class of the class and the &lt;code&gt;implements&lt;/code&gt; clause specifies a set of interfaces for which to validate the class provides an implementation.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassHeritage:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ClassExtendsClause&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;ImplementsClause&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassExtendsClause:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;extends&lt;/code&gt;&amp;emsp; &lt;em&gt;ClassType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeReference&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementsClause:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;implements&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassOrInterfaceTypeList&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A class that includes an &lt;code&gt;extends&lt;/code&gt; clause is called a &lt;strong&gt;&lt;em&gt;derived class&lt;/em&gt;&lt;/strong&gt;, and the class specified in the &lt;code&gt;extends&lt;/code&gt; clause is called the &lt;strong&gt;&lt;em&gt;base class&lt;/em&gt;&lt;/strong&gt; of the derived class. When a class heritage specification omits the &lt;code&gt;extends&lt;/code&gt; clause, the class does not have a base class. However, as is the case with every object type, type references (section &lt;a href=&#34;#3.3.1&#34;&gt;3.3.1&lt;/a&gt;) to the class will appear to have the members of the global interface type named &amp;lsquo;Object&amp;rsquo; unless those members are hidden by members with the same name in the class.&lt;/p&gt;

&lt;p&gt;The following constraints must be satisfied by the class heritage specification or otherwise a compile-time error occurs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If present, the type reference specified in the &lt;code&gt;extends&lt;/code&gt; clause must denote a class type. Furthermore, the &lt;em&gt;TypeName&lt;/em&gt; part of the type reference is required to be a reference to the class constructor function when evaluated as an expression.&lt;/li&gt;
&lt;li&gt;A class declaration may not, directly or indirectly, specify a base class that originates in the same declaration. In other words a class cannot, directly or indirectly, be a base class of itself, regardless of type arguments.&lt;/li&gt;
&lt;li&gt;The this-type (section &lt;a href=&#34;#3.6.3&#34;&gt;3.6.3&lt;/a&gt;) of the declared class must be assignable (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) to the base type reference and each of the type references listed in the &lt;code&gt;implements&lt;/code&gt; clause.&lt;/li&gt;
&lt;li&gt;The constructor function type created by the class declaration must be assignable to the base class constructor function type, ignoring construct signatures.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following example illustrates a situation in which the first rule above would be violated:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class A { a: number; }

namespace Foo {  
    var A = 1;  
    class B extends A { b: string; }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When evaluated as an expression, the type reference &amp;lsquo;A&amp;rsquo; in the &lt;code&gt;extends&lt;/code&gt; clause doesn&amp;rsquo;t reference the class constructor function of &amp;lsquo;A&amp;rsquo; (instead it references the local variable &amp;lsquo;A&amp;rsquo;).&lt;/p&gt;

&lt;p&gt;The only situation in which the last two constraints above are violated is when a class overrides one or more base class members with incompatible new members.&lt;/p&gt;

&lt;p&gt;Note that because TypeScript has a structural type system, a class doesn&amp;rsquo;t need to explicitly state that it implements an interface—it suffices for the class to simply contain the appropriate set of instance members. The &lt;code&gt;implements&lt;/code&gt; clause of a class provides a mechanism to assert and validate that the class contains the appropriate sets of instance members, but otherwise it has no effect on the class type.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-1-2-8-1-2-class-body:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.1.2&#34;/&gt;8.1.2 Class Body&lt;/h3&gt;

&lt;p&gt;The class body consists of zero or more constructor or member declarations. Statements are not allowed in the body of a class—they must be placed in the constructor or in members.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassElement:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyMemberDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IndexMemberDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The body of class may optionally contain a single constructor declaration. Constructor declarations are described in section &lt;a href=&#34;#8.3&#34;&gt;8.3&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Member declarations are used to declare instance and static members of the class. Property member declarations are described in section &lt;a href=&#34;#8.4&#34;&gt;8.4&lt;/a&gt; and index member declarations are described in section &lt;a href=&#34;#8.5&#34;&gt;8.5&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-8-2-8-2-members:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.2&#34;/&gt;8.2 Members&lt;/h2&gt;

&lt;p&gt;The members of a class consist of the members introduced through member declarations in the class body and the members inherited from the base class.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-2-1-8-2-1-instance-and-static-members:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.2.1&#34;/&gt;8.2.1 Instance and Static Members&lt;/h3&gt;

&lt;p&gt;Members are either &lt;strong&gt;&lt;em&gt;instance members&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;static members&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Instance members are members of the class type (section &lt;a href=&#34;#8.2.4&#34;&gt;8.2.4&lt;/a&gt;) and its associated this-type. Within constructors, instance member functions, and instance member accessors, the type of &lt;code&gt;this&lt;/code&gt; is the this-type (section &lt;a href=&#34;#3.6.3&#34;&gt;3.6.3&lt;/a&gt;) of the class.&lt;/p&gt;

&lt;p&gt;Static members are declared using the &lt;code&gt;static&lt;/code&gt; modifier and are members of the constructor function type (section &lt;a href=&#34;#8.2.5&#34;&gt;8.2.5&lt;/a&gt;). Within static member functions and static member accessors, the type of &lt;code&gt;this&lt;/code&gt; is the constructor function type.&lt;/p&gt;

&lt;p&gt;Class type parameters cannot be referenced in static member declarations.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-2-2-8-2-2-accessibility:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.2.2&#34;/&gt;8.2.2 Accessibility&lt;/h3&gt;

&lt;p&gt;Property members have either &lt;strong&gt;&lt;em&gt;public&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;private&lt;/em&gt;&lt;/strong&gt;, or &lt;strong&gt;&lt;em&gt;protected&lt;/em&gt;&lt;/strong&gt; accessibility. The default is public accessibility, but property member declarations may include a &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, or &lt;code&gt;protected&lt;/code&gt; modifier to explicitly specify the desired accessibility.&lt;/p&gt;

&lt;p&gt;Public property members can be accessed everywhere without restrictions.&lt;/p&gt;

&lt;p&gt;Private property members can be accessed only within their declaring class. Specifically, a private member &lt;em&gt;M&lt;/em&gt; declared in a class &lt;em&gt;C&lt;/em&gt; can be accessed only within the class body of &lt;em&gt;C&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Protected property members can be accessed only within their declaring class and classes derived from their declaring class, and a protected instance property member must be accessed &lt;em&gt;through&lt;/em&gt; an instance of the enclosing class or a subclass thereof. Specifically, a protected member &lt;em&gt;M&lt;/em&gt; declared in a class &lt;em&gt;C&lt;/em&gt; can be accessed only within the class body of &lt;em&gt;C&lt;/em&gt; or the class body of a class derived from &lt;em&gt;C&lt;/em&gt;. Furthermore, when a protected instance member &lt;em&gt;M&lt;/em&gt; is accessed in a property access &lt;em&gt;E&lt;/em&gt;&lt;code&gt;.&lt;/code&gt;&lt;em&gt;M&lt;/em&gt; within the body of a class &lt;em&gt;D&lt;/em&gt;, the type of &lt;em&gt;E&lt;/em&gt; is required to be &lt;em&gt;D&lt;/em&gt; or a type that directly or indirectly has &lt;em&gt;D&lt;/em&gt; as a base type, regardless of type arguments.&lt;/p&gt;

&lt;p&gt;Private and protected accessibility is enforced only at compile-time and serves as no more than an &lt;em&gt;indication of intent&lt;/em&gt;. Since JavaScript provides no mechanism to create private and protected properties on an object, it is not possible to enforce the private and protected modifiers in dynamic code at run-time. For example, private and protected accessibility can be defeated by changing an object&amp;rsquo;s static type to Any and accessing the member dynamically.&lt;/p&gt;

&lt;p&gt;The following example demonstrates private and protected accessibility:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class A {  
    private x: number;  
    protected y: number;  
    static f(a: A, b: B) {  
        a.x = 1;  // Ok  
        b.x = 1;  // Ok  
        a.y = 1;  // Ok  
        b.y = 1;  // Ok  
    }  
}

class B extends A {  
    static f(a: A, b: B) {  
        a.x = 1;  // Error, x only accessible within A  
        b.x = 1;  // Error, x only accessible within A  
        a.y = 1;  // Error, y must be accessed through instance of B  
        b.y = 1;  // Ok  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In class &amp;lsquo;A&amp;rsquo;, the accesses to &amp;lsquo;x&amp;rsquo; are permitted because &amp;lsquo;x&amp;rsquo; is declared in &amp;lsquo;A&amp;rsquo;, and the accesses to &amp;lsquo;y&amp;rsquo; are permitted because both take place through an instance of &amp;lsquo;A&amp;rsquo; or a type derived from &amp;lsquo;A&amp;rsquo;. In class &amp;lsquo;B&amp;rsquo;, access to &amp;lsquo;x&amp;rsquo; is not permitted, and the first access to &amp;lsquo;y&amp;rsquo; is an error because it takes place through an instance of &amp;lsquo;A&amp;rsquo;, which is not derived from the enclosing class &amp;lsquo;B&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-2-3-8-2-3-inheritance-and-overriding:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.2.3&#34;/&gt;8.2.3 Inheritance and Overriding&lt;/h3&gt;

&lt;p&gt;A derived class &lt;strong&gt;&lt;em&gt;inherits&lt;/em&gt;&lt;/strong&gt; all members from its base class it doesn&amp;rsquo;t &lt;strong&gt;&lt;em&gt;override&lt;/em&gt;&lt;/strong&gt;. Inheritance means that a derived class implicitly contains all non-overridden members of the base class. Only public and protected property members can be overridden.&lt;/p&gt;

&lt;p&gt;A property member in a derived class is said to override a property member in a base class when the derived class property member has the same name and kind (instance or static) as the base class property member. The type of an overriding property member must be assignable (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) to the type of the overridden property member, or otherwise a compile-time error occurs.&lt;/p&gt;

&lt;p&gt;Base class instance member functions can be overridden by derived class instance member functions, but not by other kinds of members.&lt;/p&gt;

&lt;p&gt;Base class instance member variables and accessors can be overridden by derived class instance member variables and accessors, but not by other kinds of members.&lt;/p&gt;

&lt;p&gt;Base class static property members can be overridden by derived class static property members of any kind as long as the types are compatible, as described above.&lt;/p&gt;

&lt;p&gt;An index member in a derived class is said to override an index member in a base class when the derived class index member is of the same index kind (string or numeric) as the base class index member. The type of an overriding index member must be assignable (section &lt;a href=&#34;#3.11.4&#34;&gt;3.11.4&lt;/a&gt;) to the type of the overridden index member, or otherwise a compile-time error occurs.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-2-4-8-2-4-class-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.2.4&#34;/&gt;8.2.4 Class Types&lt;/h3&gt;

&lt;p&gt;A class declaration declares a new named type (section &lt;a href=&#34;#3.7&#34;&gt;3.7&lt;/a&gt;) called a class type. Within the constructor and instance member functions of a class, the type of &lt;code&gt;this&lt;/code&gt; is the this-type (section &lt;a href=&#34;#3.6.3&#34;&gt;3.6.3&lt;/a&gt;) of that class type. The class type has the following members:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A property for each instance member variable declaration in the class body.&lt;/li&gt;
&lt;li&gt;A property of a function type for each instance member function declaration in the class body.&lt;/li&gt;
&lt;li&gt;A property for each uniquely named instance member accessor declaration in the class body.&lt;/li&gt;
&lt;li&gt;A property for each constructor parameter declared with a &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, or &lt;code&gt;protected&lt;/code&gt; modifier.&lt;/li&gt;
&lt;li&gt;An index signature for each instance index member declaration in the class body.&lt;/li&gt;
&lt;li&gt;All base class instance property or index members that are not overridden in the class.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All instance property members (including those that are private or protected) of a class must satisfy the constraints implied by the index members of the class as specified in section &lt;a href=&#34;#3.9.4&#34;&gt;3.9.4&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class A {  
    public x: number;  
    public f() { }  
    public g(a: any) { return undefined; }  
    static s: string;  
}

class B extends A {  
    public y: number;  
    public g(b: boolean) { return false; }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the class type of &amp;lsquo;A&amp;rsquo; is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface A {  
    x: number;  
    f: () =&amp;gt; void;  
    g: (a: any) =&amp;gt; any;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the class type of &amp;lsquo;B&amp;rsquo; is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface B {  
    x: number;  
    y: number;  
    f: () =&amp;gt; void;  
    g: (b: boolean) =&amp;gt; boolean;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that static declarations in a class do not contribute to the class type—rather, static declarations introduce properties on the constructor function object. Also note that the declaration of &amp;lsquo;g&amp;rsquo; in &amp;lsquo;B&amp;rsquo; overrides the member inherited from &amp;lsquo;A&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-2-5-8-2-5-constructor-function-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.2.5&#34;/&gt;8.2.5 Constructor Function Types&lt;/h3&gt;

&lt;p&gt;The type of the constructor function introduced by a class declaration is called the constructor function type. The constructor function type has the following members:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the class contains no constructor declaration and has no base class, a single construct signature with no parameters, having the same type parameters as the class (if any) and returning an instantiation of the class type with those type parameters passed as type arguments.&lt;/li&gt;
&lt;li&gt;If the class contains no constructor declaration and has a base class, a set of construct signatures with the same parameters as those of the base class constructor function type following substitution of type parameters with the type arguments specified in the base class type reference, all having the same type parameters as the class (if any) and returning an instantiation of the class type with those type parameters passed as type arguments.&lt;/li&gt;
&lt;li&gt;If the class contains a constructor declaration with no overloads, a construct signature with the parameter list of the constructor implementation, having the same type parameters as the class (if any) and returning an instantiation of the class type with those type parameters passed as type arguments.&lt;/li&gt;
&lt;li&gt;If the class contains a constructor declaration with overloads, a set of construct signatures with the parameter lists of the overloads, all having the same type parameters as the class (if any) and returning an instantiation of the class type with those type parameters passed as type arguments.&lt;/li&gt;
&lt;li&gt;A property for each static member variable declaration in the class body.&lt;/li&gt;
&lt;li&gt;A property of a function type for each static member function declaration in the class body.&lt;/li&gt;
&lt;li&gt;A property for each uniquely named static member accessor declaration in the class body.&lt;/li&gt;
&lt;li&gt;A property named &amp;lsquo;prototype&amp;rsquo;, the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.&lt;/li&gt;
&lt;li&gt;All base class constructor function type properties that are not overridden in the class.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Every class automatically contains a static property member named &amp;lsquo;prototype&amp;rsquo;, the type of which is the containing class with type Any substituted for each type parameter.&lt;/p&gt;

&lt;p&gt;The example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Pair&amp;lt;T1, T2&amp;gt; {  
    constructor(public item1: T1, public item2: T2) { }  
}

class TwoArrays&amp;lt;T&amp;gt; extends Pair&amp;lt;T[], T[]&amp;gt; { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;introduces two named types corresponding to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Pair&amp;lt;T1, T2&amp;gt; {  
    item1: T1;  
    item2: T2;  
}

interface TwoArrays&amp;lt;T&amp;gt; {  
    item1: T[];  
    item2: T[];  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and two constructor functions corresponding to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var Pair: {  
    new &amp;lt;T1, T2&amp;gt;(item1: T1, item2: T2): Pair&amp;lt;T1, T2&amp;gt;;  
}

var TwoArrays: {  
    new &amp;lt;T&amp;gt;(item1: T[], item2: T[]): TwoArrays&amp;lt;T&amp;gt;;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that each construct signature in the constructor function types has the same type parameters as its class and returns an instantiation of its class with those type parameters passed as type arguments. Also note that when a derived class doesn&amp;rsquo;t declare a constructor, type arguments from the base class reference are substituted before construct signatures are propagated from the base constructor function type to the derived constructor function type.&lt;/p&gt;

&lt;h2 id=&#34;a-name-8-3-8-3-constructor-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.3&#34;/&gt;8.3 Constructor Declarations&lt;/h2&gt;

&lt;p&gt;A constructor declaration declares the constructor function of a class.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructorDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;constructor&lt;/code&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;constructor&lt;/code&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Constructor declarations that specify a body are called &lt;strong&gt;&lt;em&gt;constructor implementations&lt;/em&gt;&lt;/strong&gt; and constructor declarations without a body are called &lt;strong&gt;&lt;em&gt;constructor overloads&lt;/em&gt;&lt;/strong&gt;. It is possible to specify multiple constructor overloads in a class, but a class can have at most one constructor implementation. All constructor declarations in a class must specify the same set of modifiers. Only public constructors are supported and private or protected constructors result in an error.&lt;/p&gt;

&lt;p&gt;In a class with no constructor declaration, an automatic constructor is provided, as described in section &lt;a href=&#34;#8.3.3&#34;&gt;8.3.3&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When a class has constructor overloads, the overloads determine the construct signatures of the type given to the constructor function object, and the constructor implementation signature (if any) must be assignable to that type. Otherwise, the constructor implementation itself determines the construct signature. This exactly parallels the way overloads are processed in a function declaration (section &lt;a href=&#34;#6.2&#34;&gt;6.2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;When a class has both constructor overloads and a constructor implementation, the overloads must precede the implementation and all of the declarations must be consecutive with no intervening grammatical elements.&lt;/p&gt;

&lt;p&gt;The function body of a constructor is permitted to contain return statements. If return statements specify expressions, those expressions must be of types that are assignable to the this-type (section &lt;a href=&#34;#3.6.3&#34;&gt;3.6.3&lt;/a&gt;) of the class.&lt;/p&gt;

&lt;p&gt;The type parameters of a generic class are in scope and accessible in a constructor declaration.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-3-1-8-3-1-constructor-parameters:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.3.1&#34;/&gt;8.3.1 Constructor Parameters&lt;/h3&gt;

&lt;p&gt;Similar to functions, only the constructor implementation (and not constructor overloads) can specify default value expressions for optional parameters. It is a compile-time error for such default value expressions to reference &lt;code&gt;this&lt;/code&gt;. When the output target is ECMAScript 3 or 5, for each parameter with a default value, a statement that substitutes the default value for an omitted argument is included in the JavaScript generated for the constructor function.&lt;/p&gt;

&lt;p&gt;A parameter of a &lt;em&gt;ConstructorImplementation&lt;/em&gt; may be prefixed with a &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, or &lt;code&gt;protected&lt;/code&gt; modifier. This is called a &lt;strong&gt;&lt;em&gt;parameter property declaration&lt;/em&gt;&lt;/strong&gt; and is shorthand for declaring a property with the same name as the parameter and initializing it with the value of the parameter. For example, the declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Point {  
    constructor(public x: number, public y: number) {  
        // Constructor body  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to writing&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Point {  
    public x: number;  
    public y: number;  
    constructor(x: number, y: number) {  
        this.x = x;  
        this.y = y;  
        // Constructor body  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A parameter property declaration may declare an optional parameter (by including a question mark or a default value), but the property introduced by such a declaration is always considered a required property (section &lt;a href=&#34;#3.3.6&#34;&gt;3.3.6&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-3-2-8-3-2-super-calls:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.3.2&#34;/&gt;8.3.2 Super Calls&lt;/h3&gt;

&lt;p&gt;Super calls (section &lt;a href=&#34;#4.9.1&#34;&gt;4.9.1&lt;/a&gt;) are used to call the constructor of the base class. A super call consists of the keyword &lt;code&gt;super&lt;/code&gt; followed by an argument list enclosed in parentheses. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class ColoredPoint extends Point {  
    constructor(x: number, y: number, public color: string) {  
        super(x, y);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constructors of classes with no &lt;code&gt;extends&lt;/code&gt; clause may not contain super calls, whereas constructors of derived classes must contain at least one super call somewhere in their function body. Super calls are not permitted outside constructors or in local functions inside constructors.&lt;/p&gt;

&lt;p&gt;The first statement in the body of a constructor &lt;em&gt;must&lt;/em&gt; be a super call if both of the following are true:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The containing class is a derived class.&lt;/li&gt;
&lt;li&gt;The constructor declares parameter properties or the containing class declares instance member variables with initializers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In such a required super call, it is a compile-time error for argument expressions to reference &lt;code&gt;this&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Initialization of parameter properties and instance member variables with initializers takes place immediately at the beginning of the constructor body if the class has no base class, or immediately following the super call if the class is a derived class.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-3-3-8-3-3-automatic-constructors:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.3.3&#34;/&gt;8.3.3 Automatic Constructors&lt;/h3&gt;

&lt;p&gt;If a class omits a constructor declaration, an &lt;strong&gt;&lt;em&gt;automatic constructor&lt;/em&gt;&lt;/strong&gt; is provided.&lt;/p&gt;

&lt;p&gt;In a class with no &lt;code&gt;extends&lt;/code&gt; clause, the automatic constructor has no parameters and performs no action other than executing the instance member variable initializers (section &lt;a href=&#34;#8.4.1&#34;&gt;8.4.1&lt;/a&gt;), if any.&lt;/p&gt;

&lt;p&gt;In a derived class, the automatic constructor has the same parameter list (and possibly overloads) as the base class constructor. The automatically provided constructor first forwards the call to the base class constructor using a call equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;BaseClass.apply(this, arguments);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then executes the instance member variable initializers, if any.&lt;/p&gt;

&lt;h2 id=&#34;a-name-8-4-8-4-property-member-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.4&#34;/&gt;8.4 Property Member Declarations&lt;/h2&gt;

&lt;p&gt;Property member declarations can be member variable declarations, member function declarations, or member accessor declarations.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyMemberDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;MemberVariableDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;MemberFunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;MemberAccessorDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Member declarations without a &lt;code&gt;static&lt;/code&gt; modifier are called instance member declarations. Instance property member declarations declare properties in the class type (section &lt;a href=&#34;#8.2.4&#34;&gt;8.2.4&lt;/a&gt;), and must specify names that are unique among all instance property member and parameter property declarations in the containing class, with the exception that instance get and set accessor declarations may pairwise specify the same name.&lt;/p&gt;

&lt;p&gt;Member declarations with a &lt;code&gt;static&lt;/code&gt; modifier are called static member declarations. Static property member declarations declare properties in the constructor function type (section &lt;a href=&#34;#8.2.5&#34;&gt;8.2.5&lt;/a&gt;), and must specify names that are unique among all static property member declarations in the containing class, with the exception that static get and set accessor declarations may pairwise specify the same name.&lt;/p&gt;

&lt;p&gt;Note that the declaration spaces of instance and static property members are separate. Thus, it is possible to have instance and static property members with the same name.&lt;/p&gt;

&lt;p&gt;Except for overrides, as described in section &lt;a href=&#34;#8.2.3&#34;&gt;8.2.3&lt;/a&gt;, it is an error for a derived class to declare a property member with the same name and kind (instance or static) as a base class member.&lt;/p&gt;

&lt;p&gt;Every class automatically contains a static property member named &amp;lsquo;prototype&amp;rsquo;, the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter. It is an error to explicitly declare a static property member with the name &amp;lsquo;prototype&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Below is an example of a class containing both instance and static property member declarations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Point {  
    constructor(public x: number, public y: number) { }  
    public distance(p: Point) {  
        var dx = this.x - p.x;  
        var dy = this.y - p.y;  
        return Math.sqrt(dx * dx + dy * dy);  
    }  
    static origin = new Point(0, 0);  
    static distance(p1: Point, p2: Point) { return p1.distance(p2); }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class type &amp;lsquo;Point&amp;rsquo; has the members:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Point {  
    x: number;  
    y: number;  
    distance(p: Point);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the constructor function &amp;lsquo;Point&amp;rsquo; has a type corresponding to the declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var Point: {  
    new(x: number, y: number): Point;  
    origin: Point;  
    distance(p1: Point, p2: Point): number;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-8-4-1-8-4-1-member-variable-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.4.1&#34;/&gt;8.4.1 Member Variable Declarations&lt;/h3&gt;

&lt;p&gt;A member variable declaration declares an instance member variable or a static member variable.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;MemberVariableDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The type associated with a member variable declaration is determined in the same manner as an ordinary variable declaration (see section &lt;a href=&#34;#5.2&#34;&gt;5.2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;An instance member variable declaration introduces a member in the class type and optionally initializes a property on instances of the class. Initializers in instance member variable declarations are executed once for every new instance of the class and are equivalent to assignments to properties of &lt;code&gt;this&lt;/code&gt; in the constructor. In an initializer expression for an instance member variable, &lt;code&gt;this&lt;/code&gt; is of the this-type (section &lt;a href=&#34;#3.6.3&#34;&gt;3.6.3&lt;/a&gt;) of the class.&lt;/p&gt;

&lt;p&gt;A static member variable declaration introduces a property in the constructor function type and optionally initializes a property on the constructor function object. Initializers in static member variable declarations are executed once when the containing script or module is loaded.&lt;/p&gt;

&lt;p&gt;Initializer expressions for instance member variables are evaluated in the scope of the class constructor body but are not permitted to reference parameters or local variables of the constructor. This effectively means that entities from outer scopes by the same name as a constructor parameter or local variable are inaccessible in initializer expressions for instance member variables.&lt;/p&gt;

&lt;p&gt;Since instance member variable initializers are equivalent to assignments to properties of &lt;code&gt;this&lt;/code&gt; in the constructor, the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Employee {  
    public name: string;  
    public address: string;  
    public retired = false;  
    public manager: Employee = null;  
    public reports: Employee[] = [];  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Employee {  
    public name: string;  
    public address: string;  
    public retired: boolean;  
    public manager: Employee;  
    public reports: Employee[];  
    constructor() {  
        this.retired = false;  
        this.manager = null;  
        this.reports = [];  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-8-4-2-8-4-2-member-function-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.4.2&#34;/&gt;8.4.2 Member Function Declarations&lt;/h3&gt;

&lt;p&gt;A member function declaration declares an instance member function or a static member function.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;MemberFunctionDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A member function declaration is processed in the same manner as an ordinary function declaration (section &lt;a href=&#34;#6&#34;&gt;6&lt;/a&gt;), except that in a member function &lt;code&gt;this&lt;/code&gt; has a known type.&lt;/p&gt;

&lt;p&gt;All declarations for the same member function must specify the same accessibility (public, private, or protected) and kind (instance or static).&lt;/p&gt;

&lt;p&gt;An instance member function declaration declares a property in the class type and assigns a function object to a property on the prototype object of the class. In the body of an instance member function declaration, &lt;code&gt;this&lt;/code&gt; is of the this-type (section &lt;a href=&#34;#3.6.3&#34;&gt;3.6.3&lt;/a&gt;) of the class.&lt;/p&gt;

&lt;p&gt;A static member function declaration declares a property in the constructor function type and assigns a function object to a property on the constructor function object. In the body of a static member function declaration, the type of &lt;code&gt;this&lt;/code&gt; is the constructor function type.&lt;/p&gt;

&lt;p&gt;A member function can access overridden base class members using a super property access (section &lt;a href=&#34;#4.9.2&#34;&gt;4.9.2&lt;/a&gt;). For example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class Point {  
    constructor(public x: number, public y: number) { }  
    public toString() {  
        return &amp;quot;x=&amp;quot; + this.x + &amp;quot; y=&amp;quot; + this.y;  
    }  
}

class ColoredPoint extends Point {  
    constructor(x: number, y: number, public color: string) {  
        super(x, y);  
    }  
    public toString() {  
        return super.toString() + &amp;quot; color=&amp;quot; + this.color;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a static member function, &lt;code&gt;this&lt;/code&gt; represents the constructor function object on which the static member function was invoked. Thus, a call to &amp;lsquo;new this()&amp;rsquo; may actually invoke a derived class constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class A {  
    a = 1;  
    static create() {  
        return new this();  
    }  
}

class B extends A {  
    b = 2;  
}

var x = A.create();  // new A()  
var y = B.create();  // new B()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that TypeScript doesn&amp;rsquo;t require or verify that derived constructor functions are subtypes of base constructor functions. In other words, changing the declaration of &amp;lsquo;B&amp;rsquo; to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;class B extends A {  
    constructor(public b: number) {  
        super();  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;does not cause errors in the example, even though the call to the constructor from the &amp;lsquo;create&amp;rsquo; function doesn&amp;rsquo;t specify an argument (thus giving the value &amp;lsquo;undefined&amp;rsquo; to &amp;lsquo;b&amp;rsquo;).&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-4-3-8-4-3-member-accessor-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.4.3&#34;/&gt;8.4.3 Member Accessor Declarations&lt;/h3&gt;

&lt;p&gt;A member accessor declaration declares an instance member accessor or a static member accessor.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;MemberAccessorDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;GetAccessor&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;SetAccessor&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Get and set accessors are processed in the same manner as in an object literal (section &lt;a href=&#34;#4.5&#34;&gt;4.5&lt;/a&gt;), except that a contextual type is never available in a member accessor declaration.&lt;/p&gt;

&lt;p&gt;Accessors for the same member name must specify the same accessibility.&lt;/p&gt;

&lt;p&gt;An instance member accessor declaration declares a property in the class type and defines a property on the prototype object of the class with a get or set accessor. In the body of an instance member accessor declaration, &lt;code&gt;this&lt;/code&gt; is of the this-type (section &lt;a href=&#34;#3.6.3&#34;&gt;3.6.3&lt;/a&gt;) of the class.&lt;/p&gt;

&lt;p&gt;A static member accessor declaration declares a property in the constructor function type and defines a property on the constructor function object of the class with a get or set accessor. In the body of a static member accessor declaration, the type of &lt;code&gt;this&lt;/code&gt; is the constructor function type.&lt;/p&gt;

&lt;p&gt;Get and set accessors are emitted as calls to &amp;lsquo;Object.defineProperty&amp;rsquo; in the generated JavaScript, as described in section &lt;a href=&#34;#8.7.1&#34;&gt;8.7.1&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-4-4-8-4-4-dynamic-property-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.4.4&#34;/&gt;8.4.4 Dynamic Property Declarations&lt;/h3&gt;

&lt;p&gt;If the &lt;em&gt;PropertyName&lt;/em&gt; of a property member declaration is a computed property name that doesn&amp;rsquo;t denote a well-known symbol (&lt;a href=&#34;#2.2.3&#34;&gt;2.2.3&lt;/a&gt;), the construct is considered a &lt;strong&gt;&lt;em&gt;dynamic property declaration&lt;/em&gt;&lt;/strong&gt;. The following rules apply to dynamic property declarations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A dynamic property declaration does not introduce a property in the class type or constructor function type.&lt;/li&gt;
&lt;li&gt;The property name expression of a dynamic property assignment must be of type Any or the String, Number, or Symbol primitive type.&lt;/li&gt;
&lt;li&gt;The name associated with a dynamic property declarations is considered to be a numeric property name if the property name expression is of type Any or the Number primitive type.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-8-5-8-5-index-member-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.5&#34;/&gt;8.5 Index Member Declarations&lt;/h2&gt;

&lt;p&gt;An index member declaration introduces an index signature (section &lt;a href=&#34;#3.9.4&#34;&gt;3.9.4&lt;/a&gt;) in the class type.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;IndexMemberDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IndexSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Index member declarations have no body and cannot specify an accessibility modifier.&lt;/p&gt;

&lt;p&gt;A class declaration can have at most one string index member declaration and one numeric index member declaration. All instance property members of a class must satisfy the constraints implied by the index members of the class as specified in section &lt;a href=&#34;#3.9.4&#34;&gt;3.9.4&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It is not possible to declare index members for the static side of a class.&lt;/p&gt;

&lt;p&gt;Note that it is seldom meaningful to include a string index signature in a class because it constrains all instance properties of the class. However, numeric index signatures can be useful to control the element type when a class is used in an array-like manner.&lt;/p&gt;

&lt;h2 id=&#34;a-name-8-6-8-6-decorators:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.6&#34;/&gt;8.6 Decorators&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;TODO: Document &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/2249&#34;&gt;decorators&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-name-8-7-8-7-code-generation:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.7&#34;/&gt;8.7 Code Generation&lt;/h2&gt;

&lt;p&gt;When the output target is ECMAScript 2015 or higher, type parameters, implements clauses, accessibility modifiers, and member variable declarations are removed in the emitted code, but otherwise class declarations are emitted as written. When the output target is ECMAScript 3 or 5, more comprehensive rewrites are performed, as described in this section.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-7-1-8-7-1-classes-without-extends-clauses:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.7.1&#34;/&gt;8.7.1 Classes Without Extends Clauses&lt;/h3&gt;

&lt;p&gt;A class with no &lt;code&gt;extends&lt;/code&gt; clause generates JavaScript equivalent to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var &amp;lt;ClassName&amp;gt; = (function () {  
    function &amp;lt;ClassName&amp;gt;(&amp;lt;ConstructorParameters&amp;gt;) {  
        &amp;lt;DefaultValueAssignments&amp;gt;  
        &amp;lt;ParameterPropertyAssignments&amp;gt;  
        &amp;lt;MemberVariableAssignments&amp;gt;  
        &amp;lt;ConstructorStatements&amp;gt;  
    }  
    &amp;lt;MemberFunctionStatements&amp;gt;  
    &amp;lt;StaticVariableAssignments&amp;gt;  
    return &amp;lt;ClassName&amp;gt;;  
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;ClassName&lt;/em&gt; is the name of the class.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ConstructorParameters&lt;/em&gt; is a comma separated list of the constructor&amp;rsquo;s parameter names.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;DefaultValueAssignments&lt;/em&gt; is a sequence of default property value assignments corresponding to those generated for a regular function declaration, as described in section &lt;a href=&#34;#6.6&#34;&gt;6.6&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ParameterPropertyAssignments&lt;/em&gt; is a sequence of assignments, one for each parameter property declaration in the constructor, in order they are declared, of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;this.&amp;lt;ParameterName&amp;gt; = &amp;lt;ParameterName&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;ParameterName&lt;/em&gt; is the name of a parameter property.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;MemberVariableAssignments&lt;/em&gt; is a sequence of assignments, one for each instance member variable declaration with an initializer, in the order they are declared, of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;this.&amp;lt;MemberName&amp;gt; = &amp;lt;InitializerExpression&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;MemberName&lt;/em&gt; is the name of the member variable and &lt;em&gt;InitializerExpression&lt;/em&gt; is the code generated for the initializer expression.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ConstructorStatements&lt;/em&gt; is the code generated for the statements specified in the constructor body.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;MemberFunctionStatements&lt;/em&gt; is a sequence of statements, one for each member function declaration or member accessor declaration, in the order they are declared.&lt;/p&gt;

&lt;p&gt;An instance member function declaration generates a statement of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt;ClassName&amp;gt;.prototype.&amp;lt;MemberName&amp;gt; = function (&amp;lt;FunctionParameters&amp;gt;) {  
    &amp;lt;DefaultValueAssignments&amp;gt;  
    &amp;lt;FunctionStatements&amp;gt;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and static member function declaration generates a statement of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt;ClassName&amp;gt;.&amp;lt;MemberName&amp;gt; = function (&amp;lt;FunctionParameters&amp;gt;) {  
    &amp;lt;DefaultValueAssignments&amp;gt;  
    &amp;lt;FunctionStatements&amp;gt;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;MemberName&lt;/em&gt; is the name of the member function, and &lt;em&gt;FunctionParameters&lt;/em&gt;, &lt;em&gt;DefaultValueAssignments&lt;/em&gt;, and &lt;em&gt;FunctionStatements&lt;/em&gt; correspond to those generated for a regular function declaration, as described in section &lt;a href=&#34;#6.6&#34;&gt;6.6&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A get or set instance member accessor declaration, or a pair of get and set instance member accessor declarations with the same name, generates a statement of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;Object.defineProperty(&amp;lt;ClassName&amp;gt;.prototype, &amp;quot;&amp;lt;MemberName&amp;gt;&amp;quot;, {  
    get: function () {  
        &amp;lt;GetAccessorStatements&amp;gt;  
    },  
    set: function (&amp;lt;ParameterName&amp;gt;) {  
        &amp;lt;SetAccessorStatements&amp;gt;  
    },  
    enumerable: true,  
    configurable: true  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and a get or set static member accessor declaration, or a pair of get and set static member accessor declarations with the same name, generates a statement of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;Object.defineProperty(&amp;lt;ClassName&amp;gt;, &amp;quot;&amp;lt;MemberName&amp;gt;&amp;quot;, {  
    get: function () {  
        &amp;lt;GetAccessorStatements&amp;gt;  
    },  
    set: function (&amp;lt;ParameterName&amp;gt;) {  
        &amp;lt;SetAccessorStatements&amp;gt;  
    },  
    enumerable: true,  
    configurable: true  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;MemberName&lt;/em&gt; is the name of the member accessor, &lt;em&gt;GetAccessorStatements&lt;/em&gt; is the code generated for the statements in the get acessor&amp;rsquo;s function body, &lt;em&gt;ParameterName&lt;/em&gt; is the name of the set accessor parameter, and &lt;em&gt;SetAccessorStatements&lt;/em&gt; is the code generated for the statements in the set accessor&amp;rsquo;s function body. The &amp;lsquo;get&amp;rsquo; property is included only if a get accessor is declared and the &amp;lsquo;set&amp;rsquo; property is included only if a set accessor is declared.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;StaticVariableAssignments&lt;/em&gt; is a sequence of statements, one for each static member variable declaration with an initializer, in the order they are declared, of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt;ClassName&amp;gt;.&amp;lt;MemberName&amp;gt; = &amp;lt;InitializerExpression&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;MemberName&lt;/em&gt; is the name of the static variable, and &lt;em&gt;InitializerExpression&lt;/em&gt; is the code generated for the initializer expression.&lt;/p&gt;

&lt;h3 id=&#34;a-name-8-7-2-8-7-2-classes-with-extends-clauses:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;8.7.2&#34;/&gt;8.7.2 Classes With Extends Clauses&lt;/h3&gt;

&lt;p&gt;A class with an &lt;code&gt;extends&lt;/code&gt; clause generates JavaScript equivalent to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var &amp;lt;ClassName&amp;gt; = (function (_super) {  
    __extends(&amp;lt;ClassName&amp;gt;, _super);  
    function &amp;lt;ClassName&amp;gt;(&amp;lt;ConstructorParameters&amp;gt;) {  
        &amp;lt;DefaultValueAssignments&amp;gt;  
        &amp;lt;SuperCallStatement&amp;gt;  
        &amp;lt;ParameterPropertyAssignments&amp;gt;  
        &amp;lt;MemberVariableAssignments&amp;gt;  
        &amp;lt;ConstructorStatements&amp;gt;  
    }  
    &amp;lt;MemberFunctionStatements&amp;gt;  
    &amp;lt;StaticVariableAssignments&amp;gt;  
    return &amp;lt;ClassName&amp;gt;;  
})(&amp;lt;BaseClassName&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition, the &amp;lsquo;__extends&amp;rsquo; function below is emitted at the beginning of the JavaScript source file. It copies all properties from the base constructor function object to the derived constructor function object (in order to inherit static members), and appropriately establishes the &amp;lsquo;prototype&amp;rsquo; property of the derived constructor function object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var __extends = this.__extends || function(d, b) {  
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];  
    function f() { this.constructor = d; }  
    f.prototype = b.prototype;  
    d.prototype = new f();  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;BaseClassName&lt;/em&gt; is the class name specified in the &lt;code&gt;extends&lt;/code&gt; clause.&lt;/p&gt;

&lt;p&gt;If the class has no explicitly declared constructor, the &lt;em&gt;SuperCallStatement&lt;/em&gt; takes the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;_super.apply(this, arguments);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise the &lt;em&gt;SuperCallStatement&lt;/em&gt; is present if the constructor function is required to start with a super call, as discussed in section &lt;a href=&#34;#8.3.2&#34;&gt;8.3.2&lt;/a&gt;, and takes the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;_super.call(this, &amp;lt;SuperCallArguments&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;SuperCallArguments&lt;/em&gt; is the argument list specified in the super call. Note that this call precedes the code generated for parameter properties and member variables with initializers. Super calls elsewhere in the constructor generate similar code, but the code generated for such calls will be part of the &lt;em&gt;ConstructorStatements&lt;/em&gt; section.&lt;/p&gt;

&lt;p&gt;A super property access in the constructor, an instance member function, or an instance member accessor generates JavaScript equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;_super.prototype.&amp;lt;PropertyName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;PropertyName&lt;/em&gt; is the name of the referenced base class property. When the super property access appears in a function call, the generated JavaScript is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;_super.prototype.&amp;lt;PropertyName&amp;gt;.call(this, &amp;lt;Arguments&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where Arguments is the code generated for the argument list specified in the function call.&lt;/p&gt;

&lt;p&gt;A super property access in a static member function or a static member accessor generates JavaScript equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;_super.&amp;lt;PropertyName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;PropertyName&lt;/em&gt; is the name of the referenced base class property. When the super property access appears in a function call, the generated JavaScript is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;_super.&amp;lt;PropertyName&amp;gt;.call(this, &amp;lt;Arguments&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where Arguments is the code generated for the argument list specified in the function call.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-9-9-enums:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;9&#34;/&gt;9 Enums&lt;/h1&gt;

&lt;p&gt;An enum type is a distinct subtype of the Number primitive type with an associated set of named constants that define the possible values of the enum type.&lt;/p&gt;

&lt;h2 id=&#34;a-name-9-1-9-1-enum-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;9.1&#34;/&gt;9.1 Enum Declarations&lt;/h2&gt;

&lt;p&gt;An enum declaration declares an &lt;strong&gt;&lt;em&gt;enum type&lt;/em&gt;&lt;/strong&gt; and an &lt;strong&gt;&lt;em&gt;enum object&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;const&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;enum&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;EnumBody&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;EnumDeclaration&lt;/em&gt; introduces a named type (the enum type) and a named value (the enum object) in the containing declaration space. The enum type is a distinct subtype of the Number primitive type. The enum object is a value of an anonymous object type containing a set of properties, all of the enum type, corresponding to the values declared for the enum type in the body of the declaration. The enum object&amp;rsquo;s type furthermore includes a numeric index signature with the signature &amp;lsquo;[x: number]: string&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;BindingIdentifier&lt;/em&gt; of an enum declaration may not be one of the predefined type names (section &lt;a href=&#34;#3.8.1&#34;&gt;3.8.1&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;When an enum declaration includes a &lt;code&gt;const&lt;/code&gt; modifier it is said to be a constant enum declaration. The members of a constant enum declaration must all have constant values that can be computed at compile time. Constant enum declarations are discussed in section &lt;a href=&#34;#9.4&#34;&gt;9.4&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;enum Color { Red, Green, Blue }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;declares a subtype of the Number primitive type called &amp;lsquo;Color&amp;rsquo; and introduces a variable &amp;lsquo;Color&amp;rsquo; with a type that corresponds to the declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var Color: {  
    [x: number]: string;  
    Red: Color;  
    Green: Color;  
    Blue: Color;  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The numeric index signature reflects a &amp;ldquo;reverse mapping&amp;rdquo; that is automatically generated in every enum object, as described in section &lt;a href=&#34;#9.5&#34;&gt;9.5&lt;/a&gt;. The reverse mapping provides a convenient way to obtain the string representation of an enum value. For example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var c = Color.Red;  
console.log(Color[c]);  // Outputs &amp;quot;Red&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-name-9-2-9-2-enum-members:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;9.2&#34;/&gt;9.2 Enum Members&lt;/h2&gt;

&lt;p&gt;The body of an enum declaration defines zero or more enum members which are the named values of the enum type. Each enum member has an associated numeric value of the primitive type introduced by the enum declaration.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EnumBody:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EnumMemberList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumMember&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;EnumMember&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EnumMember:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;=&amp;emsp;&lt;em&gt;EnumValue&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EnumValue:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;PropertyName&lt;/em&gt; of an enum member cannot be a computed property name (&lt;a href=&#34;#2.2.3&#34;&gt;2.2.3&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Enum members are either &lt;strong&gt;&lt;em&gt;constant members&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;computed members&lt;/em&gt;&lt;/strong&gt;. Constant members have known constant values that are substituted in place of references to the members in the generated JavaScript code. Computed members have values that are computed at run-time and not known at compile-time. No substitution is performed for references to computed members.&lt;/p&gt;

&lt;p&gt;An enum member is classified as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the member declaration specifies no value, the member is considered a constant enum member. If the member is the first member in the enum declaration, it is assigned the value zero. Otherwise, it is assigned the value of the immediately preceding member plus one, and an error occurs if the immediately preceding member is not a constant enum member.&lt;/li&gt;
&lt;li&gt;If the member declaration specifies a value that can be classified as a constant enum expression (as defined below), the member is considered a constant enum member.&lt;/li&gt;
&lt;li&gt;Otherwise, the member is considered a computed enum member.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enum value expressions must be of type Any, the Number primitive type, or the enum type itself.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;&lt;em&gt;constant enum expression&lt;/em&gt;&lt;/strong&gt; is a subset of the expression grammar that can be evaluated fully at compile time. An expression is considered a constant enum expression if it is one of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A numeric literal.&lt;/li&gt;
&lt;li&gt;An identifier or property access that denotes a previously declared member in the same constant enum declaration.&lt;/li&gt;
&lt;li&gt;A parenthesized constant enum expression.&lt;/li&gt;
&lt;li&gt;A +, –, or ~ unary operator applied to a constant enum expression.&lt;/li&gt;
&lt;li&gt;A +, –, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;gt;&amp;gt;&amp;gt;, &amp;amp;, ^, or | operator applied to two constant enum expressions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;enum Test {  
    A,  
    B,  
    C = Math.floor(Math.random() * 1000),  
    D = 10,  
    E  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, &amp;rsquo;D&amp;rsquo;, and &amp;lsquo;E&amp;rsquo; are constant members with values 0, 1, 10, and 11 respectively, and &amp;lsquo;C&amp;rsquo; is a computed member.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;enum Style {  
    None = 0,  
    Bold = 1,  
    Italic = 2,  
    Underline = 4,  
    Emphasis = Bold | Italic,  
    Hyperlink = Bold | Underline  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;all members are constant members. Note that enum member declarations can reference other enum members without qualification. Also, because enums are subtypes of the Number primitive type, numeric operators, such as the bitwise OR operator, can be used to compute enum values.&lt;/p&gt;

&lt;h2 id=&#34;a-name-9-3-9-3-declaration-merging:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;9.3&#34;/&gt;9.3 Declaration Merging&lt;/h2&gt;

&lt;p&gt;Enums are &amp;ldquo;open-ended&amp;rdquo; and enum declarations with the same qualified name relative to a common root (as defined in section &lt;a href=&#34;#2.3&#34;&gt;2.3&lt;/a&gt;) define a single enum type and contribute to a single enum object.&lt;/p&gt;

&lt;p&gt;It isn&amp;rsquo;t possible for one enum declaration to continue the automatic numbering sequence of another, and when an enum type has multiple declarations, only one declaration is permitted to omit a value for the first member.&lt;/p&gt;

&lt;p&gt;When enum declarations are merged, they must either all specify a &lt;code&gt;const&lt;/code&gt; modifier or all specify no &lt;code&gt;const&lt;/code&gt; modifier.&lt;/p&gt;

&lt;h2 id=&#34;a-name-9-4-9-4-constant-enum-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;9.4&#34;/&gt;9.4 Constant Enum Declarations&lt;/h2&gt;

&lt;p&gt;An enum declaration that specifies a &lt;code&gt;const&lt;/code&gt; modifier is a &lt;strong&gt;&lt;em&gt;constant enum declaration&lt;/em&gt;&lt;/strong&gt;. In a constant enum declaration, all members must have constant values and it is an error for a member declaration to specify an expression that isn&amp;rsquo;t classified as a constant enum expression.&lt;/p&gt;

&lt;p&gt;Unlike regular enum declarations, constant enum declarations are completely erased in the emitted JavaScript code. For this reason, it is an error to reference a constant enum object in any other context than a property access that selects one of the enum&amp;rsquo;s members. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;const enum Comparison {  
    LessThan = -1,  
    EqualTo = 0,  
    GreaterThan = 1  
}

var x = Comparison.EqualTo;  // Ok, replaced with 0 in emitted code  
var y = Comparison[Comparison.EqualTo];  // Error  
var z = Comparison;  // Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The entire const enum declaration is erased in the emitted JavaScript code. Thus, the only permitted references to the enum object are those that are replaced with an enum member value.&lt;/p&gt;

&lt;h2 id=&#34;a-name-9-5-9-5-code-generation:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;9.5&#34;/&gt;9.5 Code Generation&lt;/h2&gt;

&lt;p&gt;An enum declaration generates JavaScript equivalent to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var &amp;lt;EnumName&amp;gt;;  
(function (&amp;lt;EnumName&amp;gt;) {  
    &amp;lt;EnumMemberAssignments&amp;gt;  
})(&amp;lt;EnumName&amp;gt;||(&amp;lt;EnumName&amp;gt;={}));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;EnumName&lt;/em&gt; is the name of the enum.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;EnumMemberAssignments&lt;/em&gt; is a sequence of assignments, one for each enum member, in order they are declared, of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt;EnumName&amp;gt;[&amp;lt;EnumName&amp;gt;[&amp;quot;&amp;lt;MemberName&amp;gt;&amp;quot;] = &amp;lt;Value&amp;gt;] = &amp;quot;&amp;lt;MemberName&amp;gt;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;MemberName&lt;/em&gt; is the name of the enum member and &lt;em&gt;Value&lt;/em&gt; is the assigned constant value or the code generated for the computed value expression.&lt;/p&gt;

&lt;p&gt;For example, the &amp;lsquo;Color&amp;rsquo; enum example from section &lt;a href=&#34;#9.1&#34;&gt;9.1&lt;/a&gt; generates the following JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var Color;  
(function (Color) {  
    Color[Color[&amp;quot;Red&amp;quot;] = 0] = &amp;quot;Red&amp;quot;;  
    Color[Color[&amp;quot;Green&amp;quot;] = 1] = &amp;quot;Green&amp;quot;;  
    Color[Color[&amp;quot;Blue&amp;quot;] = 2] = &amp;quot;Blue&amp;quot;;  
})(Color||(Color={}));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-10-10-namespaces:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;10&#34;/&gt;10 Namespaces&lt;/h1&gt;

&lt;p&gt;Namespaces provide a mechanism for organizing code and declarations in hierarchies of named containers. Namespaces have named members that each denote a value, a type, or a namespace, or some combination thereof, and those members may be local or exported. The body of a namespace corresponds to a function that is executed once, thereby providing a mechanism for maintaining local state with assured isolation. Namespaces can be thought of as a formalization of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&#34;&gt;immediately-invoked function expression&lt;/a&gt; (IIFE) pattern.&lt;/p&gt;

&lt;h2 id=&#34;a-name-10-1-10-1-namespace-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;10.1&#34;/&gt;10.1 Namespace Declarations&lt;/h2&gt;

&lt;p&gt;A namespace declaration introduces a name with a namespace meaning and, in the case of an instantiated namespace, a value meaning in the containing declaration space.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;namespace&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierPath&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;NamespaceBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierPath:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierPath&lt;/em&gt;&amp;emsp;&lt;code&gt;.&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Namespaces are declared using the &lt;code&gt;namespace&lt;/code&gt; keyword, but for backward compatibility of earlier versions of TypeScript a &lt;code&gt;module&lt;/code&gt; keyword can also be used.&lt;/p&gt;

&lt;p&gt;Namespaces are either &lt;strong&gt;&lt;em&gt;instantiated&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;non-instantiated&lt;/em&gt;&lt;/strong&gt;. A non-instantiated namespace is a namespace containing only interface types, type aliases, and other non-instantiated namespace. An instantiated namespace is a namespace that doesn&amp;rsquo;t meet this definition. In intuitive terms, an instantiated namespace is one for which a namespace instance is created, whereas a non-instantiated namespace is one for which no code is generated.&lt;/p&gt;

&lt;p&gt;When a namespace identifier is referenced as a &lt;em&gt;NamespaceName&lt;/em&gt; (section &lt;a href=&#34;#3.8.2&#34;&gt;3.8.2&lt;/a&gt;) it denotes a container of namespace and type names, and when a namespace identifier is referenced as a &lt;em&gt;PrimaryExpression&lt;/em&gt; (section &lt;a href=&#34;#4.3&#34;&gt;4.3&lt;/a&gt;) it denotes the singleton namespace instance. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;namespace M {  
    export interface P { x: number; y: number; }  
    export var a = 1;  
}

var p: M.P;             // M used as NamespaceName  
var m = M;              // M used as PrimaryExpression  
var x1 = M.a;           // M used as PrimaryExpression  
var x2 = m.a;           // Same as M.a  
var q: m.P;             // Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above, when &amp;rsquo;M&amp;rsquo; is used as a &lt;em&gt;PrimaryExpression&lt;/em&gt; it denotes an object instance with a single member &amp;lsquo;a&amp;rsquo; and when &amp;rsquo;M&amp;rsquo; is used as a &lt;em&gt;NamespaceName&lt;/em&gt; it denotes a container with a single type member &amp;lsquo;P&amp;rsquo;. The final line in the example is an error because &amp;rsquo;m&amp;rsquo; is a variable which cannot be referenced in a type name.&lt;/p&gt;

&lt;p&gt;If the declaration of &amp;rsquo;M&amp;rsquo; above had excluded the exported variable &amp;lsquo;a&amp;rsquo;, &amp;rsquo;M&amp;rsquo; would be a non-instantiated namespace and it would be an error to reference &amp;rsquo;M&amp;rsquo; as a &lt;em&gt;PrimaryExpression&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A namespace declaration that specifies an &lt;em&gt;IdentifierPath&lt;/em&gt; with more than one identifier is equivalent to a series of nested single-identifier namespace declarations where all but the outermost are automatically exported. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;namespace A.B.C {  
    export var x = 1;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;corresponds to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;namespace A {  
    export namespace B {  
        export namespace C {  
            export var x = 1;  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hierarchy formed by namespace and named type names partially mirrors that formed by namespace instances and members. The example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;namespace A {  
    export namespace B {  
        export class C { }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;introduces a named type with the qualified name &amp;lsquo;A.B.C&amp;rsquo; and also introduces a constructor function that can be accessed using the expression &amp;lsquo;A.B.C&amp;rsquo;. Thus, in the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var c: A.B.C = new A.B.C();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the two occurrences of &amp;lsquo;A.B.C&amp;rsquo; in fact refer to different entities. It is the context of the occurrences that determines whether &amp;lsquo;A.B.C&amp;rsquo; is processed as a type name or an expression.&lt;/p&gt;

&lt;h2 id=&#34;a-name-10-2-10-2-namespace-body:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;10.2&#34;/&gt;10.2 Namespace Body&lt;/h2&gt;

&lt;p&gt;The body of a namespace corresponds to a function that is executed once to initialize the namespace instance.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceBody:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceElements&lt;/em&gt;&amp;emsp;&lt;em&gt;NamespaceElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;Statement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;LexicalDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;GeneratorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceDeclaration&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;AmbientDeclaration&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;ImportAliasDeclaration&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;ExportNamespaceElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportNamespaceElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;VariableStatement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;LexicalDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;GeneratorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;NamespaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-name-10-3-10-3-import-alias-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;10.3&#34;/&gt;10.3 Import Alias Declarations&lt;/h2&gt;

&lt;p&gt;Import alias declarations are used to create local aliases for entities in other namespaces.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImportAliasDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;import&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;=&lt;/code&gt;&amp;emsp;&lt;em&gt;EntityName&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EntityName:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceName&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceName&lt;/em&gt;&amp;emsp;&lt;code&gt;.&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;EntityName&lt;/em&gt; consisting of a single identifier is resolved as a &lt;em&gt;NamespaceName&lt;/em&gt; and is thus required to reference a namespace. The resulting local alias references the given namespace and is itself classified as a namespace.&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;EntityName&lt;/em&gt; consisting of more than one identifier is resolved as a &lt;em&gt;NamespaceName&lt;/em&gt; followed by an identifier that names an exported entity in the given namespace. The resulting local alias has all the meanings of the referenced entity. (As many as three distinct meanings are possible for an entity name—value, type, and namespace.) In effect, it is as if the imported entity was declared locally with the local alias name.&lt;/p&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;namespace A {  
    export interface X { s: string }  
    export var X: X;  
}

namespace B {  
    interface A { n: number }  
    import Y = A;    // Alias for namespace A  
    import Z = A.X;  // Alias for type and value A.X  
    var v: Z = Z;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;within &amp;lsquo;B&amp;rsquo;, &amp;lsquo;Y&amp;rsquo; is an alias only for namespace &amp;lsquo;A&amp;rsquo; and not the local interface &amp;lsquo;A&amp;rsquo;, whereas &amp;lsquo;Z&amp;rsquo; is an alias for all exported meanings of &amp;lsquo;A.X&amp;rsquo;, thus denoting both an interface type and a variable.&lt;/p&gt;

&lt;p&gt;If the &lt;em&gt;NamespaceName&lt;/em&gt; portion of an &lt;em&gt;EntityName&lt;/em&gt; references an instantiated namespace, the &lt;em&gt;NamespaceName&lt;/em&gt; is required to reference the namespace instance when evaluated as an expression. In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;namespace A {  
    export interface X { s: string }  
}

namespace B {  
    var A = 1;  
    import Y = A;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;Y&amp;rsquo; is a local alias for the non-instantiated namespace &amp;lsquo;A&amp;rsquo;. If the declaration of &amp;lsquo;A&amp;rsquo; is changed such that &amp;lsquo;A&amp;rsquo; becomes an instantiated namespace, for example by including a variable declaration in &amp;lsquo;A&amp;rsquo;, the import statement in &amp;lsquo;B&amp;rsquo; above would be an error because the expression &amp;lsquo;A&amp;rsquo; doesn&amp;rsquo;t reference the namespace instance of namespace &amp;lsquo;A&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;When an import statement includes an export modifier, all meanings of the local alias are exported.&lt;/p&gt;

&lt;h2 id=&#34;a-name-10-4-10-4-export-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;10.4&#34;/&gt;10.4 Export Declarations&lt;/h2&gt;

&lt;p&gt;An export declaration declares an externally accessible namespace member. An export declaration is simply a regular declaration prefixed with the keyword &lt;code&gt;export&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The members of a namespace&amp;rsquo;s export declaration space (section &lt;a href=&#34;#2.3&#34;&gt;2.3&lt;/a&gt;) constitute the namespace&amp;rsquo;s &lt;strong&gt;&lt;em&gt;export member set&lt;/em&gt;&lt;/strong&gt;. A namespace&amp;rsquo;s &lt;strong&gt;&lt;em&gt;instance type&lt;/em&gt;&lt;/strong&gt; is an object type with a property for each member in the namespace&amp;rsquo;s export member set that denotes a value.&lt;/p&gt;

&lt;p&gt;An exported member depends on a (possibly empty) set of named types (section &lt;a href=&#34;#3.7&#34;&gt;3.7&lt;/a&gt;). Those named types must be at least as accessible as the exported member, or otherwise an error occurs.&lt;/p&gt;

&lt;p&gt;The named types upon which a member depends are the named types occurring in the transitive closure of the &lt;strong&gt;&lt;em&gt;directly depends on&lt;/em&gt;&lt;/strong&gt; relationship defined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A variable directly depends on the &lt;em&gt;Type&lt;/em&gt; specified in its type annotation.&lt;/li&gt;
&lt;li&gt;A function directly depends on each &lt;em&gt;Type&lt;/em&gt; specified in a parameter or return type annotation.&lt;/li&gt;
&lt;li&gt;A class directly depends on each &lt;em&gt;Type&lt;/em&gt; specified as a type parameter constraint, each &lt;em&gt;TypeReference&lt;/em&gt; specified as a base class or implemented interface, and each &lt;em&gt;Type&lt;/em&gt; specified in a constructor parameter type annotation, public member variable type annotation, public member function parameter or return type annotation, public member accessor parameter or return type annotation, or index signature type annotation.&lt;/li&gt;
&lt;li&gt;An interface directly depends on each &lt;em&gt;Type&lt;/em&gt; specified as a type parameter constraint, each &lt;em&gt;TypeReference&lt;/em&gt; specified as a base interface, and the &lt;em&gt;ObjectType&lt;/em&gt; specified as its body.&lt;/li&gt;
&lt;li&gt;A namespace directly depends on its exported members.&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;Type&lt;/em&gt; or &lt;em&gt;ObjectType&lt;/em&gt; directly depends on every &lt;em&gt;TypeReference&lt;/em&gt; that occurs within the type at any level of nesting.&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;TypeReference&lt;/em&gt; directly depends on the type it references and on each &lt;em&gt;Type&lt;/em&gt; specified as a type argument.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A named type &lt;em&gt;T&lt;/em&gt; having a root namespace &lt;em&gt;R&lt;/em&gt; (section &lt;a href=&#34;#2.3&#34;&gt;2.3&lt;/a&gt;) is said to be &lt;strong&gt;&lt;em&gt;at least as accessible as&lt;/em&gt;&lt;/strong&gt; a member &lt;em&gt;M&lt;/em&gt; if&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;R&lt;/em&gt; is the global namespace or a module, or&lt;/li&gt;
&lt;li&gt;&lt;em&gt;R&lt;/em&gt; is a namespace in the parent namespace chain of &lt;em&gt;M&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface A { x: string; }

namespace M {  
    export interface B { x: A; }  
    export interface C { x: B; }  
    export function foo(c: C) { … }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the &amp;lsquo;foo&amp;rsquo; function depends upon the named types &amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, and &amp;lsquo;C&amp;rsquo;. In order to export &amp;lsquo;foo&amp;rsquo; it is necessary to also export &amp;lsquo;B&amp;rsquo; and &amp;lsquo;C&amp;rsquo; as they otherwise would not be at least as accessible as &amp;lsquo;foo&amp;rsquo;. The &amp;lsquo;A&amp;rsquo; interface is already at least as accessible as &amp;lsquo;foo&amp;rsquo; because I t is declared in a parent namespace of foo&amp;rsquo;s namespace.&lt;/p&gt;

&lt;h2 id=&#34;a-name-10-5-10-5-declaration-merging:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;10.5&#34;/&gt;10.5 Declaration Merging&lt;/h2&gt;

&lt;p&gt;Namespaces are &amp;ldquo;open-ended&amp;rdquo; and namespace declarations with the same qualified name relative to a common root (as defined in section &lt;a href=&#34;#2.3&#34;&gt;2.3&lt;/a&gt;) contribute to a single namespace. For example, the following two declarations of a namespace &amp;lsquo;outer&amp;rsquo; might be located in separate source files.&lt;/p&gt;

&lt;p&gt;File a.ts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;namespace outer {  
    var local = 1;           // Non-exported local variable  
    export var a = local;    // outer.a  
    export namespace inner {  
        export var x = 10;   // outer.inner.x  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File b.ts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;namespace outer {  
    var local = 2;           // Non-exported local variable  
    export var b = local;    // outer.b  
    export namespace inner {  
        export var y = 20;   // outer.inner.y  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming the two source files are part of the same program, the two declarations will have the global namespace as their common root and will therefore contribute to the same namespace instance, the instance type of which will be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;{  
    a: number;  
    b: number;  
    inner: {  
        x: number;  
        y: number;  
    };  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declaration merging does not apply to local aliases created by import alias declarations. In other words, it is not possible have an import alias declaration and a namespace declaration for the same name within the same namespace body.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: Clarify rules for &lt;a href=&#34;https://github.com/Microsoft/TypeScript/issues/3158&#34;&gt;alias resolution&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Declaration merging also extends to namespace declarations with the same qualified name relative to a common root as a function, class, or enum declaration:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When merging a function and a namespace, the type of the function object is merged with the instance type of the namespace. In effect, the overloads or implementation of the function provide the call signatures and the exported members of the namespace provide the properties of the combined type.&lt;/li&gt;
&lt;li&gt;When merging a class and a namespace, the type of the constructor function object is merged with the instance type of the namespace. In effect, the overloads or implementation of the class constructor provide the construct signatures, and the static members of the class and exported members of the namespace provide the properties of the combined type. It is an error to have static class members and exported namespace members with the same name.&lt;/li&gt;
&lt;li&gt;When merging an enum and a namespace, the type of the enum object is merged with the instance type of the namespace. In effect, the members of the enum and the exported members of the namespace provide the properties of the combined type. It is an error to have enum members and exported namespace members with the same name.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When merging a non-ambient function or class declaration and a non-ambient namespace declaration, the function or class declaration must be located prior to the namespace declaration in the same source file. This ensures that the shared object instance is created as a function object. (While it is possible to add properties to an object after its creation, it is not possible to make an object &amp;ldquo;callable&amp;rdquo; after the fact.)&lt;/p&gt;

&lt;p&gt;The example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Point {  
    x: number;  
    y: number;  
}

function point(x: number, y: number): Point {  
    return { x: x, y: y };  
}

namespace point {  
    export var origin = point(0, 0);  
    export function equals(p1: Point, p2: Point) {  
        return p1.x == p2.x &amp;amp;&amp;amp; p1.y == p2.y;  
    }  
}

var p1 = point(0, 0);  
var p2 = point.origin;  
var b = point.equals(p1, p2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;declares &amp;lsquo;point&amp;rsquo; as a function object with two properties, &amp;lsquo;origin&amp;rsquo; and &amp;lsquo;equals&amp;rsquo;. Note that the namespace declaration for &amp;lsquo;point&amp;rsquo; is located after the function declaration.&lt;/p&gt;

&lt;h2 id=&#34;a-name-10-6-10-6-code-generation:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;10.6&#34;/&gt;10.6 Code Generation&lt;/h2&gt;

&lt;p&gt;A namespace generates JavaScript code that is equivalent to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var &amp;lt;NamespaceName&amp;gt;;  
(function(&amp;lt;NamespaceName&amp;gt;) {  
    &amp;lt;NamespaceStatements&amp;gt;  
})(&amp;lt;NamespaceName&amp;gt;||(&amp;lt;NamespaceName&amp;gt;={}));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;NamespaceName&lt;/em&gt; is the name of the namespace and &lt;em&gt;NamespaceStatements&lt;/em&gt; is the code generated for the statements in the namespace body. The &lt;em&gt;NamespaceName&lt;/em&gt; function parameter may be prefixed with one or more underscore characters to ensure the name is unique within the function body. Note that the entire namespace is emitted as an anonymous function that is immediately executed. This ensures that local variables are in their own lexical environment isolated from the surrounding context. Also note that the generated function doesn&amp;rsquo;t create and return a namespace instance, but rather it extends the existing instance (which may have just been created in the function call). This ensures that namespaces can extend each other.&lt;/p&gt;

&lt;p&gt;An import statement generates code of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var &amp;lt;Alias&amp;gt; = &amp;lt;EntityName&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code is emitted only if the imported entity is referenced as a &lt;em&gt;PrimaryExpression&lt;/em&gt; somewhere in the body of the importing namespace. If an imported entity is referenced only as a &lt;em&gt;TypeName&lt;/em&gt; or &lt;em&gt;NamespaceName&lt;/em&gt;, nothing is emitted. This ensures that types declared in one namespace can be referenced through an import alias in another namespace with no run-time overhead.&lt;/p&gt;

&lt;p&gt;When a variable is exported, all references to the variable in the body of the namespace are replaced with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt;NamespaceName&amp;gt;.&amp;lt;VariableName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This effectively promotes the variable to be a property on the namespace instance and ensures that all references to the variable become references to the property.&lt;/p&gt;

&lt;p&gt;When a function, class, enum, or namespace is exported, the code generated for the entity is followed by an assignment statement of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;&amp;lt;NamespaceName&amp;gt;.&amp;lt;EntityName&amp;gt; = &amp;lt;EntityName&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This copies a reference to the entity into a property on the namespace instance.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-11-11-scripts-and-modules:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11&#34;/&gt;11 Scripts and Modules&lt;/h1&gt;

&lt;p&gt;TypeScript implements support for ECMAScript 2015 modules and supports down-level code generation targeting CommonJS, AMD, and other module systems.&lt;/p&gt;

&lt;h2 id=&#34;a-name-11-1-11-1-programs-and-source-files:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.1&#34;/&gt;11.1 Programs and Source Files&lt;/h2&gt;

&lt;p&gt;A TypeScript &lt;strong&gt;&lt;em&gt;program&lt;/em&gt;&lt;/strong&gt; consists of one or more source files.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;SourceFile:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationSourceFile&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationSourceFile&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationSourceFile:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScript&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModule&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationSourceFile:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScript&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModule&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Source files with extension &amp;lsquo;.ts&amp;rsquo; are &lt;strong&gt;&lt;em&gt;implementation source files&lt;/em&gt;&lt;/strong&gt; containing statements and declarations, and source files with extension &amp;lsquo;.d.ts&amp;rsquo; are &lt;strong&gt;&lt;em&gt;declaration source files&lt;/em&gt;&lt;/strong&gt; containing declarations only.&lt;/p&gt;

&lt;p&gt;Declaration source files are a strict subset of implementation source files and are used to declare the static type information associated with existing JavaScript code in an adjunct manner. They are entirely optional but enable the TypeScript compiler and tools to provide better verification and assistance when integrating existing JavaScript code and libraries in a TypeScript application.&lt;/p&gt;

&lt;p&gt;When a TypeScript program is compiled, all of the program&amp;rsquo;s source files are processed together. Statements and declarations in different source files can depend on each other, possibly in a circular fashion. By default, a JavaScript output file is generated for each implementation source file in a compilation, but no output is generated from declaration source files.&lt;/p&gt;

&lt;h3 id=&#34;a-name-11-1-1-11-1-1-source-files-dependencies:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.1.1&#34;/&gt;11.1.1 Source Files Dependencies&lt;/h3&gt;

&lt;p&gt;The TypeScript compiler automatically determines a source file&amp;rsquo;s dependencies and includes those dependencies in the program being compiled. The determination is made from &amp;ldquo;reference comments&amp;rdquo; and module import declarations as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A comment of the form /// &amp;lt;reference path=&amp;ldquo;…&amp;rdquo;/&amp;gt; that occurs before the first token in a source file adds a dependency on the source file specified in the path argument. The path is resolved relative to the directory of the containing source file.&lt;/li&gt;
&lt;li&gt;A module import declaration that specifies a relative module name (section &lt;a href=&#34;#11.3.1&#34;&gt;11.3.1&lt;/a&gt;) resolves the name relative to the directory of the containing source file. If a source file with the resulting path and file extension &amp;lsquo;.ts&amp;rsquo; exists, that file is added as a dependency. Otherwise, if a source file with the resulting path and file extension &amp;lsquo;.d.ts&amp;rsquo; exists, that file is added as a dependency.&lt;/li&gt;
&lt;li&gt;A module import declaration that specifies a top-level module name (section &lt;a href=&#34;#11.3.1&#34;&gt;11.3.1&lt;/a&gt;) resolves the name in a host dependent manner (typically by resolving the name relative to a module name space root or searching for the name in a series of directories). If a source file with extension &amp;lsquo;.ts&amp;rsquo; or &amp;lsquo;.d.ts&amp;rsquo; corresponding to the reference is located, that file is added as a dependency.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Any files included as dependencies in turn have their references analyzed in a transitive manner until all dependencies have been determined.&lt;/p&gt;

&lt;h2 id=&#34;a-name-11-2-11-2-scripts:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.2&#34;/&gt;11.2 Scripts&lt;/h2&gt;

&lt;p&gt;Source files that contain no module import or export declarations are classified as &lt;strong&gt;&lt;em&gt;scripts&lt;/em&gt;&lt;/strong&gt;. Scripts form the single &lt;strong&gt;&lt;em&gt;global namespace&lt;/em&gt;&lt;/strong&gt; and entities declared in scripts are in scope everywhere in a program.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScript:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScriptElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScriptElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScriptElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScriptElements&lt;/em&gt;&amp;emsp;&lt;em&gt;ImplementationScriptElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScriptElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientModuleDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;Statement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;LexicalDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;GeneratorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScript:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScriptElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScriptElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScriptElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScriptElements&lt;/em&gt;&amp;emsp;&lt;em&gt;DeclarationScriptElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScriptElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientModuleDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The initialization order of the scripts that make up the global namespace ultimately depends on the order in which the generated JavaScript files are loaded at run-time (which, for example, may be controlled by &amp;lt;script/&amp;gt; tags that reference the generated JavaScript files).&lt;/p&gt;

&lt;h2 id=&#34;a-name-11-3-11-3-modules:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3&#34;/&gt;11.3 Modules&lt;/h2&gt;

&lt;p&gt;Source files that contain at least one module import or export declaration are considered separate &lt;strong&gt;&lt;em&gt;modules&lt;/em&gt;&lt;/strong&gt;. Non-exported entities declared in a module are in scope only in that module, but exported entities can be imported into other modules using import declarations.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModule:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModuleElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModuleElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModuleElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModuleElements&lt;/em&gt;&amp;emsp;&lt;em&gt;ImplementationModuleElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModuleElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportRequireDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportImplementationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDefaultImplementationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportListDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportAssignment&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModule:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModuleElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModuleElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModuleElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModuleElements&lt;/em&gt;&amp;emsp;&lt;em&gt;DeclarationModuleElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModuleElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDeclarationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDefaultDeclarationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportListDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportAssignment&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Initialization order of modules is determined by the module loader being used and is not specified by the TypeScript language. However, it is generally the case that non-circularly dependent modules are automatically loaded and initialized in the correct order.&lt;/p&gt;

&lt;p&gt;Modules can additionally be declared using &lt;em&gt;AmbientModuleDeclarations&lt;/em&gt; in declaration scripts that directly specify the module names as string literals. This is described further in section &lt;a href=&#34;#12.2&#34;&gt;12.2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Below is an example of two modules written in separate source files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;// -------- main.ts --------  
import { message } from &amp;quot;./log&amp;quot;;  
message(&amp;quot;hello&amp;quot;);

// -------- log.ts --------  
export function message(s: string) {  
    console.log(s);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The import declaration in the &amp;lsquo;main&amp;rsquo; module references the &amp;lsquo;log&amp;rsquo; module and compiling the &amp;lsquo;main.ts&amp;rsquo; file causes the &amp;lsquo;log.ts&amp;rsquo; file to also be compiled as part of the program.&lt;/p&gt;

&lt;p&gt;TypeScript supports multiple patterns of JavaScript code generation for modules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CommonJS. This format is used by server frameworks such as node.js.&lt;/li&gt;
&lt;li&gt;AMD (Asynchronous Module Definition). This format is used by asynchronous module loaders such as RequireJS.&lt;/li&gt;
&lt;li&gt;UMD (Universal Module Definition). A variation of the AMD format that allows modules to also be loaded by CommonJS loaders.&lt;/li&gt;
&lt;li&gt;System. This format is used to represent ECMAScript 2015 semantics with high fidelity in down-level environments.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The desired module code generation pattern is selected through a compiler option and does not affect the TypeScript source code. Indeed, it is possible to author modules that can be compiled for use both on the server side (e.g. using node.js) and on the client side (using an AMD compliant loader) with no changes to the TypeScript source code.&lt;/p&gt;

&lt;h3 id=&#34;a-name-11-3-1-11-3-1-module-names:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.1&#34;/&gt;11.3.1 Module Names&lt;/h3&gt;

&lt;p&gt;Modules are identified and referenced using module names. The following definition is aligned with that provided in the &lt;a href=&#34;http://www.commonjs.org/specs/modules/1.0/&#34;&gt;CommonJS Modules&lt;/a&gt; 1.0 specification.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A module name is a string of terms delimited by forward slashes.&lt;/li&gt;
&lt;li&gt;Module names may not have file-name extensions like &amp;ldquo;.js&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Module names may be relative or top-level. A module name is relative if the first term is &amp;ldquo;.&amp;rdquo; or &amp;ldquo;..&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Top-level names are resolved off the conceptual module name space root.&lt;/li&gt;
&lt;li&gt;Relative names are resolved relative to the name of the module in which they occur.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For purposes of resolving module references, TypeScript associates a file path with every module. The file path is simply the path of the module&amp;rsquo;s source file without the file extension. For example, a module contained in the source file &amp;lsquo;C:\src\lib\io.ts&amp;rsquo; has the file path &amp;lsquo;C:/src/lib/io&amp;rsquo; and a module contained in the source file &amp;lsquo;C:\src\ui\editor.d.ts&amp;rsquo; has the file path &amp;lsquo;C:/src/ui/editor&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;A module name in an import declaration is resolved as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the import declaration specifies a relative module name, the name is resolved relative to the directory of the referencing module&amp;rsquo;s file path. The program must contain a module with the resulting file path or otherwise an error occurs. For example, in a module with the file path &amp;lsquo;C:/src/ui/main&amp;rsquo;, the module names &amp;lsquo;./editor&amp;rsquo; and &amp;lsquo;../lib/io&amp;rsquo; reference modules with the file paths &amp;lsquo;C:/src/ui/editor&amp;rsquo; and &amp;lsquo;C:/src/lib/io&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;If the import declaration specifies a top-level module name and the program contains an &lt;em&gt;AmbientModuleDeclaration&lt;/em&gt; (section &lt;a href=&#34;#12.2&#34;&gt;12.2&lt;/a&gt;) with a string literal that specifies that exact name, then the import declaration references that ambient module.&lt;/li&gt;
&lt;li&gt;If the import declaration specifies a top-level module name and the program contains no &lt;em&gt;AmbientModuleDeclaration&lt;/em&gt; (section &lt;a href=&#34;#12.2&#34;&gt;12.2&lt;/a&gt;) with a string literal that specifies that exact name, the name is resolved in a host dependent manner (for example by considering the name relative to a module name space root). If a matching module cannot be found an error occurs.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;a-name-11-3-2-11-3-2-import-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.2&#34;/&gt;11.3.2 Import Declarations&lt;/h3&gt;

&lt;p&gt;Import declarations are used to import entities from other modules and provide bindings for them in the current module.&lt;/p&gt;

&lt;p&gt;An import declaration of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as m from &amp;quot;mod&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;imports the module with the given name and creates a local binding for the module itself. The local binding is classified as a value (representing the module instance) and a namespace (representing a container of types and namespaces).&lt;/p&gt;

&lt;p&gt;An import declaration of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import { x, y, z } from &amp;quot;mod&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;imports a given module and creates local bindings for a specified list of exported members of the module. The specified names must each reference an entity in the export member set (&lt;a href=&#34;#11.3.4.4&#34;&gt;11.3.4.4&lt;/a&gt;) of the given module. The local bindings have the same names and classifications as the entities they represent unless &lt;code&gt;as&lt;/code&gt; clauses are used to that specify different local names:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import { x as a, y as b } from &amp;quot;mod&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An import declaration of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import d from &amp;quot;mod&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is exactly equivalent to the import declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import { default as d } from &amp;quot;mod&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An import declaration of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import &amp;quot;mod&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;imports the given module without creating any local bindings (this is useful only if the imported module has side effects).&lt;/p&gt;

&lt;h3 id=&#34;a-name-11-3-3-11-3-3-import-require-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.3&#34;/&gt;11.3.3 Import Require Declarations&lt;/h3&gt;

&lt;p&gt;Import require declarations exist for backward compatibility with earlier versions of TypeScript.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImportRequireDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;import&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;=&lt;/code&gt;&amp;emsp;&lt;code&gt;require&lt;/code&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;StringLiteral&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;An import require declaration introduces a local identifier that references a given module. The string literal specified in an import require declaration is interpreted as a module name (section &lt;a href=&#34;#11.3.1&#34;&gt;11.3.1&lt;/a&gt;). The local identifier introduced by the declaration becomes an alias for, and is classified exactly like, the entity exported from the referenced module. Specifically, if the referenced module contains no export assignment the identifier is classified as a value and a namespace, and if the referenced module contains an export assignment the identifier is classified exactly like the entity named in the export assignment.&lt;/p&gt;

&lt;p&gt;An import require declaration of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import m = require(&amp;quot;mod&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to the ECMAScript 2015 import declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as m from &amp;quot;mod&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;provided the referenced module contains no export assignment.&lt;/p&gt;

&lt;h3 id=&#34;a-name-11-3-4-11-3-4-export-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.4&#34;/&gt;11.3.4 Export Declarations&lt;/h3&gt;

&lt;p&gt;An export declaration declares one or more exported module members. The exported members of a module can be imported in other modules using import declarations (&lt;a href=&#34;#11.3.2&#34;&gt;11.3.2&lt;/a&gt;).&lt;/p&gt;

&lt;h4 id=&#34;a-name-11-3-4-1-11-3-4-1-export-modifiers:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.4.1&#34;/&gt;11.3.4.1 Export Modifiers&lt;/h4&gt;

&lt;p&gt;In the body of a module, a declaration can export the declared entity by including an &lt;code&gt;export&lt;/code&gt; modifier.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportImplementationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;VariableStatement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;LexicalDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;GeneratorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;NamespaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDeclarationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In addition to introducing a name in the local declaration space of the module, an exported declaration introduces the same name with the same classification in the module&amp;rsquo;s export declaration space. For example, the declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export function point(x: number, y: number) {  
    return { x, y };  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;introduces a local name &lt;code&gt;point&lt;/code&gt; and an exported name &lt;code&gt;point&lt;/code&gt; that both reference the function.&lt;/p&gt;

&lt;h4 id=&#34;a-name-11-3-4-2-11-3-4-2-export-default-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.4.2&#34;/&gt;11.3.4.2 Export Default Declarations&lt;/h4&gt;

&lt;p&gt;Export default declarations provide short-hand syntax for exporting an entity named &lt;code&gt;default&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDefaultImplementationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;GeneratorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;AssignmentExpression&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDefaultDeclarationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientFunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;ExportDefaultImplementationElement&lt;/em&gt; or &lt;em&gt;ExportDefaultDeclarationElement&lt;/em&gt; for a function, generator, or class introduces a value named &lt;code&gt;default&lt;/code&gt;, and in the case of a class, a type named &lt;code&gt;default&lt;/code&gt;, in the containing module&amp;rsquo;s export declaration space. The declaration may optionally specify a local name for the exported function, generator, or class. For example, the declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export default function point(x: number, y: number) {  
    return { x, y };  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;introduces a local name &lt;code&gt;point&lt;/code&gt; and an exported name &lt;code&gt;default&lt;/code&gt; that both reference the function. The declaration is effectively equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function point(x: number, y: number) {  
    return { x, y };  
}

export default point;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which again is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function point(x: number, y: number) {  
    return { x, y };  
}

export { point as default };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An &lt;em&gt;ExportDefaultImplementationElement&lt;/em&gt; or &lt;em&gt;ExportDefaultDeclarationElement&lt;/em&gt; for an expression consisting of a single identifier must name an entity declared in the current module or the global namespace. The declaration introduces an entity named &lt;code&gt;default&lt;/code&gt;, with the same classification as the referenced entity, in the containing module&amp;rsquo;s export declaration space. For example, the declarations&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;interface Point {  
    x: number;  
    y: number;  
}

function Point(x: number, y: number): Point {  
    return { x, y };  
}

export default Point;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;introduce a local name &lt;code&gt;Point&lt;/code&gt; and an exported name &lt;code&gt;default&lt;/code&gt;, both with a value and a type meaning.&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;ExportDefaultImplementationElement&lt;/em&gt; for any expression but a single identifier introduces a value named &lt;code&gt;default&lt;/code&gt; in the containing module&amp;rsquo;s export declaration space. For example, the declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export default &amp;quot;hello&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;introduces an exported value named &lt;code&gt;default&lt;/code&gt; of type string.&lt;/p&gt;

&lt;h4 id=&#34;a-name-11-3-4-3-11-3-4-3-export-list-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.4.3&#34;/&gt;11.3.4.3 Export List Declarations&lt;/h4&gt;

&lt;p&gt;An export list declaration exports one or more entities from the current module or a specified module.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportListDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;*&lt;/code&gt;&amp;emsp;&lt;em&gt;FromClause&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ExportClause&lt;/em&gt;&amp;emsp;&lt;em&gt;FromClause&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ExportClause&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;ExportListDeclaration&lt;/em&gt; without a &lt;em&gt;FromClause&lt;/em&gt; exports entities from the current module. In a declaration of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export { x };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the name &lt;code&gt;x&lt;/code&gt; must reference an entity declared in the current module or the global namespace, and the declaration introduces an entity with the same name and meaning in the containing module&amp;rsquo;s export declaration space.&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;ExportListDeclaration&lt;/em&gt; with a &lt;em&gt;FromClause&lt;/em&gt; re-exports entities from a specified module. In a declaration of the form&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export { x } from &amp;quot;mod&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the name &lt;code&gt;x&lt;/code&gt; must reference an entity in the export member set of the specified module, and the declaration introduces an entity with the same name and meaning in the containing module&amp;rsquo;s export declaration space. No local bindings are created for &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;ExportClause&lt;/em&gt; of an &lt;em&gt;ExportListDeclaration&lt;/em&gt; can specify multiple entities and may optionally specify different names to be used for the exported entities. For example, the declaration&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export { x, y as b, z as c };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;introduces entities named &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; in the containing module&amp;rsquo;s export declaration space with the same meaning as the local entities named &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;ExportListDeclaration&lt;/em&gt; that specifies &lt;code&gt;*&lt;/code&gt; instead of an &lt;em&gt;ExportClause&lt;/em&gt; is called an &lt;strong&gt;&lt;em&gt;export star&lt;/em&gt;&lt;/strong&gt; declaration. An export star declaration re-exports all members of a specified module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export * from &amp;quot;mod&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explicitly exported members take precedence over members re-exported using export star declarations, as described in the following section.&lt;/p&gt;

&lt;h4 id=&#34;a-name-11-3-4-4-11-3-4-4-export-member-set:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.4.4&#34;/&gt;11.3.4.4 Export Member Set&lt;/h4&gt;

&lt;p&gt;The &lt;strong&gt;&lt;em&gt;export member set&lt;/em&gt;&lt;/strong&gt; of a particular module is determined by starting with an empty set of members &lt;em&gt;E&lt;/em&gt; and an empty set of processed modules &lt;em&gt;P&lt;/em&gt;, and then processing the module as described below to form the full set of exported members in &lt;em&gt;E&lt;/em&gt;. Processing a module &lt;em&gt;M&lt;/em&gt; consists of these steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add &lt;em&gt;M&lt;/em&gt; to &lt;em&gt;P&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Add to &lt;em&gt;E&lt;/em&gt; each member in the export declaration space of &lt;em&gt;M&lt;/em&gt; with a name that isn&amp;rsquo;t already in &lt;em&gt;E&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;For each export star declaration in &lt;em&gt;M&lt;/em&gt;, in order of declaration, process the referenced module if it is not already in &lt;em&gt;P&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A module&amp;rsquo;s &lt;strong&gt;&lt;em&gt;instance type&lt;/em&gt;&lt;/strong&gt; is an object type with a property for each member in the module&amp;rsquo;s export member set that denotes a value.&lt;/p&gt;

&lt;p&gt;If a module contains an export assignment it is an error for the module to also contain export declarations. The two types of exports are mutually exclusive.&lt;/p&gt;

&lt;h3 id=&#34;a-name-11-3-5-11-3-5-export-assignments:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.5&#34;/&gt;11.3.5 Export Assignments&lt;/h3&gt;

&lt;p&gt;Export assignments exist for backward compatibility with earlier versions of TypeScript. An export assignment designates a module member as the entity to be exported in place of the module itself.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportAssignment:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;=&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A module containing an export assignment can be imported using an import require declaration (&lt;a href=&#34;#11.3.3&#34;&gt;11.3.3&lt;/a&gt;), and the local alias introduced by the import require declaration then takes on all meanings of the identifier named in the export assignment.&lt;/p&gt;

&lt;p&gt;A module containing an export assignment can also be imported using a regular import declaration (&lt;a href=&#34;#11.3.2&#34;&gt;11.3.2&lt;/a&gt;) provided the entity referenced in the export assignment is declared as a namespace or as a variable with a type annotation.&lt;/p&gt;

&lt;p&gt;Assume the following example resides in the file &amp;lsquo;point.ts&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export = Point;

class Point {  
    constructor(public x: number, public y: number) { }  
    static origin = new Point(0, 0);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &amp;lsquo;point.ts&amp;rsquo; is imported in another module, the import alias references the exported class and can be used both as a type and as a constructor function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import Pt = require(&amp;quot;./point&amp;quot;);

var p1 = new Pt(10, 20);  
var p2 = Pt.origin;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that there is no requirement that the import alias use the same name as the exported entity.&lt;/p&gt;

&lt;h3 id=&#34;a-name-11-3-6-11-3-6-commonjs-modules:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.6&#34;/&gt;11.3.6 CommonJS Modules&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.commonjs.org/specs/modules/1.0/&#34;&gt;CommonJS Modules&lt;/a&gt; definition specifies a methodology for writing JavaScript modules with implied privacy, the ability to import other modules, and the ability to explicitly export members. A CommonJS compliant system provides a &amp;lsquo;require&amp;rsquo; function that can be used to synchronously load other modules to obtain their singleton module instance, as well as an &amp;lsquo;exports&amp;rsquo; variable to which a module can add properties to define its external API.&lt;/p&gt;

&lt;p&gt;The &amp;lsquo;main&amp;rsquo; and &amp;lsquo;log&amp;rsquo; example from section &lt;a href=&#34;#11.3&#34;&gt;11.3&lt;/a&gt; above generates the following JavaScript code when compiled for the CommonJS Modules pattern:&lt;/p&gt;

&lt;p&gt;File main.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var log_1 = require(&amp;quot;./log&amp;quot;);  
log_1.message(&amp;quot;hello&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File log.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;function message(s) {  
    console.log(s);  
}  
exports.message = message;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A module import declaration is represented in the generated JavaScript as a variable initialized by a call to the &amp;lsquo;require&amp;rsquo; function provided by the module system host. A variable declaration and &amp;lsquo;require&amp;rsquo; call is emitted for a particular imported module only if the imported module, or a local alias (section &lt;a href=&#34;#10.3&#34;&gt;10.3&lt;/a&gt;) that references the imported module, is referenced as a &lt;em&gt;PrimaryExpression&lt;/em&gt; somewhere in the body of the importing module. If an imported module is referenced only as a &lt;em&gt;NamespaceName&lt;/em&gt; or &lt;em&gt;TypeQueryExpression&lt;/em&gt;, nothing is emitted.&lt;/p&gt;

&lt;p&gt;An example:&lt;/p&gt;

&lt;p&gt;File geometry.ts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export interface Point { x: number; y: number };

export function point(x: number, y: number): Point {  
    return { x, y };  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File game.ts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as g from &amp;quot;./geometry&amp;quot;;  
let p = g.point(10, 20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;lsquo;game&amp;rsquo; module references the imported &amp;lsquo;geometry&amp;rsquo; module in an expression (through its alias &amp;lsquo;g&amp;rsquo;) and a &amp;lsquo;require&amp;rsquo; call is therefore included in the emitted JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var g = require(&amp;quot;./geometry&amp;quot;);  
var p = g.point(10, 20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Had the &amp;lsquo;game&amp;rsquo; module instead been written to only reference &amp;lsquo;geometry&amp;rsquo; in a type position&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;import * as g from &amp;quot;./geometry&amp;quot;;  
let p: g.Point = { x: 10, y: 20 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the emitted JavaScript would have no dependency on the &amp;lsquo;geometry&amp;rsquo; module and would simply be&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;var p = { x: 10, y: 20 };
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-name-11-3-7-11-3-7-amd-modules:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;11.3.7&#34;/&gt;11.3.7 AMD Modules&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/amdjs/amdjs-api/wiki/AMD&#34;&gt;Asynchronous Module Definition&lt;/a&gt; (AMD) specification extends the CommonJS Modules specification with a pattern for authoring asynchronously loadable modules with associated dependencies. Using the AMD pattern, modules are emitted as calls to a global &amp;lsquo;define&amp;rsquo; function taking an array of dependencies, specified as module names, and a callback function containing the module body. The global &amp;lsquo;define&amp;rsquo; function is provided by including an AMD compliant loader in the application. The loader arranges to asynchronously load the module&amp;rsquo;s dependencies and, upon completion, calls the callback function passing resolved module instances as arguments in the order they were listed in the dependency array.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;main&amp;rdquo; and &amp;ldquo;log&amp;rdquo; example from above generates the following JavaScript code when compiled for the AMD pattern.&lt;/p&gt;

&lt;p&gt;File main.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;define([&amp;quot;require&amp;quot;, &amp;quot;exports&amp;quot;, &amp;quot;./log&amp;quot;], function(require, exports, log_1) {  
    log_1.message(&amp;quot;hello&amp;quot;);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;File log.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;define([&amp;quot;require&amp;quot;, &amp;quot;exports&amp;quot;], function(require, exports) {  
    function message(s) {  
        console.log(s);  
    }  
    exports.message = message;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The special &amp;lsquo;require&amp;rsquo; and &amp;lsquo;exports&amp;rsquo; dependencies are always present. Additional entries are added to the dependencies array and the parameter list as required to represent imported modules. Similar to the code generation for CommonJS Modules, a dependency entry is generated for a particular imported module only if the imported module is referenced as a &lt;em&gt;PrimaryExpression&lt;/em&gt; somewhere in the body of the importing module. If an imported module is referenced only as a &lt;em&gt;NamespaceName&lt;/em&gt;, no dependency is generated for that module.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-12-12-ambients:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;12&#34;/&gt;12 Ambients&lt;/h1&gt;

&lt;p&gt;Ambient declarations are used to provide static typing over existing JavaScript code. Ambient declarations differ from regular declarations in that no JavaScript code is emitted for them. Instead of introducing new variables, functions, classes, enums, or namespaces, ambient declarations provide type information for entities that exist &amp;ldquo;ambiently&amp;rdquo; and are included in a program by external means, for example by referencing a JavaScript library in a &amp;lt;script/&amp;gt; tag.&lt;/p&gt;

&lt;h2 id=&#34;a-name-12-1-12-1-ambient-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;12.1&#34;/&gt;12.1 Ambient Declarations&lt;/h2&gt;

&lt;p&gt;Ambient declarations are written using the &lt;code&gt;declare&lt;/code&gt; keyword and can declare variables, functions, classes, enums, namespaces, or modules.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientVariableDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientFunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientEnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientNamespaceDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-12-1-1-12-1-1-ambient-variable-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;12.1.1&#34;/&gt;12.1.1 Ambient Variable Declarations&lt;/h3&gt;

&lt;p&gt;An ambient variable declaration introduces a variable in the containing declaration space.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientVariableDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;var&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientBindingList&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;let&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientBindingList&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;const&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientBindingList&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientBindingList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientBinding&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientBindingList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientBinding&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientBinding:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;An ambient variable declaration may optionally include a type annotation. If no type annotation is present, the variable is assumed to have type Any.&lt;/p&gt;

&lt;p&gt;An ambient variable declaration does not permit an initializer expression to be present.&lt;/p&gt;

&lt;h3 id=&#34;a-name-12-1-2-12-1-2-ambient-function-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;12.1.2&#34;/&gt;12.1.2 Ambient Function Declarations&lt;/h3&gt;

&lt;p&gt;An ambient function declaration introduces a function in the containing declaration space.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientFunctionDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;function&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ambient functions may be overloaded by specifying multiple ambient function declarations with the same name, but it is an error to declare multiple overloads that are considered identical (section &lt;a href=&#34;#3.11.2&#34;&gt;3.11.2&lt;/a&gt;) or differ only in their return types.&lt;/p&gt;

&lt;p&gt;Ambient function declarations cannot specify a function bodies and do not permit default parameter values.&lt;/p&gt;

&lt;h3 id=&#34;a-name-12-1-3-12-1-3-ambient-class-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;12.1.3&#34;/&gt;12.1.3 Ambient Class Declarations&lt;/h3&gt;

&lt;p&gt;An ambient class declaration declares a class type and a constructor function in the containing declaration space.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;class&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;ClassHeritage&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientClassBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBody:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBodyElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBodyElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBodyElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBodyElements&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientClassBodyElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBodyElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientConstructorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientPropertyMemberDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IndexSignature&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientConstructorDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;constructor&lt;/code&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientPropertyMemberDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-name-12-1-4-12-1-4-ambient-enum-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;12.1.4&#34;/&gt;12.1.4 Ambient Enum Declarations&lt;/h3&gt;

&lt;p&gt;An ambient enum is grammatically equivalent to a non-ambient enum declaration.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientEnumDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ambient enum declarations differ from non-ambient enum declarations in two ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In ambient enum declarations, all values specified in enum member declarations must be classified as constant enum expressions.&lt;/li&gt;
&lt;li&gt;In ambient enum declarations that specify no &lt;code&gt;const&lt;/code&gt; modifier, enum member declarations that omit a value are considered computed members (as opposed to having auto-incremented values assigned).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ambient enum declarations are otherwise processed in the same manner as non-ambient enum declarations.&lt;/p&gt;

&lt;h3 id=&#34;a-name-12-1-5-12-1-5-ambient-namespace-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;12.1.5&#34;/&gt;12.1.5 Ambient Namespace Declarations&lt;/h3&gt;

&lt;p&gt;An ambient namespace declaration declares a namespace.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;namespace&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierPath&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientNamespaceBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceBody:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceElements&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientNamespaceElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientVariableDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientLexicalDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientFunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientEnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientNamespaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Except for &lt;em&gt;ImportAliasDeclarations&lt;/em&gt;, &lt;em&gt;AmbientNamespaceElements&lt;/em&gt; always declare exported entities regardless of whether they include the optional &lt;code&gt;export&lt;/code&gt; modifier.&lt;/p&gt;

&lt;h2 id=&#34;a-name-12-2-12-2-ambient-module-declarations:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;12.2&#34;/&gt;12.2 Ambient Module Declarations&lt;/h2&gt;

&lt;p&gt;An &lt;em&gt;AmbientModuleDeclaration&lt;/em&gt; declares a module. This type of declaration is permitted only at the top level in a source file that contributes to the global namespace (section &lt;a href=&#34;#11.1&#34;&gt;11.1&lt;/a&gt;). The &lt;em&gt;StringLiteral&lt;/em&gt; must specify a top-level module name. Relative module names are not permitted.&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientModuleDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;code&gt;module&lt;/code&gt;&amp;emsp;&lt;em&gt;StringLiteral&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp; &lt;em&gt;DeclarationModule&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;ImportRequireDeclaration&lt;/em&gt; in an &lt;em&gt;AmbientModuleDeclaration&lt;/em&gt; may reference other modules only through top-level module names. Relative module names are not permitted.&lt;/p&gt;

&lt;p&gt;If an ambient module declaration includes an export assignment, it is an error for any of the declarations within the module to specify an &lt;code&gt;export&lt;/code&gt; modifier. If an ambient module declaration contains no export assignment, entities declared in the module are exported regardless of whether their declarations include the optional &lt;code&gt;export&lt;/code&gt; modifier.&lt;/p&gt;

&lt;p&gt;Ambient modules are &amp;ldquo;open-ended&amp;rdquo; and ambient module declarations with the same string literal name contribute to a single module. For example, the following two declarations of a module &amp;lsquo;io&amp;rsquo; might be located in separate source files.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;declare module &amp;quot;io&amp;quot; {  
    export function readFile(filename: string): string;  
}

declare module &amp;quot;io&amp;quot; {  
    export function writeFile(filename: string, data: string): void;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This has the same effect as a single combined declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;declare module &amp;quot;io&amp;quot; {  
    export function readFile(filename: string): string;  
    export function writeFile(filename: string, data: string): void;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h1 id=&#34;a-name-a-a-grammar:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A&#34;/&gt;A Grammar&lt;/h1&gt;

&lt;p&gt;This appendix contains a summary of the grammar found in the main document. As described in section &lt;a href=&#34;#2.1&#34;&gt;2.1&lt;/a&gt;, the TypeScript grammar is a superset of the grammar defined in the &lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/&#34;&gt;ECMAScript 2015 Language Specification&lt;/a&gt; (specifically, the ECMA-262 Standard, 6th Edition) and this appendix lists only productions that are new or modified from the ECMAScript grammar.&lt;/p&gt;

&lt;h2 id=&#34;a-name-a-1-a-1-types:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A.1&#34;/&gt;A.1 Types&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameters:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;&amp;lt;&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameterList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeParameter&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameter:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;Constraint&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;Constraint:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;extends&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArguments:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;&amp;lt;&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeArgumentList&lt;/em&gt;&amp;emsp;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArgumentList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArgument&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArgumentList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeArgument&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArgument:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;Type:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;UnionOrIntersectionOrPrimaryType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructorType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;UnionOrIntersectionOrPrimaryType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;UnionType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IntersectionOrPrimaryType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;IntersectionOrPrimaryType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IntersectionType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PrimaryType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PrimaryType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ParenthesizedType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PredefinedType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeReference&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ObjectType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ArrayType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TupleType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeQuery&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ThisType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ParenthesizedType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PredefinedType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;any&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;number&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;boolean&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;string&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;symbol&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;void&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeReference:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeName&lt;/em&gt;&amp;emsp;&lt;em&gt;[no LineTerminator here]&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeArguments&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeName:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceName&lt;/em&gt;&amp;emsp;&lt;code&gt;.&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceName:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceName&lt;/em&gt;&amp;emsp;&lt;code&gt;.&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ObjectType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeBody&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeBody:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMemberList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMember&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeMember&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeMember&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeMember:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertySignature&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructSignature&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IndexSignature&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;MethodSignature&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ArrayType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PrimaryType&lt;/em&gt;&amp;emsp;&lt;em&gt;[no LineTerminator here]&lt;/em&gt;&amp;emsp;&lt;code&gt;[&lt;/code&gt;&amp;emsp;&lt;code&gt;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TupleType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;[&lt;/code&gt;&amp;emsp;&lt;em&gt;TupleElementTypes&lt;/em&gt;&amp;emsp;&lt;code&gt;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TupleElementTypes:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TupleElementType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TupleElementTypes&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;TupleElementType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TupleElementType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;UnionType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;UnionOrIntersectionOrPrimaryType&lt;/em&gt;&amp;emsp;&lt;code&gt;|&lt;/code&gt;&amp;emsp;&lt;em&gt;IntersectionOrPrimaryType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;IntersectionType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IntersectionOrPrimaryType&lt;/em&gt;&amp;emsp;&lt;code&gt;&amp;amp;&lt;/code&gt;&amp;emsp;&lt;em&gt;PrimaryType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructorType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;new&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeQuery:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;typeof&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeQueryExpression&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeQueryExpression:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeQueryExpression&lt;/em&gt;&amp;emsp;&lt;code&gt;.&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierName&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ThisType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;this&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PropertySignature:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;code&gt;?&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierName&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;StringLiteral&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NumericLiteral&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAnnotation:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;CallSignature:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ParameterList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameterList&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RestParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;OptionalParameterList&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;RestParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;RestParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;OptionalParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;RestParameter&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;RequiredParameter&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;RequiredParameter:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;BindingIdentifierOrPattern&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;em&gt;StringLiteral&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;public&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;private&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;protected&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifierOrPattern:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingPattern&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameterList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameter&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameterList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;OptionalParameter&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;OptionalParameter:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;BindingIdentifierOrPattern&lt;/em&gt;&amp;emsp;&lt;code&gt;?&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;BindingIdentifierOrPattern&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;?&lt;/code&gt;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;em&gt;StringLiteral&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;RestParameter:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;...&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructSignature:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;new&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;IndexSignature:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;[&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;code&gt;string&lt;/code&gt;&amp;emsp;&lt;code&gt;]&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;[&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;code&gt;number&lt;/code&gt;&amp;emsp;&lt;code&gt;]&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;MethodSignature:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;code&gt;?&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;type&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;=&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-name-a-2-a-2-expressions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A.2&#34;/&gt;A.2 Expressions&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyDefinition:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;CoverInitializedName&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;code&gt;:&lt;/code&gt;&amp;emsp;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;GetAccessor&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;SetAccessor&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;GetAccessor:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;get&lt;/code&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;SetAccessor:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;set&lt;/code&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifierOrPattern&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionExpression:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;function&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ArrowFormalParameters:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;Arguments:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeArguments&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ArgumentList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;UnaryExpression:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;…&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;&amp;lt;&lt;/code&gt;&amp;emsp;&lt;em&gt;Type&lt;/em&gt;&amp;emsp;&lt;code&gt;&amp;gt;&lt;/code&gt;&amp;emsp;&lt;em&gt;UnaryExpression&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-name-a-3-a-3-statements:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A.3&#34;/&gt;A.3 Statements&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;Declaration:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;…&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;VariableDeclaration:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;SimpleVariableDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DestructuringVariableDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;SimpleVariableDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DestructuringVariableDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingPattern&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;LexicalBinding:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;SimpleLexicalBinding&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DestructuringLexicalBinding&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;SimpleLexicalBinding:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DestructuringLexicalBinding:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingPattern&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-name-a-4-a-4-functions:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A.4&#34;/&gt;A.4 Functions&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionDeclaration:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;function&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;function&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-name-a-5-a-5-interfaces:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A.5&#34;/&gt;A.5 Interfaces&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;interface&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;InterfaceExtendsClause&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;ObjectType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceExtendsClause:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;extends&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassOrInterfaceTypeList&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassOrInterfaceTypeList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ClassOrInterfaceType&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ClassOrInterfaceTypeList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassOrInterfaceType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassOrInterfaceType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeReference&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-name-a-6-a-6-classes:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A.6&#34;/&gt;A.6 Classes&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassDeclaration:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;class&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;ClassHeritage&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassHeritage:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ClassExtendsClause&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;ImplementsClause&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassExtendsClause:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;extends&lt;/code&gt;&amp;emsp; &lt;em&gt;ClassType&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassType:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeReference&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementsClause:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;implements&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassOrInterfaceTypeList&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ClassElement:&lt;/em&gt;  &lt;em&gt;( Modified )&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyMemberDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IndexMemberDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ConstructorDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;constructor&lt;/code&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;constructor&lt;/code&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyMemberDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;MemberVariableDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;MemberFunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;MemberAccessorDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;MemberVariableDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;Initializer&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;MemberFunctionDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;MemberAccessorDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;GetAccessor&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;SetAccessor&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;IndexMemberDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IndexSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-name-a-7-a-7-enums:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A.7&#34;/&gt;A.7 Enums&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;const&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;enum&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;EnumBody&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EnumBody:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EnumMemberList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumMember&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumMemberList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;EnumMember&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EnumMember:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;=&amp;emsp;&lt;em&gt;EnumValue&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EnumValue:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AssignmentExpression&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-name-a-8-a-8-namespaces:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A.8&#34;/&gt;A.8 Namespaces&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;namespace&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierPath&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;NamespaceBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierPath:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IdentifierPath&lt;/em&gt;&amp;emsp;&lt;code&gt;.&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceBody:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceElements&lt;/em&gt;&amp;emsp;&lt;em&gt;NamespaceElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;Statement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;LexicalDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;GeneratorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceDeclaration&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;AmbientDeclaration&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;ImportAliasDeclaration&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;ExportNamespaceElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportNamespaceElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;VariableStatement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;LexicalDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;GeneratorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;NamespaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImportAliasDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;import&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;=&lt;/code&gt;&amp;emsp;&lt;em&gt;EntityName&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;EntityName:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceName&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceName&lt;/em&gt;&amp;emsp;&lt;code&gt;.&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-name-a-9-a-9-scripts-and-modules:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A.9&#34;/&gt;A.9 Scripts and Modules&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;SourceFile:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationSourceFile&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationSourceFile&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationSourceFile:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScript&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModule&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationSourceFile:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScript&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModule&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScript:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScriptElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScriptElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScriptElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScriptElements&lt;/em&gt;&amp;emsp;&lt;em&gt;ImplementationScriptElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationScriptElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientModuleDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;Statement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;LexicalDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;FunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;GeneratorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScript:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScriptElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScriptElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScriptElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScriptElements&lt;/em&gt;&amp;emsp;&lt;em&gt;DeclarationScriptElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationScriptElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientModuleDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;NamespaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModule:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModuleElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModuleElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModuleElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModuleElements&lt;/em&gt;&amp;emsp;&lt;em&gt;ImplementationModuleElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationModuleElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImplementationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportRequireDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportImplementationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDefaultImplementationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportListDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportAssignment&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModule:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModuleElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModuleElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModuleElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModuleElements&lt;/em&gt;&amp;emsp;&lt;em&gt;DeclarationModuleElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationModuleElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;DeclarationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDeclarationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDefaultDeclarationElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportListDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;ExportAssignment&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ImportRequireDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;import&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;code&gt;=&lt;/code&gt;&amp;emsp;&lt;code&gt;require&lt;/code&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;StringLiteral&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportImplementationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;VariableStatement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;LexicalDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;GeneratorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;NamespaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDeclarationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;TypeAliasDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDefaultImplementationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;FunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;GeneratorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;ClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;AssignmentExpression&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportDefaultDeclarationElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientFunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;default&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportListDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;*&lt;/code&gt;&amp;emsp;&lt;em&gt;FromClause&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ExportClause&lt;/em&gt;&amp;emsp;&lt;em&gt;FromClause&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;em&gt;ExportClause&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;ExportAssignment:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&amp;emsp;&lt;code&gt;=&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierReference&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-name-a-10-a-10-ambients:11c61217b547eb355969114f07ce6b46&#34;&gt;&lt;a name=&#34;A.10&#34;/&gt;A.10 Ambients&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientVariableDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientFunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientEnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientNamespaceDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientVariableDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;var&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientBindingList&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;let&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientBindingList&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;const&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientBindingList&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientBindingList:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientBinding&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientBindingList&lt;/em&gt;&amp;emsp;&lt;code&gt;,&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientBinding&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientBinding:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientFunctionDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;function&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;class&lt;/code&gt;&amp;emsp;&lt;em&gt;BindingIdentifier&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeParameters&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;ClassHeritage&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientClassBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBody:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBodyElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBodyElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBodyElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBodyElements&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientClassBodyElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientClassBodyElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientConstructorDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientPropertyMemberDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;IndexSignature&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientConstructorDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;constructor&lt;/code&gt;&amp;emsp;&lt;code&gt;(&lt;/code&gt;&amp;emsp;&lt;em&gt;ParameterList&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;)&lt;/code&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientPropertyMemberDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;TypeAnnotation&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AccessibilityModifier&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;code&gt;static&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;PropertyName&lt;/em&gt;&amp;emsp;&lt;em&gt;CallSignature&lt;/em&gt;&amp;emsp;&lt;code&gt;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientEnumDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;EnumDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;namespace&lt;/code&gt;&amp;emsp;&lt;em&gt;IdentifierPath&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp;&lt;em&gt;AmbientNamespaceBody&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceBody:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceElements&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceElements:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceElement&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceElements&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientNamespaceElement&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientNamespaceElement:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientVariableDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientLexicalDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientFunctionDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientClassDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;InterfaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientEnumDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;AmbientNamespaceDeclaration&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;export&lt;/code&gt;&lt;em&gt;&lt;sub&gt;opt&lt;/sub&gt;&lt;/em&gt;&amp;emsp;&lt;em&gt;ImportAliasDeclaration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;AmbientModuleDeclaration:&lt;/em&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&amp;emsp;&lt;code&gt;declare&lt;/code&gt;&amp;emsp;&lt;code&gt;module&lt;/code&gt;&amp;emsp;&lt;em&gt;StringLiteral&lt;/em&gt;&amp;emsp;&lt;code&gt;{&lt;/code&gt;&amp;emsp; &lt;em&gt;DeclarationModule&lt;/em&gt;&amp;emsp;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Make:Makefile</title>
      <link>http://alimy.me/post/dev_201601241856/</link>
      <pubDate>Sun, 24 Jan 2016 00:00:00 UTC</pubDate>
      
      <guid>http://alimy.me/post/dev_201601241856/</guid>
      <description>

&lt;h3 id=&#34;sect-概述:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;概述&lt;/h3&gt;

&lt;p&gt;什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。&lt;/p&gt;

&lt;p&gt;因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。&lt;/p&gt;

&lt;p&gt;makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。&lt;/p&gt;

&lt;p&gt;现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。&lt;/p&gt;

&lt;p&gt;在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。&lt;/p&gt;

&lt;h3 id=&#34;sect-关于程序的编译和链接:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;关于程序的编译和链接&lt;/h3&gt;

&lt;p&gt;在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。&lt;/p&gt;

&lt;p&gt;编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。&lt;/p&gt;

&lt;p&gt;链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。&lt;/p&gt;

&lt;p&gt;总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.&lt;/p&gt;

&lt;p&gt;好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。&lt;/p&gt;

&lt;h3 id=&#34;sect-makefile-介绍:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;Makefile 介绍&lt;/h3&gt;

&lt;p&gt;make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。&lt;/p&gt;

&lt;p&gt;首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：
    1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。
    2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。
    3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。&lt;/p&gt;

&lt;p&gt;只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。&lt;/p&gt;

&lt;h4 id=&#34;makefile的规则:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;Makefile的规则&lt;/h4&gt;

&lt;p&gt;在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      target ... : prerequisites ...
              command
              ...
              ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;prerequisites就是，要生成那个target所需要的文件或是目标。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;command也就是make需要执行的命令。（任意的Shell命令）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。&lt;/p&gt;

&lt;p&gt;说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）&lt;/p&gt;

&lt;h4 id=&#34;一个示例:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;一个示例&lt;/h4&gt;

&lt;p&gt;正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;edit : main.o kbd.o command.o display.o /
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o /
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o /
           insert.o search.o files.o utils.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;反斜杠（/）是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。&lt;/p&gt;

&lt;p&gt;在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。&lt;/p&gt;

&lt;p&gt;在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。&lt;/p&gt;

&lt;p&gt;这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。&lt;/p&gt;

&lt;h4 id=&#34;make是如何工作的:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;make是如何工作的&lt;/h4&gt;

&lt;p&gt;在默认的方式下，也就是我们只输入make命令。那么，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;make会在当前目录下找名字叫“Makefile”或“makefile”的文件。&lt;/li&gt;
&lt;li&gt;如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。&lt;/li&gt;
&lt;li&gt;如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。&lt;/li&gt;
&lt;li&gt;如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）&lt;/li&gt;
&lt;li&gt;当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。&lt;/p&gt;

&lt;p&gt;通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。&lt;/p&gt;

&lt;p&gt;于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。&lt;/p&gt;

&lt;p&gt;而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。&lt;/p&gt;

&lt;h4 id=&#34;makefile中使用变量:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;makefile中使用变量&lt;/h4&gt;

&lt;p&gt;在上面的例子中，先让我们看看edit的规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  edit : main.o kbd.o command.o display.o /
              insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o /
                   insert.o search.o files.o utils.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。&lt;/p&gt;

&lt;p&gt;比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; objects = main.o kbd.o command.o display.o /
          insert.o search.o files.o utils.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objects = main.o kbd.o command.o display.o /
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。&lt;/p&gt;

&lt;p&gt;关于变量更多的话题，我会在后续给你一一道来。&lt;/p&gt;

&lt;h4 id=&#34;让make自动推导:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;让make自动推导&lt;/h4&gt;

&lt;p&gt;GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。&lt;/p&gt;

&lt;p&gt;只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objects = main.o kbd.o command.o display.o /
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
        rm edit $(objects)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。&lt;/p&gt;

&lt;p&gt;关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。&lt;/p&gt;

&lt;h4 id=&#34;另类风格的makefile:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;另类风格的makefile&lt;/h4&gt;

&lt;p&gt;即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objects = main.o kbd.o command.o display.o /
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h

.PHONY : clean
clean :
        rm edit $(objects)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。&lt;/p&gt;

&lt;h4 id=&#34;清空目标文件的规则:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;清空目标文件的规则&lt;/h4&gt;

&lt;p&gt;每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    clean:
        rm edit $(objects)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更为稳健的做法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    .PHONY : clean
    clean :
            -rm edit $(objects)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。&lt;/p&gt;

&lt;p&gt;上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。&lt;/p&gt;

&lt;h3 id=&#34;sect-makefile-总述:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;Makefile 总述&lt;/h3&gt;

&lt;h4 id=&#34;makefile里有什么:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;Makefile里有什么？&lt;/h4&gt;

&lt;p&gt;Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。&lt;/p&gt;

&lt;p&gt;1、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。&lt;/p&gt;

&lt;p&gt;2、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。&lt;/p&gt;

&lt;p&gt;3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;/p&gt;

&lt;p&gt;4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。&lt;/p&gt;

&lt;p&gt;5、注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“/#”。&lt;/p&gt;

&lt;p&gt;最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。&lt;/p&gt;

&lt;h4 id=&#34;makefile的文件名:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;Makefile的文件名&lt;/h4&gt;

&lt;p&gt;默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。&lt;/p&gt;

&lt;p&gt;当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“&amp;ndash;file”参数，如：make -f Make.Linux或make &amp;ndash;file Make.AIX。&lt;/p&gt;

&lt;h4 id=&#34;引用其它的makefile:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;引用其它的Makefile&lt;/h4&gt;

&lt;p&gt;在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;include &amp;lt;filename&amp;gt;

filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和&lt;filename&gt;可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;include foo.make *.mk $(bar)

等价于：

include foo.make a.mk b.mk c.mk e.mk f.mk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。
2、如果目录&amp;lt;prefix&amp;gt;/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-include &amp;lt;filename&amp;gt;
其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;环境变量-makefiles:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;环境变量 MAKEFILES&lt;/h4&gt;

&lt;p&gt;如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。&lt;/p&gt;

&lt;p&gt;但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。&lt;/p&gt;

&lt;h4 id=&#34;make的工作方式:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;make的工作方式&lt;/h4&gt;

&lt;p&gt;GNU的make工作时的执行步骤入下：（想来其它的make也是类似）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、读入所有的Makefile。
2、读入被include的其它Makefile。
3、初始化文件中的变量。
4、推导隐晦规则，并分析所有规则。
5、为所有的目标文件创建依赖关系链。
6、根据依赖关系，决定哪些目标要重新生成。
7、执行生成命令。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。&lt;/p&gt;

&lt;p&gt;当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。&lt;/p&gt;

&lt;h3 id=&#34;sect-书写规则:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;书写规则&lt;/h3&gt;

&lt;p&gt;规则包含两个部分，一个是依赖关系，一个是生成目标的方法。&lt;/p&gt;

&lt;p&gt;在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。&lt;/p&gt;

&lt;p&gt;好了，还是让我们来看一看如何书写规则。&lt;/p&gt;

&lt;h4 id=&#34;规则举例:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;规则举例&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;foo.o : foo.c defs.h       # foo模块
        cc -c -g foo.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。
2、如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;规则的语法:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;规则的语法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  targets : prerequisites
    command
    ...

  或是这样：

  targets : prerequisites ; command
        command
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。&lt;/p&gt;

&lt;p&gt;command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）&lt;/p&gt;

&lt;p&gt;prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。&lt;/p&gt;

&lt;p&gt;如果命令太长，你可以使用反斜框（‘/’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。&lt;/p&gt;

&lt;p&gt;一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。&lt;/p&gt;

&lt;h4 id=&#34;在规则中使用通配符:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;在规则中使用通配符&lt;/h4&gt;

&lt;p&gt;如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“*”，“?”和“[&amp;hellip;]”。这是和Unix的B-Shell是相同的。&lt;/p&gt;

&lt;p&gt;波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。&lt;/p&gt;

&lt;p&gt;通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“*”，那么可以用转义字符“/”，如“/*”来表示真实的“*”字符，而不是任意长度的字符串。&lt;/p&gt;

&lt;p&gt;好吧，还是先来看几个例子吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clean:
     rm -f *.o

上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。

print: *.c
     lpr -p $?
     touch print

上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。

objects = *.o

上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：

objects := $(wildcard *.o)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。&lt;/p&gt;

&lt;h4 id=&#34;文件搜寻:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;文件搜寻&lt;/h4&gt;

&lt;p&gt;在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。&lt;/p&gt;

&lt;p&gt;Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VPATH = src:../headers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）&lt;/p&gt;

&lt;p&gt;另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、vpath &amp;lt;pattern&amp;gt; &amp;lt;directories&amp;gt;

为符合模式&amp;lt;pattern&amp;gt;的文件指定搜索目录&amp;lt;directories&amp;gt;。

2、vpath &amp;lt;pattern&amp;gt;

清除符合模式&amp;lt;pattern&amp;gt;的文件的搜索目录。

3、vpath

清除所有已被设置好了的文件搜索目录。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vapth使用方法中的&lt;pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。&lt;pattern&gt;指定了要搜索的文件集，而&lt;directories&gt;则指定了&lt;pattern&gt;的文件集的搜索的目录。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vpath %.h ../headers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）&lt;/p&gt;

&lt;p&gt;我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt;pattern&gt;，或是被重复了的&lt;pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vpath %.c foo
vpath %   blish
vpath %.c bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vpath %.c foo:bar
vpath %   blish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。&lt;/p&gt;

&lt;h4 id=&#34;伪目标:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;伪目标&lt;/h4&gt;

&lt;p&gt;最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clean:
        rm *.o temp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）&lt;/p&gt;

&lt;p&gt;因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。&lt;/p&gt;

&lt;p&gt;当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.PHONY : clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; .PHONY: clean
clean:
        rm *.o temp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;all : prog1 prog2 prog3
.PHONY : all

prog1 : prog1.o utils.o
        cc -o prog1 prog1.o utils.o

prog2 : prog2.o
        cc -o prog2 prog2.o

prog3 : prog3.o sort.o utils.o
        cc -o prog3 prog3.o sort.o utils.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。&lt;/p&gt;

&lt;p&gt;随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.PHONY: cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff
        rm program

cleanobj :
        rm *.o

cleandiff :
        rm *.diff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“make clean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。&lt;/p&gt;

&lt;h4 id=&#34;多目标:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;多目标&lt;/h4&gt;

&lt;p&gt;Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bigoutput littleoutput : text.g
        generate text.g -$(subst output,,$@) &amp;gt; $@

上述规则等价于：

bigoutput : text.g
        generate text.g -big &amp;gt; bigoutput
littleoutput : text.g
        generate text.g -little &amp;gt; littleoutput

其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;静态模式:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;静态模式&lt;/h4&gt;

&lt;p&gt;静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;targets ...&amp;gt;: &amp;lt;target-pattern&amp;gt;: &amp;lt;prereq-patterns ...&amp;gt;
        &amp;lt;commands&amp;gt;
        ...


targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。

target-parrtern是指明了targets的模式，也就是的目标集模式。

prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的&lt;target-parrtern&gt;定义成“%.o”，意思是我们的&lt;target&gt;集合中都是以“.o”结尾的，而如果我们的&lt;prereq-parrterns&gt;定义成“%.c”，意思是对&lt;target-parrtern&gt;所形成的目标集进行二次定义，其计算方法是，取&lt;target-parrtern&gt;模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。&lt;/p&gt;

&lt;p&gt;所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“/”进行转义，来标明真实的“%”字符。&lt;/p&gt;

&lt;p&gt;看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
        $(CC) -c $(CFLAGS) $&amp;lt; -o $@
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$&amp;lt;”和“$@”则是自动化变量，“$&amp;lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo.o : foo.c
        $(CC) -c $(CFLAGS) foo.c -o foo.o
bar.o : bar.c
        $(CC) -c $(CFLAGS) bar.c -o bar.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;files = foo.elc bar.o lose.o

$(filter %.o,$(files)): %.o: %.c
        $(CC) -c $(CFLAGS) $&amp;lt; -o $@
$(filter %.elc,$(files)): %.elc: %.el
        emacs -f batch-byte-compile $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。&lt;/p&gt;

&lt;h4 id=&#34;自动生成依赖性:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;自动生成依赖性&lt;/h4&gt;

&lt;p&gt;在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include &amp;ldquo;defs.h&amp;rdquo;”，那么我们的依赖关系应该是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.o : main.c defs.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cc -M main.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其输出是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.o : main.c defs.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -M main.c的输出是：

main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h /
     /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h /
     /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h /
     /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h /
     /usr/include/bits/sched.h /usr/include/libio.h /
     /usr/include/_G_config.h /usr/include/wchar.h /
     /usr/include/bits/wchar.h /usr/include/gconv.h /
     /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h /
     /usr/include/bits/stdio_lim.h


gcc -MM main.c的输出则是：

main.o: main.c defs.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。&lt;/p&gt;

&lt;p&gt;于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。&lt;/p&gt;

&lt;p&gt;这里，我们给出了一个模式规则来产生[.d]文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%.d: %.c
        @set -e; rm -f $@; /
         $(CC) -M $(CPPFLAGS) $&amp;lt; &amp;gt; $@.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;; /
             sed &amp;rsquo;s,/($&lt;em&gt;/)/.o[ :]&lt;/em&gt;,/1.o $@ : ,g&amp;rsquo; &amp;lt; $@.
&amp;gt; $@; /
             rm -f $@.&lt;/p&gt;

&lt;p&gt;这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&amp;lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，“
”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。&lt;/p&gt;

&lt;p&gt;总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.o : main.c defs.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main.o main.d : main.c defs.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sources = foo.c bar.c

include $(sources:.c=.d)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。&lt;/p&gt;

&lt;h3 id=&#34;sect-书写命令:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;书写命令&lt;/h3&gt;

&lt;p&gt;每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。&lt;/p&gt;

&lt;p&gt;我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。&lt;/p&gt;

&lt;h4 id=&#34;显示命令:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;显示命令&lt;/h4&gt;

&lt;p&gt;通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@echo 正在编译XXX模块......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当make执行时，会输出“正在编译XXX模块&amp;hellip;&amp;hellip;”字串，但不会输出命令，如果没有“@”，那么，make将输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo 正在编译XXX模块......
正在编译XXX模块......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果make执行时，带入make参数“-n”或“&amp;ndash;just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。&lt;/p&gt;

&lt;p&gt;而make参数“-s”或“&amp;ndash;slient”则是全面禁止命令的显示。&lt;/p&gt;

&lt;h4 id=&#34;命令执行:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;命令执行&lt;/h4&gt;

&lt;p&gt;当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例一：
    exec:
            cd /home/hchen
            pwd

示例二：
    exec:
            cd /home/hchen; pwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。&lt;/p&gt;

&lt;p&gt;make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。&lt;/p&gt;

&lt;h4 id=&#34;命令出错:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;命令出错&lt;/h4&gt;

&lt;p&gt;每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。&lt;/p&gt;

&lt;p&gt;有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。&lt;/p&gt;

&lt;p&gt;为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：&lt;/p&gt;

&lt;p&gt;clean:
            -rm -f *.o&lt;/p&gt;

&lt;p&gt;还有一个全局的办法是，给make加上“-i”或是“&amp;ndash;ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。&lt;/p&gt;

&lt;p&gt;还有一个要提一下的make的参数的是“-k”或是“&amp;ndash;keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。&lt;/p&gt;

&lt;h4 id=&#34;嵌套执行make:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;嵌套执行make&lt;/h4&gt;

&lt;p&gt;在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。&lt;/p&gt;

&lt;p&gt;例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subsystem:
        cd subdir &amp;amp;&amp;amp; $(MAKE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其等价于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subsystem:
        $(MAKE) -C subdir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。&lt;/p&gt;

&lt;p&gt;我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。&lt;/p&gt;

&lt;p&gt;如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export &amp;lt;variable ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unexport &amp;lt;variable ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例一：

    export variable = value

    其等价于：

    variable = value
    export variable

    其等价于：

    export variable := value

    其等价于：

    variable := value
    export variable

示例二：

    export variable += value

    其等价于：

    variable += value
    export variable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。&lt;/p&gt;

&lt;p&gt;需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。&lt;/p&gt;

&lt;p&gt;但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subsystem:
        cd subdir &amp;amp;&amp;amp; $(MAKE) MAKEFLAGS=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。&lt;/p&gt;

&lt;p&gt;还有一个在“嵌套执行”中比较有用的参数，“-w”或是“&amp;ndash;print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make: Entering directory `/home/hchen/gnu/make&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在完成下层make后离开目录时，我们会看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make: Leaving directory `/home/hchen/gnu/make&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“&amp;ndash;slient”）或是“&amp;ndash;no-print-directory”，那么，“-w”总是失效的。&lt;/p&gt;

&lt;h4 id=&#34;定义命令包:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;定义命令包&lt;/h4&gt;

&lt;p&gt;如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo.c : foo.y
        $(run-yacc)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。&lt;/p&gt;

&lt;h3 id=&#34;sect-使用变量:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;使用变量&lt;/h3&gt;

&lt;p&gt;在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是Makefile的其它部分中。&lt;/p&gt;

&lt;p&gt;变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。&lt;/p&gt;

&lt;p&gt;有一些变量是很奇怪字串，如“$&amp;lt;”、“$@”等，这些是自动化变量，我会在后面介绍。&lt;/p&gt;

&lt;h4 id=&#34;变量的基础:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;变量的基础&lt;/h4&gt;

&lt;p&gt;变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。&lt;/p&gt;

&lt;p&gt;变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objects = program.o foo.o utils.o
program : $(objects)
        cc -o program $(objects)

$(objects) : defs.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo = c
prog.o : prog.$(foo)
        $(foo)$(foo) -$(foo) prog.$(foo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;展开后得到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prog.o : prog.c
        cc -c prog.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。&lt;/p&gt;

&lt;p&gt;另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。&lt;/p&gt;

&lt;h4 id=&#34;变量中的变量:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;变量中的变量&lt;/h4&gt;

&lt;p&gt;在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。&lt;/p&gt;

&lt;p&gt;先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo = $(bar)
bar = $(ugh)
ugh = Huh?

all:
        echo $(foo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。&lt;/p&gt;

&lt;p&gt;这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CFLAGS = $(include_dirs) -O
include_dirs = -Ifoo -Ibar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CFLAGS = $(CFLAGS) -O

或：

A = $(B)
B = $(A)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。&lt;/p&gt;

&lt;p&gt;为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x := foo
y := $(x) bar
x := later
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其等价于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;y := foo bar
x := later
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;y := $(x) bar
x := foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，y的值是“bar”，而不是“foo bar”。&lt;/p&gt;

&lt;p&gt;上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifeq (0,${MAKELEVEL})
cur-dir   := $(shell pwd)
whoami    := $(shell whoami)
host-type := $(shell arch)
MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。&lt;/p&gt;

&lt;p&gt;下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nullstring :=
space := $(nullstring) # end of the line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dir := /foo/bar    # directory to put the frobs in
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。&lt;/p&gt;

&lt;p&gt;还有一个比较有用的操作符是“?=”，先看示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FOO ?= bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifeq ($(origin FOO), undefined)
  FOO = bar
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;变量高级用法:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;变量高级用法&lt;/h4&gt;

&lt;p&gt;这里介绍两种变量的高级使用方法，第一种是变量值的替换。&lt;/p&gt;

&lt;p&gt;我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。&lt;/p&gt;

&lt;p&gt;还是看一个示例吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo := a.o b.o c.o
bar := $(foo:.o=.c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。&lt;/p&gt;

&lt;p&gt;另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo := a.o b.o c.o
bar := $(foo:%.o=%.c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。&lt;/p&gt;

&lt;p&gt;第二种高级用法是——“把变量的值再当成变量”。先看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = y
y = z
a := $($(x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）&lt;/p&gt;

&lt;p&gt;我们还可以使用更多的层次：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = y
y = z
z = u
a := $($($(x)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。&lt;/p&gt;

&lt;p&gt;让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = $(y)
y = z
z = Hello
a := $($(x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是：a:=$(z)，也就是“Hello”。&lt;/p&gt;

&lt;p&gt;再复杂一点，我们再加上函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = variable1
variable2 := Hello
y = $(subst 1,2,$(x))
z = y
a := $($($(z)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值——“Hello”。（喔，好不容易）&lt;/p&gt;

&lt;p&gt;在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;first_second = Hello
a = first
b = second
all = $($a_$b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的“$a_$b”组成了“first_second”，于是，$(all)的值就是“Hello”。&lt;/p&gt;

&lt;p&gt;再来看看结合第一种技术的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a_objects := a.o b.o c.o
1_objects := 1.o 2.o 3.o

sources := $($(a1)_objects:.o=.c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。&lt;/p&gt;

&lt;p&gt;再来看一个这种技术和“函数”与“条件语句”一同使用的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifdef do_sort
func := sort
else
func := strip
endif

bar := a d b g q c

foo := $($(func) $(bar))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个示例中，如果定义了“do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d b g q c)，调用的就是strip函数。&lt;/p&gt;

&lt;p&gt;当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dir = foo
$(dir)_sources := $(wildcard $(dir)/*.c)
define $(dir)_print
lpr $($(dir)_sources)
endef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。&lt;/p&gt;

&lt;h4 id=&#34;追加变量值:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;追加变量值&lt;/h4&gt;

&lt;p&gt;我们可以使用“+=”操作符给变量追加值，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objects = main.o foo.o bar.o utils.o
objects += another.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）&lt;/p&gt;

&lt;p&gt;使用“+=”操作符，可以模拟为下面的这种例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objects = main.o foo.o bar.o utils.o
objects := $(objects) another.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所不同的是，用“+=”更为简洁。&lt;/p&gt;

&lt;p&gt;如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;variable := value
variable += more
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;variable := value
variable := $(variable) more
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但如果是这种情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;variable = value
variable += more
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。&lt;/p&gt;

&lt;p&gt;五、override 指示符&lt;/p&gt;

&lt;p&gt;如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override &amp;lt;variable&amp;gt; = &amp;lt;value&amp;gt;

override &amp;lt;variable&amp;gt; := &amp;lt;value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你还可以追加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override &amp;lt;variable&amp;gt; += &amp;lt;more text&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override define foo
bar
endef
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;多行变量:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;多行变量&lt;/h4&gt;

&lt;p&gt;还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。&lt;/p&gt;

&lt;p&gt;define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。&lt;/p&gt;

&lt;p&gt;下面的这个示例展示了define的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define two-lines
echo foo
echo $(bar)
endef
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;环境变量:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;环境变量&lt;/h4&gt;

&lt;p&gt;make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）&lt;/p&gt;

&lt;p&gt;因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。&lt;/p&gt;

&lt;p&gt;当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）&lt;/p&gt;

&lt;p&gt;当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。&lt;/p&gt;

&lt;h4 id=&#34;目标变量:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;目标变量&lt;/h4&gt;

&lt;p&gt;前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&amp;lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。&lt;/p&gt;

&lt;p&gt;当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。&lt;/p&gt;

&lt;p&gt;其语法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;target ...&amp;gt; : &amp;lt;variable-assignment&amp;gt;

&amp;lt;target ...&amp;gt; : overide &amp;lt;variable-assignment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;variable-assignment&gt;可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。&lt;/p&gt;

&lt;p&gt;这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prog : CFLAGS = -g
prog : prog.o foo.o bar.o
        $(CC) $(CFLAGS) prog.o foo.o bar.o

prog.o : prog.c
        $(CC) $(CFLAGS) prog.c

foo.o : foo.c
        $(CC) $(CFLAGS) foo.c

bar.o : bar.c
        $(CC) $(CFLAGS) bar.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”&lt;/p&gt;

&lt;h4 id=&#34;模式变量:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;模式变量&lt;/h4&gt;

&lt;p&gt;在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。&lt;/p&gt;

&lt;p&gt;我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%.o : CFLAGS = -O
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，模式变量的语法和“目标变量”一样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;pattern ...&amp;gt; : &amp;lt;variable-assignment&amp;gt;

&amp;lt;pattern ...&amp;gt; : override &amp;lt;variable-assignment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;override同样是针对于系统环境传入的变量，或是make命令行指定的变量。&lt;/p&gt;

&lt;h3 id=&#34;sect-使用条件判断:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;使用条件判断&lt;/h3&gt;

&lt;p&gt;使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。&lt;/p&gt;

&lt;h4 id=&#34;示例:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;示例&lt;/h4&gt;

&lt;p&gt;下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
        $(CC) -o foo $(objects) $(libs_for_gcc)
else
        $(CC) -o foo $(objects) $(normal_libs)
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。&lt;/p&gt;

&lt;p&gt;我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。&lt;/p&gt;

&lt;p&gt;当我们的变量$(CC)值是“gcc”时，目标foo的规则是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo: $(objects)
        $(CC) -o foo $(objects) $(libs_for_gcc)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo: $(objects)
        $(CC) -o foo $(objects) $(normal_libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，我们还可以把上面的那个例子写得更简洁一些：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;libs_for_gcc = -lgnu
normal_libs =

ifeq ($(CC),gcc)
  libs=$(libs_for_gcc)
else
  libs=$(normal_libs)
endif

foo: $(objects)
        $(CC) -o foo $(objects) $(libs)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;语法:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;语法&lt;/h4&gt;

&lt;p&gt;条件表达式的语法为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;conditional-directive&amp;gt;
&amp;lt;text-if-true&amp;gt;
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;conditional-directive&amp;gt;
&amp;lt;text-if-true&amp;gt;
else
&amp;lt;text-if-false&amp;gt;
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;conditional-directive&gt;表示条件关键字，如“ifeq”。这个关键字有四个。&lt;/p&gt;

&lt;p&gt;第一个是我们前面所见过的“ifeq”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifeq (&amp;lt;arg1&amp;gt;, &amp;lt;arg2&amp;gt;)
ifeq &#39;&amp;lt;arg1&amp;gt;&#39; &#39;&amp;lt;arg2&amp;gt;&#39;
ifeq &amp;quot;&amp;lt;arg1&amp;gt;&amp;quot; &amp;quot;&amp;lt;arg2&amp;gt;&amp;quot;
ifeq &amp;quot;&amp;lt;arg1&amp;gt;&amp;quot; &#39;&amp;lt;arg2&amp;gt;&#39;
ifeq &#39;&amp;lt;arg1&amp;gt;&#39; &amp;quot;&amp;lt;arg2&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifeq ($(strip $(foo)),)
&amp;lt;text-if-empty&amp;gt;
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么&lt;text-if-empty&gt;就生效。&lt;/p&gt;

&lt;p&gt;第二个条件关键字是“ifneq”。语法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifneq (&amp;lt;arg1&amp;gt;, &amp;lt;arg2&amp;gt;)
ifneq &#39;&amp;lt;arg1&amp;gt;&#39; &#39;&amp;lt;arg2&amp;gt;&#39;
ifneq &amp;quot;&amp;lt;arg1&amp;gt;&amp;quot; &amp;quot;&amp;lt;arg2&amp;gt;&amp;quot;
ifneq &amp;quot;&amp;lt;arg1&amp;gt;&amp;quot; &#39;&amp;lt;arg2&amp;gt;&#39;
ifneq &#39;&amp;lt;arg1&amp;gt;&#39; &amp;quot;&amp;lt;arg2&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。&lt;/p&gt;

&lt;p&gt;第三个条件关键字是“ifdef”。语法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifdef &amp;lt;variable-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果变量&lt;variable-name&gt;的值非空，那到表达式为真。否则，表达式为假。当然，&lt;variable-name&gt;同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;示例一：
bar =
foo = $(bar)
ifdef foo
frobozz = yes
else
frobozz = no
endif

示例二：
foo =
ifdef foo
frobozz = yes
else
frobozz = no
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。&lt;/p&gt;

&lt;p&gt;第四个条件关键字是“ifndef”。其语法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifndef &amp;lt;variable-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个我就不多说了，和“ifdef”是相反的意思。&lt;/p&gt;

&lt;p&gt;在&lt;conditional-directive&gt;这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以[Tab]键开始就行了。&lt;/p&gt;

&lt;p&gt;特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。&lt;/p&gt;

&lt;p&gt;而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。&lt;/p&gt;

&lt;h3 id=&#34;sect-使用函数:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;使用函数&lt;/h3&gt;

&lt;p&gt;在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。&lt;/p&gt;

&lt;h4 id=&#34;函数的调用语法:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;函数的调用语法&lt;/h4&gt;

&lt;p&gt;函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&amp;lt;function&amp;gt; &amp;lt;arguments&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${&amp;lt;function&amp;gt; &amp;lt;arguments&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，&lt;function&gt;就是函数名，make支持的函数不多。&lt;arguments&gt;是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。&lt;/p&gt;

&lt;p&gt;还是来看一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”。&lt;/p&gt;

&lt;h4 id=&#34;字符串处理函数:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;字符串处理函数&lt;/h4&gt;

&lt;p&gt;$(subst &amp;lt;from&amp;gt;,&amp;lt;to&amp;gt;,&amp;lt;text&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：字符串替换函数——subst。
功能：把字串&amp;lt;text&amp;gt;中的&amp;lt;from&amp;gt;字符串替换成&amp;lt;to&amp;gt;。
返回：函数返回被替换过后的字符串。

示例：

    $(subst ee,EE,feet on the street)，

    把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(patsubst&amp;lt;pattern&amp;gt;,&amp;lt;replacement&amp;gt;,&amp;lt;text&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：模式字符串替换函数——patsubst。
功能：查找&amp;lt;text&amp;gt;中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式&amp;lt;pattern&amp;gt;，如果匹配的话，则以&amp;lt;replacement&amp;gt;替换。这里，&amp;lt;pattern&amp;gt;可以包括通配符“%”，表示任意长度的字串。如果&amp;lt;replacement&amp;gt;中也包含“%”，那么，&amp;lt;replacement&amp;gt;中的这个“%”将是&amp;lt;pattern&amp;gt;中的那个“%”所代表的字串。（可以用“/”来转义，以“/%”来表示真实含义的“%”字符）
返回：函数返回被替换过后的字符串。

示例：

    $(patsubst %.c,%.o,x.c.c bar.c)

    把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”

备注：

    这和我们前面“变量章节”说过的相关知识有点相似。如：

    “$(var:&amp;lt;pattern&amp;gt;=&amp;lt;replacement&amp;gt;)”
     相当于
    “$(patsubst &amp;lt;pattern&amp;gt;,&amp;lt;replacement&amp;gt;,$(var))”，

     而“$(var: &amp;lt;suffix&amp;gt;=&amp;lt;replacement&amp;gt;)”
     则相当于
     “$(patsubst %&amp;lt;suffix&amp;gt;,%&amp;lt;replacement&amp;gt;,$(var))”。

     例如有：objects = foo.o bar.o baz.o，
     那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(strip &amp;lt;string&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：去空格函数——strip。
功能：去掉&amp;lt;string&amp;gt;字串中开头和结尾的空字符。
返回：返回被去掉空格的字符串值。
示例：

    $(strip a b c )

    把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(findstring &amp;lt;find&amp;gt;,&amp;lt;in&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：查找字符串函数——findstring。
功能：在字串&amp;lt;in&amp;gt;中查找&amp;lt;find&amp;gt;字串。
返回：如果找到，那么返回&amp;lt;find&amp;gt;，否则返回空字符串。
示例：

    $(findstring a,a b c)
    $(findstring a,b c)

    第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(filter &amp;lt;pattern&amp;hellip;&amp;gt;,&amp;lt;text&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：过滤函数——filter。
功能：以&amp;lt;pattern&amp;gt;模式过滤&amp;lt;text&amp;gt;字符串中的单词，保留符合模式&amp;lt;pattern&amp;gt;的单词。可以有多个模式。
返回：返回符合模式&amp;lt;pattern&amp;gt;的字串。
示例：

    sources := foo.c bar.c baz.s ugh.h
    foo: $(sources)
            cc $(filter %.c %.s,$(sources)) -o foo

    $(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(filter-out &amp;lt;pattern&amp;hellip;&amp;gt;,&amp;lt;text&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：反过滤函数——filter-out。
功能：以&amp;lt;pattern&amp;gt;模式过滤&amp;lt;text&amp;gt;字符串中的单词，去除符合模式&amp;lt;pattern&amp;gt;的单词。可以有多个模式。
返回：返回不符合模式&amp;lt;pattern&amp;gt;的字串。
示例：

    objects=main1.o foo.o main2.o bar.o
    mains=main1.o main2.o

    $(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(sort &amp;lt;list&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：排序函数——sort。
功能：给字符串&amp;lt;list&amp;gt;中的单词排序（升序）。
返回：返回排序后的字符串。
示例：$(sort foo bar lose)返回“bar foo lose” 。
备注：sort函数会去掉&amp;lt;list&amp;gt;中相同的单词。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(word &amp;lt;n&amp;gt;,&amp;lt;text&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：取单词函数——word。
功能：取字符串&amp;lt;text&amp;gt;中第&amp;lt;n&amp;gt;个单词。（从一开始）
返回：返回字符串&amp;lt;text&amp;gt;中第&amp;lt;n&amp;gt;个单词。如果&amp;lt;n&amp;gt;比&amp;lt;text&amp;gt;中的单词数要大，那么返回空字符串。
示例：$(word 2, foo bar baz)返回值是“bar”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(wordlist &amp;lt;s&amp;gt;,&amp;lt;e&amp;gt;,&amp;lt;text&amp;gt; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：取单词串函数——wordlist。
功能：从字符串&amp;lt;text&amp;gt;中取从&amp;lt;s&amp;gt;开始到&amp;lt;e&amp;gt;的单词串。&amp;lt;s&amp;gt;和&amp;lt;e&amp;gt;是一个数字。
返回：返回字符串&amp;lt;text&amp;gt;中从&amp;lt;s&amp;gt;到&amp;lt;e&amp;gt;的单词字串。如果&amp;lt;s&amp;gt;比&amp;lt;text&amp;gt;中的单词数要大，那么返回空字符串。如果&amp;lt;e&amp;gt;大于&amp;lt;text&amp;gt;的单词数，那么返回从&amp;lt;s&amp;gt;开始，到&amp;lt;text&amp;gt;结束的单词串。
示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(words &amp;lt;text&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：单词个数统计函数——words。
功能：统计&amp;lt;text&amp;gt;中字符串中的单词个数。
返回：返回&amp;lt;text&amp;gt;中的单词数。
示例：$(words, foo bar baz)返回值是“3”。
备注：如果我们要取&amp;lt;text&amp;gt;中最后的一个单词，我们可以这样：$(word $(words &amp;lt;text&amp;gt;),&amp;lt;text&amp;gt;)。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(firstword &amp;lt;text&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：首单词函数——firstword。
功能：取字符串&amp;lt;text&amp;gt;中的第一个单词。
返回：返回字符串&amp;lt;text&amp;gt;的第一个单词。
示例：$(firstword foo bar)返回值是“foo”。
备注：这个函数可以用word函数来实现：$(word 1,&amp;lt;text&amp;gt;)。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))

如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;文件名操作函数:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;文件名操作函数&lt;/h4&gt;

&lt;p&gt;下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。&lt;/p&gt;

&lt;p&gt;$(dir &amp;lt;names&amp;hellip;&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：取目录函数——dir。
功能：从文件名序列&amp;lt;names&amp;gt;中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。
返回：返回文件名序列&amp;lt;names&amp;gt;的目录部分。
示例： $(dir src/foo.c hacks)返回值是“src/ ./”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(notdir &amp;lt;names&amp;hellip;&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：取文件函数——notdir。
功能：从文件名序列&amp;lt;names&amp;gt;中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。
返回：返回文件名序列&amp;lt;names&amp;gt;的非目录部分。
示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(suffix &amp;lt;names&amp;hellip;&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：取后缀函数——suffix。
功能：从文件名序列&amp;lt;names&amp;gt;中取出各个文件名的后缀。
返回：返回文件名序列&amp;lt;names&amp;gt;的后缀序列，如果文件没有后缀，则返回空字串。
示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(basename &amp;lt;names&amp;hellip;&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：取前缀函数——basename。
功能：从文件名序列&amp;lt;names&amp;gt;中取出各个文件名的前缀部分。
返回：返回文件名序列&amp;lt;names&amp;gt;的前缀序列，如果文件没有前缀，则返回空字串。
示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar hacks”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(addsuffix &amp;lt;suffix&amp;gt;,&amp;lt;names&amp;hellip;&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：加后缀函数——addsuffix。
功能：把后缀&amp;amp;lt;suffix&amp;gt;加到&amp;amp;lt;names&amp;gt;中的每个单词后面。
返回：返回加过后缀的文件名序列。
示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(addprefix &amp;lt;prefix&amp;gt;,&amp;lt;names&amp;hellip;&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：加前缀函数——addprefix。
功能：把前缀&amp;amp;lt;prefix&amp;gt;加到&amp;amp;lt;names&amp;gt;中的每个单词后面。
返回：返回加过前缀的文件名序列。
示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(join &amp;lt;list1&amp;gt;,&amp;lt;list2&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;名称：连接函数——join。
功能：把&amp;amp;lt;list2&amp;gt;中的单词对应地加到&amp;amp;lt;list1&amp;gt;的单词后面。如果&amp;amp;lt;list1&amp;gt;的单词个数要比&amp;lt;list2&amp;gt;的多，那么，&amp;amp;lt;list1&amp;gt;中的多出来的单词将保持原样。如果&amp;amp;lt;list2&amp;gt;的单词个数要比&amp;amp;lt;list1&amp;gt;多，那么，&amp;amp;lt;list2&amp;gt;多出来的单词将被复制到&amp;amp;lt;list2&amp;gt;中。
返回：返回连接过后的字符串。
示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;foreach-函数:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;foreach 函数&lt;/h4&gt;

&lt;p&gt;foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(foreach &amp;amp;lt;var&amp;gt;,&amp;amp;lt;list&amp;gt;,&amp;amp;lt;text&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数的意思是，把参数&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中，然后再执行&lt;text&gt;所包含的表达式。每一次&lt;text&gt;会返回一个字符串，循环过程中，&lt;text&gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。&lt;/p&gt;

&lt;p&gt;所以，&lt;var&gt;最好是一个变量名，&lt;list&gt;可以是一个表达式，而&lt;text&gt;中一般会使用&lt;var&gt;这个参数来依次枚举&lt;list&gt;中的单词。举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;names := a b c d
files := $(foreach n,$(names),$(n).o)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。&lt;/p&gt;

&lt;p&gt;注意，foreach中的&lt;var&gt;参数是一个临时的局部变量，foreach函数执行完后，参数&lt;var&gt;的变量将不在作用，其作用域只在foreach函数当中。&lt;/p&gt;

&lt;h4 id=&#34;if-函数:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;if 函数&lt;/h4&gt;

&lt;p&gt;if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(if &amp;amp;lt;condition&amp;gt;,&amp;amp;lt;then-part&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(if &amp;amp;lt;condition&amp;gt;,&amp;amp;lt;then-part&amp;gt;,&amp;amp;lt;else-part&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。&lt;condition&gt;参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，&lt;then-part&gt;会被计算，否则&lt;else-part&gt;会被计算。&lt;/p&gt;

&lt;p&gt;而if函数的返回值是，如果&amp;lt;condition&amp;gt;为真（非空字符串），那个&amp;lt;then-part&amp;gt;会是整个函数的返回值，如果&amp;lt;condition&amp;gt;为假（空字符串），那么&amp;lt;else-part&amp;gt;会是整个函数的返回值，此时如果&amp;lt;else-part&amp;gt;没有被定义，那么，整个函数返回空字串。&lt;/p&gt;

&lt;p&gt;所以，&amp;lt;then-part&amp;gt;和&amp;lt;else-part&amp;gt;只会有一个被计算。&lt;/p&gt;

&lt;h4 id=&#34;call函数:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;call函数&lt;/h4&gt;

&lt;p&gt;call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(call &amp;amp;lt;expression&amp;gt;,&amp;amp;lt;parm1&amp;gt;,&amp;amp;lt;parm2&amp;gt;,&amp;amp;lt;parm3&amp;gt;...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当make执行这个函数时，&lt;expression&gt;参数中的变量，如$(1)，$(2)，$(3)等，会被参数&lt;parm1&gt;，&lt;parm2&gt;，&lt;parm3&gt;依次取代。而&lt;expression&gt;的返回值就是call函数的返回值。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reverse =  $(1) $(2)
foo = $(call reverse,a,b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reverse =  $(2) $(1)
foo = $(call reverse,a,b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时的foo的值就是“b a”。&lt;/p&gt;

&lt;h4 id=&#34;origin函数:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;origin函数&lt;/h4&gt;

&lt;p&gt;origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(origin &amp;amp;lt;variable&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，&amp;lt;variable&amp;gt;是变量的名字，不应该是引用。所以你最好不要在&lt;variable&gt;中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:&lt;/p&gt;

&lt;p&gt;“undefined”
      如果&amp;lt;variable&amp;gt;从来没有定义过，origin函数返回这个值“undefined”。&lt;/p&gt;

&lt;p&gt;“default”
      如果&amp;lt;variable&amp;gt;是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。&lt;/p&gt;

&lt;p&gt;“environment”
      如果&amp;lt;variable&amp;gt;是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。&lt;/p&gt;

&lt;p&gt;“file”
      如果&amp;lt;variable&amp;gt;这个变量被定义在Makefile中。&lt;/p&gt;

&lt;p&gt;“command line”
      如果&amp;lt;variable&amp;gt;这个变量是被命令行定义的。&lt;/p&gt;

&lt;p&gt;“override”
      如果&amp;lt;variable&amp;gt;是被override指示符重新定义的。&lt;/p&gt;

&lt;p&gt;“automatic”
      如果&amp;lt;variable&amp;gt;是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。&lt;/p&gt;

&lt;p&gt;这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifdef bletch
ifeq &amp;quot;$(origin bletch)&amp;quot; &amp;quot;environment&amp;quot;
bletch = barf, gag, etc.
endif
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。&lt;/p&gt;

&lt;h4 id=&#34;shell函数:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;shell函数&lt;/h4&gt;

&lt;p&gt;shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;contents := $(shell cat foo)

files := $(shell echo *.c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。&lt;/p&gt;

&lt;h4 id=&#34;控制make的函数:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;控制make的函数&lt;/h4&gt;

&lt;p&gt;make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。&lt;/p&gt;

&lt;p&gt;$(error &amp;lt;text &amp;hellip;&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;产生一个致命的错误，&amp;lt;text ...&amp;gt;是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：

示例一：
ifdef ERROR_001
$(error error is $(ERROR_001))
endif

示例二：
ERR = $(error found an error!)
.PHONY: err
err: ; $(ERR)

示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$(warning &amp;lt;text &amp;hellip;&amp;gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sect-make-的运行:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;make 的运行&lt;/h3&gt;

&lt;p&gt;一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。&lt;/p&gt;

&lt;h4 id=&#34;make的退出码:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;make的退出码&lt;/h4&gt;

&lt;p&gt;make命令执行后有三个退出码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 —— 表示成功执行。
1 —— 如果make运行时出现任何错误，其返回1。
2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make的相关参数我们会在后续章节中讲述。&lt;/p&gt;

&lt;h4 id=&#34;指定makefile:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;指定Makefile&lt;/h4&gt;

&lt;p&gt;前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。&lt;/p&gt;

&lt;p&gt;当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“&amp;ndash;file”参数（“&amp;ndash;makefile”参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make –f hchen.mk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。&lt;/p&gt;

&lt;h4 id=&#34;指定目标:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;指定目标&lt;/h4&gt;

&lt;p&gt;一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）&lt;/p&gt;

&lt;p&gt;任何在makefile中的目标都可以被指定成终极目标，但是除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。&lt;/p&gt;

&lt;p&gt;有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sources = foo.c bar.c
ifneq ( $(MAKECMDGOALS),clean)
include $(sources:.c=.d)
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。&lt;/p&gt;

&lt;p&gt;使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.PHONY: all
all: prog1 prog2 prog3 prog4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。&lt;/p&gt;

&lt;p&gt;即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; “all”
    这个伪目标是所有目标的目标，其功能一般是编译所有的目标。
 “clean”
    这个伪目标功能是删除所有被make创建的文件。
 “install”
    这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。
 “print”
    这个伪目标的功能是例出改变过的源文件。
 “tar”
    这个伪目标功能是把源程序打包备份。也就是一个tar文件。
 “dist”
    这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。
 “TAGS”
    这个伪目标功能是更新所有的目标，以备完整地重编译使用。
 “check”和“test”
    这两个伪目标一般用来测试makefile的流程。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。&lt;/p&gt;

&lt;h4 id=&#34;检查规则:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;检查规则&lt;/h4&gt;

&lt;p&gt;有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;“-n”
“--just-print”
“--dry-run”
“--recon”
不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。

“-t”
“--touch”
这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。

“-q”
“--question”
这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。

“-W &amp;lt;file&amp;gt;”
“--what-if=&amp;lt;file&amp;gt;”
“--assume-new=&amp;lt;file&amp;gt;”
“--new-file=&amp;lt;file&amp;gt;”
这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。&lt;/p&gt;

&lt;h4 id=&#34;make的参数:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;make的参数&lt;/h4&gt;

&lt;p&gt;下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。&lt;/p&gt;

&lt;p&gt;“-b”
“-m”
这两个参数的作用是忽略和其它版本make的兼容性。&lt;/p&gt;

&lt;p&gt;“-B”
“&amp;ndash;always-make”
认为所有的目标都需要更新（重编译）。&lt;/p&gt;

&lt;p&gt;“-C &amp;lt;dir&amp;gt;”&lt;/p&gt;

&lt;p&gt;“&amp;ndash;directory=&amp;lt;dir&amp;gt;”
指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。&lt;/p&gt;

&lt;p&gt;“—debug[=&amp;lt;options&amp;gt;]”
输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值：
    a —— 也就是all，输出所有的调试信息。（会非常的多）
    b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。
    v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。
    i —— 也就是implicit，输出所以的隐含规则。
    j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。
    m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。&lt;/p&gt;

&lt;p&gt;“-d”
相当于“&amp;ndash;debug=a”。&lt;/p&gt;

&lt;p&gt;“-e”
“&amp;ndash;environment-overrides”
指明环境变量的值覆盖makefile中定义的变量的值。&lt;/p&gt;

&lt;p&gt;“-f=&amp;lt;file&amp;gt;”
“&amp;ndash;file=&amp;lt;file&amp;gt;”
“&amp;ndash;makefile=&amp;lt;file&amp;gt;”
指定需要执行的makefile。&lt;/p&gt;

&lt;p&gt;“-h”
“&amp;ndash;help”
显示帮助信息。&lt;/p&gt;

&lt;p&gt;“-i”
“&amp;ndash;ignore-errors”
在执行时忽略所有的错误。&lt;/p&gt;

&lt;p&gt;“-I &amp;lt;dir&amp;gt;”
“&amp;ndash;include-dir=&amp;lt;dir&amp;gt;”
指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。&lt;/p&gt;

&lt;p&gt;“-j [&amp;lt;jobsnum&amp;gt;]”
“&amp;ndash;jobs[=&amp;lt;jobsnum&amp;gt;]”
指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）&lt;/p&gt;

&lt;p&gt;“-k”
“&amp;ndash;keep-going”
出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。&lt;/p&gt;

&lt;p&gt;“-l &amp;lt;load&amp;gt;”
“&amp;ndash;load-average[=&amp;lt;load]”
“—max-load[=&amp;lt;load&amp;gt;]”
指定make运行命令的负载。&lt;/p&gt;

&lt;p&gt;“-n”
“&amp;ndash;just-print”
“&amp;ndash;dry-run”
“&amp;ndash;recon”
仅输出执行过程中的命令序列，但并不执行。&lt;/p&gt;

&lt;p&gt;“-o &amp;lt;file&amp;gt;”
“&amp;ndash;old-file=&amp;lt;file&amp;gt;”
“&amp;ndash;assume-old=&amp;lt;file&amp;gt;”
不重新生成的指定的&amp;lt;file&amp;gt;，即使这个目标的依赖文件新于它。&lt;/p&gt;

&lt;p&gt;“-p”
“&amp;ndash;print-data-base”
输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。&lt;/p&gt;

&lt;p&gt;“-q”
“&amp;ndash;question”
不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。&lt;/p&gt;

&lt;p&gt;“-r”
“&amp;ndash;no-builtin-rules”
禁止make使用任何隐含规则。&lt;/p&gt;

&lt;p&gt;“-R”
“&amp;ndash;no-builtin-variabes”
禁止make使用任何作用于变量上的隐含规则。&lt;/p&gt;

&lt;p&gt;“-s”
“&amp;ndash;silent”
“&amp;ndash;quiet”
在命令运行时不输出命令的输出。&lt;/p&gt;

&lt;p&gt;“-S”
“&amp;ndash;no-keep-going”
“&amp;ndash;stop”
取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。&lt;/p&gt;

&lt;p&gt;“-t”
“&amp;ndash;touch”
相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。&lt;/p&gt;

&lt;p&gt;“-v”
“&amp;ndash;version”
输出make程序的版本、版权等关于make的信息。&lt;/p&gt;

&lt;p&gt;“-w”
“&amp;ndash;print-directory”
输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。&lt;/p&gt;

&lt;p&gt;“&amp;ndash;no-print-directory”
禁止“-w”选项。&lt;/p&gt;

&lt;p&gt;“-W &lt;file&gt;”
“&amp;ndash;what-if=&lt;file&gt;”
“&amp;ndash;new-file=&lt;file&gt;”
“&amp;ndash;assume-file=&lt;file&gt;”
假定目标&lt;file&gt;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得&lt;file&gt;的修改时间为当前时间。&lt;/p&gt;

&lt;p&gt;“&amp;ndash;warn-undefined-variables”
只要make发现有未定义的变量，那么就输出警告信息。&lt;/p&gt;

&lt;h3 id=&#34;sect-隐含规则:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;隐含规则&lt;/h3&gt;

&lt;p&gt;在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。&lt;/p&gt;

&lt;p&gt;“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。&lt;/p&gt;

&lt;p&gt;“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。&lt;/p&gt;

&lt;p&gt;我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。
我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。&lt;/p&gt;

&lt;h4 id=&#34;使用隐含规则:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;使用隐含规则&lt;/h4&gt;

&lt;p&gt;如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo : foo.o bar.o
        cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。&lt;/p&gt;

&lt;p&gt;make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把[.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo.o : foo.c
        cc –c foo.c $(CFLAGS)
bar.o : bar.c
    cc –c bar.c $(CFLAGS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。&lt;/p&gt;

&lt;p&gt;当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。&lt;/p&gt;

&lt;p&gt;还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo.o : foo.p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。&lt;/p&gt;

&lt;h4 id=&#34;隐含规则一览:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;隐含规则一览&lt;/h4&gt;

&lt;p&gt;这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“&amp;ndash;no-builtin-rules”选项来取消所有的预设置的隐含规则。&lt;/p&gt;

&lt;p&gt;当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表”（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。&lt;/p&gt;

&lt;p&gt;还是先来看一看常用的隐含规则吧。&lt;/p&gt;

&lt;p&gt;1、编译C程序的隐含规则。
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”&lt;/p&gt;

&lt;p&gt;2、编译C++程序的隐含规则。
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.cc”或是“&lt;n&gt;.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）&lt;/p&gt;

&lt;p&gt;3、编译Pascal程序的隐含规则。
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.p”，并且其生成命令是“$(PC) –c  $(PFLAGS)”。&lt;/p&gt;

&lt;p&gt;4、编译Fortran/Ratfor程序的隐含规则。
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.r”或“&lt;n&gt;.F”或“&lt;n&gt;.f”，并且其生成命令是:
    “.f”  “$(FC) –c  $(FFLAGS)”
    “.F”  “$(FC) –c  $(FFLAGS) $(CPPFLAGS)”
    “.f”  “$(FC) –c  $(FFLAGS) $(RFLAGS)”&lt;/p&gt;

&lt;p&gt;5、预处理Fortran/Ratfor程序的隐含规则。
“&lt;n&gt;.f”的目标的依赖目标会自动推导为“&lt;n&gt;.r”或“&lt;n&gt;.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：
    “.F”  “$(FC) –F $(CPPFLAGS) $(FFLAGS)”
    “.r”  “$(FC) –F $(FFLAGS) $(RFLAGS)”&lt;/p&gt;

&lt;p&gt;6、编译Modula-2程序的隐含规则。
“&lt;n&gt;.sym”的目标的依赖目标会自动推导为“&lt;n&gt;.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“&lt;n.o&gt;” 的目标的依赖目标会自动推导为“&lt;n&gt;.mod”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。&lt;/p&gt;

&lt;p&gt;7、汇编和汇编预处理的隐含规则。
“&lt;n&gt;.o” 的目标的依赖目标会自动推导为“&lt;n&gt;.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“&lt;n&gt;.s” 的目标的依赖目标会自动推导为“&lt;n&gt;.S”，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。&lt;/p&gt;

&lt;p&gt;8、链接Object文件的隐含规则。
“&lt;n&gt;”目标依赖于“&lt;n&gt;.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x : y.o z.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。&lt;/p&gt;

&lt;p&gt;9、Yacc C程序时的隐含规则。
“&lt;n&gt;.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）&lt;/p&gt;

&lt;p&gt;10、Lex C程序时的隐含规则。
“&lt;n&gt;.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）&lt;/p&gt;

&lt;p&gt;11、Lex Ratfor程序时的隐含规则。
“&lt;n&gt;.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。&lt;/p&gt;

&lt;p&gt;12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。
“&lt;n&gt;.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“&lt;n&gt;.y”和“&lt;n&gt;.l”也是同样的规则。&lt;/p&gt;

&lt;h4 id=&#34;隐含规则使用的变量:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;隐含规则使用的变量&lt;/h4&gt;

&lt;p&gt;在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“&amp;ndash;no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。&lt;/p&gt;

&lt;p&gt;例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把变量“$(CFLAGS)”重定义成“-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。&lt;/p&gt;

&lt;p&gt;我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：&lt;/p&gt;

&lt;p&gt;1、关于命令的变量。&lt;/p&gt;

&lt;p&gt;AR
    函数库打包程序。默认命令是“ar”。
AS
    汇编语言编译程序。默认命令是“as”。
CC
    C语言编译程序。默认命令是“cc”。
CXX
    C++语言编译程序。默认命令是“g++”。
CO
    从 RCS文件中扩展文件程序。默认命令是“co”。
CPP
    C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。
FC
    Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。
GET
    从SCCS文件中扩展文件的程序。默认命令是“get”。
LEX
    Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。
PC
    Pascal语言编译程序。默认命令是“pc”。
YACC
    Yacc文法分析器（针对于C程序）。默认命令是“yacc”。
YACCR
    Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。
MAKEINFO
    转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。
TEX
    从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。
TEXI2DVI
    从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。
WEAVE
    转换Web到TeX的程序。默认命令是“weave”。
CWEAVE
    转换C Web 到 TeX的程序。默认命令是“cweave”。
TANGLE
    转换Web到Pascal语言的程序。默认命令是“tangle”。
CTANGLE
    转换C Web 到 C。默认命令是“ctangle”。
RM
    删除文件命令。默认命令是“rm –f”。&lt;/p&gt;

&lt;p&gt;2、关于命令参数的变量&lt;/p&gt;

&lt;p&gt;下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。&lt;/p&gt;

&lt;p&gt;ARFLAGS
    函数库打包程序AR命令的参数。默认值是“rv”。
ASFLAGS
    汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。
CFLAGS
    C语言编译器参数。
CXXFLAGS
    C++语言编译器参数。
COFLAGS
    RCS命令参数。
CPPFLAGS
    C预处理器参数。（ C 和 Fortran 编译器也会用到）。
FFLAGS
    Fortran语言编译器参数。
GFLAGS
    SCCS “get”程序参数。
LDFLAGS
    链接器参数。（如：“ld”）
LFLAGS
    Lex文法分析器参数。
PFLAGS
    Pascal语言编译器参数。
RFLAGS
    Ratfor 程序的Fortran 编译器参数。
YFLAGS
    Yacc文法分析器参数。&lt;/p&gt;

&lt;h4 id=&#34;隐含规则链:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;隐含规则链&lt;/h4&gt;

&lt;p&gt;有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。&lt;/p&gt;

&lt;p&gt;在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。&lt;/p&gt;

&lt;p&gt;我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？&lt;/p&gt;

&lt;p&gt;在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。&lt;/p&gt;

&lt;p&gt;通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）&lt;/p&gt;

&lt;p&gt;你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。&lt;/p&gt;

&lt;p&gt;在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。&lt;/p&gt;

&lt;p&gt;Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规则就不会生成中间文件。&lt;/p&gt;

&lt;h4 id=&#34;定义模式规则:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;定义模式规则&lt;/h4&gt;

&lt;p&gt;你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有&amp;rdquo;%&amp;ldquo;字符。&amp;rdquo;%&amp;ldquo;的意思是表示一个或多个任意字符。在依赖目标中同样可以使用&amp;rdquo;%&amp;ldquo;，只是依赖目标中的&amp;rdquo;%&amp;ldquo;的取值，取决于其目标。&lt;/p&gt;

&lt;p&gt;有一点需要注意的是，&amp;rdquo;%&amp;ldquo;的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的&amp;rdquo;%&amp;ldquo;则发生在运行时。&lt;/p&gt;

&lt;p&gt;1、模式规则介绍&lt;/p&gt;

&lt;p&gt;模式规则中，至少在规则的目标定义中要包含&amp;rdquo;%&amp;ldquo;，否则，就是一般的规则。目标中的&amp;rdquo;%&amp;ldquo;定义表示对文件名的匹配，&amp;rdquo;%&amp;ldquo;表示长度任意的非空字符串。例如：&amp;rdquo;%.c&amp;rdquo;表示以&amp;rdquo;.c&amp;rdquo;结尾的文件名（文件名的长度至少为3），而&amp;rdquo;s.%.c&amp;rdquo;则表示以&amp;rdquo;s.&amp;ldquo;开头，&amp;rdquo;.c&amp;rdquo;结尾的文件名（文件名的长度至少为5）。&lt;/p&gt;

&lt;p&gt;如果&amp;rdquo;%&amp;ldquo;定义在目标中，那么，目标中的&amp;rdquo;%&amp;ldquo;的值决定了依赖目标中的&amp;rdquo;%&amp;ldquo;的值，也就是说，目标中的模式的&amp;rdquo;%&amp;ldquo;决定了依赖目标中&amp;rdquo;%&amp;ldquo;的样子。例如有一个模式规则如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%.o : %.c ; &amp;lt;command ......&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是&amp;rdquo;a.o b.o&amp;rdquo;，那么&amp;rdquo;%c&amp;rdquo;就是&amp;rdquo;a.c b.c&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;一旦依赖目标中的&amp;rdquo;%&amp;ldquo;模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。&lt;/p&gt;

&lt;p&gt;2、模式规则示例&lt;/p&gt;

&lt;p&gt;下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%.o : %.c
        $(CC) -c $(CFLAGS) $(CPPFLAGS) $&amp;lt; -o $@
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&amp;rdquo;$@&amp;ldquo;表示所有的目标的挨个值，&amp;rdquo;$&amp;lt;&amp;ldquo;表示了所有依赖目标的挨个值。这些奇怪的变量我们叫&amp;rdquo;自动化变量&amp;rdquo;，后面会详细讲述。&lt;/p&gt;

&lt;p&gt;下面的这个例子中有两个目标是模式的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%.tab.c %.tab.h: %.y
        bison -d $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这条规则告诉make把所有的[.y]文件都以&amp;rdquo;bison -d &lt;n&gt;.y&amp;rdquo;执行，然后生成&amp;rdquo;&lt;n&gt;.tab.c&amp;rdquo;和&amp;rdquo;&lt;n&gt;.tab.h&amp;rdquo;文件。（其中，&amp;rdquo;&lt;n&gt;&amp;ldquo;表示一个任意字符串）。如果我们的执行程序&amp;rdquo;foo&amp;rdquo;依赖于文件&amp;rdquo;parse.tab.o&amp;rdquo;和&amp;rdquo;scan.o&amp;rdquo;，并且文件&amp;rdquo;scan.o&amp;rdquo;依赖于文件&amp;rdquo;parse.tab.h&amp;rdquo;，如果&amp;rdquo;parse.y&amp;rdquo;文件被更新了，那么根据上述的规则，&amp;rdquo;bison -d parse.y&amp;rdquo;就会被执行一次，于是，&amp;rdquo;parse.tab.o&amp;rdquo;和&amp;rdquo;scan.o&amp;rdquo;的依赖文件就齐了。（假设，&amp;rdquo;parse.tab.o&amp;rdquo;由&amp;rdquo;parse.tab.c&amp;rdquo;生成，和&amp;rdquo;scan.o&amp;rdquo;由&amp;rdquo;scan.c&amp;rdquo;生成，而&amp;rdquo;foo&amp;rdquo;由&amp;rdquo;parse.tab.o&amp;rdquo;和&amp;rdquo;scan.o&amp;rdquo;链接生成，而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）&lt;/p&gt;

&lt;p&gt;3、自动化变量&lt;/p&gt;

&lt;p&gt;在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。&lt;/p&gt;

&lt;p&gt;自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。&lt;/p&gt;

&lt;p&gt;下面是所有的自动化变量及其说明：&lt;/p&gt;

&lt;p&gt;$@
    表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，&amp;rdquo;$@&amp;ldquo;就是匹配于目标中模式定义的集合。&lt;/p&gt;

&lt;p&gt;$%
    仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是&amp;rdquo;foo.a(bar.o)&amp;ldquo;，那么，&amp;rdquo;$%&amp;ldquo;就是&amp;rdquo;bar.o&amp;rdquo;，&amp;rdquo;$@&amp;ldquo;就是&amp;rdquo;foo.a&amp;rdquo;。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。&lt;/p&gt;

&lt;p&gt;$&amp;lt;
    依赖目标中的第一个目标名字。如果依赖目标是以模式（即&amp;rdquo;%&amp;ldquo;）定义的，那么&amp;rdquo;$&amp;lt;&amp;ldquo;将是符合模式的一系列的文件集。注意，其是一个一个取出来的。&lt;/p&gt;

&lt;p&gt;$?
    所有比目标新的依赖目标的集合。以空格分隔。&lt;/p&gt;

&lt;p&gt;$^
    所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。&lt;/p&gt;

&lt;p&gt;$+
    这个变量很像&amp;rdquo;$^&amp;ldquo;，也是所有依赖目标的集合。只是它不去除重复的依赖目标。&lt;/p&gt;

&lt;p&gt;$*
   这个变量表示目标模式中&amp;rdquo;%&amp;ldquo;及其之前的部分。如果目标是&amp;rdquo;dir/a.foo.b&amp;rdquo;，并且目标的模式是&amp;rdquo;a.%.b&amp;rdquo;，那么，&amp;rdquo;$&lt;em&gt;&amp;ldquo;的值就是&amp;rdquo;dir/a.foo&amp;rdquo;。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么&amp;rdquo;$&lt;/em&gt;&amp;ldquo;也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么&amp;rdquo;$&lt;em&gt;&amp;ldquo;就是除了后缀的那一部分。例如：如果目标是&amp;rdquo;foo.c&amp;rdquo;，因为&amp;rdquo;.c&amp;rdquo;是make所能识别的后缀名，所以，&amp;rdquo;$&lt;/em&gt;&amp;ldquo;的值就是&amp;rdquo;foo&amp;rdquo;。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用&amp;rdquo;$&lt;em&gt;&amp;ldquo;，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么&amp;rdquo;$&lt;/em&gt;&amp;ldquo;就是空值。&lt;/p&gt;

&lt;p&gt;当你希望只对更新过的依赖文件进行操作时，&amp;rdquo;$?&amp;ldquo;在显式规则中很有用，例如，假设有一个函数库文件叫&amp;rdquo;lib&amp;rdquo;，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lib : foo.o bar.o lose.o win.o
        ar r lib $?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上述所列出来的自动量变量中。四个变量（$@、$&amp;lt;、$%、$*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上&amp;rdquo;D&amp;rdquo;或&amp;rdquo;F&amp;rdquo;字样。这是GNU make中老版本的特性，在新版本中，我们使用函数&amp;rdquo;dir&amp;rdquo;或&amp;rdquo;notdir&amp;rdquo;就可以做到了。&amp;rdquo;D&amp;rdquo;的含义就是Directory，就是目录，&amp;rdquo;F&amp;rdquo;的含义就是File，就是文件。&lt;/p&gt;

&lt;p&gt;下面是对于上面的七个变量分别加上&amp;rdquo;D&amp;rdquo;或是&amp;rdquo;F&amp;rdquo;的含义：&lt;/p&gt;

&lt;p&gt;$(@D)
    表示&amp;rdquo;$@&amp;ldquo;的目录部分（不以斜杠作为结尾），如果&amp;rdquo;$@&amp;ldquo;值是&amp;rdquo;dir/foo.o&amp;rdquo;，那么&amp;rdquo;$(@D)&amp;ldquo;就是&amp;rdquo;dir&amp;rdquo;，而如果&amp;rdquo;$@&amp;ldquo;中没有包含斜杠的话，其值就是&amp;rdquo;.&amp;ldquo;（当前目录）。&lt;/p&gt;

&lt;p&gt;$(@F)
    表示&amp;rdquo;$@&amp;ldquo;的文件部分，如果&amp;rdquo;$@&amp;ldquo;值是&amp;rdquo;dir/foo.o&amp;rdquo;，那么&amp;rdquo;$(@F)&amp;ldquo;就是&amp;rdquo;foo.o&amp;rdquo;，&amp;rdquo;$(@F)&amp;ldquo;相当于函数&amp;rdquo;$(notdir $@)&amp;ldquo;。&lt;/p&gt;

&lt;p&gt;&amp;rdquo;$(*D)&amp;rdquo;
&amp;ldquo;$(*F)&amp;rdquo;
    和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，&amp;rdquo;$(*D)&amp;ldquo;返回&amp;rdquo;dir&amp;rdquo;，而&amp;rdquo;$(*F)&amp;ldquo;返回&amp;rdquo;foo&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;rdquo;$(%D)&amp;rdquo;
&amp;ldquo;$(%F)&amp;rdquo;
    分别表示了函数包文件成员的目录部分和文件部分。这对于形同&amp;rdquo;archive(member)&amp;ldquo;形式的目标中的&amp;rdquo;member&amp;rdquo;中包含了不同的目录很有用。&lt;/p&gt;

&lt;p&gt;&amp;rdquo;$(&amp;lt;D)&amp;rdquo;
&amp;ldquo;$(&amp;lt;F)&amp;rdquo;
    分别表示依赖文件的目录部分和文件部分。&lt;/p&gt;

&lt;p&gt;&amp;rdquo;$(^D)&amp;rdquo;
&amp;ldquo;$(^F)&amp;rdquo;
    分别表示所有依赖文件的目录部分和文件部分。（无相同的）&lt;/p&gt;

&lt;p&gt;&amp;rdquo;$(+D)&amp;rdquo;
&amp;ldquo;$(+F)&amp;rdquo;
    分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）&lt;/p&gt;

&lt;p&gt;&amp;rdquo;$(?D)&amp;rdquo;
&amp;ldquo;$(?F)&amp;rdquo;
    分别表示被更新的依赖文件的目录部分和文件部分。&lt;/p&gt;

&lt;p&gt;最后想提醒一下的是，对于&amp;rdquo;$&amp;lt;&amp;ldquo;，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，&amp;rdquo;$(&amp;lt;)&amp;ldquo;就要比&amp;rdquo;$&amp;lt;&amp;ldquo;要好一些。&lt;/p&gt;

&lt;p&gt;还得要注意的是，这些变量只使用在规则的命令中，而且一般都是&amp;rdquo;显式规则&amp;rdquo;和&amp;rdquo;静态模式规则&amp;rdquo;（参见前面&amp;rdquo;书写规则&amp;rdquo;一章）。其在隐含规则中并没有意义。&lt;/p&gt;

&lt;p&gt;4、模式的匹配&lt;/p&gt;

&lt;p&gt;一般来说，一个目标的模式有一个有前缀或是后缀的&amp;rdquo;%&amp;ldquo;，或是没有前后缀，直接就是一个&amp;rdquo;%&amp;ldquo;。因为&amp;rdquo;%&amp;ldquo;代表一个或多个字符，所以在定义好了的模式中，我们把&amp;rdquo;%&amp;ldquo;所匹配的内容叫做&amp;rdquo;茎&amp;rdquo;，例如&amp;rdquo;%.c&amp;rdquo;所匹配的文件&amp;rdquo;test.c&amp;rdquo;中&amp;rdquo;test&amp;rdquo;就是&amp;rdquo;茎&amp;rdquo;。因为在目标和依赖目标中同时有&amp;rdquo;%&amp;ldquo;时，依赖目标的&amp;rdquo;茎&amp;rdquo;会传给目标，当做目标中的&amp;rdquo;茎&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行&amp;rdquo;茎&amp;rdquo;的传递时，我们需要知道这个步骤。例如有一个模式&amp;rdquo;e%t&amp;rdquo;，文件&amp;rdquo;src/eat&amp;rdquo;匹配于该模式，于是&amp;rdquo;src/a&amp;rdquo;就是其&amp;rdquo;茎&amp;rdquo;，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式&amp;rdquo;c%r&amp;rdquo;，那么，目标就是&amp;rdquo;src/car&amp;rdquo;。（&amp;rdquo;茎&amp;rdquo;被传递）&lt;/p&gt;

&lt;p&gt;5、重载内建隐含规则&lt;/p&gt;

&lt;p&gt;你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%.o : %.c
        $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以取消内建的隐含规则，只要不在后面写命令就行。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%.o : %.s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。&lt;/p&gt;

&lt;h4 id=&#34;老式风格的-后缀规则:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;老式风格的&amp;rdquo;后缀规则&amp;rdquo;&lt;/h4&gt;

&lt;p&gt;后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：&amp;rdquo;双后缀&amp;rdquo;和&amp;rdquo;单后缀&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如&amp;rdquo;.c.o&amp;rdquo;相当于&amp;rdquo;%o : %c&amp;rdquo;。单后缀规则只定义一个后缀，也就是源文件的后缀。如&amp;rdquo;.c&amp;rdquo;相当于&amp;rdquo;% : %.c&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：&amp;rdquo;.c&amp;rdquo;和&amp;rdquo;.o&amp;rdquo;都是make所知道。因而，如果你定义了一个规则是&amp;rdquo;.c.o&amp;rdquo;那么其就是双后缀规则，意义就是&amp;rdquo;.c&amp;rdquo;是源文件的后缀，&amp;rdquo;.o&amp;rdquo;是目标文件的后缀。如下示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.c.o:
        $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.c.o: foo.h
        $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子，就是说，文件&amp;rdquo;.c.o&amp;rdquo;依赖于文件&amp;rdquo;foo.h&amp;rdquo;，而不是我们想要的这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%.o: %.c foo.h
        $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。&lt;/p&gt;

&lt;p&gt;而要让make知道一些特定的后缀，我们可以使用伪目标&amp;rdquo;.SUFFIXES&amp;rdquo;来定义或是删除，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.SUFFIXES: .hack .win
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把后缀.hack和.win加入后缀列表中的末尾。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.SUFFIXES:              # 删除默认的后缀
.SUFFIXES: .c .o .h   # 定义自己的后缀
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先清楚默认后缀，后定义自己的后缀列表。&lt;/p&gt;

&lt;p&gt;make的参数&amp;rdquo;-r&amp;rdquo;或&amp;rdquo;-no-builtin-rules&amp;rdquo;也会使用得默认的后缀列表为空。而变量&amp;rdquo;SUFFIXE&amp;rdquo;被用来定义默认的后缀列表，你可以用&amp;rdquo;.SUFFIXES&amp;rdquo;来改变后缀列表，但请不要改变变量&amp;rdquo;SUFFIXE&amp;rdquo;的值。&lt;/p&gt;

&lt;h4 id=&#34;隐含规则搜索算法:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;隐含规则搜索算法&lt;/h4&gt;

&lt;p&gt;比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是&amp;rdquo;archive(member)&amp;ldquo;的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把&amp;rdquo;member&amp;rdquo;当作T来搜索。&lt;/p&gt;

&lt;p&gt;1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是&amp;rdquo;src/foo.o&amp;rdquo;，那么，D就是&amp;rdquo;src/&amp;ldquo;，N就是&amp;rdquo;foo.o&amp;rdquo;）&lt;/p&gt;

&lt;p&gt;2、创建所有匹配于T或是N的模式规则列表。&lt;/p&gt;

&lt;p&gt;3、如果在模式规则列表中有匹配所有文件的模式，如&amp;rdquo;%&amp;ldquo;，那么从列表中移除其它的模式。&lt;/p&gt;

&lt;p&gt;4、移除列表中没有命令的规则。&lt;/p&gt;

&lt;p&gt;5、对于第一个在列表中的模式规则：
    1）推导其&amp;rdquo;茎&amp;rdquo;S，S应该是T或是N匹配于模式中&amp;rdquo;%&amp;ldquo;非空的部分。
    2）计算依赖文件。把依赖文件中的&amp;rdquo;%&amp;ldquo;都替换成&amp;rdquo;茎&amp;rdquo;S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。
3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫&amp;rdquo;理当存在&amp;rdquo;）
    4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。&lt;/p&gt;

&lt;p&gt;6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：
    1）如果规则是终止规则，那就忽略它，继续下一条模式规则。
2）计算依赖文件。（同第5步）
3）测试所有的依赖文件是否存在或是理当存在。
4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。
5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。&lt;/p&gt;

&lt;p&gt;7、如果没有隐含规则可以使用，查看&amp;rdquo;.DEFAULT&amp;rdquo;规则，如果有，采用，把&amp;rdquo;.DEFAULT&amp;rdquo;的命令给T使用。&lt;/p&gt;

&lt;p&gt;一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。&lt;/p&gt;

&lt;h3 id=&#34;sect-使用make更新函数库文件:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;sect;使用make更新函数库文件&lt;/h3&gt;

&lt;p&gt;函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令&amp;rdquo;ar&amp;rdquo;来完成打包工作。&lt;/p&gt;

&lt;h4 id=&#34;函数库文件的成员:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;函数库文件的成员&lt;/h4&gt;

&lt;p&gt;一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;archive(member)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了&amp;rdquo;ar&amp;rdquo;命令来服务的。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foolib(hack.o) : hack.o
        ar cr foolib hack.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要指定多个member，那就以空格分开，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foolib(hack.o kludge.o)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其等价于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foolib(hack.o) foolib(kludge.o)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以使用Shell的文件通配符来定义，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foolib(*.o)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;函数库成员的隐含规则:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;函数库成员的隐含规则&lt;/h4&gt;

&lt;p&gt;当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是&amp;rdquo;a(m)&amp;ldquo;形式的，其会把目标变成&amp;rdquo;(m)&amp;ldquo;。于是，如果我们的成员是&amp;rdquo;%.o&amp;rdquo;的模式定义，并且如果我们使用&amp;rdquo;make foo.a(bar.o)&amp;ldquo;的形式调用Makefile时，隐含规则会去找&amp;rdquo;bar.o&amp;rdquo;的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cc -c bar.c -o bar.o
ar r foo.a bar.o
rm -f bar.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个变量要注意的是&amp;rdquo;$%&amp;ldquo;，这是专属函数库文件的自动化变量，有关其说明请参见&amp;rdquo;自动化变量&amp;rdquo;一节。&lt;/p&gt;

&lt;h4 id=&#34;函数库文件的后缀规则:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;函数库文件的后缀规则&lt;/h4&gt;

&lt;p&gt;你可以使用&amp;rdquo;后缀规则&amp;rdquo;和&amp;rdquo;隐含规则&amp;rdquo;来生成函数库打包文件，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.c.a:
        $(CC) $(CFLAGS) $(CPPFLAGS) -c $&amp;lt; -o $*.o
        $(AR) r $@ $*.o
        $(RM) $*.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其等效于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(%.o) : %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) -c $&amp;lt; -o $*.o
        $(AR) r $@ $*.o
        $(RM) $*.o
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;注意事项:fd6ac85bb1003e2483b5b81ab67d6beb&#34;&gt;&amp;gt;注意事项&lt;/h4&gt;

&lt;p&gt;在进行函数库打包文件生成时，请小心使用make的并行机制（&amp;rdquo;-j&amp;rdquo;参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。&lt;/p&gt;

&lt;p&gt;但就目前而言，你还是应该不要尽量不要使用&amp;rdquo;-j&amp;rdquo;参数。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(注意：文章引用&lt;a href=&#34;http://blog.csdn.net/iiisan/article/details/399431#&#34; title=&#34;How to write make file&#34;&gt;&lt;strong&gt;&lt;em&gt;这里&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;，我只是为了方便以后查找，重新编辑收录博客。Make 是一个功能强大的工具，即使有那么点瑕疵，也不妨碍她的实用价值，非常值得深入研究使用)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>History of IRC</title>
      <link>http://alimy.me/post/dev_201601222145/</link>
      <pubDate>Fri, 22 Jan 2016 00:00:00 UTC</pubDate>
      
      <guid>http://alimy.me/post/dev_201601222145/</guid>
      <description>

&lt;h3 id=&#34;sect-about:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;About&lt;/h3&gt;

&lt;p&gt;IRC(Internet Relay Chat) is an application layer protocol that facilitates communication in the form of text.&lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Relay_Chat&#34; title=&#34;Internet Relay Chat&#34;&gt;[wikipedia]&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;sect-the-beginning:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;The Beginning&lt;/h3&gt;

&lt;p&gt;IRC was born during summer 1988 when Jarkko &amp;ldquo;WiZ&amp;rdquo; Oikarinen wrote the first IRC client and server at the University of Oulu, Finland (where he was working at the Department of Information Processing Science).&lt;/p&gt;

&lt;p&gt;Jarkko intended to extend the BBS software he administrated at tolsun.oulu.fi, to allow news the usenet style, real time discussions and similar BBS features. The first part he implemented was the chat part, which he did with borrowed parts written by his friends Jyrki Kuoppala and Jukka Pihl. It was initially tested on a single machine, and according to the words from Jarkko himself &amp;ldquo;The birthday of IRC was in August 1988. The exact date is unknown, at the end of the month anyways.&amp;rdquo;. The first IRC server was named tolsun.oulu.fi.&lt;/p&gt;

&lt;p&gt;Jyrki Kuoppala pushed Jarkko to ask Oulu University to free the IRC code so that it also could be run outside of Oulu, and after they finally got it released, Jyrki Kuoppala immediately installed a server (which later became irc.cs.hut.fi). This was the first &amp;ldquo;irc network&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Ari Lemmke&amp;rsquo;s own words: &amp;ldquo;At the same time Jyrki installed ircd, I was at the same room and had nothing to do, so I decided to crack into tolsun (the irc server Sun machine at Oulu), and naturally ;-) got in through a new hole in sendmail. (At that time Jyrki was still the best cracker I knew&amp;hellip;)&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Jarkko got some friends at the Helsinki and Tampere Universities to start running IRC servers when his number of users increased.&lt;/p&gt;

&lt;p&gt;Other universities soon followed. Markku Järvinen helped improving the client. At this time Jarkko realized that the rest of the BBS features probably wouldn&amp;rsquo;t fit in his program!&lt;/p&gt;

&lt;p&gt;Jarkko got in touch with guys at the University of Denver and Oregon State University. They had got an IRC network running (they had got the program from one of Jarkko&amp;rsquo;s friends, Vijay Subramaniam &amp;ndash; the first non-finnish person to use IRC) and wanted to connect to the finnish network. IRC then grew larger and got used on the entire Finnish national network - Funet - and then connected to Nordunet, the Scandinavian branch of the Internet. In November 1988, IRC had spread across the Internet.&lt;/p&gt;

&lt;p&gt;In the middle of 1989, there were some 40 servers worldwide.&lt;/p&gt;

&lt;p&gt;ircII was released 1989 by Michael Sandrof.&lt;/p&gt;

&lt;p&gt;In July 1990, IRC averaged at 12 users on 38 servers.&lt;/p&gt;

&lt;p&gt;In 1990, a new network was set up in order to develop a new version (2.6) of the ircd. The network named ChNet (about 25 servers and no users) existed a few months before disagreements among the programmers caused it to dissolve.&lt;/p&gt;

&lt;h3 id=&#34;sect-efnet:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;EFnet&lt;/h3&gt;

&lt;p&gt;In August 1990 the first major disagreement took place in the IRC world. The &amp;ldquo;A-net&amp;rdquo; (Anarchy net) included as server named eris.berkeley.edu. It was all open, required no passwords and had no limit on the number of connects. As Greg &amp;ldquo;wumpus&amp;rdquo; Lindahl explains: &amp;ldquo;it had a wildcard server line, so people were hooking up servers and nick-colliding everyone&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;Eris Free network&amp;rdquo;, EFnet, made the eris machine the first to be Q-lined (Q for quarantine) from IRC (wumpus&amp;rsquo; words again: &amp;ldquo;Eris refused to remove that line, so I formed EFnet. It wasn&amp;rsquo;t much of a fight; I got all the hubs to join, and almost everyone else got carried along.&amp;rdquo;). A-net was formed with the eris servers, EFnet was formed with the non-eris servers. History showed most servers and users went with EFnet. The name EFnet lived only shortly, as soon as ANet had died, the name EFnet became void too. There was one and only IRC left again.&lt;/p&gt;

&lt;p&gt;TubNet was the next network to splinter off. It was created by a crowd of people in #hottub that grew tired of all the netsplits. It got 5 servers and around 100 users. It died again in September the same year.&lt;/p&gt;

&lt;p&gt;One often-talked-about event in the history of IRC is the gulf war. In early 1991, live reports were available and more than 300 concurrent users were experienced for the first time.&lt;/p&gt;

&lt;h3 id=&#34;sect-undernet:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;Undernet&lt;/h3&gt;

&lt;p&gt;Another fork effort, the first that really made a big and lasting difference, was initiated by &amp;lsquo;Wildthang&amp;rsquo; in USA October 1992 (it forked off the EFnet ircd version 2.8.10). It was meant to be just a test network to develop bots on but it quickly grew to a network &amp;ldquo;for friends and their friends&amp;rdquo;. In Europe and Canada a separate new network was being worked on (by &amp;lsquo;_dl&amp;rsquo; and &amp;lsquo;WIZZARD&amp;rsquo;) and in December the french servers connected to the canadian ones, and in the end of the month, the .fr-.ca network was connected to the US one and the network that later came to be called &amp;ldquo;The Undernet&amp;rdquo; was born.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;undernetters&amp;rdquo; wanted to take ircd further in an attempt to make it less bandwidth consumptive and to try to sort out the channel chaos (netsplits and takeovers) that EFnet started to suffer from. For the latter purpose, the Undernet implemented timestamps, new routing and offered the CService &amp;ndash; a program that allowed users to register channels and then attempted to protect them from troublemakers. (More or less a global defense bot.) The very first server list presented, from Febrary 15th 1993, includes servers from USA, Canada, France, Kroatia and Japan. On August 15th, the new user count record was set to 57 users.&lt;/p&gt;

&lt;h3 id=&#34;sect-rfc:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;RFC&lt;/h3&gt;

&lt;p&gt;In May 1993, the Request For Comments 1459, for the IRC protocol is out for the public. It has since been subject to many violations and extensions.&lt;/p&gt;

&lt;p&gt;It is notable that the CTCP parts and things like colors and formats are not included in the protocol spec. Nor is character encoding.&lt;/p&gt;

&lt;h3 id=&#34;sect-dalnet:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;Dalnet&lt;/h3&gt;

&lt;p&gt;During the summer (some sources mention July) 1994, the Undernet is itself forked. This time, the new Network is called Dalnet (named after its founder: dalvenjah), and they formed the new network for better user service and even more user and channel protections. One of the more significant changes in Dalnet already from the beginning is their use of longer nicknames (the original ircd limit being 9 letters). Dalnet ircd modifications were made by Alexei &amp;ldquo;Lefler&amp;rdquo; Kosut.&lt;/p&gt;

&lt;p&gt;Dalnet was thus based on the undernet ircd server, although the dalnet pioneers were EFnet abandoners. According to James Ng the initial dalnet people were &amp;ldquo;ops in #StarTrek sick from the constant splits/lags/takeovers/etc&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Dalnet quickly offered global WallOps (IRCop messages that can be seen by users who are +w (/mode NickName +w)), longer nicknames, Q:Lined nicknames (nicknames that cannot be used i.e. ChanServ, IRCop, NickServ, etc.), global K:Lines (ban of one person or an entire domain from a server or the entire network), IRCop only communications: GlobOps, +H mode showing that an IRCop is a &amp;ldquo;helpop&amp;rdquo; etc.&lt;/p&gt;

&lt;p&gt;Much of Dalnet&amp;rsquo;s new functions were written in early 1995 by Brian &amp;ldquo;Morpher&amp;rdquo; Smith and allow users to own nicknames, channels, send memos and more.&lt;/p&gt;

&lt;h3 id=&#34;sect-oz-org:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;oz.org&lt;/h3&gt;

&lt;p&gt;Undernet split (again) in March 1996 when the sole Australian server delinked from Undernet because of difficulties with the connection across the TransPacific Australian/United States network link. The first few months of oz.org&amp;rsquo;s existance were primarily a trial delink from the Undernet because of the inability to maintain a link during peak usage hours. One of the two designers (chaos and seks) of the orginal Undernet X and W chanserv was Australian, and the same code was used for Oz.org&amp;rsquo;s Z (the name of the chanserv). In June 2001, ozorg boasted peak usages of 4,000 simultaneous users.&lt;/p&gt;

&lt;h3 id=&#34;sect-ircnet:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;IRCnet&lt;/h3&gt;

&lt;p&gt;In July 1996, after months of flame wars and discussions on the mailing list, there was yet another split due to disagreement in how the development of the ircd should evolve. Most notably, the &amp;ldquo;european&amp;rdquo; (most of those servers were in europe) side that later named itself IRCnet argued for nick and channel delays, where the EFnet side argued for timestamps. Most (not all) of the IRCnet servers were in Europe, while most of the EFnet server were in the US. This event is also known as &amp;ldquo;The Great Split&amp;rdquo; in many IRC societies. EFnet has since (as of August 1998) grown and passed the number of users it had then. In the autumn year 2000, EFnet has some 50,000 users and IRCnet 70,000.&lt;/p&gt;

&lt;h3 id=&#34;sect-freenode-open-projects-network:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;Freenode - Open Projects Network&lt;/h3&gt;

&lt;p&gt;Yet another IRC network that opened its doors in 1998 named the Open Projects Network, and had about 100 users and less than 20 channels that year. In late 2001 it had grown to nearly 4,000 users and over 1,300 channels. The OPN uses the Dancer IRCD server, after having been using ircu the intial few years.&lt;/p&gt;

&lt;p&gt;This network was later renamed to &lt;strong&gt;Freenode&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;In 2011, it peaks at 65,000 users in 40,000 channels.&lt;/p&gt;

&lt;h3 id=&#34;sect-other-networks:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;Other Networks&lt;/h3&gt;

&lt;p&gt;Of course, while internet is booming so does IRC. There exists hundreds of independent IRC networks today (like amiganet, linuxnet, galaxynet, bestnet, NewNet, AnotherNet, ChatNet, UpperNet, ZAnet, X-Net, GammaNet, SuperChat, IceNet, RedBrasil, GR-Net, AlphaStar, SorceryNet etc), but luckily there is &amp;ldquo;only&amp;rdquo; four of the main ones (this was the reality back in 1998) that keep develop their own version of the ircd server software.&lt;/p&gt;

&lt;p&gt;Of course, as of 2002, lots of other networks have popped up and now numerous of them are developing their own customized versions of the IRC protocol.&lt;/p&gt;

&lt;h3 id=&#34;sect-further-standardization-attempts:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;Further Standardization Attempts&lt;/h3&gt;

&lt;p&gt;IETF-IRCUP was an initiative started in January 1998, to gather all the flavours of IRC servers to document a new RFC and possibly set a new standard for all networks to commit to. That project died.&lt;/p&gt;

&lt;p&gt;CTCP/2 was an attempt, started in 1997 by Bjorn Reese, to develop and standardize the Client To Client Protocol that was never in the RFC. Clients have been known to extend and modify the original CTCP protocol without allowing non-compliant clients to filter the new codes. CTCP/2 was meant to define how codes and perhaps more important new codes should be introduced in order to let old clients remain functional. It was also meant to address the IPv6 problems the DCC intiating sequence has. The CTCP/2 project died as well.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll just have to wait and see what the future of IRC has to show&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;sect-irc-popularity:cd0c7a29cb84719e2c5940354f1276de&#34;&gt;&amp;sect;IRC Popularity&lt;/h3&gt;

&lt;p&gt;According to measurements done by &lt;a href=&#34;http://irc.netsplit.de/networks/top10.php&#34;&gt;&lt;strong&gt;irc.netsplit.de&lt;/strong&gt;&lt;/a&gt;, IRC in general have lost users gradually since &lt;sup&gt;2004&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2005&lt;/sub&gt;. Those years, the top 4 IRC networks all had over 100,000 users each on a daily basis. Those networks were Quakenet, Undernet, IRCnet and EFnet. Quakenet was in the lead with more than 200,000 users.&lt;/p&gt;

&lt;p&gt;In the beginning of 2011, Quakenet is just above 100,000 users and the only network over 100K.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article&amp;rsquo;s original author is &lt;a href=&#34;http://daniel.haxx.se/&#34; title=&#34;Daniel&#39;s home page&#34;&gt;&lt;strong&gt;&lt;em&gt;Daniel Stenberg&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; and the links is &lt;a href=&#34;http://daniel.haxx.se/irchistory.html&#34; title=&#34;History of IRC&#34;&gt; &lt;strong&gt;here&lt;/strong&gt; &lt;/a&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DogeOS,SmartOS,illumos</title>
      <link>http://alimy.me/post/dev_201601161712/</link>
      <pubDate>Sat, 16 Jan 2016 00:00:00 UTC</pubDate>
      
      <guid>http://alimy.me/post/dev_201601161712/</guid>
      <description>

&lt;h3 id=&#34;sect-这些都是什么:a570edf7f9cf5da971e53a3290dfcb84&#34;&gt;&amp;sect;这些都是什么？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;都是操作系统&lt;/li&gt;
&lt;li&gt;都是云计算操作系统&lt;/li&gt;
&lt;li&gt;都是先进的云计算操作系统&lt;/li&gt;
&lt;li&gt;都是小众的先进的云计算操作系统&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;del&gt;讲完收工&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;当然不是这么简单 :)&lt;/p&gt;

&lt;p&gt;但是也不希望写的太长。以下就尽量言简意垓的把来龙去脉，历史纠纷，以及革命先进性都说清楚。&lt;/p&gt;

&lt;h3 id=&#34;sect-从illumos开始:a570edf7f9cf5da971e53a3290dfcb84&#34;&gt;&amp;sect;从illumos开始&lt;/h3&gt;

&lt;p&gt;什么是&lt;a href=&#34;http://www.illumos.org&#34;&gt;illumos&lt;/a&gt;？简单的讲，illumos是OpenSolaris的后续开源项目。万恶的Oracle收购了Sun之后，原有OpenSolaris的开发者基本上都离开了Oracle，组成了illumos社区，继续对OpenSolaris先进的内核进行维护，更新，以及添加nb的新功能。这种事情在Oracle的收购史上似乎一再出现，想想MySQL，OpenOffice，Java，强烈的既视感。&lt;/p&gt;

&lt;p&gt;当然，OpenSolaris不是完蛋了，其实还&lt;a href=&#34;http://solaris.java.net/&#34;&gt;存活着&lt;/a&gt;。不过因为核心开发者的出走，都在illumos那边玩，很多&lt;a href=&#34;http://www.slideshare.net/ahl0003/illumos-innovations-that-will-never-be-in-oracle-solaris&#34;&gt;先进特性&lt;/a&gt;（尤以存储和虚拟化方面为甚）都不再回流。&lt;/p&gt;

&lt;p&gt;illumos继承了所有OpenSolaris的先进特性，例如ZFS，Zone，Crossbow和Dtrace。简单的总结如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ZFS可以说是终极文件系统，提供了卷管理，快照，和所有想得到的nb东西&lt;code&gt;在linux里面，这个功能由
LVM以及一堆不同的文件系统完成&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Zone是OS Container，即操作系统隔离，或者叫做轻量级虚拟机&lt;code&gt;linux在Zone出现5年之后，也
模仿开发了LXC功能&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Crossbow是网络虚拟化，说白了就是将网卡硬件和软件设备分离，一块硬件对应好多个软件设备，并且
提供了nb的虚拟switch支持&lt;code&gt;linux这部分的成果也基本上进入了内核，在几年之后&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dtrace是系统管理员的终极武器，无痛在线勘察系统瓶颈的手术刀&lt;code&gt;MacOSX借用FreeBSD的成果
移植了Dtrace，构成了Xcode中nb闪闪的instruments功能（乔老爷子亲自宣布的），linux这边
限于授权协议问题，则由IBM联合RedHat克隆了一份，名为SystemTap&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后，在joyent公司里面&lt;a href=&#34;http://www.slideshare.net/bcantrill/experiences-porting-kvm-to-smartos&#34;&gt;两位神人的努力下&lt;/a&gt;，KVM被移植到了illumos内核上，于是illumos也拥有了通常所说的&lt;a href=&#34;http://en.wikipedia.org/wiki/Hypervisor&#34;&gt;Type 2虚拟化技术&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;于是illumos = ZFS + Zone + Crossbow + Dtrace + KVM。所有云计算的关键服务在这里集合，形成了一个为云计算而生的系统内核。&lt;/p&gt;

&lt;p&gt;但是需要注意的是illumos只是一个内核（正确的说是，内核(OS)加网络层(Network)，即ON）。在geek的手里，它已经完备;放在生产环境，则还欠缺一个包装。&lt;/p&gt;

&lt;h3 id=&#34;sect-然后是smartos:a570edf7f9cf5da971e53a3290dfcb84&#34;&gt;&amp;sect;然后是SmartOS&lt;/h3&gt;

&lt;p&gt;怎么把illumos包装成通常意义上的OS，这是接下来需要考虑的问题，也是最好的商业化的契机。&lt;/p&gt;

&lt;p&gt;于是就诞生了一批社区和公司围绕着illumos做包装工作，产品谓之发行版。&lt;/p&gt;

&lt;p&gt;第一个明显的方向，即是让GNU工具，也就是通常意义上我们认识的linux部分（Gnome，KDE，X11等等）跑在illumos内核上，组成一个可以天天使用和开发的平台。这方面诞生了&lt;a href=&#34;http://www.openindiana.org&#34;&gt;OpenIndiana&lt;/a&gt;，安装使用这个系统，在感官层次，基本上与linux也区别不大。&lt;/p&gt;

&lt;p&gt;但是illumos的优势毕竟不是在桌面系统，而是在服务器上。所以第二个方向，就是打包成一个可以给数据中心使用的云操作系统。这方面的公司，就有&lt;a href=&#34;http://www.nexenta.com&#34;&gt;nexenta&lt;/a&gt;，&lt;a href=&#34;http://www.delphix.com&#34;&gt;delphix&lt;/a&gt;和&lt;a href=&#34;http://www.joyent.com&#34;&gt;joyent&lt;/a&gt;三家公司。前两者集中火力发挥ZFS存储的威力，对准EMC开炮。joyent则走向了云计算，不仅运营自己的公有云，也提供私有云解决方案。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.smartos.org&#34;&gt;SmartOS&lt;/a&gt;即是joyent在包装illumos方面的答案。joyent将illumos内核和必要的组件和命令行工具，打包成为了一个300MB左右的LiveCD，实现了“启动即拥有云计算能力”这个目标。&lt;/p&gt;

&lt;p&gt;joyent公司其实更加为人熟知的，是其&lt;a href=&#34;http://www.nodejs.org&#34;&gt;nodejs&lt;/a&gt;平台。SmartOS里面的关键命令行工具和组件，都是用nodejs来实现的。用javascript来实现严肃认真的服务器功能，或许这很让人觉得有些不可思议。但是joyent就是这样做的，而且用事实证明，他们干的很不错，实现的效率并不比编译好的二进制程序差。&lt;/p&gt;

&lt;p&gt;因为KVM技术是由joyent第一次整合进入illumos，所以SmartOS理所当然成为第一个能提供KVM服务（即运行CentOS，Ubuntu和Windows）的illumos发行版。鉴于illumos社区的良好风气，&lt;a href=&#34;https://github.com/joyent/illumos-kvm&#34;&gt;KVM on illumos&lt;/a&gt;从一开始就是开源项目，最后也进入illumos内核。&lt;/p&gt;

&lt;p&gt;SmartOS的特点总结如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;继承了illumos所有的特点（ZFS + Zone + Crossbow + Dtrace + KVM）&lt;code&gt;linux近年来，在KVM
和LXC进入内核之后，也逐步具有了以上功能，但是网络虚拟化和Dtrace部分，则始终差一点&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;集成了joyent所开发的vmadm，imgadm等工具软件，使得虚拟化部分具有了可操作性&lt;code&gt;linux系统则是
由libvirt+一系列小工具来完成这些功能&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;秉承LiveOS的理念，强调无需安装，将几乎全部的服务器资源留给了租户&lt;code&gt;linux方面，这方面的进步则
不明显，但是有商业公司进行探讨&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;sect-project-fifo:a570edf7f9cf5da971e53a3290dfcb84&#34;&gt;&amp;sect;Project FiFo&lt;/h3&gt;

&lt;p&gt;SmartOS是纯粹为云计算而生的操作系统，出世之后即引起了群众的注意，开始应用。但是数据中心维护的管理员熟知，安装好方才是梦魇的开始。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;怎么维护系统？&lt;/li&gt;
&lt;li&gt;怎么管理系统的各项资源？&lt;/li&gt;
&lt;li&gt;怎么进行日常的操作？&lt;/li&gt;
&lt;li&gt;怎么监控系统？&lt;/li&gt;
&lt;li&gt;怎么处理系统的故障？&lt;/li&gt;
&lt;li&gt;怎么升级系统？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回答这些问题，方才是系统管理员最终选择一个操作系统的真正考察点。&lt;/p&gt;

&lt;p&gt;SmartOS只可以部分的回答上述问题。&lt;/p&gt;

&lt;p&gt;joyent是一个商业公司，它并没有把所有的东西都放在SmartOS里面让大家免费使用。准确的说，joyent将回答所有上述问题的*能力*，无私的都放在了SmartOS中。但是体现这些能力的*工具*，或者以更为熟知的术语表述，*运维管理系统*，并没有放出来。joyent的运维管理工具，名为SmartDataCenter，是一个商业产品，需要不菲的授权费用才可以使用。&lt;/p&gt;

&lt;p&gt;于是使用SmartOS运营数据中心，就变成如下两种常见的方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;强者不需要任何运维工具。因为既然能力都已经具备，那么实际上所有事情都可以通过一些基本管理工具，以及API的调用完成。换言之，强者会开发自己的运维系统。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不具备开发自己运维系统能力的用户。要么就是小规模的使用SmartOS，生产虚拟机之后，即很长时间不去动弹它（SmartOS的稳定性基本可以保证终身不怎么出问题），要么就是去获取SmartDataCetner的授权。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;如果有一个开源的运维管理系统就好了？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;通常我们都会这么想。&lt;/p&gt;

&lt;p&gt;运维管理系统的开发，理论上来讲，并不是一个很难的事情，只是需要付出大量的时间和开发精力（因此可能illumos内核那帮家伙不屑去做:)）。然而，这套系统又是运维的核心部分，天然的具有巨大的商业价值。因此不排除有些运营SmartOS的商业公司，开发了这套系统，但是并没有将之开源。&lt;/p&gt;

&lt;p&gt;直到&lt;a href=&#34;http://www.project-fifo.net&#34;&gt;Project FiFo&lt;/a&gt;的出现。&lt;/p&gt;

&lt;p&gt;Project FiFo贡献了一套开源SmartOS的运维管理系统，它的开发者主要是德国人&lt;a href=&#34;https://github.com/Licenser&#34;&gt;Heinz N. Gies&lt;/a&gt;。FiFo不仅仅是一套运维系统，实际上它还做了更多，完成了镜像管理，高可用，多数据中心管理等多方面的任务。简言之，Project FiFo解决了前面提出的大多数的问题。&lt;/p&gt;

&lt;p&gt;让我们感谢Heinz先。&lt;/p&gt;

&lt;h3 id=&#34;sect-最后是dogeos:a570edf7f9cf5da971e53a3290dfcb84&#34;&gt;&amp;sect;最后是DogeOS&lt;/h3&gt;

&lt;p&gt;Project FiFo作为一套运维管理系统，补全了SmartOS，但是它并不是SmartOS的一部分。&lt;/p&gt;

&lt;p&gt;简单的说，用户仍然需要先安装SmartOS，再安装好FiFo。注意，SmartOS理论上是没有安装这种概念的，但是FiFo作为管理系统，显然是需要安装以解决持久化的问题的。&lt;/p&gt;

&lt;p&gt;于是用户再一次可能陷入混乱。&lt;/p&gt;

&lt;p&gt;作为一个SmartOS的爱好者，本来我是准备克隆一套SmartDataCenter来扬名立万的:)，但是发现Heinz把这件事情做的这么好，我就放弃了自己开发，转而投入到*粉*Heinz的事业中去。&lt;/p&gt;

&lt;p&gt;直到我发现了Project FiFo还并不是SmartOS一部分这个问题，便开始解决这个问题。&lt;/p&gt;

&lt;p&gt;我计划将SmartOS拆散重组，整合FiFo进去，形成了一个可能稍微好用一点点的系统。&lt;/p&gt;

&lt;p&gt;这个系统被我叫做&lt;a href=&#34;http://www.dogeos.net&#34;&gt;DogeOS&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;一个理想中的，生来用来管理数据中心的，完备的云计算操作系统，终于可能成为现实。&lt;/p&gt;

&lt;p&gt;这让我为之兴奋不已。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://liyu1981.github.io/dogeos-smartos-illumos/&#34; title=&#34;liyu1981&#39;s page&#34;&gt;【转载自liyu1981】&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Markdown</title>
      <link>http://alimy.me/post/dev_201601131558/</link>
      <pubDate>Wed, 13 Jan 2016 00:00:00 UTC</pubDate>
      
      <guid>http://alimy.me/post/dev_201601131558/</guid>
      <description>

&lt;h3 id=&#34;sect-what-is-markdown:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;&amp;sect; What is Markdown?&lt;/h3&gt;

&lt;p&gt;Markdown is a way to style text on the web. You control the display of the
document; formatting words as bold or italic, adding images, and creating lists
are just a few of the things we can do with Markdown. Mostly, Markdown is just
regular text with a few non-alphabetic characters thrown in, like # or *.&lt;br /&gt;
&lt;a href=&#34;http://daringfireball.net/projects/markdown/&#34; title=&#34;Daring FireBall: Home&#34;&gt;[Markdown Reference]&lt;/a&gt; &lt;a href=&#34;https://guides.github.com/features/mastering-markdown/&#34; title=&#34;GitHub&#39;s Mastering Markdown&#34;&gt;[Mastering Markdown]&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;sect-syntax-cheatsheet:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;&amp;sect; Syntax Cheatsheet:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Phrase Emphasis&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt; *italic*   **bold**
 _italic_   __bold__
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;italic&lt;/em&gt;   &lt;strong&gt;bold&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;italic&lt;/em&gt;   &lt;strong&gt;bold&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Links-Inline(titles are optional)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;An [example](http://url.com/ &amp;quot;Title&amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;An &lt;a href=&#34;http://url.com/&#34; title=&#34;Title&#34;&gt;example&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Links-Reference-style labels(titles are optional)&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;[example][id] reference-style link.
[example] [id] reference-style link.
[example][] reference-style link.

[id]: http://example.com/ &amp;quot;Optional Title Here&amp;quot;
[id]: http://example.com/ &#39;Option Tile Here&#39;
[id]: http://example.com/ (Option Tile Here)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reference-style link: &lt;a href=&#34;https://github.com/alimy&#34; title=&#34;alimy&#39;s github&#34;&gt;GitHub&lt;/a&gt; &lt;a href=&#34;https://twitter.com/alimy86&#34; title=&#34;alimy&#39;s twitter&#34;&gt;Twitter&lt;/a&gt; &lt;a href=&#34;http://alimy.me/&#34; title=&#34;alimy&#39;s blog&#34;&gt;Alimy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Images-Inline(titles are optional)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;![alt text](/path/img.jpg &amp;quot;Optional Title Here&amp;quot;)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Images-Reference-style(titles are optional)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![alt text][id]
[id]: /url/to/img.jpg &amp;quot;Optional Title Here&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Headers-Setext-style&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Header 1
========
Header 2
--------
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;header-1:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;Header 1&lt;/h1&gt;

&lt;h2 id=&#34;header-2:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;Header 2&lt;/h2&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Headers-Atx-style(closing #&amp;rsquo;s are optional)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Header 1 #
## Header 2 ##
### Header 3
#### Header 4
##### Header 5
###### Header 6
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;h1 id=&#34;header-1-1:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;Header 1&lt;/h1&gt;

&lt;h2 id=&#34;header-2-1:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;Header 2&lt;/h2&gt;

&lt;h3 id=&#34;header-3:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;Header 3&lt;/h3&gt;

&lt;h4 id=&#34;header-4:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;Header 4&lt;/h4&gt;

&lt;h5 id=&#34;header-5:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;Header 5&lt;/h5&gt;

&lt;h6 id=&#34;header-6:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;Header 6&lt;/h6&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List-Ordered,without paragraphs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;gt;   1. first
  &amp;gt;   2. second
  &amp;gt;   3. Three
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List-Unordered,with paragraphs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;gt;   * A list item.
  &amp;gt;     with multiple paragraphs
  &amp;gt;   * Bar
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Blockquotes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Email-style angle brackets
&amp;gt; are used for blockquotes.


&amp;gt; &amp;gt; And, they can be nested.


&amp;gt; #### Headers in blockquotes
&amp;gt;
&amp;gt; * You can quote a list.
&amp;gt; * Etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Preview below:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Email-style angle brackets
are used for blockquotes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;And, they can be nested.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;headers-in-blockquotes:8a3103bd0efc46558eecfb5aef7eee0d&#34;&gt;Headers in blockquotes&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;You can quote a list.&lt;/li&gt;
&lt;li&gt;Etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Code Spans&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`&amp;lt;code&amp;gt;` spans are delimited by backticks.
You can include literal backticks like `` `this` ``.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Preformatted Code Blocks
Indent every line of a code block by at least 4 spaces or 1 tab.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is a normal paragraph.


  This is a preformatted
  code block.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Preview below:&lt;/p&gt;

&lt;p&gt;This is a normal paragraph.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is a preformatted
code block.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Horizontal Rules&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ---
  ***
  * * *
  - - - -
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Manual Line Breaks&lt;br /&gt;
end a line with two or more spaces:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;Roses are red,  
Violets are blue.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Preview below:&lt;/p&gt;

&lt;p&gt;Roses are red,&lt;br /&gt;
Violets are blue.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Too many open files 的解决方法</title>
      <link>http://alimy.me/post/dev_201601121531/</link>
      <pubDate>Tue, 12 Jan 2016 00:00:00 UTC</pubDate>
      
      <guid>http://alimy.me/post/dev_201601121531/</guid>
      <description>

&lt;h2 id=&#34;由来:24c92de71c82cd5c5c09db7aef53b004&#34;&gt;&amp;gt;由来&lt;/h2&gt;

&lt;p&gt;gogs 打开一个android app库的资源文件夹(/coding/Coding-Android/src/master/app/src/main/res/drawable-xxhdpi)
返回 500&lt;/p&gt;

&lt;h2 id=&#34;源头:24c92de71c82cd5c5c09db7aef53b004&#34;&gt;&amp;gt;源头&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[git@linux gogs]$ ./gogs web
2016/01/12 15:35:31 [T] Custom path: /home/git/opt/gogs/custom
2016/01/12 15:35:31 [T] Log path: /home/git/opt/gogs/log
2016/01/12 15:35:31 [I] Gogs 0.8.19.0111
2016/01/12 15:35:31 [I] Log Mode: File(Info)
2016/01/12 15:35:31 [I] Cache Service Enabled
2016/01/12 15:35:31 [I] Session Service Enabled
2016/01/12 15:35:31 [I] Git Version: 2.5.0
2016/01/12 15:35:31 [I] SQLite3 Supported
2016/01/12 15:35:31 [I] Run Mode: Production
2016/01/12 15:35:31 [T] Doing: CheckRepoStats
2016/01/12 15:35:31 [I] Listen: http://0.0.0.0:2048
[Macaron] Started GET /coding/Coding-Android/src/master/app/src/main/res/drawable-xxhdpi for 127.0.0.1
2016/01/12 15:35:36 [D] Session ID: bd615aa3d0616740
2016/01/12 15:35:36 [D] CSRF Token: Ff7aL72oaVjpxMgcOS0fqcVokWE6MTQ1MjU2NzkxMjM0NTE3Njg2MA==
2016/01/12 15:35:37 [...routers/repo/view.go:134 Home()] [E] GetCommitsInfo: GetCommitByPath (app/src/main/res/drawable-xxhdpi//ic_location_list_check.png): pipe2: too many open files

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;bull; 原来是&lt;code&gt;pipe2: too many open files&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;ulimit:24c92de71c82cd5c5c09db7aef53b004&#34;&gt;&amp;gt;ulimit&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[git@linux gogs]$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 31850
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 4096
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 8182
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;bull; 嗯，(open files)=4096，那也不小啊，gogs君，这是Bug吗？好吧，我改&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;解决方案:24c92de71c82cd5c5c09db7aef53b004&#34;&gt;&amp;gt;解决方案&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[root@linux gogs]# cat /proc/sys/fs/file-max
813396

[root@linux gogs]# ulimit -n 32768

[root@linux gogs]# ulimit -Sn
32768

[root@linux gogs]# ulimit -Hn
65536

[root@linux gogs]# ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 31850
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 32768
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 32768
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;终极方案:24c92de71c82cd5c5c09db7aef53b004&#34;&gt;&amp;gt;终极方案&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[root@linux gogs]# cat /etc/security/limits.conf
# /etc/security/limits.conf
#
#This file sets the resource limits for the users logged in via PAM.
#It does not affect resource limits of the system services.
#
#Also note that configuration files in /etc/security/limits.d directory,
#which are read in alphabetical order, override the settings in this
#file in case the domain is the same or more specific.
#That means for example that setting a limit for wildcard domain here
#can be overriden with a wildcard setting in a config file in the
#subdirectory, but a user specific setting here can be overriden only
#with a user specific setting in the subdirectory.
#
#Each line describes a limit for a user in the form:
#
#&amp;lt;domain&amp;gt;        &amp;lt;type&amp;gt;  &amp;lt;item&amp;gt;  &amp;lt;value&amp;gt;
#
#Where:
#&amp;lt;domain&amp;gt; can be:
#        - a user name
#        - a group name, with @group syntax
#        - the wildcard *, for default entry
#        - the wildcard %, can be also used with %group syntax,
#                 for maxlogin limit
#
#&amp;lt;type&amp;gt; can have the two values:
#        - &amp;quot;soft&amp;quot; for enforcing the soft limits
#        - &amp;quot;hard&amp;quot; for enforcing hard limits
#
#&amp;lt;item&amp;gt; can be one of the following:
#        - core - limits the core file size (KB)
#        - data - max data size (KB)
#        - fsize - maximum filesize (KB)
#        - memlock - max locked-in-memory address space (KB)
#        - nofile - max number of open file descriptors
#        - rss - max resident set size (KB)
#        - stack - max stack size (KB)
#        - cpu - max CPU time (MIN)
#        - nproc - max number of processes
#        - as - address space limit (KB)
#        - maxlogins - max number of logins for this user
#        - maxsyslogins - max number of logins on the system
#        - priority - the priority to run user process with
#        - locks - max number of file locks the user can hold
#        - sigpending - max number of pending signals
#        - msgqueue - max memory used by POSIX message queues (bytes)
#        - nice - max nice priority allowed to raise to values: [-20, 19]
#        - rtprio - max realtime priority
#
#&amp;lt;domain&amp;gt;      &amp;lt;type&amp;gt;  &amp;lt;item&amp;gt;         &amp;lt;value&amp;gt;
#

#*               soft    core            0
#*               hard    rss             10000
#@student        hard    nproc           20
#@faculty        soft    nproc           20
#@faculty        hard    nproc           50
#ftp             hard    nproc           0
#@student        -       maxlogins       4

# End of file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;bull; 编辑这个配置文件修改limits&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@linux gogs]# vi /etc/security/limits.conf

[root@linux gogs]# cat /etc/security/limits.conf
# /etc/security/limits.conf
#
#&amp;lt;domain&amp;gt;      &amp;lt;type&amp;gt;  &amp;lt;item&amp;gt;         &amp;lt;value&amp;gt;
*   soft    nproc   32768
*   hard    nproc   65536
*   soft    nofile  32768
*   hard    nofile  65536
# End of file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;bull; 系统重启后生效。&lt;/p&gt;

&lt;h2 id=&#34;limits-conf的工作原理:24c92de71c82cd5c5c09db7aef53b004&#34;&gt;&amp;gt;limits.conf的工作原理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;limits.conf是pam_limits.so的配置文件&lt;/li&gt;
&lt;li&gt;/etc/pam.d/下的应用程序调用pam_***.so模块&lt;/li&gt;
&lt;li&gt;当用户访问服务器，服务程序将请求发送到PAM模块，PAM模块根据服务名称在/etc/pam.d
目录下选择一个对应的服务文件，然后根据服务文件的内容选择具体的PAM模块进行处理。&lt;/li&gt;
&lt;li&gt;例：限制admin用户登录到sshd的服务不能超过2个
在/etc/pam.d/sshd 中添加 session required pam_limits.so
在/etc/security/limits.conf中添加 admin - maxlogins 2&lt;/li&gt;
&lt;li&gt;查看应用程序能否被PAM支持，用ldd&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;limits-conf文件中的参数配置方式:24c92de71c82cd5c5c09db7aef53b004&#34;&gt;&amp;gt;limits.conf文件中的参数配置方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;暂时地，登录 shell 会话期间使用ulimit 命令配置&lt;/li&gt;
&lt;li&gt;永久地，通过将一个相应的 ulimit 语句添加到由登录 shell 读取的文件之一
（例如 ~/.profile 或者 ~/.bashrc），即特定于 shell 的用户资源文件；
或者通过编辑 /etc/security/limits.conf.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;后记:24c92de71c82cd5c5c09db7aef53b004&#34;&gt;&amp;gt;后记&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;以上方法并没有完全解决gogs:too many files -&amp;gt; return 500的问题,如果以服务的模式运行
&lt;code&gt;[root@linux gogs]# systemctl start gogs.service&lt;/code&gt;问题依然存在，但是在Shell
会话中&lt;code&gt;[git@linux gogs]$ ./gogs web&lt;/code&gt;却没有问题，不再出现too many files 的错误。
Google了一下还是没有什么好的思路，就去github.com/gogits/gogs的Issue中找答案，那里本来
就有一个关于too manyfiles的讨论-&lt;a href=&#34;https://github.com/gogits/gogs/issues/1270&#34;&gt;[GitHub Issue]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原来是sysemd在搞怪。systemd对limits的配置是在相应的服务定义文件中（如gogs的服务定义是在
/usr/lib/systemd/system/gogs.service），如果需要配置相应的limits，systemd
提供了对应的&lt;code&gt;directive&lt;/code&gt;(eg: &lt;code&gt;LimitNOFILE&lt;/code&gt; &lt;code&gt;LimitMEMLOCK&lt;/code&gt; &amp;hellip;)，
systemd忽略通过ulimit配置的limits（是否理会/etc/security/limits.conf中的配置以及如
何响应就不得而知了，没有深究）对systemd不是特别了解，有时间再深入研究。&lt;/li&gt;
&lt;li&gt;下面是我的gogs.service&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;[git@linux gogs]$ cat /usr/lib/systemd/system/gogs.service
[Unit]
Description=Gogs (Go Git Service)
After=syslog.target
After=network.target

[Service]
LimitMEMLOCK=infinity
LimitNOFILE=65535
Type=simple
User=git
Group=git
WorkingDirectory=/home/git/opt/gogs
ExecStart=/home/git/opt/gogs/gogs web
Restart=always
Environment=USER=git HOME=/home/git

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于TOML</title>
      <link>http://alimy.me/post/dev_201601031221/</link>
      <pubDate>Sun, 03 Jan 2016 00:00:00 UTC</pubDate>
      
      <guid>http://alimy.me/post/dev_201601031221/</guid>
      <description>

&lt;h2 id=&#34;toml的由来:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;TOML的由来&lt;/h2&gt;

&lt;p&gt;TOML的全称是　Tom&amp;rsquo;s Obvious, Minimal Language，因为它是GitHub　前CEO,联合创始人
Tom Preston-Werner 于2013年创建的语言。&lt;/p&gt;

&lt;p&gt;配置文件的使用由来已久，从.ini、XML、JSON、YAML再到TOML，语言的表达能力越来越强，同时书
写便捷性也在不断提升。&lt;/p&gt;

&lt;h2 id=&#34;toml-的目标:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;TOML 的目标&lt;/h2&gt;

&lt;p&gt;TOML的目标是成为一个小规模的易于使用的语义化配置文件格式。TOML被设计为可以无二义性的转换
为一个哈希表(Hash table)，从而被多种语言解析。&lt;/p&gt;

&lt;h3 id=&#34;例子:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;title = &amp;quot;TOML 例子&amp;quot;

[owner]
name = &amp;quot;Tom Preston-Werner&amp;quot;
organization = &amp;quot;GitHub&amp;quot;
bio = &amp;quot;GitHub Cofounder &amp;amp; CEO\nLikes tater tots and beer.&amp;quot;
dob = 1979-05-27T07:32:00Z # 日期时间是一等公民。为什么不呢？

[database]
server = &amp;quot;192.168.1.1&amp;quot;
ports = [ 8001, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  # 你可以依照你的意愿缩进。使用空格或Tab。TOML不会在意。
  [servers.alpha]
  ip = &amp;quot;10.0.0.1&amp;quot;
  dc = &amp;quot;eqdc10&amp;quot;

  [servers.beta]
  ip = &amp;quot;10.0.0.2&amp;quot;
  dc = &amp;quot;eqdc10&amp;quot;

[clients]
data = [ [&amp;quot;gamma&amp;quot;, &amp;quot;delta&amp;quot;], [1, 2] ]

# 在数组里换行没有关系。
hosts = [
  &amp;quot;alpha&amp;quot;,
  &amp;quot;omega&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TOML是大小写敏感的。&lt;/p&gt;

&lt;h3 id=&#34;注释:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;注释&lt;/h3&gt;

&lt;p&gt;使用 # 表示注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# I am a comment. Hear me roar. Roar.
key = &amp;quot;value&amp;quot; # Yeah, you can do this.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字符串:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;字符串&lt;/h3&gt;

&lt;p&gt;字符串和 JSON 的定义一致，只有一点除外：　TOML 要求使用　UTF-8 编码。&lt;/p&gt;

&lt;p&gt;注释以引号包裹，里面的字符必须是　UTF-8 格式。引号、反斜杠和控制字符（U+0000 到 U+001F）
需要转义。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;I&#39;m a string. \&amp;quot;You can quote me\&amp;quot;. Name\tJos\u00E9\nLocation\tSF.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用的转义序列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\b     - backspace       (U+0008)
\t     - tab             (U+0009)
\n     - linefeed        (U+000A)
\f     - form feed       (U+000C)
\r     - carriage return (U+000D)
\&amp;quot;     - quote           (U+0022)
\/     - slash           (U+002F)
\\     - backslash       (U+005C)
\uXXXX - unicode         (U+XXXX)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用保留的特殊字符，TOML　会抛出错误。例如，在　Windows 平台上，应该使用两个反斜杠来表示
路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wrong = &amp;quot;C:\Users\nodejs\templates&amp;quot; # 注意：这不会生成合法的路径。
right = &amp;quot;C:\\Users\\nodejs\\templates&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二进制数据建议使用　Base64　或其他合适的编码。具体的处理取决于特定的应用。&lt;/p&gt;

&lt;h3 id=&#34;整数:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;整数&lt;/h3&gt;

&lt;p&gt;整数就是一些没有小数点的数字。想用负数？按直觉来就行。整数的尺寸最小为64位。&lt;/p&gt;

&lt;h3 id=&#34;浮点数:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;浮点数&lt;/h3&gt;

&lt;p&gt;浮点数带小数点。小数点两边都有数字。64位精度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.1415
-0.01
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;布尔值:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;布尔值&lt;/h3&gt;

&lt;p&gt;布尔值永远是小写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;true
false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;日期时间:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;日期时间&lt;/h3&gt;

&lt;p&gt;使用　ISO 8601　完整格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1979-05-27T07:32:00Z
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数组:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;数组&lt;/h3&gt;

&lt;p&gt;数组使用方括号包裹。空格会被忽略。元素使用逗号分隔。注意，不允许混用数据类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ 1, 2, 3 ]
[ &amp;quot;red&amp;quot;, &amp;quot;yellow&amp;quot;, &amp;quot;green&amp;quot; ]
[ [ 1, 2 ], [3, 4, 5] ]
[ [ 1, 2 ], [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;] ] # 这是可以的。
[ 1, 2.0 ] # 注意：这是不行的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组可以多行。也就是说，除了空格之外，方括号间的换行也会被忽略。在关闭方括号前的最终项后的
逗号是允许的。&lt;/p&gt;

&lt;h3 id=&#34;表格:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;表格&lt;/h3&gt;

&lt;p&gt;表格（也叫哈希表或字典）是键值对的集合。它们在方括号内，自成一行。注意和数组相区分，数组只
有值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[table]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此之下，直到下一个　table 或　EOF 之前，是这个表格的键值对。键在左，值在右，等号在中间。
键以非空字符开始，以等号前的非空字符为结尾。键值对是无序的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[table]
key = &amp;quot;value&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以随意缩进，使用 Tab 或空格。为什么要缩进呢？因为你可以嵌套表格。&lt;/p&gt;

&lt;p&gt;嵌套表格的表格名称中使用.。你可以任意命名你的表格，只是不要用点，点是保留的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[dog.tater]
type = &amp;quot;pug&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上等价于如下的 JSON 结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ &amp;quot;dog&amp;quot;: { &amp;quot;tater&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;pug&amp;quot; } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不想的话，你不用声明所有的父表。TOML　知道该如何处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# [x] 你
# [x.y] 不需要
# [x.y.z] 这些
[x.y.z.w] # 可以直接写
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空表是允许的，其中没有键值对。&lt;/p&gt;

&lt;p&gt;只要父表没有被直接定义，而且没有定义一个特定的键，你可以继续写入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a.b]
c = 1

[a]
d = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而你不能多次定义键和表格。这么做是不合法的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 别这么干！

[a]
b = 1

[a]
c = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# 也别这个干

[a]
b = 1

[a.b]
c = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;表格数组:c808c7cfd184060a6bdad6a24f7f1e55&#34;&gt;表格数组&lt;/h3&gt;

&lt;p&gt;最后要介绍的类型是表格数组。表格数组可以通过包裹在双方括号内的表格名来表达。使用相同的双方
括号名称的表格是同一个数组的元素。表格按照书写的顺序插入。双方括号表格如果没有键值对，会被
当成空表。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[products]]
name = &amp;quot;Hammer&amp;quot;
sku = 738594937

[[products]]

[[products]]
name = &amp;quot;Nail&amp;quot;
sku = 284758393
color = &amp;quot;gray&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价于以下的　JSON 结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;products&amp;quot;: [
    { &amp;quot;name&amp;quot;: &amp;quot;Hammer&amp;quot;, &amp;quot;sku&amp;quot;: 738594937 },
    { },
    { &amp;quot;name&amp;quot;: &amp;quot;Nail&amp;quot;, &amp;quot;sku&amp;quot;: 284758393, &amp;quot;color&amp;quot;: &amp;quot;gray&amp;quot; }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表格数组同样可以嵌套。只需在子表格上使用相同的双方括号语法。每一个双方括号子表格回从属于最
近定义的上层表格元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[fruit]]
  name = &amp;quot;apple&amp;quot;

  [fruit.physical]
    color = &amp;quot;red&amp;quot;
    shape = &amp;quot;round&amp;quot;

  [[fruit.variety]]
    name = &amp;quot;red delicious&amp;quot;

  [[fruit.variety]]
    name = &amp;quot;granny smith&amp;quot;

[[fruit]]
  name = &amp;quot;banana&amp;quot;

  [[fruit.variety]]
    name = &amp;quot;plantain&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价于如下的　JSON 结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;fruit&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;apple&amp;quot;,
      &amp;quot;physical&amp;quot;: {
        &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,
        &amp;quot;shape&amp;quot;: &amp;quot;round&amp;quot;
      },
      &amp;quot;variety&amp;quot;: [
        { &amp;quot;name&amp;quot;: &amp;quot;red delicious&amp;quot; },
        { &amp;quot;name&amp;quot;: &amp;quot;granny smith&amp;quot; }
      ]
    },
    {
      &amp;quot;name&amp;quot;: &amp;quot;banana&amp;quot;,
      &amp;quot;variety&amp;quot;: [
        { &amp;quot;name&amp;quot;: &amp;quot;plantain&amp;quot; }
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尝试定义一个普通的表格，使用已经定义的数组的名称，将抛出一个解析错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 不合法的　TOML

[[fruit]]
  name = &amp;quot;apple&amp;quot;

  [[fruit.variety]]
    name = &amp;quot;red delicious&amp;quot;

  # 和上面冲突了
  [fruit.variety]
    name = &amp;quot;granny smith&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>TOML v0.4.0</title>
      <link>http://alimy.me/post/dev_201601021221/</link>
      <pubDate>Sat, 02 Jan 2016 00:00:00 UTC</pubDate>
      
      <guid>http://alimy.me/post/dev_201601021221/</guid>
      <description>

&lt;p&gt;Tom&amp;rsquo;s Obvious, Minimal Language.&lt;/p&gt;

&lt;p&gt;By Tom Preston-Werner.&lt;/p&gt;

&lt;p&gt;Be warned, this spec is still changing a lot. Until it&amp;rsquo;s marked as 1.0, you
should assume that it is unstable and act accordingly.&lt;/p&gt;

&lt;h2 id=&#34;objectives:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Objectives&lt;/h2&gt;

&lt;p&gt;TOML aims to be a minimal configuration file format that&amp;rsquo;s easy to read due to
obvious semantics. TOML is designed to map unambiguously to a hash table. TOML
should be easy to parse into data structures in a wide variety of languages.&lt;/p&gt;

&lt;h2 id=&#34;example:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# This is a TOML document. Boom.

title = &amp;quot;TOML Example&amp;quot;

[owner]
name = &amp;quot;Lance Uppercut&amp;quot;
dob = 1979-05-27T07:32:00-08:00 # First class dates? Why not?

[database]
server = &amp;quot;192.168.1.1&amp;quot;
ports = [ 8001, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  # You can indent as you please. Tabs or spaces. TOML don&#39;t care.
  [servers.alpha]
  ip = &amp;quot;10.0.0.1&amp;quot;
  dc = &amp;quot;eqdc10&amp;quot;

  [servers.beta]
  ip = &amp;quot;10.0.0.2&amp;quot;
  dc = &amp;quot;eqdc10&amp;quot;

[clients]
data = [ [&amp;quot;gamma&amp;quot;, &amp;quot;delta&amp;quot;], [1, 2] ]

# Line breaks are OK when inside arrays
hosts = [
  &amp;quot;alpha&amp;quot;,
  &amp;quot;omega&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;spec:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Spec&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TOML is case sensitive.&lt;/li&gt;
&lt;li&gt;A TOML file must contain only UTF-8 encoded Unicode characters.&lt;/li&gt;
&lt;li&gt;Whitespace means tab (0x09) or space (0x20).&lt;/li&gt;
&lt;li&gt;Newline means LF (0x0A) or CRLF (0x0D0A).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;comment:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Comment&lt;/h2&gt;

&lt;p&gt;Speak your mind with the hash symbol. They go from the symbol to the end of the
line.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# I am a comment. Hear me roar. Roar.
key = &amp;quot;value&amp;quot; # Yeah, you can do this.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;string:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;String&lt;/h2&gt;

&lt;p&gt;There are four ways to express strings: basic, multi-line basic, literal, and
multi-line literal. All strings must contain only valid UTF-8 characters.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Basic strings&lt;/strong&gt; are surrounded by quotation marks. Any Unicode character may
be used except those that must be escaped: quotation mark, backslash, and the
control characters (U+0000 to U+001F).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;&amp;quot;I&#39;m a string. \&amp;quot;You can quote me\&amp;quot;. Name\tJos\u00E9\nLocation\tSF.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For convenience, some popular characters have a compact escape sequence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\b         - backspace       (U+0008)
\t         - tab             (U+0009)
\n         - linefeed        (U+000A)
\f         - form feed       (U+000C)
\r         - carriage return (U+000D)
\&amp;quot;         - quote           (U+0022)
\\         - backslash       (U+005C)
\uXXXX     - unicode         (U+XXXX)
\UXXXXXXXX - unicode         (U+XXXXXXXX)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any Unicode character may be escaped with the &lt;code&gt;\uXXXX&lt;/code&gt; or &lt;code&gt;\UXXXXXXXX&lt;/code&gt; forms.
The escape codes must be valid Unicode &lt;a href=&#34;http://unicode.org/glossary/#unicode_scalar_value&#34;&gt;scalar values&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All other escape sequences not listed above are reserved and, if used, TOML
should produce an error.&lt;/p&gt;

&lt;p&gt;Sometimes you need to express passages of text (e.g. translation files) or would
like to break up a very long string into multiple lines. TOML makes this easy.
&lt;strong&gt;Multi-line basic strings&lt;/strong&gt; are surrounded by three quotation marks on each
side and allow newlines. A newline immediately following the opening delimiter
will be trimmed. All other whitespace and newline characters remain intact.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;key1 = &amp;quot;&amp;quot;&amp;quot;
Roses are red
Violets are blue&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TOML parsers should feel free to normalize newline to whatever makes sense for
their platform.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# On a Unix system, the above multi-line string will most likely be the same as:
key2 = &amp;quot;Roses are red\nViolets are blue&amp;quot;

# On a Windows system, it will most likely be equivalent to:
key3 = &amp;quot;Roses are red\r\nViolets are blue&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For writing long strings without introducing extraneous whitespace, end a line
with a &lt;code&gt;\&lt;/code&gt;. The &lt;code&gt;\&lt;/code&gt; will be trimmed along with all whitespace (including
newlines) up to the next non-whitespace character or closing delimiter. If the
first characters after the opening delimiter are a backslash and a newline, then
they will both be trimmed along with all whitespace and newlines up to the next
non-whitespace character or closing delimiter. All of the escape sequences that
are valid for basic strings are also valid for multi-line basic strings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# The following strings are byte-for-byte equivalent:
key1 = &amp;quot;The quick brown fox jumps over the lazy dog.&amp;quot;

key2 = &amp;quot;&amp;quot;&amp;quot;
The quick brown \


  fox jumps over \
    the lazy dog.&amp;quot;&amp;quot;&amp;quot;

key3 = &amp;quot;&amp;quot;&amp;quot;\
       The quick brown \
       fox jumps over \
       the lazy dog.\
       &amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any Unicode character may be used except those that must be escaped: backslash
and the control characters (U+0000 to U+001F). Quotation marks need not be
escaped unless their presence would create a premature closing delimiter.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re a frequent specifier of Windows paths or regular expressions, then
having to escape backslashes quickly becomes tedious and error prone. To help,
TOML supports literal strings where there is no escaping allowed at all.
&lt;strong&gt;Literal strings&lt;/strong&gt; are surrounded by single quotes. Like basic strings, they
must appear on a single line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# What you see is what you get.
winpath  = &#39;C:\Users\nodejs\templates&#39;
winpath2 = &#39;\\ServerX\admin$\system32\&#39;
quoted   = &#39;Tom &amp;quot;Dubs&amp;quot; Preston-Werner&#39;
regex    = &#39;&amp;lt;\i\c*\s*&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since there is no escaping, there is no way to write a single quote inside a
literal string enclosed by single quotes. Luckily, TOML supports a multi-line
version of literal strings that solves this problem. &lt;strong&gt;Multi-line literal
strings&lt;/strong&gt; are surrounded by three single quotes on each side and allow newlines.
Like literal strings, there is no escaping whatsoever. A newline immediately
following the opening delimiter will be trimmed. All other content between the
delimiters is interpreted as-is without modification.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;regex2 = &#39;&#39;&#39;I [dw]on&#39;t need \d{2} apples&#39;&#39;&#39;
lines  = &#39;&#39;&#39;
The first newline is
trimmed in raw strings.
   All other whitespace
   is preserved.
&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For binary data it is recommended that you use Base64 or another suitable ASCII
or UTF-8 encoding. The handling of that encoding will be application specific.&lt;/p&gt;

&lt;h2 id=&#34;integer:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Integer&lt;/h2&gt;

&lt;p&gt;Integers are whole numbers. Positive numbers may be prefixed with a plus sign.
Negative numbers are prefixed with a minus sign.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;+99
42
0
-17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For large numbers, you may use underscores to enhance readability. Each
underscore must be surrounded by at least one digit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;1_000
5_349_221
1_2_3_4_5     # valid but inadvisable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Leading zeros are not allowed. Hex, octal, and binary forms are not allowed.
Values such as &amp;ldquo;infinity&amp;rdquo; and &amp;ldquo;not a number&amp;rdquo; that cannot be expressed as a
series of digits are not allowed.&lt;/p&gt;

&lt;p&gt;64 bit (signed long) range expected (âˆ’9,223,372,036,854,775,808 to
9,223,372,036,854,775,807).&lt;/p&gt;

&lt;h2 id=&#34;float:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Float&lt;/h2&gt;

&lt;p&gt;A float consists of an integer part (which may be prefixed with a plus or minus
sign) followed by a fractional part and/or an exponent part. If both a
fractional part and exponent part are present, the fractional part must precede
the exponent part.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# fractional
+1.0
3.1415
-0.01

# exponent
5e+22
1e6
-2E-2

# both
6.626e-34
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A fractional part is a decimal point followed by one or more digits.&lt;/p&gt;

&lt;p&gt;An exponent part is an E (upper or lower case) followed by an integer part
(which may be prefixed with a plus or minus sign).&lt;/p&gt;

&lt;p&gt;Similar to integers, you may use underscores to enhance readability. Each
underscore must be surrounded by at least one digit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;9_224_617.445_991_228_313
1e1_000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;64-bit (double) precision expected.&lt;/p&gt;

&lt;h2 id=&#34;boolean:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Boolean&lt;/h2&gt;

&lt;p&gt;Booleans are just the tokens you&amp;rsquo;re used to. Always lowercase.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;true
false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;datetime:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Datetime&lt;/h2&gt;

&lt;p&gt;Datetimes are &lt;a href=&#34;http://tools.ietf.org/html/rfc3339&#34;&gt;RFC 3339&lt;/a&gt; dates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;1979-05-27T07:32:00Z
1979-05-27T00:32:00-07:00
1979-05-27T00:32:00.999999-07:00
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;array:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Array&lt;/h2&gt;

&lt;p&gt;Arrays are square brackets with other primitives inside. Whitespace is ignored.
Elements are separated by commas. Data types may not be mixed (though all string
types should be considered the same type).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[ 1, 2, 3 ]
[ &amp;quot;red&amp;quot;, &amp;quot;yellow&amp;quot;, &amp;quot;green&amp;quot; ]
[ [ 1, 2 ], [3, 4, 5] ]
[ &amp;quot;all&amp;quot;, &#39;strings&#39;, &amp;quot;&amp;quot;&amp;quot;are the same&amp;quot;&amp;quot;&amp;quot;, &#39;&#39;&#39;type&#39;&#39;&#39;] # this is ok
[ [ 1, 2 ], [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;] ] # this is ok
[ 1, 2.0 ] # note: this is NOT ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arrays can also be multiline. So in addition to ignoring whitespace, arrays also
ignore newlines between the brackets. Terminating commas are ok before the
closing bracket.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;key = [
  1, 2, 3
]

key = [
  1,
  2, # this is ok
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;table:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Table&lt;/h2&gt;

&lt;p&gt;Tables (also known as hash tables or dictionaries) are collections of key/value
pairs. They appear in square brackets on a line by themselves. You can tell them
apart from arrays because arrays are only ever values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[table]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Under that, and until the next table or EOF are the key/values of that table.
Keys are on the left of the equals sign and values are on the right. Whitespace
is ignored around key names and values. The key, equals sign, and value must
be on the same line (though some values can be broken over multiple lines).&lt;/p&gt;

&lt;p&gt;Keys may be either bare or quoted. &lt;strong&gt;Bare keys&lt;/strong&gt; may only contain letters,
numbers, underscores, and dashes (&lt;code&gt;A-Za-z0-9_-&lt;/code&gt;). &lt;strong&gt;Quoted keys&lt;/strong&gt; follow the
exact same rules as basic strings and allow you to use a much broader set of key
names. Best practice is to use bare keys except when absolutely necessary.&lt;/p&gt;

&lt;p&gt;Key/value pairs within tables are not guaranteed to be in any specific order.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[table]
key = &amp;quot;value&amp;quot;
bare_key = &amp;quot;value&amp;quot;
bare-key = &amp;quot;value&amp;quot;

&amp;quot;127.0.0.1&amp;quot; = &amp;quot;value&amp;quot;
&amp;quot;character encoding&amp;quot; = &amp;quot;value&amp;quot;
&amp;quot;ÊŽÇÊž&amp;quot; = &amp;quot;value&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dots are prohibited in bare keys because dots are used to signify nested tables!
Naming rules for each dot separated part are the same as for keys (see above).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dog.&amp;quot;tater.man&amp;quot;]
type = &amp;quot;pug&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In JSON land, that would give you the following structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &amp;quot;dog&amp;quot;: { &amp;quot;tater.man&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;pug&amp;quot; } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whitespace around dot-separated parts is ignored, however, best practice is to
not use any extraneous whitespace.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[a.b.c]          # this is best practice
[ d.e.f ]        # same as [d.e.f]
[ g .  h  . i ]  # same as [g.h.i]
[ j . &amp;quot;Êž&amp;quot; . l ]  # same as [j.&amp;quot;Êž&amp;quot;.l]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You don&amp;rsquo;t need to specify all the super-tables if you don&amp;rsquo;t want to. TOML knows
how to do it for you.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# [x] you
# [x.y] don&#39;t
# [x.y.z] need these
[x.y.z.w] # for this to work
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Empty tables are allowed and simply have no key/value pairs within them.&lt;/p&gt;

&lt;p&gt;As long as a super-table hasn&amp;rsquo;t been directly defined and hasn&amp;rsquo;t defined a
specific key, you may still write to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[a.b]
c = 1

[a]
d = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You cannot define any key or table more than once. Doing so is invalid.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# DO NOT DO THIS

[a]
b = 1

[a]
c = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# DO NOT DO THIS EITHER

[a]
b = 1

[a.b]
c = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All table names and keys must be non-empty.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# NOT VALID TOML
[]
[a.]
[a..b]
[.b]
[.]
 = &amp;quot;no key name&amp;quot; # not allowed
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;inline-table:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Inline Table&lt;/h2&gt;

&lt;p&gt;Inline tables provide a more compact syntax for expressing tables. They are
especially useful for grouped data that can otherwise quickly become verbose.
Inline tables are enclosed in curly braces &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;. Within the braces, zero
or more comma separated key/value pairs may appear. Key/value pairs take the
same form as key/value pairs in standard tables. All value types are allowed,
including inline tables.&lt;/p&gt;

&lt;p&gt;Inline tables are intended to appear on a single line. No newlines are allowed
between the curly braces unless they are valid within a value. Even so, it is
strongly discouraged to break an inline table onto multiples lines. If you find
yourself gripped with this desire, it means you should be using standard tables.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;name = { first = &amp;quot;Tom&amp;quot;, last = &amp;quot;Preston-Werner&amp;quot; }
point = { x = 1, y = 2 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The inline tables above are identical to the following standard table
definitions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[name]
first = &amp;quot;Tom&amp;quot;
last = &amp;quot;Preston-Werner&amp;quot;

[point]
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;array-of-tables:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Array of Tables&lt;/h2&gt;

&lt;p&gt;The last type that has not yet been expressed is an array of tables. These can
be expressed by using a table name in double brackets. Each table with the same
double bracketed name will be an element in the array. The tables are inserted
in the order encountered. A double bracketed table without any key/value pairs
will be considered an empty table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[products]]
name = &amp;quot;Hammer&amp;quot;
sku = 738594937

[[products]]

[[products]]
name = &amp;quot;Nail&amp;quot;
sku = 284758393
color = &amp;quot;gray&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In JSON land, that would give you the following structure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;products&amp;quot;: [
    { &amp;quot;name&amp;quot;: &amp;quot;Hammer&amp;quot;, &amp;quot;sku&amp;quot;: 738594937 },
    { },
    { &amp;quot;name&amp;quot;: &amp;quot;Nail&amp;quot;, &amp;quot;sku&amp;quot;: 284758393, &amp;quot;color&amp;quot;: &amp;quot;gray&amp;quot; }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can create nested arrays of tables as well. Just use the same double bracket
syntax on sub-tables. Each double-bracketed sub-table will belong to the most
recently defined table element above it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[fruit]]
  name = &amp;quot;apple&amp;quot;

  [fruit.physical]
    color = &amp;quot;red&amp;quot;
    shape = &amp;quot;round&amp;quot;

  [[fruit.variety]]
    name = &amp;quot;red delicious&amp;quot;

  [[fruit.variety]]
    name = &amp;quot;granny smith&amp;quot;

[[fruit]]
  name = &amp;quot;banana&amp;quot;

  [[fruit.variety]]
    name = &amp;quot;plantain&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above TOML maps to the following JSON.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;fruit&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;apple&amp;quot;,
      &amp;quot;physical&amp;quot;: {
        &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,
        &amp;quot;shape&amp;quot;: &amp;quot;round&amp;quot;
      },
      &amp;quot;variety&amp;quot;: [
        { &amp;quot;name&amp;quot;: &amp;quot;red delicious&amp;quot; },
        { &amp;quot;name&amp;quot;: &amp;quot;granny smith&amp;quot; }
      ]
    },
    {
      &amp;quot;name&amp;quot;: &amp;quot;banana&amp;quot;,
      &amp;quot;variety&amp;quot;: [
        { &amp;quot;name&amp;quot;: &amp;quot;plantain&amp;quot; }
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Attempting to define a normal table with the same name as an already established
array must produce an error at parse time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# INVALID TOML DOC
[[fruit]]
  name = &amp;quot;apple&amp;quot;

  [[fruit.variety]]
    name = &amp;quot;red delicious&amp;quot;

  # This table conflicts with the previous table
  [fruit.variety]
    name = &amp;quot;granny smith&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may also use inline tables where appropriate:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;points = [ { x = 1, y = 2, z = 3 },
           { x = 7, y = 8, z = 9 },
           { x = 2, y = 4, z = 8 } ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;seriously:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Seriously?&lt;/h2&gt;

&lt;p&gt;Yep.&lt;/p&gt;

&lt;h2 id=&#34;but-why:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;But why?&lt;/h2&gt;

&lt;p&gt;Because we need a decent human-readable format that unambiguously maps to a hash
table and the YAML spec is like 80 pages long and gives me rage. No, JSON
doesn&amp;rsquo;t count. You know why.&lt;/p&gt;

&lt;h2 id=&#34;oh-god-you-re-right:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Oh god, you&amp;rsquo;re right&lt;/h2&gt;

&lt;p&gt;Yuuuup. Wanna help? Send a pull request. Or write a parser. BE BRAVE.&lt;/p&gt;

&lt;h2 id=&#34;projects-using-toml:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Projects using TOML&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://doc.crates.io/&#34;&gt;Cargo&lt;/a&gt; - The Rust language&amp;rsquo;s package manager.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://influxdb.com/&#34;&gt;InfluxDB&lt;/a&gt; - Distributed time series database.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hekad.readthedocs.org&#34;&gt;Heka&lt;/a&gt; - Stream processing system by Mozilla.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; - Static site generator in Go.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;implementations:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Implementations&lt;/h2&gt;

&lt;p&gt;If you have an implementation, send a pull request adding to this list. Please
note the commit SHA1 or version tag that your parser supports in your Readme.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C#/.NET - &lt;a href=&#34;https://github.com/LBreedlove/Toml.net&#34;&gt;https://github.com/LBreedlove/Toml.net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C#/.NET - &lt;a href=&#34;https://github.com/rossipedia/toml-net&#34;&gt;https://github.com/rossipedia/toml-net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C#/.NET - &lt;a href=&#34;https://github.com/RichardVasquez/TomlDotNet&#34;&gt;https://github.com/RichardVasquez/TomlDotNet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C#/.NET - &lt;a href=&#34;https://github.com/azyobuzin/HyperTomlProcessor&#34;&gt;https://github.com/azyobuzin/HyperTomlProcessor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C (@ajwans) - &lt;a href=&#34;https://github.com/ajwans/libtoml&#34;&gt;https://github.com/ajwans/libtoml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C (@mzgoddard) - &lt;a href=&#34;https://github.com/mzgoddard/tomlc&#34;&gt;https://github.com/mzgoddard/tomlc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C++ (@evilncrazy) - &lt;a href=&#34;https://github.com/evilncrazy/ctoml&#34;&gt;https://github.com/evilncrazy/ctoml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C++ (@skystrife) - &lt;a href=&#34;https://github.com/skystrife/cpptoml&#34;&gt;https://github.com/skystrife/cpptoml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C++ (@mayah) - &lt;a href=&#34;https://github.com/mayah/tinytoml&#34;&gt;https://github.com/mayah/tinytoml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clojure (@lantiga) - &lt;a href=&#34;https://github.com/lantiga/clj-toml&#34;&gt;https://github.com/lantiga/clj-toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clojure (@manicolosi) - &lt;a href=&#34;https://github.com/manicolosi/clojoml&#34;&gt;https://github.com/manicolosi/clojoml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CoffeeScript (@biilmann) - &lt;a href=&#34;https://github.com/biilmann/coffee-toml&#34;&gt;https://github.com/biilmann/coffee-toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Common Lisp (@pnathan) - &lt;a href=&#34;https://github.com/pnathan/pp-toml&#34;&gt;https://github.com/pnathan/pp-toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;D - &lt;a href=&#34;https://github.com/iccodegr/toml.d&#34;&gt;https://github.com/iccodegr/toml.d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dart (@just95) - &lt;a href=&#34;https://github.com/just95/toml.dart&#34;&gt;https://github.com/just95/toml.dart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Erlang - &lt;a href=&#34;https://github.com/kalta/etoml.git&#34;&gt;https://github.com/kalta/etoml.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Erlang - &lt;a href=&#34;https://github.com/kaos/tomle&#34;&gt;https://github.com/kaos/tomle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Emacs Lisp (@gongoZ) - &lt;a href=&#34;https://github.com/gongo/emacs-toml&#34;&gt;https://github.com/gongo/emacs-toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go (@thompelletier) - &lt;a href=&#34;https://github.com/pelletier/go-toml&#34;&gt;https://github.com/pelletier/go-toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go (@laurent22) - &lt;a href=&#34;https://github.com/laurent22/toml-go&#34;&gt;https://github.com/laurent22/toml-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go w/ Reflection (@BurntSushi) - &lt;a href=&#34;https://github.com/BurntSushi/toml&#34;&gt;https://github.com/BurntSushi/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go (@achun) - &lt;a href=&#34;https://github.com/achun/tom-toml&#34;&gt;https://github.com/achun/tom-toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go (@naoina) - &lt;a href=&#34;https://github.com/naoina/toml&#34;&gt;https://github.com/naoina/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Haskell (@seliopou) - &lt;a href=&#34;https://github.com/seliopou/toml&#34;&gt;https://github.com/seliopou/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Haxe (@raincole) - &lt;a href=&#34;https://github.com/raincole/haxetoml&#34;&gt;https://github.com/raincole/haxetoml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java (@agrison) - &lt;a href=&#34;https://github.com/agrison/jtoml&#34;&gt;https://github.com/agrison/jtoml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java (@johnlcox) - &lt;a href=&#34;https://github.com/johnlcox/toml4j&#34;&gt;https://github.com/johnlcox/toml4j&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java (@mwanji) - &lt;a href=&#34;https://github.com/mwanji/toml4j&#34;&gt;https://github.com/mwanji/toml4j&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java - &lt;a href=&#34;https://github.com/asafh/jtoml&#34;&gt;https://github.com/asafh/jtoml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java w/ ANTLR (@MatthiasSchuetz) - &lt;a href=&#34;https://github.com/mschuetz/toml&#34;&gt;https://github.com/mschuetz/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Julia (@pygy) - &lt;a href=&#34;https://github.com/pygy/TOML.jl&#34;&gt;https://github.com/pygy/TOML.jl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Literate CoffeeScript (@JonathanAbrams) - &lt;a href=&#34;https://github.com/JonAbrams/tomljs&#34;&gt;https://github.com/JonAbrams/tomljs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nim (@ziotom78) - &lt;a href=&#34;https://github.com/ziotom78/parsetoml&#34;&gt;https://github.com/ziotom78/parsetoml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;node.js/browser - &lt;a href=&#34;https://github.com/ricardobeat/toml.js&#34;&gt;https://github.com/ricardobeat/toml.js&lt;/a&gt; (npm install tomljs)&lt;/li&gt;
&lt;li&gt;node.js - &lt;a href=&#34;https://github.com/BinaryMuse/toml-node&#34;&gt;https://github.com/BinaryMuse/toml-node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;node.js/browser (@redhotvengeance) - &lt;a href=&#34;https://github.com/redhotvengeance/topl&#34;&gt;https://github.com/redhotvengeance/topl&lt;/a&gt; (topl npm package)&lt;/li&gt;
&lt;li&gt;node.js/browser (@alexanderbeletsky) - &lt;a href=&#34;https://github.com/alexanderbeletsky/toml-js&#34;&gt;https://github.com/alexanderbeletsky/toml-js&lt;/a&gt; (npm browser amd)&lt;/li&gt;
&lt;li&gt;Objective C (@mneorr) - &lt;a href=&#34;https://github.com/mneorr/toml-objc.git&#34;&gt;https://github.com/mneorr/toml-objc.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Objective-C (@SteveStreza) - &lt;a href=&#34;https://github.com/amazingsyco/TOML&#34;&gt;https://github.com/amazingsyco/TOML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OCaml (@mackwic) &lt;a href=&#34;https://github.com/mackwic/to.ml&#34;&gt;https://github.com/mackwic/to.ml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Perl (@alexkalderimis) - &lt;a href=&#34;https://github.com/alexkalderimis/config-toml.pl&#34;&gt;https://github.com/alexkalderimis/config-toml.pl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Perl - &lt;a href=&#34;https://github.com/dlc/toml&#34;&gt;https://github.com/dlc/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PHP (@leonelquinteros) - &lt;a href=&#34;https://github.com/leonelquinteros/php-toml.git&#34;&gt;https://github.com/leonelquinteros/php-toml.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PHP (@jimbomoss) - &lt;a href=&#34;https://github.com/jamesmoss/toml&#34;&gt;https://github.com/jamesmoss/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PHP (@coop182) - &lt;a href=&#34;https://github.com/coop182/toml-php&#34;&gt;https://github.com/coop182/toml-php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PHP (@checkdomain) - &lt;a href=&#34;https://github.com/checkdomain/toml&#34;&gt;https://github.com/checkdomain/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PHP (@zidizei) - &lt;a href=&#34;https://github.com/zidizei/toml-php&#34;&gt;https://github.com/zidizei/toml-php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PHP (@yosymfony) - &lt;a href=&#34;https://github.com/yosymfony/toml&#34;&gt;https://github.com/yosymfony/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python (@f03lipe) - &lt;a href=&#34;https://github.com/f03lipe/toml-python&#34;&gt;https://github.com/f03lipe/toml-python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python (@uiri) - &lt;a href=&#34;https://github.com/uiri/toml&#34;&gt;https://github.com/uiri/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python - &lt;a href=&#34;https://github.com/bryant/pytoml&#34;&gt;https://github.com/bryant/pytoml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python (@elssar) - &lt;a href=&#34;https://github.com/elssar/tomlgun&#34;&gt;https://github.com/elssar/tomlgun&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python (@marksteve) - &lt;a href=&#34;https://github.com/marksteve/toml-ply&#34;&gt;https://github.com/marksteve/toml-ply&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python (@hit9) - &lt;a href=&#34;https://github.com/hit9/toml.py&#34;&gt;https://github.com/hit9/toml.py&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Racket (@greghendershott) - &lt;a href=&#34;https://github.com/greghendershott/toml&#34;&gt;https://github.com/greghendershott/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ruby (@jm) - &lt;a href=&#34;https://github.com/jm/toml&#34;&gt;https://github.com/jm/toml&lt;/a&gt; (toml gem)&lt;/li&gt;
&lt;li&gt;Ruby (@eMancu) - &lt;a href=&#34;https://github.com/eMancu/toml-rb&#34;&gt;https://github.com/eMancu/toml-rb&lt;/a&gt; (toml-rb gem)&lt;/li&gt;
&lt;li&gt;Ruby (@charliesome) - &lt;a href=&#34;https://github.com/charliesome/toml2&#34;&gt;https://github.com/charliesome/toml2&lt;/a&gt; (toml2 gem)&lt;/li&gt;
&lt;li&gt;Ruby (@sandeepravi) - &lt;a href=&#34;https://github.com/sandeepravi/tomlp&#34;&gt;https://github.com/sandeepravi/tomlp&lt;/a&gt; (tomlp gem)&lt;/li&gt;
&lt;li&gt;Rust (@mneumann) - &lt;a href=&#34;https://github.com/mneumann/rust-toml&#34;&gt;https://github.com/mneumann/rust-toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rust (@alexcrichton) - &lt;a href=&#34;https://github.com/alexcrichton/toml-rs&#34;&gt;https://github.com/alexcrichton/toml-rs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Scala - &lt;a href=&#34;https://github.com/axelarge/tomelette&#34;&gt;https://github.com/axelarge/tomelette&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;validators:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Validators&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Go (@BurntSushi) - &lt;a href=&#34;https://github.com/BurntSushi/toml/tree/master/cmd/tomlv&#34;&gt;https://github.com/BurntSushi/toml/tree/master/cmd/tomlv&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;language-agnostic-test-suite-for-toml-decoders-and-encoders:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Language agnostic test suite for TOML decoders and encoders&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;toml-test (@BurntSushi) - &lt;a href=&#34;https://github.com/BurntSushi/toml-test&#34;&gt;https://github.com/BurntSushi/toml-test&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;editor-support:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Editor support&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Atom - &lt;a href=&#34;https://github.com/atom/language-toml&#34;&gt;https://github.com/atom/language-toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Emacs (@dryman) - &lt;a href=&#34;https://github.com/dryman/toml-mode.el&#34;&gt;https://github.com/dryman/toml-mode.el&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notepad++ (@fireforge) - &lt;a href=&#34;https://github.com/fireforge/toml-notepadplusplus&#34;&gt;https://github.com/fireforge/toml-notepadplusplus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sublime Text 2 &amp;amp; 3 (@Gakai) - &lt;a href=&#34;https://github.com/Gakai/sublime_toml_highlighting&#34;&gt;https://github.com/Gakai/sublime_toml_highlighting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Synwrite - &lt;a href=&#34;http://uvviewsoft.com/synwrite/download.html&#34;&gt;http://uvviewsoft.com/synwrite/download.html&lt;/a&gt; ; call Options/ Addons manager/ Install&lt;/li&gt;
&lt;li&gt;TextMate (@infininight) - &lt;a href=&#34;https://github.com/textmate/toml.tmbundle&#34;&gt;https://github.com/textmate/toml.tmbundle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vim (@cespare) - &lt;a href=&#34;https://github.com/cespare/vim-toml&#34;&gt;https://github.com/cespare/vim-toml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;encoder:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Encoder&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Dart (@just95) - &lt;a href=&#34;https://github.com/just95/toml.dart&#34;&gt;https://github.com/just95/toml.dart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go w/ Reflection (@BurntSushi) - &lt;a href=&#34;https://github.com/BurntSushi/toml&#34;&gt;https://github.com/BurntSushi/toml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PHP (@ayushchd) - &lt;a href=&#34;https://github.com/ayushchd/php-toml-encoder&#34;&gt;https://github.com/ayushchd/php-toml-encoder&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;converters:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Converters&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;remarshal (@dbohdan) - &lt;a href=&#34;https://github.com/dbohdan/remarshal&#34;&gt;https://github.com/dbohdan/remarshal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;yaml2toml (@jtyr) - &lt;a href=&#34;https://github.com/jtyr/yaml2toml-converter&#34;&gt;https://github.com/jtyr/yaml2toml-converter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;yaml2toml.dart (@just95) - &lt;a href=&#34;https://github.com/just95/yaml2toml.dart&#34;&gt;https://github.com/just95/yaml2toml.dart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;organization:5ff9e6c178c0a97810ff2a2c2ec622b5&#34;&gt;Organization&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;toml-lang (@BurntSushi) - &lt;a href=&#34;https://github.com/toml-lang&#34;&gt;https://github.com/toml-lang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
