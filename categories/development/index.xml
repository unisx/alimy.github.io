<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Development on Alimy </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://alimy.me/categories/development/</link>
    
    
    <copyright>&amp;copy;2016, Alimy; all rights reserved.</copyright>
    <updated>Fri, 11 Mar 2016 21:05:00 CST</updated>
    
    <item>
      <title>Jackson: Json Polymorphism</title>
      <link>http://alimy.me/post/dev_201603112105/</link>
      <pubDate>Fri, 11 Mar 2016 21:05:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112105/</guid>
      <description>

&lt;p&gt;Jackson provides a way to maintain sub type information while serializing java objects. It is possible to recreate the exact sub type. The type information can be embedded into the json as a property. In the example below we create a zoo, that has a list of animals. The animal may be an elephant or a lion, and they both extend the Animal abstract class. While deserializing we want to create the exact animal type. We also demonstrate the use of @JsonTypeInfo and @JsonSubTypes annotations.&lt;/p&gt;

&lt;h3 id=&#34;data-serialization-and-polymorphism-example:46b64fca9632a887d3524460bdf45d73&#34;&gt;Data Serialization and Polymorphism Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class SerializeExample1 {
    private static String outputFile = &amp;quot;zoo.json&amp;quot;;

    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {
        // let start creating the zoo
        Zoo zoo = new Zoo(&amp;quot;Samba Wild Park&amp;quot;, &amp;quot;Paz&amp;quot;);
        Lion lion = new Lion(&amp;quot;Simba&amp;quot;);
        Elephant elephant = new Elephant(&amp;quot;Manny&amp;quot;);
        List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;();
        animals.add(lion);
        animals.add(elephant);
        zoo.setAnimals(animals);

        ObjectMapper mapper = new ObjectMapper();
        mapper.writerWithDefaultPrettyPrinter().writeValue(new FileWriter(new File(outputFile)), zoo);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we look at the various classes, lets also see how to deserialize this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.File;
import java.io.IOException;

import org.apache.commons.io.FileUtils;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class DeSerializeExample1 {

    public static void main(String[] args) throws JsonParseException, JsonMappingException, IOException {
        ObjectMapper mapper = new ObjectMapper();
        Zoo zoo = mapper.readValue(FileUtils.readFileToByteArray(new File(&amp;quot;zoo.json&amp;quot;)), Zoo.class);
        System.out.println(zoo);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;zoo-class:46b64fca9632a887d3524460bdf45d73&#34;&gt;Zoo class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeInfo.As;

@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS, include = As.PROPERTY, property = &amp;quot;@class&amp;quot;)
public class Zoo {

    public String name;
    public String city;
    public List&amp;lt;Animal&amp;gt; animals;

    @JsonCreator
    public Zoo(@JsonProperty(&amp;quot;name&amp;quot;) String name, @JsonProperty(&amp;quot;city&amp;quot;) String city) {
        this.name = name;
        this.city = city;
    }

    public void setAnimals(List&amp;lt;animal&amp;gt; animals) {
        this.animals = animals;
    }

    @Override
    public String toString() {
        return &amp;quot;Zoo [name=&amp;quot; + name + &amp;quot;, city=&amp;quot; + city + &amp;quot;, animals=&amp;quot; + animals + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;animal-abstract-class:46b64fca9632a887d3524460bdf45d73&#34;&gt;Animal Abstract class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonSubTypes.Type;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeInfo.As;

@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = As.PROPERTY, property = &amp;quot;@class&amp;quot;)
@JsonSubTypes({ @Type(value = Lion.class, name = &amp;quot;lion&amp;quot;), @Type(value = Elephant.class, name = &amp;quot;elephant&amp;quot;) })
public abstract class Animal {
    @JsonProperty(&amp;quot;name&amp;quot;)
    String name;
    @JsonProperty(&amp;quot;sound&amp;quot;)
    String sound;
    @JsonProperty(&amp;quot;type&amp;quot;)
    String type;
    @JsonProperty(&amp;quot;endangered&amp;quot;)
    boolean endangered;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;lion-class:46b64fca9632a887d3524460bdf45d73&#34;&gt;Lion class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class Lion extends Animal {

    private String name;

    @JsonCreator
    public Lion(@JsonProperty(&amp;quot;name&amp;quot;) String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getSound() {
        return &amp;quot;Roar&amp;quot;;
    }

    public String getType() {
        return &amp;quot;carnivorous&amp;quot;;
    }

    public boolean isEndangered() {
        return true;
    }

    @Override
    public String toString() {
        return &amp;quot;Lion [name=&amp;quot; + name + &amp;quot;, getName()=&amp;quot; + getName() + &amp;quot;, getSound()=&amp;quot; + getSound() + &amp;quot;, getType()=&amp;quot; + getType() + &amp;quot;, isEndangered()=&amp;quot;
                + isEndangered() + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;elephant-class:46b64fca9632a887d3524460bdf45d73&#34;&gt;Elephant class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class Elephant extends Animal {

    @JsonProperty
    private String name;

    @JsonCreator
    public Elephant(@JsonProperty(&amp;quot;name&amp;quot;) String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getSound() {
        return &amp;quot;trumpet&amp;quot;;
    }

    public String getType() {
        return &amp;quot;herbivorous&amp;quot;;
    }

    public boolean isEndangered() {
        return false;
    }

    @Override
    public String toString() {
        return &amp;quot;Elephant [name=&amp;quot; + name + &amp;quot;, getName()=&amp;quot; + getName() + &amp;quot;, getSound()=&amp;quot; + getSound() + &amp;quot;, getType()=&amp;quot; + getType()
                + &amp;quot;, isEndangered()=&amp;quot; + isEndangered() + &amp;quot;]&amp;quot;;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-Serialization-polymorphism.jsp&#34; title=&#34;Json Polymorphism&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: jackson Mix- In Annotations</title>
      <link>http://alimy.me/post/dev_201603112100/</link>
      <pubDate>Fri, 11 Mar 2016 21:00:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112100/</guid>
      <description>

&lt;p&gt;Annotations are a great way to manage serialization and deserialization in Jackson. However, what do you do if you want to annotate a third party class, or if you dont want to tightly couple your POJOs to jackson annotations. This is where Mix-in comes into play. You define a mix-in abstract class that is kind of a proxy to the actual class. Annotations are then definied over this proxy class&lt;/p&gt;

&lt;h3 id=&#34;jackson-mix-in-example:7634bf28f621093315cf4d8b563f8a36&#34;&gt;Jackson Mix-In Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.File;
import java.io.IOException;

import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class SerializeExample3 {
    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {
        ObjectMapper mapper = new ObjectMapper();
        mapper.addMixInAnnotations(Bird.class, BirdMixIn.class);
        Bird bird = new Bird(&amp;quot;scarlet Ibis&amp;quot;);
        bird.setSound(&amp;quot;eee&amp;quot;);
        bird.setHabitat(&amp;quot;water&amp;quot;);

        mapper.writerWithDefaultPrettyPrinter().writeValue(new File(&amp;quot;bird.json&amp;quot;), bird);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-bird-class:7634bf28f621093315cf4d8b563f8a36&#34;&gt;The Bird class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

public class Bird {

    private String name;
    private String sound;
    private String habitat;

    public Bird(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getSound() {
        return sound;
    }

    public String getHabitat() {
        return habitat;
    }

    public void setSound(String sound) {
        this.sound = sound;
    }

    public void setHabitat(String habitat) {
        this.habitat = habitat;
    }

    @Override
    public String toString() {
        return &amp;quot;Bird [name=&amp;quot; + name + &amp;quot;, sound=&amp;quot; + sound + &amp;quot;, habitat=&amp;quot; + habitat + &amp;quot;]&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-mix-in-class:7634bf28f621093315cf4d8b563f8a36&#34;&gt;The Mix-in class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonProperty;

public abstract class BirdMixIn {
    BirdMixIn(@JsonProperty(&amp;quot;name&amp;quot;) String name) {
    };

    @JsonProperty(&amp;quot;sound&amp;quot;)
    abstract String getSound();

    @JsonProperty(&amp;quot;habitat&amp;quot;)
    abstract String getHabitat();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-mix-in-annotation.jsp&#34; title=&#34;jackson Mix- In Annotations&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: Json data binding filters</title>
      <link>http://alimy.me/post/dev_201603112055/</link>
      <pubDate>Fri, 11 Mar 2016 20:55:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112055/</guid>
      <description>

&lt;p&gt;Jackson provides an effective an efficient way to bind json to POJOs. However, at times, certain properties may need to be ignored while converting a json to java ojbect and a java object to json string. Jackson provides three ways to filter properties.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;@JsonIgnoreProperties- This annotation can be used at the type level to ignore json properties. In the example below we ignore the &amp;lsquo;tags&amp;rsquo; property from the albums dataset.&lt;/li&gt;
&lt;li&gt;@JsonIgnore - This annotation can be set at property level to ignore certain properties.&lt;/li&gt;
&lt;li&gt;Using Custom filters&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The example below shows method 1 and 2. Also note the use of the @JsonAutoDetect annotation.&lt;/p&gt;

&lt;h3 id=&#34;data-binding-filters-example:36264cd232902e18141acc789ff21fa2&#34;&gt;Data Binding Filters Example&lt;/h3&gt;

&lt;h4 id=&#34;databinding:36264cd232902e18141acc789ff21fa2&#34;&gt;Databinding&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.JsonProperty;

// Do not use fields to autodetect. use the public getter methods to autodetect properties
@JsonAutoDetect(fieldVisibility = Visibility.NONE, getterVisibility = Visibility.PUBLIC_ONLY)
public class AlbumsFilter {

    private String title;
    private DatasetFilter[] datasetFilter;
    public String total_pages;

    protected String getTotal_pages() {
        return total_pages;
    }

    public String getTitle() {
        return title;
    }

    // this getter method is for the &#39;dataset&#39; property
    @JsonProperty(&amp;quot;dataset&amp;quot;)
    public DatasetFilter[] getDatasetFilter() {
        return datasetFilter;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;datasetfilter-class:36264cd232902e18141acc789ff21fa2&#34;&gt;DatasetFilter class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

// ignore the property with name &#39;tags&#39;.
@JsonIgnoreProperties({ &amp;quot;tags&amp;quot; })
public class DatasetFilter {
    private String album_id;
    private String album_title;
    private Map&amp;lt;String , Object&amp;gt; otherProperties = new HashMap&amp;lt;String , Object&amp;gt;();
    private String album_comments;

    @JsonCreator
    public DatasetFilter(@JsonProperty(&amp;quot;album_id&amp;quot;) String album_id, @JsonProperty(&amp;quot;album_title&amp;quot;) String album_title) {
        this.album_id = album_id;
        this.album_title = album_title;
    }

    // ignore the property specified by this getter.
    @JsonIgnore
    public String getAlbum_comments() {
        return album_comments;
    }

    public String getAlbum_id() {
        return album_id;
    }

    public void setAlbum_id(String album_id) {
        this.album_id = album_id;
    }

    public String getAlbum_title() {
        return album_title;
    }

    public void setAlbum_title(String album_title) {
        this.album_title = album_title;
    }

    public Object get(String name) {
        return otherProperties.get(name);
    }

    // this method is used to get all properties not specified earlier.
    @JsonAnyGetter
    public Map&amp;lt;String , Object&amp;gt; any() {
        return otherProperties;
    }

    @JsonAnySetter
    public void set(String name, Object value) {
        otherProperties.put(name, value);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-data-binding-filters.jsp&#34; title=&#34;Json data binding filters&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: Json annotations and dyna beans</title>
      <link>http://alimy.me/post/dev_201603112050/</link>
      <pubDate>Fri, 11 Mar 2016 20:50:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112050/</guid>
      <description>

&lt;p&gt;The json string at times have a lot of properties. It seems a waste creating a POJO with all those properties. Wouldnt it be great if there was a catch&amp;rsquo;all that could read all properties in a map? Jackson provides annotations to do just that. In the example below we have set two properties in the bean and the other properties are read into a map. These example also introduces some common annotations using in Jackson. Lets look at them briefly:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;@JsonProperty-This annotation is used to mark a method as a getter or setter for a property. In other words, it associates a json field with a java property. If a name is specified (@JsonProperty(&amp;ldquo;age&amp;rdquo;)) then the java property that is annotated with this annotation is mapped to the &amp;lsquo;age&amp;rsquo; field of the json, If no name is specified the java property name is used.&lt;/li&gt;
&lt;li&gt;@JsonCreator-This annotation is used the define constructors that are used to create java objects from json string. It is used during data binding and specifies properties that will be used to create java objects during deserialization.&lt;/li&gt;
&lt;li&gt;@JsonAnyGetter and @JsonAnySetter - This annotations are used to mark methods that set or read fields that are not handled by any other java property. These act like catch-all and handle all fields that are not handled by any other java property. The fields are stored in a map as key value pairs.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;data-binding-example:bbe5bd370d848e969f04326afa884de3&#34;&gt;Data Binding Example&lt;/h3&gt;

&lt;h4 id=&#34;databinding:bbe5bd370d848e969f04326afa884de3&#34;&gt;Databinding&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

public class AlbumsDynamic {

    private String title;
    private DatasetDynamic[] dataset;

    public void setTitle(String title) {
        this.title = title;
    }

    public void setDataset(DatasetDynamic[] dataset) {
        this.dataset = dataset;
    }

    public String getTitle() {
        return title;
    }

    public DatasetDynamic[] getDataset() {
        return dataset;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dataset-class:bbe5bd370d848e969f04326afa884de3&#34;&gt;Dataset class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class DatasetDynamic {
    private String album_id;
    private String album_title;
    private Map&amp;lt;String , Object&amp;gt; otherProperties = new HashMap&amp;lt;String , Object&amp;gt;();

    @JsonCreator
    public DatasetDynamic(@JsonProperty(&amp;quot;album_id&amp;quot;) String album_id, @JsonProperty(&amp;quot;album_title&amp;quot;) String album_title) {
        this.album_id = album_id;
        this.album_title = album_title;
    }

    public String getAlbum_id() {
        return album_id;
    }

    public void setAlbum_id(String album_id) {
        this.album_id = album_id;
    }

    public String getAlbum_title() {
        return album_title;
    }

    public void setAlbum_title(String album_title) {
        this.album_title = album_title;
    }

    public Object get(String name) {
        return otherProperties.get(name);
    }

    @JsonAnyGetter
    public Map&amp;lt;String , Object&amp;gt; any() {
        return otherProperties;
    }

    @JsonAnySetter
    public void set(String name, Object value) {
        otherProperties.put(name, value);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-Annotations-Dynamic-Beans.jsp&#34; title=&#34;Json annotations and dyna beans&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: List serialization</title>
      <link>http://alimy.me/post/dev_201603112045/</link>
      <pubDate>Fri, 11 Mar 2016 20:45:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112045/</guid>
      <description>

&lt;p&gt;In this tutorial we will see how to convert a java List to JSON. Serializing list is a little tricky since by default the type info is not stored while serializing and deserializing lists. In this tutorial we look at two examples. In the first example we serialize an Object that has a java List as one of its properties. In the second example we try and serialize the List directly. In both examples we use special configuration to preserve type info.&lt;/p&gt;

&lt;h3 id=&#34;example-1-serializing-object-containing-a-list:cbcae65ab0364befdb15ef6b14f2b41b&#34;&gt;Example 1 : Serializing Object containing a list&lt;/h3&gt;

&lt;p&gt;The example converts a Zoo class to json. the zoo class contains the name of zoo, its city and a list of animals. The list is of type &amp;lsquo;Animal&amp;rsquo;, i.e. the list contains elements that are subclass of the Abstract class Animal. Lets see what happens when we try to serialize zoo. First we create the Zoo class. Notice how the constructor looks. When we try to get the Zoo Object back from the JSON, Jackson has to know that it should create the Zoo Object using the constructor that takes in the name and city properties.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Zoo {
    public String name;
    public String city;


    @JsonCreator
    public Zoo(@JsonProperty(&amp;quot;name&amp;quot;) String name,@JsonProperty(&amp;quot;city&amp;quot;) String city) {
        this.name = name;
        this.city = city;
    }

    public List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;Animal&amp;gt;();

    public List&amp;lt;Animal&amp;gt; addAnimal(Animal animal) {
        animals.add(animal);
        return animals;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Animal is an abstract class. It is further extended to create the Elephant and the Lion class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Elephant extends Animal {

    @JsonCreator
    public Elephant(@JsonProperty(&amp;quot;name&amp;quot;) String name) {
        super.name = name;
    }

    @Override
    public String toString() {
        return &amp;quot;Elephant : &amp;quot; + name;
    }
}

class Lion extends Animal {
    @JsonCreator
    public Lion(@JsonProperty(&amp;quot;name&amp;quot;) String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &amp;quot;Lion: &amp;quot; + name;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets now create a serializer for Zoo. Imagine that the London zoo needs to shift to a larger area. We will have to serialize the zoo from its current location and deserialize it at the target location. (a teleportation machine)&lt;/p&gt;

&lt;p&gt;We use the ObjectMapper class to do the serialization and print the json to console. You could also print it to a file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class SerializeZoo {
    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {
         Zoo zoo = new Zoo(&amp;quot;London Zoo&amp;quot;, &amp;quot;London&amp;quot;);
         Lion lion = new Lion(&amp;quot;Simba&amp;quot;);
         Elephant elephant = new Elephant(&amp;quot;Manny&amp;quot;);
         zoo.addAnimal(elephant).add(lion);
         ObjectMapper mapper = new ObjectMapper();
         mapper.writeValue(System.out, zoo);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok so lets see how our zoo looks like. Remember, we should be able to re create the zoo (along with all its animals) when we deserialize it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;London Zoo&amp;quot;,&amp;quot;city&amp;quot;:&amp;quot;London&amp;quot;,&amp;quot;animals&amp;quot;:[{&amp;quot;name&amp;quot;:&amp;quot;Manny&amp;quot;},{&amp;quot;name&amp;quot;:&amp;quot;Simba&amp;quot;}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clearly our teleporter is not ready. Manny and Simba are in there, but there is nothing in the json that says that Manny is an elephant and Simba is a lion. Lets see what happens when we try to deserialize the zoo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.IOException;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class DeserializeZoo {

    public static void main(String[] args) throws JsonParseException, JsonMappingException, IOException {
        String json = &amp;quot;{\&amp;quot;name\&amp;quot;:\&amp;quot;London Zoo\&amp;quot;,\&amp;quot;city\&amp;quot;:\&amp;quot;London\&amp;quot;,&amp;quot; + &amp;quot;\&amp;quot;animals\&amp;quot;:[{\&amp;quot;name\&amp;quot;:\&amp;quot;Manny\&amp;quot;},{\&amp;quot;name\&amp;quot;:\&amp;quot;Simba\&amp;quot;}]}&amp;quot;;
        ObjectMapper mapper = new ObjectMapper();
        mapper.readValue(json, Zoo.class);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get an error! the error says &amp;ldquo;Can not construct instance of com.studytrails.json.jackson.Animal, problem: abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information&amp;rdquo; . Ok, we were expecting this. Lets see how to resolve it. We need to be able to put the information about the type in the json. There are two things you need
to do this&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Tell Jackson that we need to include the type info for Animal class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = As.PROPERTY, property = &amp;quot;@class&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tell Jackson that Animal can have subclasses Elephant and Lion&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@JsonSubTypes({ @Type(value = Lion.class, name = &amp;quot;lion&amp;quot;), @Type(value = Elephant.class, name = &amp;quot;elephant&amp;quot;) })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see how our json looks now&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;London Zoo&amp;quot;,&amp;quot;city&amp;quot;:&amp;quot;London&amp;quot;,
&amp;quot;animals&amp;quot;:[{&amp;quot;@class&amp;quot;:&amp;quot;com.studytrails.json.jackson.Elephant&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Manny&amp;quot;},
           {&amp;quot;@class&amp;quot;:&amp;quot;com.studytrails.json.jackson.Lion&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Simba&amp;quot;}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks much better. Now, if you read the json back using the Zoo class then it works well and the Zoo class would have a list of animals.&lt;/p&gt;

&lt;h3 id=&#34;example-2-serializing-a-list:cbcae65ab0364befdb15ef6b14f2b41b&#34;&gt;Example 2 : Serializing a list&lt;/h3&gt;

&lt;p&gt;In the previous example we saw how to serialize a class that has a List. In this example lets see how to serialize a list directly. We will use the same Animal, Lion and Elephant classes. Lets see what happens when we try to serialize the list directly (note that we have added the typeinfo annotations to the Animal class)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SerializeAnimals {
    public static void main(String[] args) throws JsonGenerationException, JsonMappingException, IOException {
        List&amp;lt;animal&amp;gt; animals = new ArrayList&amp;lt;animal&amp;gt;();
        Lion lion = new Lion(&amp;quot;Samba&amp;quot;);
        Elephant elephant = new Elephant(&amp;quot;Manny&amp;quot;);
        animals.add(lion);
        animals.add(elephant);
        ObjectMapper mapper = new ObjectMapper();

        mapper.writeValue(System.out, animals);
    }
}  



&amp;lt;/animal&amp;gt;&amp;lt;/animal&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives the following json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{&amp;quot;name&amp;quot;:&amp;quot;Samba&amp;quot;},{&amp;quot;name&amp;quot;:&amp;quot;Manny&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No type info! To add type info while serializing Lists directly you need to configure the mapper in this way&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapper.writerWithType(new TypeReference&amp;lt;List
        &amp;lt;Animal&amp;gt;&amp;gt;() {
        }).writeValue(System.out, animals);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This now produces the correct json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[{&amp;quot;@class&amp;quot;:&amp;quot;com.studytrails.json.jackson.Lion&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Samba&amp;quot;},
{&amp;quot;@class&amp;quot;:&amp;quot;com.studytrails.json.jackson.Elephant&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;Manny&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So to recap, in this tutorial we saw how to i. serialize a Java object containing a List and ii. serialize a list (root object)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-Serialization-list.jsp&#34; title=&#34;jackson List serialization&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: Json Data Binding</title>
      <link>http://alimy.me/post/dev_201603112040/</link>
      <pubDate>Fri, 11 Mar 2016 20:40:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112040/</guid>
      <description>

&lt;p&gt;A thing that most java developers love to deal with is &amp;hellip;. Java POJO. Wouldn&amp;rsquo;t you love a black box where you can see JSON string entering from one side and POJOs coming out from the other. That&amp;rsquo;s what Jackson data binding does. This can be best explained by an example. We use the json from free music archive. It has an API to get latest albums in the form of JSON. we would read that json string (Click on this link to see the json) into Albums object. The Albums object contains an array of Dataset.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how The JSON to Java conversion works&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The first step is to create the Java class that would hold the JSON data. Look at the json. we create an Albums object to hold the entire json. The json contains an array of &amp;lsquo;dataset&amp;rsquo; elements. We create a Java Object of type DataSet and in the Albums object we create a dataset property that is an array of type DataSet.&lt;/li&gt;
&lt;li&gt;Create an instance of the com.fasterxml.jackson.databind.ObjectMapper class. This is the class that maps a JSON to a Java Object.&lt;code&gt;ObjectMapper mapper = new ObjectMapper();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;We use the &lt;em&gt;readValue&lt;/em&gt; method of the ObjectMapper to read. There are multiple versions of this method and we use the method that takes in a URL. However, there are method that read from a file, inputstream, String or a ByteArray.&lt;/li&gt;
&lt;li&gt;The ObjectMapper caches serializers and deserializers so it would be a good idea to reuse an ObjectMapper instance for multiple conversions&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you have an InputStream then pass it to Jackson as such and do not wrap it in InputStreamReader for performance reasons.&lt;/p&gt;

&lt;h3 id=&#34;data-binding-example:8bc1c18631645e9b29be4de3b97e5ac6&#34;&gt;Data Binding Example&lt;/h3&gt;

&lt;h4 id=&#34;databinding:8bc1c18631645e9b29be4de3b97e5ac6&#34;&gt;Databinding&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class DataBinding1 {
	public static void main(String[] args) throws JsonParseException, JsonMappingException, MalformedURLException, IOException {
		String url = &amp;quot;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=2&amp;quot;;
		ObjectMapper mapper = new ObjectMapper();
		mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
		Albums albums = mapper.readValue(new URL(url), Albums.class);
		Dataset[] datasets = albums.getDataset();
		for (Dataset dataset : datasets) {
			System.out.println(dataset.getAlbum_title());
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have disabled the feature that causes the mapper to break if it encounters an unknown property. Therefore, if the json has 10 properties and you define only two in your bean, then the other 8 will be ignored.&lt;/p&gt;

&lt;h4 id=&#34;the-albums-class:8bc1c18631645e9b29be4de3b97e5ac6&#34;&gt;The Albums class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;


public class Albums {

	private String title;
	private Dataset[] dataset;

	public void setTitle(String title) {
		this.title = title;
	}

	public void setDataset(Dataset[] dataset) {
		this.dataset = dataset;
	}

	public String getTitle() {
		return title;
	}

	public Dataset[] getDataset() {
		return dataset;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dataset-class:8bc1c18631645e9b29be4de3b97e5ac6&#34;&gt;Dataset class&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.util.HashMap;
import java.util.Map;

public class Dataset {
	private String album_id;
	private String album_title;
	private Map&amp;lt;String , Object&amp;gt; otherProperties = new HashMap&amp;lt;String , Object&amp;gt;();

	public String getAlbum_id() {
		return album_id;
	}

	public void setAlbum_id(String album_id) {
		this.album_id = album_id;
	}

	public String getAlbum_title() {
		return album_title;
	}

	public void setAlbum_title(String album_title) {
		this.album_title = album_title;
	}

	public Object get(String name) {
		return otherProperties.get(name);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-Data-Binding.jsp&#34; title=&#34;Jackson - Data Binding&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: build java tree model from json</title>
      <link>http://alimy.me/post/dev_201603112035/</link>
      <pubDate>Fri, 11 Mar 2016 20:35:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112035/</guid>
      <description>&lt;p&gt;Jackson provides a tree node called com.fasterxml.jackson.databind.JsonNode. The ObjectMapper provides a method to read the json into a tree with the root being a JsonNode. This can be thought of as being similar to DOM nodes in XML DOM trees. The example below demonstrates building a tree from the json string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Iterator;

import org.apache.commons.io.IOUtils;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class TreeModelParser1 {
	public static void main(String[] args) throws MalformedURLException, IOException {
		// Get a list of albums from free music archive. limit the results to 5
		String url = &amp;quot;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=2&amp;quot;;
		// Get the contents of json as a string using commons IO IOUTils class.
		String genreJson = IOUtils.toString(new URL(url));

		// create an ObjectMapper instance.
		ObjectMapper mapper = new ObjectMapper();
		// use the ObjectMapper to read the json string and create a tree
		JsonNode node = mapper.readTree(genreJson);

		// lets see what type the node is
		System.out.println(node.getNodeType()); // prints OBJECT
		// is it a container
		System.out.println(node.isContainerNode()); // prints true
		// lets find out what fields it has
		Iterator&amp;lt;String&amp;gt; fieldNames = node.fieldNames();
		while (fieldNames.hasNext()) {
			String fieldName = fieldNames.next();
			System.out.println(fieldName);// prints title, message, errors,
											// total,
											// total_pages, page, limit, dataset
		}

		// we now know what elemets the container has. lets get the value for
		// one of them
		System.out.println(node.get(&amp;quot;title&amp;quot;).asText()); // prints
														// &amp;quot;Free Music Archive&amp;quot;.

		// Lets look at the dataset now.
		JsonNode dataset = node.get(&amp;quot;dataset&amp;quot;);

		// what is its type?
		System.out.println(dataset.getNodeType()); // Prints ARRAY

		// so the dataset is an array. Lets iterate through the array and see
		// what each of the elements are
		Iterator&amp;lt;JsonNode&amp;gt; datasetElements = dataset.iterator();
		while (datasetElements.hasNext()) {
			JsonNode datasetElement = datasetElements.next();
			// what is its type
			System.out.println(datasetElement.getNodeType());// Prints Object
			// it is again a container . what are the elements ?
			Iterator&amp;lt;String&amp;gt; datasetElementFields = datasetElement.fieldNames();
			while (datasetElementFields.hasNext()) {
				String datasetElementField = datasetElementFields.next();
				System.out.println(datasetElementField); // prints album_id,
															// album_title,
															// album_handle,
															// album_url,
															// album_type,
															// artist_name,
															// artist_url,
															// album_producer,
															// album_engineer,
															// album_information,
															// album_date_released,
															// album_comments,
															// album_favorites,
															// album_tracks,
															// album_listens,
															// album_date_created,
															// album_image_file,
															// album_images

			}
			// break from the loop, since we just want to see the structure
			break;

		}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets look at another example that shows the use of the path method. The path method is similar to the get() method but if the node does not exist, it does not return null but returns an object of type MissingNode&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Iterator;

import org.apache.commons.io.IOUtils;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class TreeModelParser2 {
	public static void main(String[] args) throws MalformedURLException, IOException {
		// Get a list of albums from free music archive. limit the results to 5
		String url = &amp;quot;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=10&amp;quot;;
		// Get the contents of json as a string using commons IO IOUTils class.
		String genreJson = IOUtils.toString(new URL(url));

		// create an ObjectMapper instance.
		ObjectMapper mapper = new ObjectMapper();
		// use the ObjectMapper to read the json string and create a tree
		JsonNode node = mapper.readTree(genreJson);

		// not the use of path. this does not cause the code to break if the
		// code does not exist
		Iterator&amp;lt;JsonNode&amp;gt; albums = node.path(&amp;quot;dataset&amp;quot;).iterator();
		while (albums.hasNext()) {
			System.out.println(albums.next().path(&amp;quot;album_title&amp;quot;));
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-json-tree-parsing.jsp&#34; title=&#34;build java tree model from json&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: json and java - Streaming</title>
      <link>http://alimy.me/post/dev_201603112030/</link>
      <pubDate>Fri, 11 Mar 2016 20:30:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112030/</guid>
      <description>

&lt;h3 id=&#34;streaming-parser-and-generator:6aa21e9855db39cd085c6c3608dd23fc&#34;&gt;Streaming Parser and Generator&lt;/h3&gt;

&lt;p&gt;Jackson provides a low level API to parse json string. The API provides token for each json object. For example, the start of json &amp;lsquo;{&amp;rsquo; is the first object that the parser provides. The key value pair is another single object. The client code can use the tokens and get the json properties or build a java object out of it if required. This low level API is extremely powerful but needs a lot of coding. For most cases, Jackson&amp;rsquo;s tree traversing and data binding capability should be explored instead. We provide two examples below. The first example demonstrates json parsing and the second demonstrated json generation.&lt;/p&gt;

&lt;h3 id=&#34;json-parsing-example:6aa21e9855db39cd085c6c3608dd23fc&#34;&gt;Json Parsing Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;

/**
 * The aim of this class is to get the list of albums from free music archive
 * (limit to 5)
 *
 */
public class StreamParser1 {
    public static void main(String[] args) throws MalformedURLException, IOException {
        // Get a list of albums from free music archive. limit the results to 5
        String url = &amp;quot;http://freemusicarchive.org/api/get/albums.json?api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=5&amp;quot;;
        // get an instance of the json parser from the json factory
        JsonFactory factory = new JsonFactory();
        JsonParser parser = factory.createParser(new URL(url));

        // continue parsing the token till the end of input is reached
        while (!parser.isClosed()) {
            // get the token
            JsonToken token = parser.nextToken();
            // if its the last token then we are done
            if (token == null)
                break;
            // we want to look for a field that says dataset

            if (JsonToken.FIELD_NAME.equals(token) &amp;amp;&amp;amp; &amp;quot;dataset&amp;quot;.equals(parser.getCurrentName())) {
                // we are entering the datasets now. The first token should be
                // start of array
                token = parser.nextToken();
                if (!JsonToken.START_ARRAY.equals(token)) {
                    // bail out
                    break;
                }
                // each element of the array is an album so the next token
                // should be {
                token = parser.nextToken();
                if (!JsonToken.START_OBJECT.equals(token)) {
                    break;
                }
                // we are now looking for a field that says &amp;quot;album_title&amp;quot;. We
                // continue looking till we find all such fields. This is
                // probably not a best way to parse this json, but this will
                // suffice for this example.
                while (true) {
                    token = parser.nextToken();
                    if (token == null)
                        break;
                    if (JsonToken.FIELD_NAME.equals(token) &amp;amp;&amp;amp; &amp;quot;album_title&amp;quot;.equals(parser.getCurrentName())) {
                        token = parser.nextToken();
                        System.out.println(parser.getText());
                    }

                }

            }

        }

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;json-generation-example:6aa21e9855db39cd085c6c3608dd23fc&#34;&gt;Json Generation Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;

/**
 *
 * In This example we look at generating a json using the jsongenerator. we will
 * be creating a json similar to
 * http://freemusicarchive.org/api/get/albums.json?
 * api_key=60BLHNQCAOUFPIBZ&amp;amp;limit=1, but use only a couple of fields
 *
 */
public class StreamGenerator1 {
    public static void main(String[] args) throws IOException {
        JsonFactory factory = new JsonFactory();
        JsonGenerator generator = factory.createGenerator(new FileWriter(new File(&amp;quot;albums.json&amp;quot;)));

        // start writing with {
        generator.writeStartObject();
        generator.writeFieldName(&amp;quot;title&amp;quot;);
        generator.writeString(&amp;quot;Free Music Archive - Albums&amp;quot;);
        generator.writeFieldName(&amp;quot;dataset&amp;quot;);
        // start an array
        generator.writeStartArray();
        generator.writeStartObject();
        generator.writeStringField(&amp;quot;album_title&amp;quot;, &amp;quot;A.B.A.Y.A.M&amp;quot;);
        generator.writeEndObject();
        generator.writeEndArray();
        generator.writeEndObject();

        generator.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-json-streaming.jsp&#34; title=&#34;json and java - Streaming&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: Java to JSON and back</title>
      <link>http://alimy.me/post/dev_201603112025/</link>
      <pubDate>Fri, 11 Mar 2016 20:25:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112025/</guid>
      <description>

&lt;h3 id=&#34;creating-json-from-java:627c82fc263a42c0c87ad3244752e285&#34;&gt;Creating JSON from Java&lt;/h3&gt;

&lt;p&gt;Jackson provides classes that can be used to convert a Java Object to JSON and back. In this example we look at how to build a JSON construct from a Java Object. We will start with a simple class and gradually start adding complexities to it. Lets say that we are a music company and we want to publish an api where users can query for Album. We first build an Album class with a single property title.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Album {
    private String title;

    public Album(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we use the ObjectMapper to convert the Object to JSON. By Default Jackson would use BeanSerializer to serialize the POJO. Here&amp;rsquo;s how our serializer Example looks so far. Note that the bean should have getters for private properties or the property should be public Here&amp;rsquo;s how the JSON looks&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;title&amp;quot;:&amp;quot;Kind Of Blue&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets add an array of links to the album (along with their getters and setters) These could be links to the press releases or album reviews.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private String[] links;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the main method add this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;album.setLinks(new String[] { &amp;quot;link1&amp;quot;, &amp;quot;link2&amp;quot; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how the JSON looks now. Note that the array is converted to a JSON array. (enclosed within &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;title&amp;quot;:&amp;quot;Kind Of Blue&amp;quot;,&amp;quot;links&amp;quot;:[&amp;quot;link1&amp;quot;,&amp;quot;link2&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we add a List of Songs to the Album.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt;&amp;gt; Songs = new ArrayList&amp;lt;String&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add the list to the Albums Object&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; songs = new ArrayList&amp;lt;String&amp;gt;();
songs.add(&amp;quot;So What&amp;quot;);
songs.add(&amp;quot;Flamenco Sketches&amp;quot;);
songs.add(&amp;quot;Freddie Freeloader&amp;quot;);
album.setSongs(songs);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting json looks like this. Note that the List is also converted to an array. You can learn more about List Serialization in this tutorial.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;title&amp;quot;:&amp;quot;Kind Of Blue&amp;quot;,&amp;quot;links&amp;quot;:[&amp;quot;link1&amp;quot;,&amp;quot;link2&amp;quot;],
&amp;quot;songs&amp;quot;:[&amp;quot;So What&amp;quot;,&amp;quot;Flamenco Sketches&amp;quot;,&amp;quot;Freddie Freeloader&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, lets add an artist to the Album. Artist is a class that contains the artist name and his birthdate represented by a Date instance. Note that Artist is an object and hence is enclosed in JSON by &amp;lsquo;{&amp;rsquo; and &amp;lsquo;}&amp;rsquo;. These brackers are JSON representation of objects and contains key value pairs. For brevity we declare the Artist properties as public.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Artist {
    public String name;
    public Date birthDate;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets add an Artist to the album&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Artist artist = new Artist();
artist.name = &amp;quot;Miles Davis&amp;quot;;
SimpleDateFormat format = new SimpleDateFormat(&amp;quot;dd-MM-yyyy&amp;quot;);
artist.birthDate = format.parse(&amp;quot;26-05-1926&amp;quot;);
album.setArtist(artist);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The JSON&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;title&amp;quot;:&amp;quot;Kind Of Blue&amp;quot;,&amp;quot;links&amp;quot;:[&amp;quot;link1&amp;quot;,&amp;quot;link2&amp;quot;],
&amp;quot;songs&amp;quot;:[&amp;quot;So What&amp;quot;,&amp;quot;Flamenco Sketches&amp;quot;,&amp;quot;Freddie Freeloader&amp;quot;],
&amp;quot;artist&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;Miles Davis&amp;quot;,&amp;quot;birthDate&amp;quot;:-1376027600000}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make JSON visually more readable we add this line. Note that this should not be done for production systems, but only during testing or development since this would increase the size of the json.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapper.configure(SerializationFeature.INDENT_OUTPUT, true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The JSON now looks well formatted&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;title&amp;quot; : &amp;quot;Kind Of Blue&amp;quot;,
  &amp;quot;links&amp;quot; : [ &amp;quot;link1&amp;quot; , &amp;quot;link2&amp;quot; ],
  &amp;quot;songs&amp;quot; : [ &amp;quot;So What&amp;quot;, &amp;quot;Flamenco Sketches&amp;quot;, &amp;quot;Freddie Freeloader&amp;quot; ],
  &amp;quot;artist&amp;quot; : {
    &amp;quot;name&amp;quot; : &amp;quot;Miles Davis&amp;quot;,
    &amp;quot;birthDate&amp;quot; : -1376027600000
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we now add a map of musicians and the instrument they play in the album.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Map&amp;lt;String,String&amp;gt; musicians = new HashMap&amp;lt;String, String&amp;gt;();
public Map&amp;lt;String, String&amp;gt; getMusicians() {
        return Collections.unmodifiableMap(musicians);
}
public void addMusician(String key, String value){
        musicians.put(key, value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in the main class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;album.addMusician(&amp;quot;Miles Davis&amp;quot;, &amp;quot;Trumpet, Band leader&amp;quot;);
album.addMusician(&amp;quot;Julian Adderley&amp;quot;, &amp;quot;Alto Saxophone&amp;quot;);
album.addMusician(&amp;quot;Paul Chambers&amp;quot;, &amp;quot;double bass&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;title&amp;quot; : &amp;quot;Kind Of Blue&amp;quot;,
  &amp;quot;links&amp;quot; : [ &amp;quot;link1&amp;quot;, &amp;quot;link2&amp;quot; ],
  &amp;quot;songs&amp;quot; : [ &amp;quot;So What&amp;quot;, &amp;quot;Flamenco Sketches&amp;quot;, &amp;quot;Freddie Freeloader&amp;quot; ],
  &amp;quot;artist&amp;quot; : {
    &amp;quot;name&amp;quot; : &amp;quot;Miles Davis&amp;quot;,
    &amp;quot;birthDate&amp;quot; : -1376027600000
  },
  &amp;quot;musicians&amp;quot; : {
    &amp;quot;Julian Adderley&amp;quot; : &amp;quot;Alto Saxophone&amp;quot;,
    &amp;quot;Paul Chambers&amp;quot; : &amp;quot;double bass&amp;quot;,
    &amp;quot;Miles Davis&amp;quot; : &amp;quot;Trumpet, Band leader&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets add some more features to the conversion. we first tell the mapper to arrange the Map by keys using it natural order&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The date has been formatted as the epoch time. Lets format it into a more human readable format&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SimpleDateFormat outputFormat = new SimpleDateFormat(&amp;quot;dd MMM yyyy&amp;quot;);
mapper.setDateFormat(outputFormat);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, jackson uses the name of the java field as the name of the json property. You can change that by using annotations as explained in this tutorial. However at times you may not have access to the java bean or you do not want to bind the java bean to a Jackson annotation. In this case jackson provides a way to change the default field name. Use the setPropertyNamingStrategy method on the mapper to set the naming strategy for the field. You need to override either the the nameForField method or the nameForGetterMethod depending on whether you have public field in the bean or a getter in the bean. In our example lets change the &amp;lsquo;title&amp;rsquo; of the album to &amp;lsquo;Album-Title&amp;rsquo; and the &amp;lsquo;name&amp;rsquo; of the artist to &amp;lsquo;Artist-Name&amp;rsquo;. Make this changes to the main method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapper.setPropertyNamingStrategy(new PropertyNamingStrategy() {
@Override
public String nameForField(MapperConfig&amp;lt;?&amp;gt; config, AnnotatedField field, String defaultName) {
   if (field.getFullName().equals(&amp;quot;com.studytrails.json.jackson.Artist#name&amp;quot;))
        return &amp;quot;Artist-Name&amp;quot;;
        return super.nameForField(config, field, defaultName);
}

@Override
public String nameForGetterMethod(MapperConfig&amp;lt;?&amp;gt; config, AnnotatedMethod method, String defaultName) {
  if (method.getAnnotated().getDeclaringClass().equals(Album.class) &amp;amp;&amp;amp; defaultName.equals(&amp;quot;title&amp;quot;))
        return &amp;quot;Album-Title&amp;quot;;
        return super.nameForGetterMethod(config, method, defaultName);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The json now looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;Album-Title&amp;quot; : &amp;quot;Kind Of Blue&amp;quot;,
  &amp;quot;links&amp;quot; : [ &amp;quot;link1&amp;quot;, &amp;quot;link2&amp;quot; ],
  &amp;quot;songs&amp;quot; : [ &amp;quot;So What&amp;quot;, &amp;quot;Flamenco Sketches&amp;quot;, &amp;quot;Freddie Freeloader&amp;quot; ],
  &amp;quot;artist&amp;quot; : {
    &amp;quot;Artist-Name&amp;quot; : &amp;quot;Miles Davis&amp;quot;,
    &amp;quot;birthDate&amp;quot; : &amp;quot;26 May 1926&amp;quot;
  },
  &amp;quot;musicians&amp;quot; : {
    &amp;quot;Julian Adderley&amp;quot; : &amp;quot;Alto Saxophone&amp;quot;,
    &amp;quot;Miles Davis&amp;quot; : &amp;quot;Trumpet, Band leader&amp;quot;,
    &amp;quot;Paul Chambers&amp;quot; : &amp;quot;double bass&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let us now see how Jackson handles null. we add three new properties to the Artist class and do not assign values to them. we add age(int), homeTown(String) and awardsWon (String[])&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public int age;
public String homeTown;
public List&amp;lt;String&amp;gt; awardsWon = new ArrayList&amp;lt;String&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how they look after converting to json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;age&amp;quot; : 0,
 &amp;quot;homeTown&amp;quot; : null,
 &amp;quot;awardsWon&amp;quot; : [ ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we use this configuration to ignore properties that are empty&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mapper.setSerializationInclusion(Include.NON_EMPTY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To explicitely ignore a field use filters are described in this tutorial. Here&amp;rsquo;s the complete example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
import com.fasterxml.jackson.databind.introspect.AnnotatedField;
import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;

public class SerializationExample {

    public static void main(String[] args) throws IOException, ParseException {
        ObjectMapper mapper = new ObjectMapper();
        Album album = new Album(&amp;quot;Kind Of Blue&amp;quot;);
        album.setLinks(new String[] { &amp;quot;link1&amp;quot;, &amp;quot;link2&amp;quot; });
        List&amp;lt;string&amp;gt; songs = new ArrayList&amp;lt;string&amp;gt;();
        songs.add(&amp;quot;So What&amp;quot;);
        songs.add(&amp;quot;Flamenco Sketches&amp;quot;);
        songs.add(&amp;quot;Freddie Freeloader&amp;quot;);
        album.setSongs(songs);
        Artist artist = new Artist();
        artist.name = &amp;quot;Miles Davis&amp;quot;;
        SimpleDateFormat format = new SimpleDateFormat(&amp;quot;dd-MM-yyyy&amp;quot;);
        artist.birthDate = format.parse(&amp;quot;26-05-1926&amp;quot;);
        album.setArtist(artist);
        album.addMusician(&amp;quot;Miles Davis&amp;quot;, &amp;quot;Trumpet, Band leader&amp;quot;);
        album.addMusician(&amp;quot;Julian Adderley&amp;quot;, &amp;quot;Alto Saxophone&amp;quot;);
        album.addMusician(&amp;quot;Paul Chambers&amp;quot;, &amp;quot;double bass&amp;quot;);
        mapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        mapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);
        SimpleDateFormat outputFormat = new SimpleDateFormat(&amp;quot;dd MMM yyyy&amp;quot;);
        mapper.setDateFormat(outputFormat);
        mapper.setPropertyNamingStrategy(new PropertyNamingStrategy() {
            @Override
            public String nameForField(MapperConfig&amp;lt;!--?--&amp;gt; config, AnnotatedField field, String defaultName) {
                if (field.getFullName().equals(&amp;quot;com.studytrails.json.jackson.Artist#name&amp;quot;))
                    return &amp;quot;Artist-Name&amp;quot;;
                return super.nameForField(config, field, defaultName);
            }

            @Override
            public String nameForGetterMethod(MapperConfig&amp;lt;!--?--&amp;gt; config, AnnotatedMethod method, String defaultName) {
                if (method.getAnnotated().getDeclaringClass().equals(Album.class) &amp;amp;&amp;amp; defaultName.equals(&amp;quot;title&amp;quot;))
                    return &amp;quot;Album-Title&amp;quot;;
                return super.nameForGetterMethod(config, method, defaultName);
            }
        });
        mapper.setSerializationInclusion(Include.NON_EMPTY);
        mapper.writeValue(System.out, album);
    }
}

class Album {
    private String title;
    private String[] links;
    private List&amp;lt;string&amp;gt; songs = new ArrayList&amp;lt;string&amp;gt;();
    private Artist artist;
    private Map&amp;lt;string ,=&amp;quot;&amp;quot; string=&amp;quot;&amp;quot;&amp;gt; musicians = new HashMap&amp;lt;string ,=&amp;quot;&amp;quot; string=&amp;quot;&amp;quot;&amp;gt;();

    public Album(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }

    public void setLinks(String[] links) {
        this.links = links;
    }

    public String[] getLinks() {
        return links;
    }

    public void setSongs(List&amp;lt;string&amp;gt; songs) {
        this.songs = songs;
    }

    public List&amp;lt;string&amp;gt; getSongs() {
        return songs;
    }

    public void setArtist(Artist artist) {
        this.artist = artist;
    }

    public Artist getArtist() {
        return artist;
    }

    public Map&amp;lt;string ,=&amp;quot;&amp;quot; string=&amp;quot;&amp;quot;&amp;gt; getMusicians() {
        return Collections.unmodifiableMap(musicians);
    }

    public void addMusician(String key, String value) {
        musicians.put(key, value);
    }
}

class Artist {
    public String name;
    public Date birthDate;
    public int age;
    public String homeTown;
    public List&amp;lt;string&amp;gt; awardsWon = new ArrayList&amp;lt;string&amp;gt;();
}

&amp;lt;/string&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the first part of the tutorial where we saw how to convert a java object to json. in the next part we see how to build a JSON using a tree approach.&lt;/p&gt;

&lt;h3 id=&#34;creating-json-using-a-tree-model:627c82fc263a42c0c87ad3244752e285&#34;&gt;Creating JSON Using a Tree Model&lt;/h3&gt;

&lt;p&gt;It is also possible to build a json using a simple tree model. This could be useful if you dont want to write classes for your JSON structure. We will use the same example as above i.e. an album that has an array songs, an artist and an array of musicians. To write a tree you need to first do this setup:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a JsonNodeFactory to create the nodes&lt;/li&gt;
&lt;li&gt;Create a JsonGenerator from a JsonFactory and specify the output method. In this method we print to console.&lt;/li&gt;
&lt;li&gt;Create an ObjectMapper that will use the jsonGenerator and the root node to create the JSON.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After setting it all up we create a single root node for album. Note that by default the object mapper does not name the root node.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.json.jackson;

import java.io.IOException;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;

public class SerializationExampleTreeModel {
    public static void main(String[] args) throws IOException {
        // Create the node factory that gives us nodes.
        JsonNodeFactory factory = new JsonNodeFactory(false);

        // create a json factory to write the treenode as json. for the example
        // we just write to console
        JsonFactory jsonFactory = new JsonFactory();
        JsonGenerator generator = jsonFactory.createGenerator(System.out);
        ObjectMapper mapper = new ObjectMapper();

        // the root node - album
        JsonNode album = factory.objectNode();
        mapper.writeTree(generator, album);

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This prints&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A lot of lines of code to print two brackets! but lets see how it is to build our json now. We first add the first property of the album i.e. &amp;lsquo;Album-Title&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;album.put(&amp;quot;Album-Title&amp;quot;, &amp;quot;Kind Of Blue&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how our JSON looks now&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;Album-Title&amp;quot;:&amp;quot;Kind Of Blue&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now add the links array&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayNode links = factory.arrayNode();
links.add(&amp;quot;link1&amp;quot;).add(&amp;quot;link2&amp;quot;);
album.put(&amp;quot;links&amp;quot;, links);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The JSON&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;Album-Title&amp;quot;:&amp;quot;Kind Of Blue&amp;quot;,&amp;quot;links&amp;quot;:[&amp;quot;link1&amp;quot;,&amp;quot;link2&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we add the artist object. Note that artist by itself is a JsonObject. we add that to the album.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ObjectNode artist = factory.objectNode();
artist.put(&amp;quot;Artist-Name&amp;quot;, &amp;quot;Miles Davis&amp;quot;);
artist.put(&amp;quot;birthDate&amp;quot;, &amp;quot;26 May 1926&amp;quot;);
album.put(&amp;quot;artist&amp;quot;, artist);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The JSON&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;Album-Title&amp;quot;:&amp;quot;Kind Of Blue&amp;quot;,&amp;quot;links&amp;quot;:[&amp;quot;link1&amp;quot;,&amp;quot;link2&amp;quot;],
&amp;quot;artist&amp;quot;:{&amp;quot;Artist-Name&amp;quot;:&amp;quot;Miles Davis&amp;quot;,&amp;quot;birthDate&amp;quot;:&amp;quot;26 May 1926&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We not add the musicians. The musicians are not in an array but there is an object of type musicians. We therefore create an object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ObjectNode musicians = factory.objectNode();
musicians.put(&amp;quot;Julian Adderley&amp;quot;, &amp;quot;Alto Saxophone&amp;quot;);
musicians.put(&amp;quot;Miles Davis&amp;quot;, &amp;quot;Trumpet, Band leader&amp;quot;);
album.put(&amp;quot;musicians&amp;quot;, musicians);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The JSON&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;Album-Title&amp;quot;:&amp;quot;Kind Of Blue&amp;quot;,&amp;quot;links&amp;quot;:[&amp;quot;link1&amp;quot;,&amp;quot;link2&amp;quot;],
&amp;quot;artist&amp;quot;:{&amp;quot;Artist-Name&amp;quot;:&amp;quot;Miles Davis&amp;quot;,&amp;quot;birthDate&amp;quot;:&amp;quot;26 May 1926&amp;quot;},
&amp;quot;musicians&amp;quot;:{&amp;quot;Julian Adderley&amp;quot;:&amp;quot;Alto Saxophone&amp;quot;,&amp;quot;Miles Davis&amp;quot;:&amp;quot;Trumpet, Band leader&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can similarly add other elements. If you have multiple albums then you would probably generate an array in a for loop. It would typically be faster to generate JSON from a Java Object.&lt;/p&gt;

&lt;h3 id=&#34;creating-json-stream:627c82fc263a42c0c87ad3244752e285&#34;&gt;Creating JSON Stream&lt;/h3&gt;

&lt;p&gt;Look at &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-json-streaming.jsp&#34; title=&#34;json and java - Streaming&#34;&gt;this tutorial&lt;/a&gt; to see an example of generating a JSON stream.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/jackson-create-json.jsp&#34; title=&#34;Java to JSON and back&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jackson: Introduction</title>
      <link>http://alimy.me/post/dev_201603112020/</link>
      <pubDate>Fri, 11 Mar 2016 20:20:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603112020/</guid>
      <description>

&lt;h3 id=&#34;overview-of-the-jackson-api:10fec90ec27555a816eebd49d4333399&#34;&gt;Overview of The Jackson API&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.fasterxml.com/JacksonHome&#34; title=&#34;Jackson Api&#34;&gt;Jackson Api&lt;/a&gt; contains a lot of functionalities to read and build json using java. It has very powerful data binding capabilities and provides a framework to serialize custom java objects to json string and deserialize json string back to java objects. Json written with jackson can contain embedded class information that helps in creating the complete object tree during deserialization.&lt;/p&gt;

&lt;h3 id=&#34;creating-json-from-java:10fec90ec27555a816eebd49d4333399&#34;&gt;Creating JSON from JAVA&lt;/h3&gt;

&lt;p&gt;There are three ways to create JSON from JAVA:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;From a Java Object (The Same object can also be then used to read the JSON)&lt;/li&gt;
&lt;li&gt;From a JsonNode Tree&lt;/li&gt;
&lt;li&gt;Building a Json Stream&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the &lt;a href=&#34;http://alimy.me/post/dev_201603112025&#34; title=&#34;Java to JSON and back&#34;&gt;first tutorial&lt;/a&gt; we look at all the three ways of creating JSON. Note that if you are new to Jackson this is probably the best place to begin even if you are looking at a way to parse JSON.&lt;/p&gt;

&lt;h3 id=&#34;parsing-json:10fec90ec27555a816eebd49d4333399&#34;&gt;Parsing JSON&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;http://alimy.me/post/dev_201603112025&#34; title=&#34;Java to JSON and back&#34;&gt;previous tutorial&lt;/a&gt; showed how to convert a java object to JSON. the same java object can then be used to bind the json to java. However, as the author of jackson points out, there are three ways to parse JSON using Jackson.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603112030&#34; title=&#34;json and java - Streaming&#34;&gt;Streaming&lt;/a&gt; - use the JsonParser to parse the json stream. It provides the json elements as tokens. Use the JsonGenerator to generate the json from string, integer, boolean etc.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603112035&#34; title=&#34;build java tree model from json&#34;&gt;Tree Traversing&lt;/a&gt; - the compete json can be read into a JsonNode. The node can then be traversed to get the required property. A tree can also be created and then written as json string&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603112040&#34; title=&#34;Data Binding&#34;&gt;Data Binding&lt;/a&gt; - Binding the Json to custom java objects (POJO). Jackson offers a lot of flexibility around these. Annotation can be used to mark properties and constructors on the POJO.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Jackson provides certain features that make the API extremely useful and flexible. These features are&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603112045&#34; title=&#34;List Serialization&#34;&gt;List Serialization&lt;/a&gt; - Serialization list can be tricky if type info is to be preserved. Look at this example to see how to do that.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603112050&#34; title=&#34;Annotation and Dynamic beans&#34;&gt;Annotation and Dynamic beans&lt;/a&gt; - Serialize unknown properties of json into a Map in the Java Object.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603112055&#34; title=&#34;Annotation Filters&#34;&gt;Annotation Filters&lt;/a&gt; - While data binding, properties of the POJO can be ignored or filtered out. These filters can be set using annotation on the POJO or by using custom filters in the calling class.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603112100&#34; title=&#34;Mix-in&#34;&gt;Mix-in&lt;/a&gt; - Annotations on POJO can be used to map the POJO properties to Json properties and to also mark constructors for use during data binding. However, what if the POJO is from a third party, and cannot be annotated. Mix-in comes to the rescue. It provides a way to annotate third party classes.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alimy.me/post/dev_201603112105&#34; title=&#34;Polymorphic Behaviour&#34;&gt;Polymorphic Behaviour&lt;/a&gt; - If a Json is created using objects that are specific instances of an abstract class, then Jackson provides a way to create the exact subclass&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The subsequent tutorials provides examples for each of the above cases.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/json/java-jackson-introduction.jsp&#34; title=&#34;Jackson Introduction&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XStream: XML Transformation</title>
      <link>http://alimy.me/post/dev_201603092120/</link>
      <pubDate>Wed, 09 Mar 2016 21:20:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092120/</guid>
      <description>&lt;p&gt;XStream provides a TraxSource (extends SAXSource) that can be used as an input to XSLT transformation. The TraxSource uses a java Object and the corresponding XStream Object. The java object can then be directly converted to XSLT target without actually converting to XML. Lets look at an example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.ArrayList;

import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.TraxSource;

public class XStreamTransformationExample {
	public static void main(String[] args) throws TransformerFactoryConfigurationError, TransformerException {
		XStreamTransformationExample transformationExample = new XStreamTransformationExample();
		transformationExample.runTransformation();
	}

	private void runTransformation() throws TransformerFactoryConfigurationError, TransformerException {
		XStream xstream = new XStream();
		xstream.alias(&amp;quot;rss&amp;quot;, Rss2.class);
		xstream.alias(&amp;quot;item&amp;quot;, Item2.class);
		Rss2 rss = new Rss2();
		Channel2 channel = new Channel2();
		rss.channel = channel;
		channel.title = &amp;quot;Title&amp;quot;;
		channel.link = &amp;quot;link&amp;quot;;
		channel.image = new Image2();
		channel.image.link = &amp;quot;image link&amp;quot;;
		Item2 item1 = new Item2();
		item1.link = &amp;quot;item link&amp;quot;;
		item1.title = &amp;quot;Item Title&amp;quot;;
		channel.items = new ArrayList&amp;lt;Item2&amp;gt;();
		channel.items.add(item1);
		System.out.println(xstream.toXML(rss));

		Transformer transformer = TransformerFactory.newInstance().newTransformer(new StreamSource(&amp;quot;bbc.xsl&amp;quot;));
		TraxSource traxSource = new TraxSource(rss, xstream);
		StreamResult result = new StreamResult(System.out);
		transformer.transform(traxSource, result);

		// prints the html on console

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The XML.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

			link

				image link




					item link

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Rss2 and other classes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.Arrays;
import java.util.List;

public class Rss2 {
	public Channel2 channel;

	@Override
	public String toString() {
		return &amp;quot;Rss [channel=&amp;quot; + channel + &amp;quot;]&amp;quot;;
	}

}

class Channel2 {
	public String title;
	public String link;
	public String description;
	public String language;
	public String lastBuildDate;
	public String copyright;
	public Image2 image;
	public String ttl;
	public AtomLink a_link;
	public List items;

	public class AtomLink {
		public String href;
		public String rel;
		public String type;

		@Override
		public String toString() {
			return &amp;quot;AtomLink [href=&amp;quot; + href + &amp;quot;, rel=&amp;quot; + rel + &amp;quot;, type=&amp;quot; + type + &amp;quot;]&amp;quot;;
		}

	}

	@Override
	public String toString() {
		return &amp;quot;Channel [title=&amp;quot; + title + &amp;quot;, link=&amp;quot; + link + &amp;quot;, description=&amp;quot; + description + &amp;quot;, language=&amp;quot; + language + &amp;quot;, lastBuildDate=&amp;quot;
				+ lastBuildDate + &amp;quot;, copyright=&amp;quot; + copyright + &amp;quot;, image=&amp;quot; + image + &amp;quot;, ttl=&amp;quot; + ttl + &amp;quot;, a_link=&amp;quot; + a_link + &amp;quot;, items=&amp;quot; + items + &amp;quot;]&amp;quot;;
	}

}

class Item2 {
	public String title;
	public String description;
	public String link;
	public String guid;
	public String pubDate;
	public MediaThumbnail[] media_thumbnails;

	@Override
	public String toString() {
		return &amp;quot;Item [title=&amp;quot; + title + &amp;quot;, link=&amp;quot; + link + &amp;quot;, guid=&amp;quot; + guid + &amp;quot;, pubDate=&amp;quot; + pubDate + &amp;quot;, media_thumbnails=&amp;quot;
				+ Arrays.toString(media_thumbnails) + &amp;quot;]&amp;quot;;
	}

	public class MediaThumbnail {
		public int width;
		public int height;
		public String url;

		@Override
		public String toString() {
			return &amp;quot;MediaThumbnail [width=&amp;quot; + width + &amp;quot;, height=&amp;quot; + height + &amp;quot;, url=&amp;quot; + url + &amp;quot;]&amp;quot;;
		}

	}

}

class Image2 {
	public String url;
	public String title;
	public String link;
	public String width;
	public String height;

	@Override
	public String toString() {
		return &amp;quot;Image [url=&amp;quot; + url + &amp;quot;, title=&amp;quot; + title + &amp;quot;, link=&amp;quot; + link + &amp;quot;, width=&amp;quot; + width + &amp;quot;, height=&amp;quot; + height + &amp;quot;]&amp;quot;;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-xml-transformation.jsp&#34; title=&#34;XML Transformation&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XStream: Json to Java</title>
      <link>http://alimy.me/post/dev_201603092115/</link>
      <pubDate>Wed, 09 Mar 2016 21:15:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092115/</guid>
      <description>&lt;p&gt;XStream can also be used with JSON. XStream provides two drivers : a JsonHierarchicalStreamDriver and a JettisonMappedXmlDriver. The JsonHierarchicalStreamDriver can be used to write a JSON string but cannot deserialize a JSON. JettisonMappedXmlDriver can be used to deserialize a JSON but it introduces an additional dependency. In this example we deserialize a json string into a java object.&lt;/p&gt;

&lt;p&gt;Note: The mapping from Java to JSON (and back) is limited, since not anything can be expressed in JSON as with XML. It works quite well for simple objects, but one should not expect wonders. Additionally XStream supports only Jettison 1.0.1. Any other version will not work correctly (even newer ones).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.ArrayList;
import java.util.List;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamImplicit;
import com.thoughtworks.xstream.io.json.JettisonMappedXmlDriver;

public class XStreamJsonExample {

	private String json = &amp;quot;{Music:{albums:[{name:name1,year:1980}]}}&amp;quot;;

	public static void main(String[] args) {
		XStreamJsonExample example = new XStreamJsonExample();
		example.serializeJsonUsingxStream();
	}

	private void serializeJsonUsingxStream() {

		XStream xStream = new XStream(new JettisonMappedXmlDriver());
		xStream.processAnnotations(Music7.class);
		Music7 music7 = (Music7) xStream.fromXML(json);
		System.out.println(music7);
		Music7 music = new Music7();
		Album7 album1 = new Album7();
		album1.name = &amp;quot;name1&amp;quot;;
		album1.year = 1980;
		music.albums.add(album1);
		Album7 album2 = new Album7();
		album2.name = &amp;quot;name2&amp;quot;;
		album2.year = 1981;
		music.albums.add(album2);
		System.out.println(xStream.toXML(music));
	}
}

@XStreamAlias(&amp;quot;Music&amp;quot;)
class Music7 {
	@XStreamImplicit
	List&amp;lt;Album7&amp;gt; albums = new ArrayList&amp;lt;Album7&amp;gt;();

	@Override
	public String toString() {
		return &amp;quot;Music7 [albums=&amp;quot; + albums + &amp;quot;]&amp;quot;;
	}

}

@XStreamAlias(&amp;quot;Album&amp;quot;)
class Album7 {
	String name;
	int year;

	@Override
	public String toString() {
		return &amp;quot;Album7 [name=&amp;quot; + name + &amp;quot;, year=&amp;quot; + year + &amp;quot;]&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-json-example.jsp&#34; title=&#34;XStream - Json to Java&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XStream: Collection Converters</title>
      <link>http://alimy.me/post/dev_201603092105/</link>
      <pubDate>Wed, 09 Mar 2016 21:05:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092105/</guid>
      <description>&lt;p&gt;In the earlier tutorials we saw how to convert a &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;parsing an xml&#34;&gt;Java object to XML and back&lt;/a&gt;, &lt;a href=&#34;http://alimy.me/post/dev_201603092055&#34; title=&#34;custom converter&#34;&gt;custom converter&lt;/a&gt; and &lt;a href=&#34;http://alimy.me/post/dev_201603092100&#34; title=&#34;basic converters&#34;&gt;basic converters&lt;/a&gt;. In this tutorial we look at how XStream converts array and collections from java to xml and vice versa. We will convert the following types :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;String[]&lt;/li&gt;
&lt;li&gt;char[]&lt;/li&gt;
&lt;li&gt;List&lt;String&gt;&lt;/li&gt;
&lt;li&gt;java.util.Properties&lt;/li&gt;
&lt;li&gt;List&lt;String&gt;&lt;/li&gt;
&lt;li&gt;Map&lt;String, String&gt;&lt;/li&gt;
&lt;li&gt;TreeMap&lt;String, String&gt; treeMap&lt;/li&gt;
&lt;li&gt;TreeSet&lt;String&gt; treeSet&lt;/li&gt;
&lt;li&gt;enum&lt;/li&gt;
&lt;li&gt;EnumMap&lt;testEnum, String&gt; testEnum is an enum&lt;/li&gt;
&lt;li&gt;EnumSet&lt;testEnum&gt; testEnum is an enum&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here&amp;rsquo;s the complete example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;
import java.util.TreeSet;

import com.thoughtworks.xstream.XStream;

public class ConverterExample2 {
	public static void main(String[] args) {
		ConverterExample2 example2 = new ConverterExample2();
		example2.runExample();
	}

	public void runExample() {
		XStream xStream = new XStream();
		CollectionConverterExample classContainingCollection = new CollectionConverterExample();
		classContainingCollection.initialize();
		String xml = xStream.toXML(classContainingCollection);
		System.out.println(xml);
	}
}

class CollectionConverterExample {

	String[] stringArray = new String[] { &amp;quot;StringA&amp;quot;, &amp;quot;StringB&amp;quot;, &amp;quot;StringC&amp;quot; };
	char[] charArray = new char[] { &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; };
	List&amp;lt;String&amp;gt; listA = new ArrayList&amp;lt;String&amp;gt;();
	Map&amp;lt;String, String&amp;gt; mapA = new HashMap&amp;lt;String, String&amp;gt;();
	Properties properties = new Properties();
	List&amp;lt;String&amp;gt; singletonList;
	Map&amp;lt;String, String&amp;gt; singletonMap;

	TreeMap&amp;lt;String, String&amp;gt; treeMap = new TreeMap&amp;lt;String, String&amp;gt;();
	TreeSet&amp;lt;String&amp;gt; treeSet = new TreeSet&amp;lt;String&amp;gt;();
	enum testEnum {testA, testB}
	testEnum testeEnumValue = testEnum.testA;
	EnumMap&amp;lt;testEnum, String&amp;gt; testEnumMap = new EnumMap&amp;lt;CollectionConverterExample.testEnum, String&amp;gt;(testEnum.class);
	EnumSet&amp;lt;testEnum&amp;gt; testEnumSet = EnumSet.range(testEnum.testA, testEnum.testB);

	public void initialize() {
		listA.add(&amp;quot;testA&amp;quot;);
		mapA.put(&amp;quot;keyA&amp;quot;, &amp;quot;ValueA&amp;quot;);
		properties.put(&amp;quot;propertyA&amp;quot;, &amp;quot;valueA&amp;quot;);
		treeMap.put(&amp;quot;treeA&amp;quot;, &amp;quot;valueA&amp;quot;);
		treeMap.put(&amp;quot;treeB&amp;quot;, &amp;quot;valueB&amp;quot;);
		treeSet.add(&amp;quot;treeB&amp;quot;);
		treeSet.add(&amp;quot;treeA&amp;quot;);
		singletonList = Collections.singletonList(&amp;quot;singletonListA&amp;quot;);
		singletonMap = Collections.singletonMap(&amp;quot;key1&amp;quot;, &amp;quot;value1&amp;quot;);

		testEnumMap.put(testEnum.testA, &amp;quot;testEnumMapValue1&amp;quot;);
		testEnumMap.put(testEnum.testB, &amp;quot;testEnumMapValue2&amp;quot;);

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resultant XML looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
		StringA
		StringB
		StringC

	abcde

		testA



	  keyA
	  ValueA






		singletonListA



	  key1
	  value1




	  treeA
	  valueA


	  treeB
	  valueB



		treeA
		treeB
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-collection-converters.jsp&#34; title=&#34;Collection Converters&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XStream: Basic Built-in Converters</title>
      <link>http://alimy.me/post/dev_201603092100/</link>
      <pubDate>Wed, 09 Mar 2016 21:00:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092100/</guid>
      <description>&lt;p&gt;In the previous tutorials we saw an example of how to convert &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;parsing an xml&#34;&gt;java object to XML and back&lt;/a&gt;. That tutorial also explained the concept of aliases and implicit collection.In the last tutorial we show how to write a custom converter. In this tutorial, lets see some of the basic built in converters of XStream and how the resultant XML from those converters look like. We will look at how the following types are converted. XStream has converters for each of these. These are just a sample of the converters that XStream has. These converters only exist for a better and faster handling of a type compared to the generic converters.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BigDecimal&lt;/li&gt;
&lt;li&gt;BigInteger&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;byte&lt;/li&gt;
&lt;li&gt;char&lt;/li&gt;
&lt;li&gt;Date&lt;/li&gt;
&lt;li&gt;Double&lt;/li&gt;
&lt;li&gt;Float&lt;/li&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;Long&lt;/li&gt;
&lt;li&gt;Object&lt;/li&gt;
&lt;li&gt;StringBuffer&lt;/li&gt;
&lt;li&gt;StringBuilder&lt;/li&gt;
&lt;li&gt;URI&lt;/li&gt;
&lt;li&gt;URL&lt;/li&gt;
&lt;li&gt;UUID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the next tutorial we look at examples of arrays and Collections.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Date;
import java.util.TimeZone;
import java.util.UUID;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.basic.BooleanConverter;
import com.thoughtworks.xstream.converters.basic.DateConverter;

public class ConverterExample1 {

	public static void main(String[] args) throws MalformedURLException, URISyntaxException {
		ConverterExample1 converter = new ConverterExample1();
		converter.convert();
	}

	private void convert() throws MalformedURLException, URISyntaxException {

		BasicConverterFields basicConverterExample = new BasicConverterFields();
		basicConverterExample.initialize();

		XStream xStream = new XStream();

		xStream.registerLocalConverter(BasicConverterFields.class, &amp;quot;flag&amp;quot;, BooleanConverter.BINARY);

		DateConverter dateConverter = new DateConverter(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;, new String[] {}, TimeZone.getTimeZone(&amp;quot;UTC&amp;quot;));
		xStream.registerConverter(dateConverter);

		String xml = xStream.toXML(basicConverterExample);

		System.out.println(xml);

		BasicConverterFields basicConverterFromXML = (BasicConverterFields) xStream.fromXML(xml);
		System.out.println(basicConverterFromXML);

	}

	class BasicConverterFields {
		BigDecimal bigDecimal = new BigDecimal(10000000000.0);
		BigInteger bigInteger = new BigInteger(&amp;quot;1000000000&amp;quot;);
		boolean flag = true;
		byte byteA = &#39;a&#39;;
		char charA = &#39;a&#39;;
		Date date = new Date();
		Double doubleA = new Double(1000000000000.0);
		Float floatA = new Float(10000000000000f);
		int intA = 100;
		Long longA = new Long(100000);
		Object nullA = null;
		Short shortA = new Short((short) 1);
		StringBuffer stringBufferA = new StringBuffer(&amp;quot;test&amp;quot;);
		StringBuilder stringBuilderA = new StringBuilder().append(&amp;quot;test&amp;quot;);
		URI UriA = null;
		URL urlA = null;
		UUID uuidA = UUID.fromString(&amp;quot;0000000a-000b-000c-000d-00000000000e&amp;quot;);

		public void initialize() throws URISyntaxException, MalformedURLException {
			UriA = new URI(&amp;quot;file://C/work/fileA&amp;quot;);
			urlA = new URL(&amp;quot;http://www.google.com&amp;quot;);
		}

		@Override
		public String toString() {
			return &amp;quot;BasicConverterFields [bigDecimal=&amp;quot; + bigDecimal + &amp;quot;, bigInteger=&amp;quot; + bigInteger + &amp;quot;, flag=&amp;quot; + flag + &amp;quot;, byteA=&amp;quot; + byteA
					+ &amp;quot;, charA=&amp;quot; + charA + &amp;quot;, date=&amp;quot; + date + &amp;quot;, doubleA=&amp;quot; + doubleA + &amp;quot;, floatA=&amp;quot; + floatA + &amp;quot;, intA=&amp;quot; + intA + &amp;quot;, longA=&amp;quot; + longA
					+ &amp;quot;, nullA=&amp;quot; + nullA + &amp;quot;, shortA=&amp;quot; + shortA + &amp;quot;, stringBufferA=&amp;quot; + stringBufferA + &amp;quot;, stringBuilderA=&amp;quot; + stringBuilderA
					+ &amp;quot;, UriA=&amp;quot; + UriA + &amp;quot;, urlA=&amp;quot; + urlA + &amp;quot;, uuidA=&amp;quot; + uuidA + &amp;quot;]&amp;quot;;
		}

	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The toXML method prints this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10000000000
1000000000
1
97
a
2014-04-26 04:14:38
1.0E12
9.9999998E12
100
100000
1
test
test
file://C/work/fileA
http://www.google.com
0000000a-000b-000c-000d-00000000000e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fromXML method prints this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BasicConverterFields [bigDecimal=10000000000, bigInteger=1000000000, flag=true, byteA=97, charA=a,
date=Sat Apr 26 09:44:38 IST 2014, doubleA=1.0E12, floatA=9.9999998E12, intA=100, longA=100000,
nullA=null, shortA=1, stringBufferA=test, stringBuilderA=test, UriA=file://C/work/fileA,
urlA=http://www.google.com, uuidA=0000000a-000b-000c-000d-00000000000e]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-basic-converters.jsp&#34; title=&#34;Basic Built-in Converters&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XStream: Custom Converter for BufferedImage</title>
      <link>http://alimy.me/post/dev_201603092055/</link>
      <pubDate>Wed, 09 Mar 2016 20:55:00 CST</pubDate>
      
      <guid>http://alimy.me/post/dev_201603092055/</guid>
      <description>&lt;p&gt;In the previous tutorials we saw an example of how to convert a &lt;a href=&#34;http://alimy.me/post/dev_201603081411&#34; title=&#34;parsing an xml&#34;&gt;java object to XML and back&lt;/a&gt;. That tutorial also explained the concept of aliases and implicit collection. While serializing a Java object to XML XStream uses custom converters. These converters specify how to create XML from a Java Object or how to create a Java Object from XML elements. In most cases the provided converters should suffice, however, in certain cases you may want to create your own converters. To do so create a class that implements com.thoughtworks.xstream.converters.Converter and implement the void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context); and Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context); The example below demonstrates a CustomConverter. To make the example more interesting we will write a converter to serialize a BufferedImage. The image for the example can be downloaded from here&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.studytrails.xml.xstream;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import javax.imageio.ImageIO;

import org.apache.commons.io.output.ByteArrayOutputStream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.core.util.Base64Encoder;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;

public class CustomConverterExample {

    public static void main(String[] args) throws IOException {
        CustomConverterExample customConverterExample = new CustomConverterExample();
        customConverterExample.showCustomConversionForBufferedImage();
    }

    private void showCustomConversionForBufferedImage() throws IOException {
        Company company = new Company();
        company.setName(&amp;quot;Study Trails&amp;quot;);
        BufferedImage in = ImageIO.read(new File(&amp;quot;st1_200.jpg&amp;quot;));
        BufferedImage newImage = new BufferedImage(in.getWidth(), in.getHeight(), BufferedImage.TYPE_INT_RGB);
        Graphics2D g = newImage.createGraphics();
        g.drawImage(in, 0, 0, null);
        g.dispose();
        company.setImage(newImage);
        XStream xStream = new XStream();
        xStream.registerConverter(new CustomBufferedImageConverter());
        String xml = xStream.toXML(company);

        Company company2 = (Company) xStream.fromXML(xml);
        File outputfile = new File(&amp;quot;st2_200.jpg&amp;quot;);
        ImageIO.write(company2.image, &amp;quot;jpg&amp;quot;, outputfile);

    }

}

class Company {
    String name;
    BufferedImage image;

    public void setName(String name) {
        this.name = name;
    }

    public void setImage(BufferedImage image) {
        this.image = image;
    }
}

class CustomBufferedImageConverter implements Converter {
    @Override
    public boolean canConvert(Class type) {

        return type.isAssignableFrom(BufferedImage.class);
    }

    @Override
    public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {
        BufferedImage bufferedImage = (BufferedImage) source;
        try {
            ByteArrayOutputStream outStream = new ByteArrayOutputStream();
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outStream);
            ImageIO.write(bufferedImage, &amp;quot;jpg&amp;quot;, objectOutputStream);
            outStream.flush();
            Base64Encoder encorder = new Base64Encoder();
            String imageString = encorder.encode(outStream.toByteArray());
            outStream.close();
            writer.setValue(imageString);
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

    @Override
    public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
        BufferedImage image = null;
        try {
            Base64Encoder encoder = new Base64Encoder();
            byte[] imageBytes = encoder.decode(reader.getValue());
            ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(imageBytes));
            image = ImageIO.read(inputStream);
            inputStream.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return image;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;(Note: This article’s original links is &lt;a href=&#34;http://www.studytrails.com/java/xml/xstream/xstream-custom-converter.jsp&#34; title=&#34;XStream custom converter&#34;&gt;&lt;em&gt;here&lt;/em&gt;&lt;/a&gt; )&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
